var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target3, value6) => __defProp(target3, "name", { value: value6, configurable: true });
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target3, all14) => {
  for (var name in all14)
    __defProp(target3, name, { get: all14[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target3) => (target3 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target3, "default", { value: mod, enumerable: true }) : target3,
  mod
));

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn2 = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn2, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance2;
var init_performance = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options4) {
        this.name = name;
        this.startTime = options4?.startTime || _performanceNow();
        this.detail = options4?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type3) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type3) {
        return this._entries.filter((e) => e.name === name && (!type3 || e.entryType === type3));
      }
      getEntriesByType(type3) {
        return this._entries.filter((e) => e.entryType === type3);
      }
      mark(name, options4) {
        const entry = new PerformanceMark(name, options4);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start3;
        let end6;
        if (typeof startOrMeasureOptions === "string") {
          start3 = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end6 = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start3 = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end6 = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start3,
          detail: {
            start: start3,
            end: end6
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type3, listener, options4) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type3, listener, options4) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options4) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn2) {
        return fn2;
      }
      runInAsyncScope(fn2, thisArg, ...args2) {
        return fn2.call(thisArg, ...args2);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance2 = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2.7.13_unenv@2.0.0-rc.24_workerd@1.20251210.0/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2.7.13_unenv@2.0.0-rc.24_workerd@1.20251210.0/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance2;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2.7.13_unenv@2.0.0-rc.24_workerd@1.20251210.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2.7.13_unenv@2.0.0-rc.24_workerd@1.20251210.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// node_modules/.pnpm/wrangler@4.54.0_@cloudflare+workers-types@4.20241106.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "node_modules/.pnpm/wrangler@4.54.0_@cloudflare+workers-types@4.20241106.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now2 = Date.now();
      const seconds2 = Math.trunc(now2 / 1e3);
      const nanos2 = now2 % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds2 - startTime[0];
        let diffNanos = nanos2 - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds2, nanos2];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir4, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env3) {
        return 1;
      }
      hasColors(count7, env3) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs
var NODE_VERSION;
var init_node_version = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/node-version.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NODE_VERSION = "22.14.0";
  }
});

// node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "node_modules/.pnpm/unenv@2.0.0-rc.24/node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    init_node_version();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value6 = this[prop];
          if (typeof value6 === "function") {
            this[prop] = value6.bind(this);
          }
        }
      }
      // --- event emitter ---
      emitWarning(warning, type3, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type3 ? `${type3}: ` : ""}${warning}`);
      }
      emit(...args2) {
        return super.emit(...args2);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      // --- stdio (lazy initializers) ---
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      // --- cwd ---
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      // --- dummy props and getters ---
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return `v${NODE_VERSION}`;
      }
      get versions() {
        return { node: NODE_VERSION };
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      // --- noop methods ---
      ref() {
      }
      unref() {
      }
      // --- unimplemented methods ---
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      // --- attached interfaces ---
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      // --- undefined props ---
      mainModule = void 0;
      domain = void 0;
      // optional
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      // internals
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// node_modules/.pnpm/@cloudflare+unenv-preset@2.7.13_unenv@2.0.0-rc.24_workerd@1.20251210.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, workerdProcess, isWorkerdProcessV2, unenvProcess, exit, features, platform, env, hrtime3, nextTick, _channel, _disconnect, _events, _eventsCount, _handleQueue, _maxListeners, _pendingMessage, _send, assert2, disconnect, mainModule, _debugEnd, _debugProcess, _exiting, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _linkedBinding, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, abort, addListener, allowedNodeEnvironmentFlags, arch, argv, argv0, availableMemory, binding, channel, chdir, config, connected, constrainedMemory, cpuUsage, cwd, debugPort, dlopen, domain, emit, emitWarning, eventNames, execArgv, execPath, exitCode, finalization, getActiveResourcesInfo, getegid, geteuid, getgid, getgroups, getMaxListeners, getuid, hasUncaughtExceptionCaptureCallback, initgroups, kill, listenerCount, listeners, loadEnvFile, memoryUsage, moduleLoadList, off, on, once, openStdin, permission, pid, ppid, prependListener, prependOnceListener, rawListeners, reallyExit, ref, release, removeAllListeners, removeListener, report, resourceUsage, send, setegid, seteuid, setgid, setgroups, setMaxListeners, setSourceMapsEnabled, setuid, setUncaughtExceptionCaptureCallback, sourceMapsEnabled, stderr, stdin, stdout, throwDeprecation, title, traceDeprecation, umask, unref, uptime, version, versions, _process, process_default;
var init_process2 = __esm({
  "node_modules/.pnpm/@cloudflare+unenv-preset@2.7.13_unenv@2.0.0-rc.24_workerd@1.20251210.0/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    workerdProcess = getBuiltinModule("node:process");
    isWorkerdProcessV2 = globalThis.Cloudflare.compatibilityFlags.enable_nodejs_process_v2;
    unenvProcess = new Process({
      env: globalProcess.env,
      // `hrtime` is only available from workerd process v2
      hrtime: isWorkerdProcessV2 ? workerdProcess.hrtime : hrtime,
      // `nextTick` is available from workerd process v1
      nextTick: workerdProcess.nextTick
    });
    ({ exit, features, platform } = workerdProcess);
    ({
      env: (
        // Always implemented by workerd
        env
      ),
      hrtime: (
        // Only implemented in workerd v2
        hrtime3
      ),
      nextTick: (
        // Always implemented by workerd
        nextTick
      )
    } = unenvProcess);
    ({
      _channel,
      _disconnect,
      _events,
      _eventsCount,
      _handleQueue,
      _maxListeners,
      _pendingMessage,
      _send,
      assert: assert2,
      disconnect,
      mainModule
    } = unenvProcess);
    ({
      _debugEnd: (
        // @ts-expect-error `_debugEnd` is missing typings
        _debugEnd
      ),
      _debugProcess: (
        // @ts-expect-error `_debugProcess` is missing typings
        _debugProcess
      ),
      _exiting: (
        // @ts-expect-error `_exiting` is missing typings
        _exiting
      ),
      _fatalException: (
        // @ts-expect-error `_fatalException` is missing typings
        _fatalException
      ),
      _getActiveHandles: (
        // @ts-expect-error `_getActiveHandles` is missing typings
        _getActiveHandles
      ),
      _getActiveRequests: (
        // @ts-expect-error `_getActiveRequests` is missing typings
        _getActiveRequests
      ),
      _kill: (
        // @ts-expect-error `_kill` is missing typings
        _kill
      ),
      _linkedBinding: (
        // @ts-expect-error `_linkedBinding` is missing typings
        _linkedBinding
      ),
      _preload_modules: (
        // @ts-expect-error `_preload_modules` is missing typings
        _preload_modules
      ),
      _rawDebug: (
        // @ts-expect-error `_rawDebug` is missing typings
        _rawDebug
      ),
      _startProfilerIdleNotifier: (
        // @ts-expect-error `_startProfilerIdleNotifier` is missing typings
        _startProfilerIdleNotifier
      ),
      _stopProfilerIdleNotifier: (
        // @ts-expect-error `_stopProfilerIdleNotifier` is missing typings
        _stopProfilerIdleNotifier
      ),
      _tickCallback: (
        // @ts-expect-error `_tickCallback` is missing typings
        _tickCallback
      ),
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      arch,
      argv,
      argv0,
      availableMemory,
      binding: (
        // @ts-expect-error `binding` is missing typings
        binding
      ),
      channel,
      chdir,
      config,
      connected,
      constrainedMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      domain: (
        // @ts-expect-error `domain` is missing typings
        domain
      ),
      emit,
      emitWarning,
      eventNames,
      execArgv,
      execPath,
      exitCode,
      finalization,
      getActiveResourcesInfo,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getMaxListeners,
      getuid,
      hasUncaughtExceptionCaptureCallback,
      initgroups: (
        // @ts-expect-error `initgroups` is missing typings
        initgroups
      ),
      kill,
      listenerCount,
      listeners,
      loadEnvFile,
      memoryUsage,
      moduleLoadList: (
        // @ts-expect-error `moduleLoadList` is missing typings
        moduleLoadList
      ),
      off,
      on,
      once,
      openStdin: (
        // @ts-expect-error `openStdin` is missing typings
        openStdin
      ),
      permission,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      reallyExit: (
        // @ts-expect-error `reallyExit` is missing typings
        reallyExit
      ),
      ref,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      send,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setMaxListeners,
      setSourceMapsEnabled,
      setuid,
      setUncaughtExceptionCaptureCallback,
      sourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      throwDeprecation,
      title,
      traceDeprecation,
      umask,
      unref,
      uptime,
      version,
      versions
    } = isWorkerdProcessV2 ? workerdProcess : unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// node_modules/.pnpm/wrangler@4.54.0_@cloudflare+workers-types@4.20241106.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "node_modules/.pnpm/wrangler@4.54.0_@cloudflare+workers-types@4.20241106.0/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// wrangler-modules-watch:wrangler:modules-watch
var init_wrangler_modules_watch = __esm({
  "wrangler-modules-watch:wrangler:modules-watch"() {
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// node_modules/.pnpm/wrangler@4.54.0_@cloudflare+workers-types@4.20241106.0/node_modules/wrangler/templates/modules-watch-stub.js
var init_modules_watch_stub = __esm({
  "node_modules/.pnpm/wrangler@4.54.0_@cloudflare+workers-types@4.20241106.0/node_modules/wrangler/templates/modules-watch-stub.js"() {
    init_wrangler_modules_watch();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/platform/browser/globalThis.js
var require_globalThis = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/platform/browser/globalThis.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports._globalThis = void 0;
    exports._globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/platform/browser/index.js
var require_browser = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/platform/browser/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: /* @__PURE__ */ __name(function() {
        return m[k];
      }, "get") });
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_globalThis(), exports);
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/version.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VERSION = void 0;
    exports.VERSION = "1.9.0";
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/internal/semver.js
var require_semver = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/internal/semver.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCompatible = exports._makeCompatibilityCheck = void 0;
    var version_1 = require_version();
    var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    function _makeCompatibilityCheck(ownVersion) {
      const acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
      const rejectedVersions = /* @__PURE__ */ new Set();
      const myVersionMatch = ownVersion.match(re);
      if (!myVersionMatch) {
        return () => false;
      }
      const ownVersionParsed = {
        major: +myVersionMatch[1],
        minor: +myVersionMatch[2],
        patch: +myVersionMatch[3],
        prerelease: myVersionMatch[4]
      };
      if (ownVersionParsed.prerelease != null) {
        return /* @__PURE__ */ __name(function isExactmatch(globalVersion) {
          return globalVersion === ownVersion;
        }, "isExactmatch");
      }
      function _reject(v) {
        rejectedVersions.add(v);
        return false;
      }
      __name(_reject, "_reject");
      function _accept(v) {
        acceptedVersions.add(v);
        return true;
      }
      __name(_accept, "_accept");
      return /* @__PURE__ */ __name(function isCompatible(globalVersion) {
        if (acceptedVersions.has(globalVersion)) {
          return true;
        }
        if (rejectedVersions.has(globalVersion)) {
          return false;
        }
        const globalVersionMatch = globalVersion.match(re);
        if (!globalVersionMatch) {
          return _reject(globalVersion);
        }
        const globalVersionParsed = {
          major: +globalVersionMatch[1],
          minor: +globalVersionMatch[2],
          patch: +globalVersionMatch[3],
          prerelease: globalVersionMatch[4]
        };
        if (globalVersionParsed.prerelease != null) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major !== globalVersionParsed.major) {
          return _reject(globalVersion);
        }
        if (ownVersionParsed.major === 0) {
          if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
            return _accept(globalVersion);
          }
          return _reject(globalVersion);
        }
        if (ownVersionParsed.minor <= globalVersionParsed.minor) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }, "isCompatible");
    }
    __name(_makeCompatibilityCheck, "_makeCompatibilityCheck");
    exports._makeCompatibilityCheck = _makeCompatibilityCheck;
    exports.isCompatible = _makeCompatibilityCheck(version_1.VERSION);
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/internal/global-utils.js
var require_global_utils = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/internal/global-utils.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unregisterGlobal = exports.getGlobal = exports.registerGlobal = void 0;
    var platform_1 = require_browser();
    var version_1 = require_version();
    var semver_1 = require_semver();
    var major = version_1.VERSION.split(".")[0];
    var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(`opentelemetry.js.api.${major}`);
    var _global = platform_1._globalThis;
    function registerGlobal(type3, instance, diag, allowOverride = false) {
      var _a;
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
        version: version_1.VERSION
      };
      if (!allowOverride && api[type3]) {
        const err = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${type3}`);
        diag.error(err.stack || err.message);
        return false;
      }
      if (api.version !== version_1.VERSION) {
        const err = new Error(`@opentelemetry/api: Registration of version v${api.version} for ${type3} does not match previously registered API v${version_1.VERSION}`);
        diag.error(err.stack || err.message);
        return false;
      }
      api[type3] = instance;
      diag.debug(`@opentelemetry/api: Registered a global for ${type3} v${version_1.VERSION}.`);
      return true;
    }
    __name(registerGlobal, "registerGlobal");
    exports.registerGlobal = registerGlobal;
    function getGlobal(type3) {
      var _a, _b;
      const globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
      if (!globalVersion || !(0, semver_1.isCompatible)(globalVersion)) {
        return;
      }
      return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type3];
    }
    __name(getGlobal, "getGlobal");
    exports.getGlobal = getGlobal;
    function unregisterGlobal(type3, diag) {
      diag.debug(`@opentelemetry/api: Unregistering a global for ${type3} v${version_1.VERSION}.`);
      const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
      if (api) {
        delete api[type3];
      }
    }
    __name(unregisterGlobal, "unregisterGlobal");
    exports.unregisterGlobal = unregisterGlobal;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js
var require_ComponentLogger = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/ComponentLogger.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagComponentLogger = void 0;
    var global_utils_1 = require_global_utils();
    var DiagComponentLogger = class {
      static {
        __name(this, "DiagComponentLogger");
      }
      constructor(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      debug(...args2) {
        return logProxy("debug", this._namespace, args2);
      }
      error(...args2) {
        return logProxy("error", this._namespace, args2);
      }
      info(...args2) {
        return logProxy("info", this._namespace, args2);
      }
      warn(...args2) {
        return logProxy("warn", this._namespace, args2);
      }
      verbose(...args2) {
        return logProxy("verbose", this._namespace, args2);
      }
    };
    exports.DiagComponentLogger = DiagComponentLogger;
    function logProxy(funcName, namespace, args2) {
      const logger3 = (0, global_utils_1.getGlobal)("diag");
      if (!logger3) {
        return;
      }
      args2.unshift(namespace);
      return logger3[funcName](...args2);
    }
    __name(logProxy, "logProxy");
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/types.js
var require_types = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/types.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagLogLevel = void 0;
    var DiagLogLevel;
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel = exports.DiagLogLevel || (exports.DiagLogLevel = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js
var require_logLevelLogger = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/internal/logLevelLogger.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createLogLevelDiagLogger = void 0;
    var types_1 = require_types();
    function createLogLevelDiagLogger(maxLevel, logger3) {
      if (maxLevel < types_1.DiagLogLevel.NONE) {
        maxLevel = types_1.DiagLogLevel.NONE;
      } else if (maxLevel > types_1.DiagLogLevel.ALL) {
        maxLevel = types_1.DiagLogLevel.ALL;
      }
      logger3 = logger3 || {};
      function _filterFunc(funcName, theLevel) {
        const theFunc = logger3[funcName];
        if (typeof theFunc === "function" && maxLevel >= theLevel) {
          return theFunc.bind(logger3);
        }
        return function() {
        };
      }
      __name(_filterFunc, "_filterFunc");
      return {
        error: _filterFunc("error", types_1.DiagLogLevel.ERROR),
        warn: _filterFunc("warn", types_1.DiagLogLevel.WARN),
        info: _filterFunc("info", types_1.DiagLogLevel.INFO),
        debug: _filterFunc("debug", types_1.DiagLogLevel.DEBUG),
        verbose: _filterFunc("verbose", types_1.DiagLogLevel.VERBOSE)
      };
    }
    __name(createLogLevelDiagLogger, "createLogLevelDiagLogger");
    exports.createLogLevelDiagLogger = createLogLevelDiagLogger;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/diag.js
var require_diag = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/diag.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagAPI = void 0;
    var ComponentLogger_1 = require_ComponentLogger();
    var logLevelLogger_1 = require_logLevelLogger();
    var types_1 = require_types();
    var global_utils_1 = require_global_utils();
    var API_NAME = "diag";
    var DiagAPI = class _DiagAPI {
      static {
        __name(this, "DiagAPI");
      }
      /**
       * Private internal constructor
       * @private
       */
      constructor() {
        function _logProxy(funcName) {
          return function(...args2) {
            const logger3 = (0, global_utils_1.getGlobal)("diag");
            if (!logger3)
              return;
            return logger3[funcName](...args2);
          };
        }
        __name(_logProxy, "_logProxy");
        const self2 = this;
        const setLogger = /* @__PURE__ */ __name((logger3, optionsOrLogLevel = { logLevel: types_1.DiagLogLevel.INFO }) => {
          var _a, _b, _c;
          if (logger3 === self2) {
            const err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          const oldLogger = (0, global_utils_1.getGlobal)("diag");
          const newLogger = (0, logLevelLogger_1.createLogLevelDiagLogger)((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : types_1.DiagLogLevel.INFO, logger3);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            const stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn(`Current logger will be overwritten from ${stack}`);
            newLogger.warn(`Current logger will overwrite one already registered from ${stack}`);
          }
          return (0, global_utils_1.registerGlobal)("diag", newLogger, self2, true);
        }, "setLogger");
        self2.setLogger = setLogger;
        self2.disable = () => {
          (0, global_utils_1.unregisterGlobal)(API_NAME, self2);
        };
        self2.createComponentLogger = (options4) => {
          return new ComponentLogger_1.DiagComponentLogger(options4);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      /** Get the singleton instance of the DiagAPI API */
      static instance() {
        if (!this._instance) {
          this._instance = new _DiagAPI();
        }
        return this._instance;
      }
    };
    exports.DiagAPI = DiagAPI;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js
var require_baggage_impl = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/internal/baggage-impl.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaggageImpl = void 0;
    var BaggageImpl = class _BaggageImpl {
      static {
        __name(this, "BaggageImpl");
      }
      constructor(entries3) {
        this._entries = entries3 ? new Map(entries3) : /* @__PURE__ */ new Map();
      }
      getEntry(key) {
        const entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      }
      getAllEntries() {
        return Array.from(this._entries.entries()).map(([k, v]) => [k, v]);
      }
      setEntry(key, entry) {
        const newBaggage = new _BaggageImpl(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      }
      removeEntry(key) {
        const newBaggage = new _BaggageImpl(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      }
      removeEntries(...keys6) {
        const newBaggage = new _BaggageImpl(this._entries);
        for (const key of keys6) {
          newBaggage._entries.delete(key);
        }
        return newBaggage;
      }
      clear() {
        return new _BaggageImpl();
      }
    };
    exports.BaggageImpl = BaggageImpl;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js
var require_symbol = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/internal/symbol.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baggageEntryMetadataSymbol = void 0;
    exports.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/utils.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.baggageEntryMetadataFromString = exports.createBaggage = void 0;
    var diag_1 = require_diag();
    var baggage_impl_1 = require_baggage_impl();
    var symbol_1 = require_symbol();
    var diag = diag_1.DiagAPI.instance();
    function createBaggage(entries3 = {}) {
      return new baggage_impl_1.BaggageImpl(new Map(Object.entries(entries3)));
    }
    __name(createBaggage, "createBaggage");
    exports.createBaggage = createBaggage;
    function baggageEntryMetadataFromString(str) {
      if (typeof str !== "string") {
        diag.error(`Cannot create baggage metadata from unknown type: ${typeof str}`);
        str = "";
      }
      return {
        __TYPE__: symbol_1.baggageEntryMetadataSymbol,
        toString() {
          return str;
        }
      };
    }
    __name(baggageEntryMetadataFromString, "baggageEntryMetadataFromString");
    exports.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context/context.js
var require_context = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context/context.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ROOT_CONTEXT = exports.createContextKey = void 0;
    function createContextKey(description) {
      return Symbol.for(description);
    }
    __name(createContextKey, "createContextKey");
    exports.createContextKey = createContextKey;
    var BaseContext = class _BaseContext {
      static {
        __name(this, "BaseContext");
      }
      /**
       * Construct a new context which inherits values from an optional parent context.
       *
       * @param parentContext a context from which to inherit values
       */
      constructor(parentContext) {
        const self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = (key) => self2._currentContext.get(key);
        self2.setValue = (key, value6) => {
          const context17 = new _BaseContext(self2._currentContext);
          context17._currentContext.set(key, value6);
          return context17;
        };
        self2.deleteValue = (key) => {
          const context17 = new _BaseContext(self2._currentContext);
          context17._currentContext.delete(key);
          return context17;
        };
      }
    };
    exports.ROOT_CONTEXT = new BaseContext();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js
var require_consoleLogger = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag/consoleLogger.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagConsoleLogger = void 0;
    var consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    var DiagConsoleLogger = class {
      static {
        __name(this, "DiagConsoleLogger");
      }
      constructor() {
        function _consoleFunc(funcName) {
          return function(...args2) {
            if (console) {
              let theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args2);
              }
            }
          };
        }
        __name(_consoleFunc, "_consoleFunc");
        for (let i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
    };
    exports.DiagConsoleLogger = DiagConsoleLogger;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js
var require_NoopMeter = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeter.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createNoopMeter = exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = exports.NOOP_OBSERVABLE_GAUGE_METRIC = exports.NOOP_OBSERVABLE_COUNTER_METRIC = exports.NOOP_UP_DOWN_COUNTER_METRIC = exports.NOOP_HISTOGRAM_METRIC = exports.NOOP_GAUGE_METRIC = exports.NOOP_COUNTER_METRIC = exports.NOOP_METER = exports.NoopObservableUpDownCounterMetric = exports.NoopObservableGaugeMetric = exports.NoopObservableCounterMetric = exports.NoopObservableMetric = exports.NoopHistogramMetric = exports.NoopGaugeMetric = exports.NoopUpDownCounterMetric = exports.NoopCounterMetric = exports.NoopMetric = exports.NoopMeter = void 0;
    var NoopMeter = class {
      static {
        __name(this, "NoopMeter");
      }
      constructor() {
      }
      /**
       * @see {@link Meter.createGauge}
       */
      createGauge(_name, _options) {
        return exports.NOOP_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createHistogram}
       */
      createHistogram(_name, _options) {
        return exports.NOOP_HISTOGRAM_METRIC;
      }
      /**
       * @see {@link Meter.createCounter}
       */
      createCounter(_name, _options) {
        return exports.NOOP_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createUpDownCounter}
       */
      createUpDownCounter(_name, _options) {
        return exports.NOOP_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableGauge}
       */
      createObservableGauge(_name, _options) {
        return exports.NOOP_OBSERVABLE_GAUGE_METRIC;
      }
      /**
       * @see {@link Meter.createObservableCounter}
       */
      createObservableCounter(_name, _options) {
        return exports.NOOP_OBSERVABLE_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.createObservableUpDownCounter}
       */
      createObservableUpDownCounter(_name, _options) {
        return exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      }
      /**
       * @see {@link Meter.addBatchObservableCallback}
       */
      addBatchObservableCallback(_callback, _observables) {
      }
      /**
       * @see {@link Meter.removeBatchObservableCallback}
       */
      removeBatchObservableCallback(_callback) {
      }
    };
    exports.NoopMeter = NoopMeter;
    var NoopMetric = class {
      static {
        __name(this, "NoopMetric");
      }
    };
    exports.NoopMetric = NoopMetric;
    var NoopCounterMetric = class extends NoopMetric {
      static {
        __name(this, "NoopCounterMetric");
      }
      add(_value, _attributes) {
      }
    };
    exports.NoopCounterMetric = NoopCounterMetric;
    var NoopUpDownCounterMetric = class extends NoopMetric {
      static {
        __name(this, "NoopUpDownCounterMetric");
      }
      add(_value, _attributes) {
      }
    };
    exports.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
    var NoopGaugeMetric = class extends NoopMetric {
      static {
        __name(this, "NoopGaugeMetric");
      }
      record(_value, _attributes) {
      }
    };
    exports.NoopGaugeMetric = NoopGaugeMetric;
    var NoopHistogramMetric = class extends NoopMetric {
      static {
        __name(this, "NoopHistogramMetric");
      }
      record(_value, _attributes) {
      }
    };
    exports.NoopHistogramMetric = NoopHistogramMetric;
    var NoopObservableMetric = class {
      static {
        __name(this, "NoopObservableMetric");
      }
      addCallback(_callback) {
      }
      removeCallback(_callback) {
      }
    };
    exports.NoopObservableMetric = NoopObservableMetric;
    var NoopObservableCounterMetric = class extends NoopObservableMetric {
      static {
        __name(this, "NoopObservableCounterMetric");
      }
    };
    exports.NoopObservableCounterMetric = NoopObservableCounterMetric;
    var NoopObservableGaugeMetric = class extends NoopObservableMetric {
      static {
        __name(this, "NoopObservableGaugeMetric");
      }
    };
    exports.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
    var NoopObservableUpDownCounterMetric = class extends NoopObservableMetric {
      static {
        __name(this, "NoopObservableUpDownCounterMetric");
      }
    };
    exports.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
    exports.NOOP_METER = new NoopMeter();
    exports.NOOP_COUNTER_METRIC = new NoopCounterMetric();
    exports.NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    exports.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    exports.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    exports.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    exports.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    exports.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
    function createNoopMeter() {
      return exports.NOOP_METER;
    }
    __name(createNoopMeter, "createNoopMeter");
    exports.createNoopMeter = createNoopMeter;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/Metric.js
var require_Metric = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/Metric.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueType = void 0;
    var ValueType;
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType = exports.ValueType || (exports.ValueType = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js
var require_TextMapPropagator = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation/TextMapPropagator.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultTextMapSetter = exports.defaultTextMapGetter = void 0;
    exports.defaultTextMapGetter = {
      get(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    exports.defaultTextMapSetter = {
      set(carrier, key, value6) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value6;
      }
    };
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js
var require_NoopContextManager = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context/NoopContextManager.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopContextManager = void 0;
    var context_1 = require_context();
    var NoopContextManager = class {
      static {
        __name(this, "NoopContextManager");
      }
      active() {
        return context_1.ROOT_CONTEXT;
      }
      with(_context, fn2, thisArg, ...args2) {
        return fn2.call(thisArg, ...args2);
      }
      bind(_context, target3) {
        return target3;
      }
      enable() {
        return this;
      }
      disable() {
        return this;
      }
    };
    exports.NoopContextManager = NoopContextManager;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/context.js
var require_context2 = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/context.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContextAPI = void 0;
    var NoopContextManager_1 = require_NoopContextManager();
    var global_utils_1 = require_global_utils();
    var diag_1 = require_diag();
    var API_NAME = "context";
    var NOOP_CONTEXT_MANAGER = new NoopContextManager_1.NoopContextManager();
    var ContextAPI = class _ContextAPI {
      static {
        __name(this, "ContextAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Context API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _ContextAPI();
        }
        return this._instance;
      }
      /**
       * Set the current context manager.
       *
       * @returns true if the context manager was successfully registered, else false
       */
      setGlobalContextManager(contextManager) {
        return (0, global_utils_1.registerGlobal)(API_NAME, contextManager, diag_1.DiagAPI.instance());
      }
      /**
       * Get the currently active context
       */
      active() {
        return this._getContextManager().active();
      }
      /**
       * Execute a function with an active context
       *
       * @param context context to be active during function execution
       * @param fn function to execute in a context
       * @param thisArg optional receiver to be used for calling fn
       * @param args optional arguments forwarded to fn
       */
      with(context17, fn2, thisArg, ...args2) {
        return this._getContextManager().with(context17, fn2, thisArg, ...args2);
      }
      /**
       * Bind a context to a target function or event emitter
       *
       * @param context context to bind to the event emitter or function. Defaults to the currently active context
       * @param target function or event emitter to bind
       */
      bind(context17, target3) {
        return this._getContextManager().bind(context17, target3);
      }
      _getContextManager() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_CONTEXT_MANAGER;
      }
      /** Disable and remove the global context manager */
      disable() {
        this._getContextManager().disable();
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    exports.ContextAPI = ContextAPI;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/trace_flags.js
var require_trace_flags = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/trace_flags.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceFlags = void 0;
    var TraceFlags2;
    (function(TraceFlags3) {
      TraceFlags3[TraceFlags3["NONE"] = 0] = "NONE";
      TraceFlags3[TraceFlags3["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags2 = exports.TraceFlags || (exports.TraceFlags = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js
var require_invalid_span_constants = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/invalid-span-constants.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = void 0;
    var trace_flags_1 = require_trace_flags();
    exports.INVALID_SPANID = "0000000000000000";
    exports.INVALID_TRACEID = "00000000000000000000000000000000";
    exports.INVALID_SPAN_CONTEXT = {
      traceId: exports.INVALID_TRACEID,
      spanId: exports.INVALID_SPANID,
      traceFlags: trace_flags_1.TraceFlags.NONE
    };
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js
var require_NonRecordingSpan = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NonRecordingSpan.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonRecordingSpan = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants();
    var NonRecordingSpan = class {
      static {
        __name(this, "NonRecordingSpan");
      }
      constructor(_spanContext = invalid_span_constants_1.INVALID_SPAN_CONTEXT) {
        this._spanContext = _spanContext;
      }
      // Returns a SpanContext.
      spanContext() {
        return this._spanContext;
      }
      // By default does nothing
      setAttribute(_key, _value) {
        return this;
      }
      // By default does nothing
      setAttributes(_attributes) {
        return this;
      }
      // By default does nothing
      addEvent(_name, _attributes) {
        return this;
      }
      addLink(_link) {
        return this;
      }
      addLinks(_links) {
        return this;
      }
      // By default does nothing
      setStatus(_status) {
        return this;
      }
      // By default does nothing
      updateName(_name) {
        return this;
      }
      // By default does nothing
      end(_endTime) {
      }
      // isRecording always returns false for NonRecordingSpan.
      isRecording() {
        return false;
      }
      // By default does nothing
      recordException(_exception, _time) {
      }
    };
    exports.NonRecordingSpan = NonRecordingSpan;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/context-utils.js
var require_context_utils = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/context-utils.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSpanContext = exports.setSpanContext = exports.deleteSpan = exports.setSpan = exports.getActiveSpan = exports.getSpan = void 0;
    var context_1 = require_context();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var context_2 = require_context2();
    var SPAN_KEY = (0, context_1.createContextKey)("OpenTelemetry Context Key SPAN");
    function getSpan(context17) {
      return context17.getValue(SPAN_KEY) || void 0;
    }
    __name(getSpan, "getSpan");
    exports.getSpan = getSpan;
    function getActiveSpan() {
      return getSpan(context_2.ContextAPI.getInstance().active());
    }
    __name(getActiveSpan, "getActiveSpan");
    exports.getActiveSpan = getActiveSpan;
    function setSpan(context17, span4) {
      return context17.setValue(SPAN_KEY, span4);
    }
    __name(setSpan, "setSpan");
    exports.setSpan = setSpan;
    function deleteSpan(context17) {
      return context17.deleteValue(SPAN_KEY);
    }
    __name(deleteSpan, "deleteSpan");
    exports.deleteSpan = deleteSpan;
    function setSpanContext(context17, spanContext) {
      return setSpan(context17, new NonRecordingSpan_1.NonRecordingSpan(spanContext));
    }
    __name(setSpanContext, "setSpanContext");
    exports.setSpanContext = setSpanContext;
    function getSpanContext(context17) {
      var _a;
      return (_a = getSpan(context17)) === null || _a === void 0 ? void 0 : _a.spanContext();
    }
    __name(getSpanContext, "getSpanContext");
    exports.getSpanContext = getSpanContext;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js
var require_spancontext_utils = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/spancontext-utils.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wrapSpanContext = exports.isSpanContextValid = exports.isValidSpanId = exports.isValidTraceId = void 0;
    var invalid_span_constants_1 = require_invalid_span_constants();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
    function isValidTraceId(traceId) {
      return VALID_TRACEID_REGEX.test(traceId) && traceId !== invalid_span_constants_1.INVALID_TRACEID;
    }
    __name(isValidTraceId, "isValidTraceId");
    exports.isValidTraceId = isValidTraceId;
    function isValidSpanId(spanId) {
      return VALID_SPANID_REGEX.test(spanId) && spanId !== invalid_span_constants_1.INVALID_SPANID;
    }
    __name(isValidSpanId, "isValidSpanId");
    exports.isValidSpanId = isValidSpanId;
    function isSpanContextValid(spanContext) {
      return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
    }
    __name(isSpanContextValid, "isSpanContextValid");
    exports.isSpanContextValid = isSpanContextValid;
    function wrapSpanContext(spanContext) {
      return new NonRecordingSpan_1.NonRecordingSpan(spanContext);
    }
    __name(wrapSpanContext, "wrapSpanContext");
    exports.wrapSpanContext = wrapSpanContext;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js
var require_NoopTracer = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracer.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopTracer = void 0;
    var context_1 = require_context2();
    var context_utils_1 = require_context_utils();
    var NonRecordingSpan_1 = require_NonRecordingSpan();
    var spancontext_utils_1 = require_spancontext_utils();
    var contextApi = context_1.ContextAPI.getInstance();
    var NoopTracer2 = class {
      static {
        __name(this, "NoopTracer");
      }
      // startSpan starts a noop span.
      startSpan(name, options4, context17 = contextApi.active()) {
        const root = Boolean(options4 === null || options4 === void 0 ? void 0 : options4.root);
        if (root) {
          return new NonRecordingSpan_1.NonRecordingSpan();
        }
        const parentFromContext = context17 && (0, context_utils_1.getSpanContext)(context17);
        if (isSpanContext(parentFromContext) && (0, spancontext_utils_1.isSpanContextValid)(parentFromContext)) {
          return new NonRecordingSpan_1.NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan_1.NonRecordingSpan();
        }
      }
      startActiveSpan(name, arg2, arg3, arg4) {
        let opts;
        let ctx;
        let fn2;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn2 = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn2 = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn2 = arg4;
        }
        const parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        const span4 = this.startSpan(name, opts, parentContext);
        const contextWithSpanSet = (0, context_utils_1.setSpan)(parentContext, span4);
        return contextApi.with(contextWithSpanSet, fn2, void 0, span4);
      }
    };
    exports.NoopTracer = NoopTracer2;
    function isSpanContext(spanContext) {
      return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
    }
    __name(isSpanContext, "isSpanContext");
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js
var require_ProxyTracer = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracer.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyTracer = void 0;
    var NoopTracer_1 = require_NoopTracer();
    var NOOP_TRACER = new NoopTracer_1.NoopTracer();
    var ProxyTracer = class {
      static {
        __name(this, "ProxyTracer");
      }
      constructor(_provider, name, version2, options4) {
        this._provider = _provider;
        this.name = name;
        this.version = version2;
        this.options = options4;
      }
      startSpan(name, options4, context17) {
        return this._getTracer().startSpan(name, options4, context17);
      }
      startActiveSpan(_name, _options, _context, _fn) {
        const tracer4 = this._getTracer();
        return Reflect.apply(tracer4.startActiveSpan, tracer4, arguments);
      }
      /**
       * Try to get a tracer from the proxy tracer provider.
       * If the proxy tracer provider has no delegate, return a noop tracer.
       */
      _getTracer() {
        if (this._delegate) {
          return this._delegate;
        }
        const tracer4 = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer4) {
          return NOOP_TRACER;
        }
        this._delegate = tracer4;
        return this._delegate;
      }
    };
    exports.ProxyTracer = ProxyTracer;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js
var require_NoopTracerProvider = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/NoopTracerProvider.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopTracerProvider = void 0;
    var NoopTracer_1 = require_NoopTracer();
    var NoopTracerProvider = class {
      static {
        __name(this, "NoopTracerProvider");
      }
      getTracer(_name, _version2, _options) {
        return new NoopTracer_1.NoopTracer();
      }
    };
    exports.NoopTracerProvider = NoopTracerProvider;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js
var require_ProxyTracerProvider = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/ProxyTracerProvider.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProxyTracerProvider = void 0;
    var ProxyTracer_1 = require_ProxyTracer();
    var NoopTracerProvider_1 = require_NoopTracerProvider();
    var NOOP_TRACER_PROVIDER = new NoopTracerProvider_1.NoopTracerProvider();
    var ProxyTracerProvider = class {
      static {
        __name(this, "ProxyTracerProvider");
      }
      /**
       * Get a {@link ProxyTracer}
       */
      getTracer(name, version2, options4) {
        var _a;
        return (_a = this.getDelegateTracer(name, version2, options4)) !== null && _a !== void 0 ? _a : new ProxyTracer_1.ProxyTracer(this, name, version2, options4);
      }
      getDelegate() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      }
      /**
       * Set the delegate tracer provider
       */
      setDelegate(delegate) {
        this._delegate = delegate;
      }
      getDelegateTracer(name, version2, options4) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version2, options4);
      }
    };
    exports.ProxyTracerProvider = ProxyTracerProvider;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js
var require_SamplingResult = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/SamplingResult.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SamplingDecision = void 0;
    var SamplingDecision;
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision = exports.SamplingDecision || (exports.SamplingDecision = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/span_kind.js
var require_span_kind = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/span_kind.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpanKind = void 0;
    var SpanKind3;
    (function(SpanKind4) {
      SpanKind4[SpanKind4["INTERNAL"] = 0] = "INTERNAL";
      SpanKind4[SpanKind4["SERVER"] = 1] = "SERVER";
      SpanKind4[SpanKind4["CLIENT"] = 2] = "CLIENT";
      SpanKind4[SpanKind4["PRODUCER"] = 3] = "PRODUCER";
      SpanKind4[SpanKind4["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind3 = exports.SpanKind || (exports.SpanKind = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/status.js
var require_status = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/status.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpanStatusCode = void 0;
    var SpanStatusCode2;
    (function(SpanStatusCode3) {
      SpanStatusCode3[SpanStatusCode3["UNSET"] = 0] = "UNSET";
      SpanStatusCode3[SpanStatusCode3["OK"] = 1] = "OK";
      SpanStatusCode3[SpanStatusCode3["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode2 = exports.SpanStatusCode || (exports.SpanStatusCode = {}));
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js
var require_tracestate_validators = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-validators.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateValue = exports.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    var VALID_KEY = `[a-z]${VALID_KEY_CHAR_RANGE}{0,255}`;
    var VALID_VENDOR_KEY = `[a-z0-9]${VALID_KEY_CHAR_RANGE}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE}{0,13}`;
    var VALID_KEY_REGEX = new RegExp(`^(?:${VALID_KEY}|${VALID_VENDOR_KEY})$`);
    var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
    function validateKey(key) {
      return VALID_KEY_REGEX.test(key);
    }
    __name(validateKey, "validateKey");
    exports.validateKey = validateKey;
    function validateValue(value6) {
      return VALID_VALUE_BASE_REGEX.test(value6) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value6);
    }
    __name(validateValue, "validateValue");
    exports.validateValue = validateValue;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js
var require_tracestate_impl = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/tracestate-impl.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceStateImpl = void 0;
    var tracestate_validators_1 = require_tracestate_validators();
    var MAX_TRACE_STATE_ITEMS = 32;
    var MAX_TRACE_STATE_LEN = 512;
    var LIST_MEMBERS_SEPARATOR = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    var TraceStateImpl = class _TraceStateImpl {
      static {
        __name(this, "TraceStateImpl");
      }
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value6) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value6);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            const key = listMember.slice(0, i);
            const value6 = listMember.slice(i + 1, part.length);
            if ((0, tracestate_validators_1.validateKey)(key) && (0, tracestate_validators_1.validateValue)(value6)) {
              agg.set(key, value6);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceStateImpl();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports.TraceStateImpl = TraceStateImpl;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace/internal/utils.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createTraceState = void 0;
    var tracestate_impl_1 = require_tracestate_impl();
    function createTraceState3(rawTraceState) {
      return new tracestate_impl_1.TraceStateImpl(rawTraceState);
    }
    __name(createTraceState3, "createTraceState");
    exports.createTraceState = createTraceState3;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context-api.js
var require_context_api = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/context-api.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.context = void 0;
    var context_1 = require_context2();
    exports.context = context_1.ContextAPI.getInstance();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag-api.js
var require_diag_api = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/diag-api.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.diag = void 0;
    var diag_1 = require_diag();
    exports.diag = diag_1.DiagAPI.instance();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js
var require_NoopMeterProvider = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics/NoopMeterProvider.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NOOP_METER_PROVIDER = exports.NoopMeterProvider = void 0;
    var NoopMeter_1 = require_NoopMeter();
    var NoopMeterProvider = class {
      static {
        __name(this, "NoopMeterProvider");
      }
      getMeter(_name, _version2, _options) {
        return NoopMeter_1.NOOP_METER;
      }
    };
    exports.NoopMeterProvider = NoopMeterProvider;
    exports.NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/metrics.js
var require_metrics = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/metrics.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MetricsAPI = void 0;
    var NoopMeterProvider_1 = require_NoopMeterProvider();
    var global_utils_1 = require_global_utils();
    var diag_1 = require_diag();
    var API_NAME = "metrics";
    var MetricsAPI = class _MetricsAPI {
      static {
        __name(this, "MetricsAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
      }
      /** Get the singleton instance of the Metrics API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _MetricsAPI();
        }
        return this._instance;
      }
      /**
       * Set the current global meter provider.
       * Returns true if the meter provider was successfully registered, else false.
       */
      setGlobalMeterProvider(provider) {
        return (0, global_utils_1.registerGlobal)(API_NAME, provider, diag_1.DiagAPI.instance());
      }
      /**
       * Returns the global meter provider.
       */
      getMeterProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NoopMeterProvider_1.NOOP_METER_PROVIDER;
      }
      /**
       * Returns a meter from the global meter provider.
       */
      getMeter(name, version2, options4) {
        return this.getMeterProvider().getMeter(name, version2, options4);
      }
      /** Remove the global meter provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
    };
    exports.MetricsAPI = MetricsAPI;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics-api.js
var require_metrics_api = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/metrics-api.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.metrics = void 0;
    var metrics_1 = require_metrics();
    exports.metrics = metrics_1.MetricsAPI.getInstance();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js
var require_NoopTextMapPropagator = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation/NoopTextMapPropagator.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NoopTextMapPropagator = void 0;
    var NoopTextMapPropagator = class {
      static {
        __name(this, "NoopTextMapPropagator");
      }
      /** Noop inject function does nothing */
      inject(_context, _carrier) {
      }
      /** Noop extract function does nothing and returns the input context */
      extract(context17, _carrier) {
        return context17;
      }
      fields() {
        return [];
      }
    };
    exports.NoopTextMapPropagator = NoopTextMapPropagator;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js
var require_context_helpers = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/baggage/context-helpers.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deleteBaggage = exports.setBaggage = exports.getActiveBaggage = exports.getBaggage = void 0;
    var context_1 = require_context2();
    var context_2 = require_context();
    var BAGGAGE_KEY = (0, context_2.createContextKey)("OpenTelemetry Baggage Key");
    function getBaggage(context17) {
      return context17.getValue(BAGGAGE_KEY) || void 0;
    }
    __name(getBaggage, "getBaggage");
    exports.getBaggage = getBaggage;
    function getActiveBaggage() {
      return getBaggage(context_1.ContextAPI.getInstance().active());
    }
    __name(getActiveBaggage, "getActiveBaggage");
    exports.getActiveBaggage = getActiveBaggage;
    function setBaggage(context17, baggage) {
      return context17.setValue(BAGGAGE_KEY, baggage);
    }
    __name(setBaggage, "setBaggage");
    exports.setBaggage = setBaggage;
    function deleteBaggage(context17) {
      return context17.deleteValue(BAGGAGE_KEY);
    }
    __name(deleteBaggage, "deleteBaggage");
    exports.deleteBaggage = deleteBaggage;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/propagation.js
var require_propagation = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/propagation.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PropagationAPI = void 0;
    var global_utils_1 = require_global_utils();
    var NoopTextMapPropagator_1 = require_NoopTextMapPropagator();
    var TextMapPropagator_1 = require_TextMapPropagator();
    var context_helpers_1 = require_context_helpers();
    var utils_1 = require_utils();
    var diag_1 = require_diag();
    var API_NAME = "propagation";
    var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator_1.NoopTextMapPropagator();
    var PropagationAPI = class _PropagationAPI {
      static {
        __name(this, "PropagationAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this.createBaggage = utils_1.createBaggage;
        this.getBaggage = context_helpers_1.getBaggage;
        this.getActiveBaggage = context_helpers_1.getActiveBaggage;
        this.setBaggage = context_helpers_1.setBaggage;
        this.deleteBaggage = context_helpers_1.deleteBaggage;
      }
      /** Get the singleton instance of the Propagator API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _PropagationAPI();
        }
        return this._instance;
      }
      /**
       * Set the current propagator.
       *
       * @returns true if the propagator was successfully registered, else false
       */
      setGlobalPropagator(propagator) {
        return (0, global_utils_1.registerGlobal)(API_NAME, propagator, diag_1.DiagAPI.instance());
      }
      /**
       * Inject context into a carrier to be propagated inter-process
       *
       * @param context Context carrying tracing data to inject
       * @param carrier carrier to inject context into
       * @param setter Function used to set values on the carrier
       */
      inject(context17, carrier, setter = TextMapPropagator_1.defaultTextMapSetter) {
        return this._getGlobalPropagator().inject(context17, carrier, setter);
      }
      /**
       * Extract context from a carrier
       *
       * @param context Context which the newly created context will inherit from
       * @param carrier Carrier to extract context from
       * @param getter Function used to extract keys from a carrier
       */
      extract(context17, carrier, getter = TextMapPropagator_1.defaultTextMapGetter) {
        return this._getGlobalPropagator().extract(context17, carrier, getter);
      }
      /**
       * Return a list of all fields which may be used by the propagator.
       */
      fields() {
        return this._getGlobalPropagator().fields();
      }
      /** Remove the global propagator */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
      }
      _getGlobalPropagator() {
        return (0, global_utils_1.getGlobal)(API_NAME) || NOOP_TEXT_MAP_PROPAGATOR;
      }
    };
    exports.PropagationAPI = PropagationAPI;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation-api.js
var require_propagation_api = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/propagation-api.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.propagation = void 0;
    var propagation_1 = require_propagation();
    exports.propagation = propagation_1.PropagationAPI.getInstance();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/trace.js
var require_trace = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/api/trace.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceAPI = void 0;
    var global_utils_1 = require_global_utils();
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    var spancontext_utils_1 = require_spancontext_utils();
    var context_utils_1 = require_context_utils();
    var diag_1 = require_diag();
    var API_NAME = "trace";
    var TraceAPI = class _TraceAPI {
      static {
        __name(this, "TraceAPI");
      }
      /** Empty private constructor prevents end users from constructing a new instance of the API */
      constructor() {
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
        this.wrapSpanContext = spancontext_utils_1.wrapSpanContext;
        this.isSpanContextValid = spancontext_utils_1.isSpanContextValid;
        this.deleteSpan = context_utils_1.deleteSpan;
        this.getSpan = context_utils_1.getSpan;
        this.getActiveSpan = context_utils_1.getActiveSpan;
        this.getSpanContext = context_utils_1.getSpanContext;
        this.setSpan = context_utils_1.setSpan;
        this.setSpanContext = context_utils_1.setSpanContext;
      }
      /** Get the singleton instance of the Trace API */
      static getInstance() {
        if (!this._instance) {
          this._instance = new _TraceAPI();
        }
        return this._instance;
      }
      /**
       * Set the current global tracer.
       *
       * @returns true if the tracer provider was successfully registered, else false
       */
      setGlobalTracerProvider(provider) {
        const success = (0, global_utils_1.registerGlobal)(API_NAME, this._proxyTracerProvider, diag_1.DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      }
      /**
       * Returns the global tracer provider.
       */
      getTracerProvider() {
        return (0, global_utils_1.getGlobal)(API_NAME) || this._proxyTracerProvider;
      }
      /**
       * Returns a tracer from the global tracer provider.
       */
      getTracer(name, version2) {
        return this.getTracerProvider().getTracer(name, version2);
      }
      /** Remove the global tracer provider */
      disable() {
        (0, global_utils_1.unregisterGlobal)(API_NAME, diag_1.DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider_1.ProxyTracerProvider();
      }
    };
    exports.TraceAPI = TraceAPI;
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace-api.js
var require_trace_api = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/trace-api.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trace = void 0;
    var trace_1 = require_trace();
    exports.trace = trace_1.TraceAPI.getInstance();
  }
});

// node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/src/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.trace = exports.propagation = exports.metrics = exports.diag = exports.context = exports.INVALID_SPAN_CONTEXT = exports.INVALID_TRACEID = exports.INVALID_SPANID = exports.isValidSpanId = exports.isValidTraceId = exports.isSpanContextValid = exports.createTraceState = exports.TraceFlags = exports.SpanStatusCode = exports.SpanKind = exports.SamplingDecision = exports.ProxyTracerProvider = exports.ProxyTracer = exports.defaultTextMapSetter = exports.defaultTextMapGetter = exports.ValueType = exports.createNoopMeter = exports.DiagLogLevel = exports.DiagConsoleLogger = exports.ROOT_CONTEXT = exports.createContextKey = exports.baggageEntryMetadataFromString = void 0;
    var utils_1 = require_utils();
    Object.defineProperty(exports, "baggageEntryMetadataFromString", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return utils_1.baggageEntryMetadataFromString;
    }, "get") });
    var context_1 = require_context();
    Object.defineProperty(exports, "createContextKey", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return context_1.createContextKey;
    }, "get") });
    Object.defineProperty(exports, "ROOT_CONTEXT", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return context_1.ROOT_CONTEXT;
    }, "get") });
    var consoleLogger_1 = require_consoleLogger();
    Object.defineProperty(exports, "DiagConsoleLogger", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return consoleLogger_1.DiagConsoleLogger;
    }, "get") });
    var types_1 = require_types();
    Object.defineProperty(exports, "DiagLogLevel", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return types_1.DiagLogLevel;
    }, "get") });
    var NoopMeter_1 = require_NoopMeter();
    Object.defineProperty(exports, "createNoopMeter", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return NoopMeter_1.createNoopMeter;
    }, "get") });
    var Metric_1 = require_Metric();
    Object.defineProperty(exports, "ValueType", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return Metric_1.ValueType;
    }, "get") });
    var TextMapPropagator_1 = require_TextMapPropagator();
    Object.defineProperty(exports, "defaultTextMapGetter", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return TextMapPropagator_1.defaultTextMapGetter;
    }, "get") });
    Object.defineProperty(exports, "defaultTextMapSetter", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return TextMapPropagator_1.defaultTextMapSetter;
    }, "get") });
    var ProxyTracer_1 = require_ProxyTracer();
    Object.defineProperty(exports, "ProxyTracer", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ProxyTracer_1.ProxyTracer;
    }, "get") });
    var ProxyTracerProvider_1 = require_ProxyTracerProvider();
    Object.defineProperty(exports, "ProxyTracerProvider", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return ProxyTracerProvider_1.ProxyTracerProvider;
    }, "get") });
    var SamplingResult_1 = require_SamplingResult();
    Object.defineProperty(exports, "SamplingDecision", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return SamplingResult_1.SamplingDecision;
    }, "get") });
    var span_kind_1 = require_span_kind();
    Object.defineProperty(exports, "SpanKind", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return span_kind_1.SpanKind;
    }, "get") });
    var status_1 = require_status();
    Object.defineProperty(exports, "SpanStatusCode", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return status_1.SpanStatusCode;
    }, "get") });
    var trace_flags_1 = require_trace_flags();
    Object.defineProperty(exports, "TraceFlags", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return trace_flags_1.TraceFlags;
    }, "get") });
    var utils_2 = require_utils2();
    Object.defineProperty(exports, "createTraceState", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return utils_2.createTraceState;
    }, "get") });
    var spancontext_utils_1 = require_spancontext_utils();
    Object.defineProperty(exports, "isSpanContextValid", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return spancontext_utils_1.isSpanContextValid;
    }, "get") });
    Object.defineProperty(exports, "isValidTraceId", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return spancontext_utils_1.isValidTraceId;
    }, "get") });
    Object.defineProperty(exports, "isValidSpanId", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return spancontext_utils_1.isValidSpanId;
    }, "get") });
    var invalid_span_constants_1 = require_invalid_span_constants();
    Object.defineProperty(exports, "INVALID_SPANID", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return invalid_span_constants_1.INVALID_SPANID;
    }, "get") });
    Object.defineProperty(exports, "INVALID_TRACEID", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return invalid_span_constants_1.INVALID_TRACEID;
    }, "get") });
    Object.defineProperty(exports, "INVALID_SPAN_CONTEXT", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return invalid_span_constants_1.INVALID_SPAN_CONTEXT;
    }, "get") });
    var context_api_1 = require_context_api();
    Object.defineProperty(exports, "context", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return context_api_1.context;
    }, "get") });
    var diag_api_1 = require_diag_api();
    Object.defineProperty(exports, "diag", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return diag_api_1.diag;
    }, "get") });
    var metrics_api_1 = require_metrics_api();
    Object.defineProperty(exports, "metrics", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return metrics_api_1.metrics;
    }, "get") });
    var propagation_api_1 = require_propagation_api();
    Object.defineProperty(exports, "propagation", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return propagation_api_1.propagation;
    }, "get") });
    var trace_api_1 = require_trace_api();
    Object.defineProperty(exports, "trace", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return trace_api_1.trace;
    }, "get") });
    exports.default = {
      context: context_api_1.context,
      diag: diag_api_1.diag,
      metrics: metrics_api_1.metrics,
      propagation: propagation_api_1.propagation,
      trace: trace_api_1.trace
    };
  }
});

// node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/internal/utils.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createConstMap = void 0;
    // @__NO_SIDE_EFFECTS__
    function createConstMap(values6) {
      let res = {};
      const len = values6.length;
      for (let lp = 0; lp < len; lp++) {
        const val = values6[lp];
        if (val) {
          res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
        }
      }
      return res;
    }
    __name(createConstMap, "createConstMap");
    exports.createConstMap = createConstMap;
  }
});

// node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js
var require_SemanticAttributes = __commonJS({
  "node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/trace/SemanticAttributes.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = exports.SEMATTRS_NET_HOST_CARRIER_MNC = exports.SEMATTRS_NET_HOST_CARRIER_MCC = exports.SEMATTRS_NET_HOST_CARRIER_NAME = exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = exports.SEMATTRS_NET_HOST_NAME = exports.SEMATTRS_NET_HOST_PORT = exports.SEMATTRS_NET_HOST_IP = exports.SEMATTRS_NET_PEER_NAME = exports.SEMATTRS_NET_PEER_PORT = exports.SEMATTRS_NET_PEER_IP = exports.SEMATTRS_NET_TRANSPORT = exports.SEMATTRS_FAAS_INVOKED_REGION = exports.SEMATTRS_FAAS_INVOKED_PROVIDER = exports.SEMATTRS_FAAS_INVOKED_NAME = exports.SEMATTRS_FAAS_COLDSTART = exports.SEMATTRS_FAAS_CRON = exports.SEMATTRS_FAAS_TIME = exports.SEMATTRS_FAAS_DOCUMENT_NAME = exports.SEMATTRS_FAAS_DOCUMENT_TIME = exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = exports.SEMATTRS_FAAS_EXECUTION = exports.SEMATTRS_FAAS_TRIGGER = exports.SEMATTRS_EXCEPTION_ESCAPED = exports.SEMATTRS_EXCEPTION_STACKTRACE = exports.SEMATTRS_EXCEPTION_MESSAGE = exports.SEMATTRS_EXCEPTION_TYPE = exports.SEMATTRS_DB_SQL_TABLE = exports.SEMATTRS_DB_MONGODB_COLLECTION = exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = exports.SEMATTRS_DB_HBASE_NAMESPACE = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = exports.SEMATTRS_DB_CASSANDRA_TABLE = exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = exports.SEMATTRS_DB_OPERATION = exports.SEMATTRS_DB_STATEMENT = exports.SEMATTRS_DB_NAME = exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = exports.SEMATTRS_DB_USER = exports.SEMATTRS_DB_CONNECTION_STRING = exports.SEMATTRS_DB_SYSTEM = exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = void 0;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = exports.SEMATTRS_MESSAGING_DESTINATION = exports.SEMATTRS_MESSAGING_SYSTEM = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = exports.SEMATTRS_AWS_DYNAMODB_COUNT = exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = exports.SEMATTRS_AWS_DYNAMODB_SELECT = exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = exports.SEMATTRS_AWS_DYNAMODB_LIMIT = exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = exports.SEMATTRS_HTTP_CLIENT_IP = exports.SEMATTRS_HTTP_ROUTE = exports.SEMATTRS_HTTP_SERVER_NAME = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = exports.SEMATTRS_HTTP_USER_AGENT = exports.SEMATTRS_HTTP_FLAVOR = exports.SEMATTRS_HTTP_STATUS_CODE = exports.SEMATTRS_HTTP_SCHEME = exports.SEMATTRS_HTTP_HOST = exports.SEMATTRS_HTTP_TARGET = exports.SEMATTRS_HTTP_URL = exports.SEMATTRS_HTTP_METHOD = exports.SEMATTRS_CODE_LINENO = exports.SEMATTRS_CODE_FILEPATH = exports.SEMATTRS_CODE_NAMESPACE = exports.SEMATTRS_CODE_FUNCTION = exports.SEMATTRS_THREAD_NAME = exports.SEMATTRS_THREAD_ID = exports.SEMATTRS_ENDUSER_SCOPE = exports.SEMATTRS_ENDUSER_ROLE = exports.SEMATTRS_ENDUSER_ID = exports.SEMATTRS_PEER_SERVICE = void 0;
    exports.DBSYSTEMVALUES_FILEMAKER = exports.DBSYSTEMVALUES_DERBY = exports.DBSYSTEMVALUES_FIREBIRD = exports.DBSYSTEMVALUES_ADABAS = exports.DBSYSTEMVALUES_CACHE = exports.DBSYSTEMVALUES_EDB = exports.DBSYSTEMVALUES_FIRSTSQL = exports.DBSYSTEMVALUES_INGRES = exports.DBSYSTEMVALUES_HANADB = exports.DBSYSTEMVALUES_MAXDB = exports.DBSYSTEMVALUES_PROGRESS = exports.DBSYSTEMVALUES_HSQLDB = exports.DBSYSTEMVALUES_CLOUDSCAPE = exports.DBSYSTEMVALUES_HIVE = exports.DBSYSTEMVALUES_REDSHIFT = exports.DBSYSTEMVALUES_POSTGRESQL = exports.DBSYSTEMVALUES_DB2 = exports.DBSYSTEMVALUES_ORACLE = exports.DBSYSTEMVALUES_MYSQL = exports.DBSYSTEMVALUES_MSSQL = exports.DBSYSTEMVALUES_OTHER_SQL = exports.SemanticAttributes = exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = exports.SEMATTRS_MESSAGE_ID = exports.SEMATTRS_MESSAGE_TYPE = exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = exports.SEMATTRS_RPC_JSONRPC_VERSION = exports.SEMATTRS_RPC_GRPC_STATUS_CODE = exports.SEMATTRS_RPC_METHOD = exports.SEMATTRS_RPC_SERVICE = exports.SEMATTRS_RPC_SYSTEM = exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = exports.SEMATTRS_MESSAGING_CONSUMER_ID = exports.SEMATTRS_MESSAGING_OPERATION = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = exports.SEMATTRS_MESSAGING_CONVERSATION_ID = exports.SEMATTRS_MESSAGING_MESSAGE_ID = exports.SEMATTRS_MESSAGING_URL = exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = exports.SEMATTRS_MESSAGING_PROTOCOL = exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = void 0;
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = exports.FaasDocumentOperationValues = exports.FAASDOCUMENTOPERATIONVALUES_DELETE = exports.FAASDOCUMENTOPERATIONVALUES_EDIT = exports.FAASDOCUMENTOPERATIONVALUES_INSERT = exports.FaasTriggerValues = exports.FAASTRIGGERVALUES_OTHER = exports.FAASTRIGGERVALUES_TIMER = exports.FAASTRIGGERVALUES_PUBSUB = exports.FAASTRIGGERVALUES_HTTP = exports.FAASTRIGGERVALUES_DATASOURCE = exports.DbCassandraConsistencyLevelValues = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = exports.DbSystemValues = exports.DBSYSTEMVALUES_COCKROACHDB = exports.DBSYSTEMVALUES_MEMCACHED = exports.DBSYSTEMVALUES_ELASTICSEARCH = exports.DBSYSTEMVALUES_GEODE = exports.DBSYSTEMVALUES_NEO4J = exports.DBSYSTEMVALUES_DYNAMODB = exports.DBSYSTEMVALUES_COSMOSDB = exports.DBSYSTEMVALUES_COUCHDB = exports.DBSYSTEMVALUES_COUCHBASE = exports.DBSYSTEMVALUES_REDIS = exports.DBSYSTEMVALUES_MONGODB = exports.DBSYSTEMVALUES_HBASE = exports.DBSYSTEMVALUES_CASSANDRA = exports.DBSYSTEMVALUES_COLDFUSION = exports.DBSYSTEMVALUES_H2 = exports.DBSYSTEMVALUES_VERTICA = exports.DBSYSTEMVALUES_TERADATA = exports.DBSYSTEMVALUES_SYBASE = exports.DBSYSTEMVALUES_SQLITE = exports.DBSYSTEMVALUES_POINTBASE = exports.DBSYSTEMVALUES_PERVASIVE = exports.DBSYSTEMVALUES_NETEZZA = exports.DBSYSTEMVALUES_MARIADB = exports.DBSYSTEMVALUES_INTERBASE = exports.DBSYSTEMVALUES_INSTANTDB = exports.DBSYSTEMVALUES_INFORMIX = void 0;
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = exports.MessagingDestinationKindValues = exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = exports.HttpFlavorValues = exports.HTTPFLAVORVALUES_QUIC = exports.HTTPFLAVORVALUES_SPDY = exports.HTTPFLAVORVALUES_HTTP_2_0 = exports.HTTPFLAVORVALUES_HTTP_1_1 = exports.HTTPFLAVORVALUES_HTTP_1_0 = exports.NetHostConnectionSubtypeValues = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = exports.NetHostConnectionTypeValues = exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = exports.NETHOSTCONNECTIONTYPEVALUES_CELL = exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = exports.NetTransportValues = exports.NETTRANSPORTVALUES_OTHER = exports.NETTRANSPORTVALUES_INPROC = exports.NETTRANSPORTVALUES_PIPE = exports.NETTRANSPORTVALUES_UNIX = exports.NETTRANSPORTVALUES_IP = exports.NETTRANSPORTVALUES_IP_UDP = exports.NETTRANSPORTVALUES_IP_TCP = exports.FaasInvokedProviderValues = exports.FAASINVOKEDPROVIDERVALUES_GCP = exports.FAASINVOKEDPROVIDERVALUES_AZURE = exports.FAASINVOKEDPROVIDERVALUES_AWS = void 0;
    exports.MessageTypeValues = exports.MESSAGETYPEVALUES_RECEIVED = exports.MESSAGETYPEVALUES_SENT = exports.RpcGrpcStatusCodeValues = exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = exports.RPCGRPCSTATUSCODEVALUES_ABORTED = exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = exports.RPCGRPCSTATUSCODEVALUES_OK = exports.MessagingOperationValues = exports.MESSAGINGOPERATIONVALUES_PROCESS = void 0;
    var utils_1 = require_utils3();
    var TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
    var TMP_DB_SYSTEM = "db.system";
    var TMP_DB_CONNECTION_STRING = "db.connection_string";
    var TMP_DB_USER = "db.user";
    var TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
    var TMP_DB_NAME = "db.name";
    var TMP_DB_STATEMENT = "db.statement";
    var TMP_DB_OPERATION = "db.operation";
    var TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
    var TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
    var TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
    var TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
    var TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
    var TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
    var TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
    var TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
    var TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
    var TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
    var TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
    var TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
    var TMP_DB_SQL_TABLE = "db.sql.table";
    var TMP_EXCEPTION_TYPE = "exception.type";
    var TMP_EXCEPTION_MESSAGE = "exception.message";
    var TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
    var TMP_EXCEPTION_ESCAPED = "exception.escaped";
    var TMP_FAAS_TRIGGER = "faas.trigger";
    var TMP_FAAS_EXECUTION = "faas.execution";
    var TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
    var TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
    var TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
    var TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
    var TMP_FAAS_TIME = "faas.time";
    var TMP_FAAS_CRON = "faas.cron";
    var TMP_FAAS_COLDSTART = "faas.coldstart";
    var TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
    var TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
    var TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
    var TMP_NET_TRANSPORT = "net.transport";
    var TMP_NET_PEER_IP = "net.peer.ip";
    var TMP_NET_PEER_PORT = "net.peer.port";
    var TMP_NET_PEER_NAME = "net.peer.name";
    var TMP_NET_HOST_IP = "net.host.ip";
    var TMP_NET_HOST_PORT = "net.host.port";
    var TMP_NET_HOST_NAME = "net.host.name";
    var TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
    var TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
    var TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
    var TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
    var TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
    var TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
    var TMP_PEER_SERVICE = "peer.service";
    var TMP_ENDUSER_ID = "enduser.id";
    var TMP_ENDUSER_ROLE = "enduser.role";
    var TMP_ENDUSER_SCOPE = "enduser.scope";
    var TMP_THREAD_ID = "thread.id";
    var TMP_THREAD_NAME = "thread.name";
    var TMP_CODE_FUNCTION = "code.function";
    var TMP_CODE_NAMESPACE = "code.namespace";
    var TMP_CODE_FILEPATH = "code.filepath";
    var TMP_CODE_LINENO = "code.lineno";
    var TMP_HTTP_METHOD = "http.method";
    var TMP_HTTP_URL = "http.url";
    var TMP_HTTP_TARGET = "http.target";
    var TMP_HTTP_HOST = "http.host";
    var TMP_HTTP_SCHEME = "http.scheme";
    var TMP_HTTP_STATUS_CODE = "http.status_code";
    var TMP_HTTP_FLAVOR = "http.flavor";
    var TMP_HTTP_USER_AGENT = "http.user_agent";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
    var TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
    var TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
    var TMP_HTTP_SERVER_NAME = "http.server_name";
    var TMP_HTTP_ROUTE = "http.route";
    var TMP_HTTP_CLIENT_IP = "http.client_ip";
    var TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
    var TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
    var TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
    var TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
    var TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
    var TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
    var TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
    var TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
    var TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
    var TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
    var TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
    var TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
    var TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
    var TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
    var TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
    var TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
    var TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
    var TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
    var TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
    var TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
    var TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
    var TMP_MESSAGING_SYSTEM = "messaging.system";
    var TMP_MESSAGING_DESTINATION = "messaging.destination";
    var TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
    var TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
    var TMP_MESSAGING_PROTOCOL = "messaging.protocol";
    var TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
    var TMP_MESSAGING_URL = "messaging.url";
    var TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
    var TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
    var TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
    var TMP_MESSAGING_OPERATION = "messaging.operation";
    var TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
    var TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
    var TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
    var TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
    var TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
    var TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
    var TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
    var TMP_RPC_SYSTEM = "rpc.system";
    var TMP_RPC_SERVICE = "rpc.service";
    var TMP_RPC_METHOD = "rpc.method";
    var TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
    var TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
    var TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
    var TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
    var TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
    var TMP_MESSAGE_TYPE = "message.type";
    var TMP_MESSAGE_ID = "message.id";
    var TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
    var TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
    exports.SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
    exports.SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
    exports.SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
    exports.SEMATTRS_DB_USER = TMP_DB_USER;
    exports.SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
    exports.SEMATTRS_DB_NAME = TMP_DB_NAME;
    exports.SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
    exports.SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
    exports.SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
    exports.SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
    exports.SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
    exports.SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
    exports.SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
    exports.SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
    exports.SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
    exports.SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
    exports.SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
    exports.SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
    exports.SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
    exports.SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
    exports.SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
    exports.SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
    exports.SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
    exports.SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
    exports.SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
    exports.SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
    exports.SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
    exports.SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
    exports.SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
    exports.SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
    exports.SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
    exports.SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
    exports.SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
    exports.SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
    exports.SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
    exports.SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
    exports.SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
    exports.SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
    exports.SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
    exports.SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
    exports.SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
    exports.SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
    exports.SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
    exports.SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
    exports.SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
    exports.SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
    exports.SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
    exports.SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
    exports.SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
    exports.SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
    exports.SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
    exports.SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
    exports.SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
    exports.SEMATTRS_THREAD_ID = TMP_THREAD_ID;
    exports.SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
    exports.SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
    exports.SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
    exports.SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
    exports.SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
    exports.SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
    exports.SEMATTRS_HTTP_URL = TMP_HTTP_URL;
    exports.SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
    exports.SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
    exports.SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
    exports.SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
    exports.SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
    exports.SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
    exports.SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
    exports.SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
    exports.SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
    exports.SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
    exports.SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
    exports.SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
    exports.SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
    exports.SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
    exports.SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
    exports.SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
    exports.SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
    exports.SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
    exports.SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
    exports.SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
    exports.SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
    exports.SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
    exports.SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
    exports.SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
    exports.SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
    exports.SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
    exports.SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
    exports.SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
    exports.SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
    exports.SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
    exports.SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
    exports.SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
    exports.SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
    exports.SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
    exports.SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
    exports.SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
    exports.SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
    exports.SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
    exports.SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
    exports.SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
    exports.SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
    exports.SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
    exports.SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
    exports.SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
    exports.SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
    exports.SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
    exports.SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
    exports.SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
    exports.SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
    exports.SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
    exports.SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
    exports.SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
    exports.SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
    exports.SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
    exports.SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
    exports.SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
    exports.SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
    exports.SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
    exports.SemanticAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWS_LAMBDA_INVOKED_ARN,
      TMP_DB_SYSTEM,
      TMP_DB_CONNECTION_STRING,
      TMP_DB_USER,
      TMP_DB_JDBC_DRIVER_CLASSNAME,
      TMP_DB_NAME,
      TMP_DB_STATEMENT,
      TMP_DB_OPERATION,
      TMP_DB_MSSQL_INSTANCE_NAME,
      TMP_DB_CASSANDRA_KEYSPACE,
      TMP_DB_CASSANDRA_PAGE_SIZE,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
      TMP_DB_CASSANDRA_TABLE,
      TMP_DB_CASSANDRA_IDEMPOTENCE,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
      TMP_DB_CASSANDRA_COORDINATOR_ID,
      TMP_DB_CASSANDRA_COORDINATOR_DC,
      TMP_DB_HBASE_NAMESPACE,
      TMP_DB_REDIS_DATABASE_INDEX,
      TMP_DB_MONGODB_COLLECTION,
      TMP_DB_SQL_TABLE,
      TMP_EXCEPTION_TYPE,
      TMP_EXCEPTION_MESSAGE,
      TMP_EXCEPTION_STACKTRACE,
      TMP_EXCEPTION_ESCAPED,
      TMP_FAAS_TRIGGER,
      TMP_FAAS_EXECUTION,
      TMP_FAAS_DOCUMENT_COLLECTION,
      TMP_FAAS_DOCUMENT_OPERATION,
      TMP_FAAS_DOCUMENT_TIME,
      TMP_FAAS_DOCUMENT_NAME,
      TMP_FAAS_TIME,
      TMP_FAAS_CRON,
      TMP_FAAS_COLDSTART,
      TMP_FAAS_INVOKED_NAME,
      TMP_FAAS_INVOKED_PROVIDER,
      TMP_FAAS_INVOKED_REGION,
      TMP_NET_TRANSPORT,
      TMP_NET_PEER_IP,
      TMP_NET_PEER_PORT,
      TMP_NET_PEER_NAME,
      TMP_NET_HOST_IP,
      TMP_NET_HOST_PORT,
      TMP_NET_HOST_NAME,
      TMP_NET_HOST_CONNECTION_TYPE,
      TMP_NET_HOST_CONNECTION_SUBTYPE,
      TMP_NET_HOST_CARRIER_NAME,
      TMP_NET_HOST_CARRIER_MCC,
      TMP_NET_HOST_CARRIER_MNC,
      TMP_NET_HOST_CARRIER_ICC,
      TMP_PEER_SERVICE,
      TMP_ENDUSER_ID,
      TMP_ENDUSER_ROLE,
      TMP_ENDUSER_SCOPE,
      TMP_THREAD_ID,
      TMP_THREAD_NAME,
      TMP_CODE_FUNCTION,
      TMP_CODE_NAMESPACE,
      TMP_CODE_FILEPATH,
      TMP_CODE_LINENO,
      TMP_HTTP_METHOD,
      TMP_HTTP_URL,
      TMP_HTTP_TARGET,
      TMP_HTTP_HOST,
      TMP_HTTP_SCHEME,
      TMP_HTTP_STATUS_CODE,
      TMP_HTTP_FLAVOR,
      TMP_HTTP_USER_AGENT,
      TMP_HTTP_REQUEST_CONTENT_LENGTH,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_SERVER_NAME,
      TMP_HTTP_ROUTE,
      TMP_HTTP_CLIENT_IP,
      TMP_AWS_DYNAMODB_TABLE_NAMES,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
      TMP_AWS_DYNAMODB_CONSISTENT_READ,
      TMP_AWS_DYNAMODB_PROJECTION,
      TMP_AWS_DYNAMODB_LIMIT,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
      TMP_AWS_DYNAMODB_INDEX_NAME,
      TMP_AWS_DYNAMODB_SELECT,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
      TMP_AWS_DYNAMODB_TABLE_COUNT,
      TMP_AWS_DYNAMODB_SCAN_FORWARD,
      TMP_AWS_DYNAMODB_SEGMENT,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
      TMP_AWS_DYNAMODB_COUNT,
      TMP_AWS_DYNAMODB_SCANNED_COUNT,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
      TMP_MESSAGING_SYSTEM,
      TMP_MESSAGING_DESTINATION,
      TMP_MESSAGING_DESTINATION_KIND,
      TMP_MESSAGING_TEMP_DESTINATION,
      TMP_MESSAGING_PROTOCOL,
      TMP_MESSAGING_PROTOCOL_VERSION,
      TMP_MESSAGING_URL,
      TMP_MESSAGING_MESSAGE_ID,
      TMP_MESSAGING_CONVERSATION_ID,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
      TMP_MESSAGING_OPERATION,
      TMP_MESSAGING_CONSUMER_ID,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
      TMP_MESSAGING_KAFKA_CLIENT_ID,
      TMP_MESSAGING_KAFKA_PARTITION,
      TMP_MESSAGING_KAFKA_TOMBSTONE,
      TMP_RPC_SYSTEM,
      TMP_RPC_SERVICE,
      TMP_RPC_METHOD,
      TMP_RPC_GRPC_STATUS_CODE,
      TMP_RPC_JSONRPC_VERSION,
      TMP_RPC_JSONRPC_REQUEST_ID,
      TMP_RPC_JSONRPC_ERROR_CODE,
      TMP_RPC_JSONRPC_ERROR_MESSAGE,
      TMP_MESSAGE_TYPE,
      TMP_MESSAGE_ID,
      TMP_MESSAGE_COMPRESSED_SIZE,
      TMP_MESSAGE_UNCOMPRESSED_SIZE
    ]);
    var TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
    var TMP_DBSYSTEMVALUES_MSSQL = "mssql";
    var TMP_DBSYSTEMVALUES_MYSQL = "mysql";
    var TMP_DBSYSTEMVALUES_ORACLE = "oracle";
    var TMP_DBSYSTEMVALUES_DB2 = "db2";
    var TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
    var TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
    var TMP_DBSYSTEMVALUES_HIVE = "hive";
    var TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
    var TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
    var TMP_DBSYSTEMVALUES_PROGRESS = "progress";
    var TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
    var TMP_DBSYSTEMVALUES_HANADB = "hanadb";
    var TMP_DBSYSTEMVALUES_INGRES = "ingres";
    var TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
    var TMP_DBSYSTEMVALUES_EDB = "edb";
    var TMP_DBSYSTEMVALUES_CACHE = "cache";
    var TMP_DBSYSTEMVALUES_ADABAS = "adabas";
    var TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
    var TMP_DBSYSTEMVALUES_DERBY = "derby";
    var TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
    var TMP_DBSYSTEMVALUES_INFORMIX = "informix";
    var TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
    var TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
    var TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
    var TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
    var TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
    var TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
    var TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
    var TMP_DBSYSTEMVALUES_SYBASE = "sybase";
    var TMP_DBSYSTEMVALUES_TERADATA = "teradata";
    var TMP_DBSYSTEMVALUES_VERTICA = "vertica";
    var TMP_DBSYSTEMVALUES_H2 = "h2";
    var TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
    var TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
    var TMP_DBSYSTEMVALUES_HBASE = "hbase";
    var TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
    var TMP_DBSYSTEMVALUES_REDIS = "redis";
    var TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
    var TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
    var TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
    var TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
    var TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
    var TMP_DBSYSTEMVALUES_GEODE = "geode";
    var TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
    var TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
    var TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
    exports.DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
    exports.DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
    exports.DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
    exports.DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
    exports.DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
    exports.DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
    exports.DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
    exports.DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
    exports.DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
    exports.DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
    exports.DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
    exports.DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
    exports.DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
    exports.DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
    exports.DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
    exports.DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
    exports.DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
    exports.DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
    exports.DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
    exports.DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
    exports.DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
    exports.DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
    exports.DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
    exports.DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
    exports.DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
    exports.DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
    exports.DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
    exports.DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
    exports.DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
    exports.DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
    exports.DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
    exports.DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
    exports.DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
    exports.DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
    exports.DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
    exports.DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
    exports.DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
    exports.DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
    exports.DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
    exports.DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
    exports.DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
    exports.DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
    exports.DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
    exports.DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
    exports.DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
    exports.DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
    exports.DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
    exports.DbSystemValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBSYSTEMVALUES_OTHER_SQL,
      TMP_DBSYSTEMVALUES_MSSQL,
      TMP_DBSYSTEMVALUES_MYSQL,
      TMP_DBSYSTEMVALUES_ORACLE,
      TMP_DBSYSTEMVALUES_DB2,
      TMP_DBSYSTEMVALUES_POSTGRESQL,
      TMP_DBSYSTEMVALUES_REDSHIFT,
      TMP_DBSYSTEMVALUES_HIVE,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE,
      TMP_DBSYSTEMVALUES_HSQLDB,
      TMP_DBSYSTEMVALUES_PROGRESS,
      TMP_DBSYSTEMVALUES_MAXDB,
      TMP_DBSYSTEMVALUES_HANADB,
      TMP_DBSYSTEMVALUES_INGRES,
      TMP_DBSYSTEMVALUES_FIRSTSQL,
      TMP_DBSYSTEMVALUES_EDB,
      TMP_DBSYSTEMVALUES_CACHE,
      TMP_DBSYSTEMVALUES_ADABAS,
      TMP_DBSYSTEMVALUES_FIREBIRD,
      TMP_DBSYSTEMVALUES_DERBY,
      TMP_DBSYSTEMVALUES_FILEMAKER,
      TMP_DBSYSTEMVALUES_INFORMIX,
      TMP_DBSYSTEMVALUES_INSTANTDB,
      TMP_DBSYSTEMVALUES_INTERBASE,
      TMP_DBSYSTEMVALUES_MARIADB,
      TMP_DBSYSTEMVALUES_NETEZZA,
      TMP_DBSYSTEMVALUES_PERVASIVE,
      TMP_DBSYSTEMVALUES_POINTBASE,
      TMP_DBSYSTEMVALUES_SQLITE,
      TMP_DBSYSTEMVALUES_SYBASE,
      TMP_DBSYSTEMVALUES_TERADATA,
      TMP_DBSYSTEMVALUES_VERTICA,
      TMP_DBSYSTEMVALUES_H2,
      TMP_DBSYSTEMVALUES_COLDFUSION,
      TMP_DBSYSTEMVALUES_CASSANDRA,
      TMP_DBSYSTEMVALUES_HBASE,
      TMP_DBSYSTEMVALUES_MONGODB,
      TMP_DBSYSTEMVALUES_REDIS,
      TMP_DBSYSTEMVALUES_COUCHBASE,
      TMP_DBSYSTEMVALUES_COUCHDB,
      TMP_DBSYSTEMVALUES_COSMOSDB,
      TMP_DBSYSTEMVALUES_DYNAMODB,
      TMP_DBSYSTEMVALUES_NEO4J,
      TMP_DBSYSTEMVALUES_GEODE,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH,
      TMP_DBSYSTEMVALUES_MEMCACHED,
      TMP_DBSYSTEMVALUES_COCKROACHDB
    ]);
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
    var TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
    exports.DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
    exports.DbCassandraConsistencyLevelValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
    ]);
    var TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
    var TMP_FAASTRIGGERVALUES_HTTP = "http";
    var TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
    var TMP_FAASTRIGGERVALUES_TIMER = "timer";
    var TMP_FAASTRIGGERVALUES_OTHER = "other";
    exports.FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
    exports.FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
    exports.FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
    exports.FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
    exports.FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
    exports.FaasTriggerValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASTRIGGERVALUES_DATASOURCE,
      TMP_FAASTRIGGERVALUES_HTTP,
      TMP_FAASTRIGGERVALUES_PUBSUB,
      TMP_FAASTRIGGERVALUES_TIMER,
      TMP_FAASTRIGGERVALUES_OTHER
    ]);
    var TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
    var TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
    var TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
    exports.FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
    exports.FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
    exports.FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
    exports.FaasDocumentOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
    ]);
    var TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    var TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
    var TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
    var TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
    exports.FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
    exports.FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
    exports.FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
    exports.FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
    exports.FaasInvokedProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP
    ]);
    var TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
    var TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
    var TMP_NETTRANSPORTVALUES_IP = "ip";
    var TMP_NETTRANSPORTVALUES_UNIX = "unix";
    var TMP_NETTRANSPORTVALUES_PIPE = "pipe";
    var TMP_NETTRANSPORTVALUES_INPROC = "inproc";
    var TMP_NETTRANSPORTVALUES_OTHER = "other";
    exports.NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
    exports.NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
    exports.NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
    exports.NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
    exports.NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
    exports.NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
    exports.NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
    exports.NetTransportValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETTRANSPORTVALUES_IP_TCP,
      TMP_NETTRANSPORTVALUES_IP_UDP,
      TMP_NETTRANSPORTVALUES_IP,
      TMP_NETTRANSPORTVALUES_UNIX,
      TMP_NETTRANSPORTVALUES_PIPE,
      TMP_NETTRANSPORTVALUES_INPROC,
      TMP_NETTRANSPORTVALUES_OTHER
    ]);
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
    var TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
    exports.NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
    exports.NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
    exports.NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
    exports.NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
    exports.NetHostConnectionTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
    ]);
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
    var TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
    exports.NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
    exports.NetHostConnectionSubtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
    ]);
    var TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
    var TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
    var TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
    var TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
    var TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
    exports.HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
    exports.HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
    exports.HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
    exports.HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
    exports.HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
    exports.HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC
    };
    var TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
    var TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
    exports.MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
    exports.MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
    exports.MessagingDestinationKindValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
    ]);
    var TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
    var TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
    exports.MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
    exports.MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
    exports.MessagingOperationValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS
    ]);
    var TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
    var TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
    var TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
    var TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
    var TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
    var TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
    var TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
    var TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
    var TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
    var TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
    var TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
    var TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
    var TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
    var TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
    exports.RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
    exports.RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
    exports.RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
    exports.RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
    exports.RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
    exports.RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
    exports.RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
    exports.RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
    exports.RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
    exports.RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
    exports.RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
    exports.RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
    exports.RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
    exports.RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
    exports.RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
    exports.RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
    exports.RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
    exports.RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
    };
    var TMP_MESSAGETYPEVALUES_SENT = "SENT";
    var TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
    exports.MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
    exports.MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
    exports.MessageTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_MESSAGETYPEVALUES_SENT,
      TMP_MESSAGETYPEVALUES_RECEIVED
    ]);
  }
});

// node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js
var require_trace2 = __commonJS({
  "node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/trace/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticAttributes(), exports);
  }
});

// node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js
var require_SemanticResourceAttributes = __commonJS({
  "node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/resource/SemanticResourceAttributes.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = exports.SEMRESATTRS_K8S_STATEFULSET_UID = exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = exports.SEMRESATTRS_K8S_REPLICASET_NAME = exports.SEMRESATTRS_K8S_REPLICASET_UID = exports.SEMRESATTRS_K8S_CONTAINER_NAME = exports.SEMRESATTRS_K8S_POD_NAME = exports.SEMRESATTRS_K8S_POD_UID = exports.SEMRESATTRS_K8S_NAMESPACE_NAME = exports.SEMRESATTRS_K8S_NODE_UID = exports.SEMRESATTRS_K8S_NODE_NAME = exports.SEMRESATTRS_K8S_CLUSTER_NAME = exports.SEMRESATTRS_HOST_IMAGE_VERSION = exports.SEMRESATTRS_HOST_IMAGE_ID = exports.SEMRESATTRS_HOST_IMAGE_NAME = exports.SEMRESATTRS_HOST_ARCH = exports.SEMRESATTRS_HOST_TYPE = exports.SEMRESATTRS_HOST_NAME = exports.SEMRESATTRS_HOST_ID = exports.SEMRESATTRS_FAAS_MAX_MEMORY = exports.SEMRESATTRS_FAAS_INSTANCE = exports.SEMRESATTRS_FAAS_VERSION = exports.SEMRESATTRS_FAAS_ID = exports.SEMRESATTRS_FAAS_NAME = exports.SEMRESATTRS_DEVICE_MODEL_NAME = exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = exports.SEMRESATTRS_DEVICE_ID = exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = exports.SEMRESATTRS_CONTAINER_RUNTIME = exports.SEMRESATTRS_CONTAINER_ID = exports.SEMRESATTRS_CONTAINER_NAME = exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = exports.SEMRESATTRS_AWS_ECS_TASK_ARN = exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = exports.SEMRESATTRS_CLOUD_PLATFORM = exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = exports.SEMRESATTRS_CLOUD_REGION = exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = exports.SEMRESATTRS_CLOUD_PROVIDER = void 0;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = exports.CLOUDPLATFORMVALUES_AZURE_AKS = exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = exports.CLOUDPLATFORMVALUES_AZURE_VM = exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = exports.CLOUDPLATFORMVALUES_AWS_EKS = exports.CLOUDPLATFORMVALUES_AWS_ECS = exports.CLOUDPLATFORMVALUES_AWS_EC2 = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = exports.CloudProviderValues = exports.CLOUDPROVIDERVALUES_GCP = exports.CLOUDPROVIDERVALUES_AZURE = exports.CLOUDPROVIDERVALUES_AWS = exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = exports.SemanticResourceAttributes = exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = exports.SEMRESATTRS_WEBENGINE_VERSION = exports.SEMRESATTRS_WEBENGINE_NAME = exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = exports.SEMRESATTRS_TELEMETRY_SDK_NAME = exports.SEMRESATTRS_SERVICE_VERSION = exports.SEMRESATTRS_SERVICE_INSTANCE_ID = exports.SEMRESATTRS_SERVICE_NAMESPACE = exports.SEMRESATTRS_SERVICE_NAME = exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = exports.SEMRESATTRS_PROCESS_OWNER = exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = exports.SEMRESATTRS_PROCESS_COMMAND_LINE = exports.SEMRESATTRS_PROCESS_COMMAND = exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = exports.SEMRESATTRS_PROCESS_PID = exports.SEMRESATTRS_OS_VERSION = exports.SEMRESATTRS_OS_NAME = exports.SEMRESATTRS_OS_DESCRIPTION = exports.SEMRESATTRS_OS_TYPE = exports.SEMRESATTRS_K8S_CRONJOB_NAME = exports.SEMRESATTRS_K8S_CRONJOB_UID = exports.SEMRESATTRS_K8S_JOB_NAME = exports.SEMRESATTRS_K8S_JOB_UID = exports.SEMRESATTRS_K8S_DAEMONSET_NAME = exports.SEMRESATTRS_K8S_DAEMONSET_UID = void 0;
    exports.TelemetrySdkLanguageValues = exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = exports.TELEMETRYSDKLANGUAGEVALUES_PHP = exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = exports.TELEMETRYSDKLANGUAGEVALUES_GO = exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = exports.TELEMETRYSDKLANGUAGEVALUES_CPP = exports.OsTypeValues = exports.OSTYPEVALUES_Z_OS = exports.OSTYPEVALUES_SOLARIS = exports.OSTYPEVALUES_AIX = exports.OSTYPEVALUES_HPUX = exports.OSTYPEVALUES_DRAGONFLYBSD = exports.OSTYPEVALUES_OPENBSD = exports.OSTYPEVALUES_NETBSD = exports.OSTYPEVALUES_FREEBSD = exports.OSTYPEVALUES_DARWIN = exports.OSTYPEVALUES_LINUX = exports.OSTYPEVALUES_WINDOWS = exports.HostArchValues = exports.HOSTARCHVALUES_X86 = exports.HOSTARCHVALUES_PPC64 = exports.HOSTARCHVALUES_PPC32 = exports.HOSTARCHVALUES_IA64 = exports.HOSTARCHVALUES_ARM64 = exports.HOSTARCHVALUES_ARM32 = exports.HOSTARCHVALUES_AMD64 = exports.AwsEcsLaunchtypeValues = exports.AWSECSLAUNCHTYPEVALUES_FARGATE = exports.AWSECSLAUNCHTYPEVALUES_EC2 = exports.CloudPlatformValues = exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = void 0;
    var utils_1 = require_utils3();
    var TMP_CLOUD_PROVIDER = "cloud.provider";
    var TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
    var TMP_CLOUD_REGION = "cloud.region";
    var TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
    var TMP_CLOUD_PLATFORM = "cloud.platform";
    var TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
    var TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
    var TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
    var TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
    var TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
    var TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
    var TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
    var TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
    var TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
    var TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
    var TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
    var TMP_CONTAINER_NAME = "container.name";
    var TMP_CONTAINER_ID = "container.id";
    var TMP_CONTAINER_RUNTIME = "container.runtime";
    var TMP_CONTAINER_IMAGE_NAME = "container.image.name";
    var TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
    var TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
    var TMP_DEVICE_ID = "device.id";
    var TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
    var TMP_DEVICE_MODEL_NAME = "device.model.name";
    var TMP_FAAS_NAME = "faas.name";
    var TMP_FAAS_ID = "faas.id";
    var TMP_FAAS_VERSION = "faas.version";
    var TMP_FAAS_INSTANCE = "faas.instance";
    var TMP_FAAS_MAX_MEMORY = "faas.max_memory";
    var TMP_HOST_ID = "host.id";
    var TMP_HOST_NAME = "host.name";
    var TMP_HOST_TYPE = "host.type";
    var TMP_HOST_ARCH = "host.arch";
    var TMP_HOST_IMAGE_NAME = "host.image.name";
    var TMP_HOST_IMAGE_ID = "host.image.id";
    var TMP_HOST_IMAGE_VERSION = "host.image.version";
    var TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
    var TMP_K8S_NODE_NAME = "k8s.node.name";
    var TMP_K8S_NODE_UID = "k8s.node.uid";
    var TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
    var TMP_K8S_POD_UID = "k8s.pod.uid";
    var TMP_K8S_POD_NAME = "k8s.pod.name";
    var TMP_K8S_CONTAINER_NAME = "k8s.container.name";
    var TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
    var TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
    var TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
    var TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
    var TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
    var TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
    var TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
    var TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
    var TMP_K8S_JOB_UID = "k8s.job.uid";
    var TMP_K8S_JOB_NAME = "k8s.job.name";
    var TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
    var TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
    var TMP_OS_TYPE = "os.type";
    var TMP_OS_DESCRIPTION = "os.description";
    var TMP_OS_NAME = "os.name";
    var TMP_OS_VERSION = "os.version";
    var TMP_PROCESS_PID = "process.pid";
    var TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
    var TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
    var TMP_PROCESS_COMMAND = "process.command";
    var TMP_PROCESS_COMMAND_LINE = "process.command_line";
    var TMP_PROCESS_COMMAND_ARGS = "process.command_args";
    var TMP_PROCESS_OWNER = "process.owner";
    var TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
    var TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
    var TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
    var TMP_SERVICE_NAME = "service.name";
    var TMP_SERVICE_NAMESPACE = "service.namespace";
    var TMP_SERVICE_INSTANCE_ID = "service.instance.id";
    var TMP_SERVICE_VERSION = "service.version";
    var TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    var TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    var TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    var TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
    var TMP_WEBENGINE_NAME = "webengine.name";
    var TMP_WEBENGINE_VERSION = "webengine.version";
    var TMP_WEBENGINE_DESCRIPTION = "webengine.description";
    exports.SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
    exports.SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
    exports.SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
    exports.SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
    exports.SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
    exports.SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
    exports.SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
    exports.SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
    exports.SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
    exports.SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
    exports.SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
    exports.SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
    exports.SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
    exports.SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
    exports.SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
    exports.SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
    exports.SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
    exports.SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
    exports.SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
    exports.SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
    exports.SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
    exports.SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
    exports.SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
    exports.SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
    exports.SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
    exports.SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
    exports.SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
    exports.SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
    exports.SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
    exports.SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
    exports.SEMRESATTRS_HOST_ID = TMP_HOST_ID;
    exports.SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
    exports.SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
    exports.SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
    exports.SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
    exports.SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
    exports.SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
    exports.SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
    exports.SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
    exports.SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
    exports.SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
    exports.SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
    exports.SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
    exports.SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
    exports.SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
    exports.SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
    exports.SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
    exports.SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
    exports.SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
    exports.SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
    exports.SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
    exports.SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
    exports.SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
    exports.SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
    exports.SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
    exports.SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
    exports.SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
    exports.SEMRESATTRS_OS_NAME = TMP_OS_NAME;
    exports.SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
    exports.SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
    exports.SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
    exports.SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
    exports.SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
    exports.SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
    exports.SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
    exports.SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
    exports.SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
    exports.SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
    exports.SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
    exports.SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
    exports.SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
    exports.SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
    exports.SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
    exports.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
    exports.SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
    exports.SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
    exports.SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
    exports.SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
    exports.SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
    exports.SemanticResourceAttributes = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUD_PROVIDER,
      TMP_CLOUD_ACCOUNT_ID,
      TMP_CLOUD_REGION,
      TMP_CLOUD_AVAILABILITY_ZONE,
      TMP_CLOUD_PLATFORM,
      TMP_AWS_ECS_CONTAINER_ARN,
      TMP_AWS_ECS_CLUSTER_ARN,
      TMP_AWS_ECS_LAUNCHTYPE,
      TMP_AWS_ECS_TASK_ARN,
      TMP_AWS_ECS_TASK_FAMILY,
      TMP_AWS_ECS_TASK_REVISION,
      TMP_AWS_EKS_CLUSTER_ARN,
      TMP_AWS_LOG_GROUP_NAMES,
      TMP_AWS_LOG_GROUP_ARNS,
      TMP_AWS_LOG_STREAM_NAMES,
      TMP_AWS_LOG_STREAM_ARNS,
      TMP_CONTAINER_NAME,
      TMP_CONTAINER_ID,
      TMP_CONTAINER_RUNTIME,
      TMP_CONTAINER_IMAGE_NAME,
      TMP_CONTAINER_IMAGE_TAG,
      TMP_DEPLOYMENT_ENVIRONMENT,
      TMP_DEVICE_ID,
      TMP_DEVICE_MODEL_IDENTIFIER,
      TMP_DEVICE_MODEL_NAME,
      TMP_FAAS_NAME,
      TMP_FAAS_ID,
      TMP_FAAS_VERSION,
      TMP_FAAS_INSTANCE,
      TMP_FAAS_MAX_MEMORY,
      TMP_HOST_ID,
      TMP_HOST_NAME,
      TMP_HOST_TYPE,
      TMP_HOST_ARCH,
      TMP_HOST_IMAGE_NAME,
      TMP_HOST_IMAGE_ID,
      TMP_HOST_IMAGE_VERSION,
      TMP_K8S_CLUSTER_NAME,
      TMP_K8S_NODE_NAME,
      TMP_K8S_NODE_UID,
      TMP_K8S_NAMESPACE_NAME,
      TMP_K8S_POD_UID,
      TMP_K8S_POD_NAME,
      TMP_K8S_CONTAINER_NAME,
      TMP_K8S_REPLICASET_UID,
      TMP_K8S_REPLICASET_NAME,
      TMP_K8S_DEPLOYMENT_UID,
      TMP_K8S_DEPLOYMENT_NAME,
      TMP_K8S_STATEFULSET_UID,
      TMP_K8S_STATEFULSET_NAME,
      TMP_K8S_DAEMONSET_UID,
      TMP_K8S_DAEMONSET_NAME,
      TMP_K8S_JOB_UID,
      TMP_K8S_JOB_NAME,
      TMP_K8S_CRONJOB_UID,
      TMP_K8S_CRONJOB_NAME,
      TMP_OS_TYPE,
      TMP_OS_DESCRIPTION,
      TMP_OS_NAME,
      TMP_OS_VERSION,
      TMP_PROCESS_PID,
      TMP_PROCESS_EXECUTABLE_NAME,
      TMP_PROCESS_EXECUTABLE_PATH,
      TMP_PROCESS_COMMAND,
      TMP_PROCESS_COMMAND_LINE,
      TMP_PROCESS_COMMAND_ARGS,
      TMP_PROCESS_OWNER,
      TMP_PROCESS_RUNTIME_NAME,
      TMP_PROCESS_RUNTIME_VERSION,
      TMP_PROCESS_RUNTIME_DESCRIPTION,
      TMP_SERVICE_NAME,
      TMP_SERVICE_NAMESPACE,
      TMP_SERVICE_INSTANCE_ID,
      TMP_SERVICE_VERSION,
      TMP_TELEMETRY_SDK_NAME,
      TMP_TELEMETRY_SDK_LANGUAGE,
      TMP_TELEMETRY_SDK_VERSION,
      TMP_TELEMETRY_AUTO_VERSION,
      TMP_WEBENGINE_NAME,
      TMP_WEBENGINE_VERSION,
      TMP_WEBENGINE_DESCRIPTION
    ]);
    var TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    var TMP_CLOUDPROVIDERVALUES_AWS = "aws";
    var TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
    var TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
    exports.CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
    exports.CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
    exports.CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
    exports.CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
    exports.CloudProviderValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_CLOUDPROVIDERVALUES_AWS,
      TMP_CLOUDPROVIDERVALUES_AZURE,
      TMP_CLOUDPROVIDERVALUES_GCP
    ]);
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
    var TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
    var TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
    var TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
    var TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
    var TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
    var TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
    var TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
    var TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
    var TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
    var TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
    var TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
    var TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
    var TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
    var TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
    var TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
    exports.CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
    exports.CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
    exports.CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
    exports.CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
    exports.CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
    exports.CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
    exports.CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
    exports.CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
    exports.CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
    exports.CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
    exports.CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
    exports.CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
    exports.CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
    exports.CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
    exports.CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
    exports.CloudPlatformValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
      TMP_CLOUDPLATFORMVALUES_AWS_EC2,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
    ]);
    var TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
    var TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
    exports.AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
    exports.AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
    exports.AwsEcsLaunchtypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_AWSECSLAUNCHTYPEVALUES_EC2,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
    ]);
    var TMP_HOSTARCHVALUES_AMD64 = "amd64";
    var TMP_HOSTARCHVALUES_ARM32 = "arm32";
    var TMP_HOSTARCHVALUES_ARM64 = "arm64";
    var TMP_HOSTARCHVALUES_IA64 = "ia64";
    var TMP_HOSTARCHVALUES_PPC32 = "ppc32";
    var TMP_HOSTARCHVALUES_PPC64 = "ppc64";
    var TMP_HOSTARCHVALUES_X86 = "x86";
    exports.HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
    exports.HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
    exports.HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
    exports.HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
    exports.HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
    exports.HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
    exports.HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
    exports.HostArchValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_HOSTARCHVALUES_AMD64,
      TMP_HOSTARCHVALUES_ARM32,
      TMP_HOSTARCHVALUES_ARM64,
      TMP_HOSTARCHVALUES_IA64,
      TMP_HOSTARCHVALUES_PPC32,
      TMP_HOSTARCHVALUES_PPC64,
      TMP_HOSTARCHVALUES_X86
    ]);
    var TMP_OSTYPEVALUES_WINDOWS = "windows";
    var TMP_OSTYPEVALUES_LINUX = "linux";
    var TMP_OSTYPEVALUES_DARWIN = "darwin";
    var TMP_OSTYPEVALUES_FREEBSD = "freebsd";
    var TMP_OSTYPEVALUES_NETBSD = "netbsd";
    var TMP_OSTYPEVALUES_OPENBSD = "openbsd";
    var TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
    var TMP_OSTYPEVALUES_HPUX = "hpux";
    var TMP_OSTYPEVALUES_AIX = "aix";
    var TMP_OSTYPEVALUES_SOLARIS = "solaris";
    var TMP_OSTYPEVALUES_Z_OS = "z_os";
    exports.OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
    exports.OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
    exports.OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
    exports.OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
    exports.OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
    exports.OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
    exports.OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
    exports.OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
    exports.OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
    exports.OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
    exports.OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
    exports.OsTypeValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_OSTYPEVALUES_WINDOWS,
      TMP_OSTYPEVALUES_LINUX,
      TMP_OSTYPEVALUES_DARWIN,
      TMP_OSTYPEVALUES_FREEBSD,
      TMP_OSTYPEVALUES_NETBSD,
      TMP_OSTYPEVALUES_OPENBSD,
      TMP_OSTYPEVALUES_DRAGONFLYBSD,
      TMP_OSTYPEVALUES_HPUX,
      TMP_OSTYPEVALUES_AIX,
      TMP_OSTYPEVALUES_SOLARIS,
      TMP_OSTYPEVALUES_Z_OS
    ]);
    var TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
    var TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
    exports.TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
    exports.TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
    exports.TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
    exports.TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
    exports.TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
    exports.TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
    exports.TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
    exports.TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
    exports.TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
    exports.TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
    exports.TelemetrySdkLanguageValues = /* @__PURE__ */ (0, utils_1.createConstMap)([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
    ]);
  }
});

// node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js
var require_resource = __commonJS({
  "node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/resource/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_SemanticResourceAttributes(), exports);
  }
});

// node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/stable_attributes.js
var require_stable_attributes = __commonJS({
  "node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/stable_attributes.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ATTR_EXCEPTION_TYPE = exports.ATTR_EXCEPTION_STACKTRACE = exports.ATTR_EXCEPTION_MESSAGE = exports.ATTR_EXCEPTION_ESCAPED = exports.ERROR_TYPE_VALUE_OTHER = exports.ATTR_ERROR_TYPE = exports.DOTNET_GC_HEAP_GENERATION_VALUE_POH = exports.DOTNET_GC_HEAP_GENERATION_VALUE_LOH = exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = exports.ATTR_DOTNET_GC_HEAP_GENERATION = exports.DB_SYSTEM_NAME_VALUE_POSTGRESQL = exports.DB_SYSTEM_NAME_VALUE_MYSQL = exports.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER = exports.DB_SYSTEM_NAME_VALUE_MARIADB = exports.ATTR_DB_SYSTEM_NAME = exports.ATTR_DB_STORED_PROCEDURE_NAME = exports.ATTR_DB_RESPONSE_STATUS_CODE = exports.ATTR_DB_QUERY_TEXT = exports.ATTR_DB_QUERY_SUMMARY = exports.ATTR_DB_OPERATION_NAME = exports.ATTR_DB_OPERATION_BATCH_SIZE = exports.ATTR_DB_NAMESPACE = exports.ATTR_DB_COLLECTION_NAME = exports.ATTR_CODE_STACKTRACE = exports.ATTR_CODE_LINE_NUMBER = exports.ATTR_CODE_FUNCTION_NAME = exports.ATTR_CODE_FILE_PATH = exports.ATTR_CODE_COLUMN_NUMBER = exports.ATTR_CLIENT_PORT = exports.ATTR_CLIENT_ADDRESS = exports.ATTR_ASPNETCORE_USER_IS_AUTHENTICATED = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = void 0;
    exports.OTEL_STATUS_CODE_VALUE_ERROR = exports.ATTR_OTEL_STATUS_CODE = exports.ATTR_OTEL_SCOPE_VERSION = exports.ATTR_OTEL_SCOPE_NAME = exports.NETWORK_TYPE_VALUE_IPV6 = exports.NETWORK_TYPE_VALUE_IPV4 = exports.ATTR_NETWORK_TYPE = exports.NETWORK_TRANSPORT_VALUE_UNIX = exports.NETWORK_TRANSPORT_VALUE_UDP = exports.NETWORK_TRANSPORT_VALUE_TCP = exports.NETWORK_TRANSPORT_VALUE_QUIC = exports.NETWORK_TRANSPORT_VALUE_PIPE = exports.ATTR_NETWORK_TRANSPORT = exports.ATTR_NETWORK_PROTOCOL_VERSION = exports.ATTR_NETWORK_PROTOCOL_NAME = exports.ATTR_NETWORK_PEER_PORT = exports.ATTR_NETWORK_PEER_ADDRESS = exports.ATTR_NETWORK_LOCAL_PORT = exports.ATTR_NETWORK_LOCAL_ADDRESS = exports.JVM_THREAD_STATE_VALUE_WAITING = exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = exports.JVM_THREAD_STATE_VALUE_TERMINATED = exports.JVM_THREAD_STATE_VALUE_RUNNABLE = exports.JVM_THREAD_STATE_VALUE_NEW = exports.JVM_THREAD_STATE_VALUE_BLOCKED = exports.ATTR_JVM_THREAD_STATE = exports.ATTR_JVM_THREAD_DAEMON = exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = exports.JVM_MEMORY_TYPE_VALUE_HEAP = exports.ATTR_JVM_MEMORY_TYPE = exports.ATTR_JVM_MEMORY_POOL_NAME = exports.ATTR_JVM_GC_NAME = exports.ATTR_JVM_GC_ACTION = exports.ATTR_HTTP_ROUTE = exports.ATTR_HTTP_RESPONSE_STATUS_CODE = exports.ATTR_HTTP_RESPONSE_HEADER = exports.ATTR_HTTP_REQUEST_RESEND_COUNT = exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = exports.HTTP_REQUEST_METHOD_VALUE_TRACE = exports.HTTP_REQUEST_METHOD_VALUE_PUT = exports.HTTP_REQUEST_METHOD_VALUE_POST = exports.HTTP_REQUEST_METHOD_VALUE_PATCH = exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = exports.HTTP_REQUEST_METHOD_VALUE_HEAD = exports.HTTP_REQUEST_METHOD_VALUE_GET = exports.HTTP_REQUEST_METHOD_VALUE_DELETE = exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = exports.HTTP_REQUEST_METHOD_VALUE_OTHER = exports.ATTR_HTTP_REQUEST_METHOD = exports.ATTR_HTTP_REQUEST_HEADER = void 0;
    exports.ATTR_USER_AGENT_ORIGINAL = exports.ATTR_URL_SCHEME = exports.ATTR_URL_QUERY = exports.ATTR_URL_PATH = exports.ATTR_URL_FULL = exports.ATTR_URL_FRAGMENT = exports.ATTR_TELEMETRY_SDK_VERSION = exports.ATTR_TELEMETRY_SDK_NAME = exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = exports.ATTR_TELEMETRY_SDK_LANGUAGE = exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = exports.ATTR_SIGNALR_TRANSPORT = exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = exports.ATTR_SIGNALR_CONNECTION_STATUS = exports.ATTR_SERVICE_VERSION = exports.ATTR_SERVICE_NAME = exports.ATTR_SERVER_PORT = exports.ATTR_SERVER_ADDRESS = exports.ATTR_OTEL_STATUS_DESCRIPTION = exports.OTEL_STATUS_CODE_VALUE_OK = void 0;
    exports.ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
    exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
    exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
    exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
    exports.ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
    exports.ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
    exports.ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
    exports.ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
    exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
    exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
    exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
    exports.ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
    exports.ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
    exports.ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
    exports.ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
    exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
    exports.ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
    exports.ATTR_ASPNETCORE_USER_IS_AUTHENTICATED = "aspnetcore.user.is_authenticated";
    exports.ATTR_CLIENT_ADDRESS = "client.address";
    exports.ATTR_CLIENT_PORT = "client.port";
    exports.ATTR_CODE_COLUMN_NUMBER = "code.column.number";
    exports.ATTR_CODE_FILE_PATH = "code.file.path";
    exports.ATTR_CODE_FUNCTION_NAME = "code.function.name";
    exports.ATTR_CODE_LINE_NUMBER = "code.line.number";
    exports.ATTR_CODE_STACKTRACE = "code.stacktrace";
    exports.ATTR_DB_COLLECTION_NAME = "db.collection.name";
    exports.ATTR_DB_NAMESPACE = "db.namespace";
    exports.ATTR_DB_OPERATION_BATCH_SIZE = "db.operation.batch.size";
    exports.ATTR_DB_OPERATION_NAME = "db.operation.name";
    exports.ATTR_DB_QUERY_SUMMARY = "db.query.summary";
    exports.ATTR_DB_QUERY_TEXT = "db.query.text";
    exports.ATTR_DB_RESPONSE_STATUS_CODE = "db.response.status_code";
    exports.ATTR_DB_STORED_PROCEDURE_NAME = "db.stored_procedure.name";
    exports.ATTR_DB_SYSTEM_NAME = "db.system.name";
    exports.DB_SYSTEM_NAME_VALUE_MARIADB = "mariadb";
    exports.DB_SYSTEM_NAME_VALUE_MICROSOFT_SQL_SERVER = "microsoft.sql_server";
    exports.DB_SYSTEM_NAME_VALUE_MYSQL = "mysql";
    exports.DB_SYSTEM_NAME_VALUE_POSTGRESQL = "postgresql";
    exports.ATTR_DOTNET_GC_HEAP_GENERATION = "dotnet.gc.heap.generation";
    exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN0 = "gen0";
    exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN1 = "gen1";
    exports.DOTNET_GC_HEAP_GENERATION_VALUE_GEN2 = "gen2";
    exports.DOTNET_GC_HEAP_GENERATION_VALUE_LOH = "loh";
    exports.DOTNET_GC_HEAP_GENERATION_VALUE_POH = "poh";
    exports.ATTR_ERROR_TYPE = "error.type";
    exports.ERROR_TYPE_VALUE_OTHER = "_OTHER";
    exports.ATTR_EXCEPTION_ESCAPED = "exception.escaped";
    exports.ATTR_EXCEPTION_MESSAGE = "exception.message";
    exports.ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
    exports.ATTR_EXCEPTION_TYPE = "exception.type";
    var ATTR_HTTP_REQUEST_HEADER2 = /* @__PURE__ */ __name((key) => `http.request.header.${key}`, "ATTR_HTTP_REQUEST_HEADER");
    exports.ATTR_HTTP_REQUEST_HEADER = ATTR_HTTP_REQUEST_HEADER2;
    exports.ATTR_HTTP_REQUEST_METHOD = "http.request.method";
    exports.HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
    exports.HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
    exports.HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
    exports.HTTP_REQUEST_METHOD_VALUE_GET = "GET";
    exports.HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
    exports.HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
    exports.HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
    exports.HTTP_REQUEST_METHOD_VALUE_POST = "POST";
    exports.HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
    exports.HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
    exports.ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
    exports.ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
    var ATTR_HTTP_RESPONSE_HEADER2 = /* @__PURE__ */ __name((key) => `http.response.header.${key}`, "ATTR_HTTP_RESPONSE_HEADER");
    exports.ATTR_HTTP_RESPONSE_HEADER = ATTR_HTTP_RESPONSE_HEADER2;
    exports.ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
    exports.ATTR_HTTP_ROUTE = "http.route";
    exports.ATTR_JVM_GC_ACTION = "jvm.gc.action";
    exports.ATTR_JVM_GC_NAME = "jvm.gc.name";
    exports.ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
    exports.ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
    exports.JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
    exports.JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
    exports.ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
    exports.ATTR_JVM_THREAD_STATE = "jvm.thread.state";
    exports.JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
    exports.JVM_THREAD_STATE_VALUE_NEW = "new";
    exports.JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
    exports.JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
    exports.JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
    exports.JVM_THREAD_STATE_VALUE_WAITING = "waiting";
    exports.ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
    exports.ATTR_NETWORK_LOCAL_PORT = "network.local.port";
    exports.ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
    exports.ATTR_NETWORK_PEER_PORT = "network.peer.port";
    exports.ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
    exports.ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
    exports.ATTR_NETWORK_TRANSPORT = "network.transport";
    exports.NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
    exports.NETWORK_TRANSPORT_VALUE_QUIC = "quic";
    exports.NETWORK_TRANSPORT_VALUE_TCP = "tcp";
    exports.NETWORK_TRANSPORT_VALUE_UDP = "udp";
    exports.NETWORK_TRANSPORT_VALUE_UNIX = "unix";
    exports.ATTR_NETWORK_TYPE = "network.type";
    exports.NETWORK_TYPE_VALUE_IPV4 = "ipv4";
    exports.NETWORK_TYPE_VALUE_IPV6 = "ipv6";
    exports.ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
    exports.ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
    exports.ATTR_OTEL_STATUS_CODE = "otel.status_code";
    exports.OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
    exports.OTEL_STATUS_CODE_VALUE_OK = "OK";
    exports.ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
    exports.ATTR_SERVER_ADDRESS = "server.address";
    exports.ATTR_SERVER_PORT = "server.port";
    exports.ATTR_SERVICE_NAME = "service.name";
    exports.ATTR_SERVICE_VERSION = "service.version";
    exports.ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
    exports.SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
    exports.SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
    exports.SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
    exports.ATTR_SIGNALR_TRANSPORT = "signalr.transport";
    exports.SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
    exports.SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
    exports.SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
    exports.ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
    exports.TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
    exports.ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    exports.ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    exports.ATTR_URL_FRAGMENT = "url.fragment";
    exports.ATTR_URL_FULL = "url.full";
    exports.ATTR_URL_PATH = "url.path";
    exports.ATTR_URL_QUERY = "url.query";
    exports.ATTR_URL_SCHEME = "url.scheme";
    exports.ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
  }
});

// node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/stable_metrics.js
var require_stable_metrics = __commonJS({
  "node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/stable_metrics.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = exports.METRIC_KESTREL_REJECTED_CONNECTIONS = exports.METRIC_KESTREL_QUEUED_REQUESTS = exports.METRIC_KESTREL_QUEUED_CONNECTIONS = exports.METRIC_KESTREL_CONNECTION_DURATION = exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = exports.METRIC_JVM_THREAD_COUNT = exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = exports.METRIC_JVM_MEMORY_USED = exports.METRIC_JVM_MEMORY_LIMIT = exports.METRIC_JVM_MEMORY_COMMITTED = exports.METRIC_JVM_GC_DURATION = exports.METRIC_JVM_CPU_TIME = exports.METRIC_JVM_CPU_RECENT_UTILIZATION = exports.METRIC_JVM_CPU_COUNT = exports.METRIC_JVM_CLASS_UNLOADED = exports.METRIC_JVM_CLASS_LOADED = exports.METRIC_JVM_CLASS_COUNT = exports.METRIC_HTTP_SERVER_REQUEST_DURATION = exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = exports.METRIC_DOTNET_TIMER_COUNT = exports.METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT = exports.METRIC_DOTNET_THREAD_POOL_THREAD_COUNT = exports.METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH = exports.METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET = exports.METRIC_DOTNET_PROCESS_CPU_TIME = exports.METRIC_DOTNET_PROCESS_CPU_COUNT = exports.METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS = exports.METRIC_DOTNET_JIT_COMPILED_METHODS = exports.METRIC_DOTNET_JIT_COMPILED_IL_SIZE = exports.METRIC_DOTNET_JIT_COMPILATION_TIME = exports.METRIC_DOTNET_GC_PAUSE_TIME = exports.METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE = exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE = exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE = exports.METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED = exports.METRIC_DOTNET_GC_COLLECTIONS = exports.METRIC_DOTNET_EXCEPTIONS = exports.METRIC_DOTNET_ASSEMBLY_COUNT = exports.METRIC_DB_CLIENT_OPERATION_DURATION = exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = void 0;
    exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = void 0;
    exports.METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
    exports.METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
    exports.METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
    exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
    exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
    exports.METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
    exports.METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
    exports.METRIC_DB_CLIENT_OPERATION_DURATION = "db.client.operation.duration";
    exports.METRIC_DOTNET_ASSEMBLY_COUNT = "dotnet.assembly.count";
    exports.METRIC_DOTNET_EXCEPTIONS = "dotnet.exceptions";
    exports.METRIC_DOTNET_GC_COLLECTIONS = "dotnet.gc.collections";
    exports.METRIC_DOTNET_GC_HEAP_TOTAL_ALLOCATED = "dotnet.gc.heap.total_allocated";
    exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_FRAGMENTATION_SIZE = "dotnet.gc.last_collection.heap.fragmentation.size";
    exports.METRIC_DOTNET_GC_LAST_COLLECTION_HEAP_SIZE = "dotnet.gc.last_collection.heap.size";
    exports.METRIC_DOTNET_GC_LAST_COLLECTION_MEMORY_COMMITTED_SIZE = "dotnet.gc.last_collection.memory.committed_size";
    exports.METRIC_DOTNET_GC_PAUSE_TIME = "dotnet.gc.pause.time";
    exports.METRIC_DOTNET_JIT_COMPILATION_TIME = "dotnet.jit.compilation.time";
    exports.METRIC_DOTNET_JIT_COMPILED_IL_SIZE = "dotnet.jit.compiled_il.size";
    exports.METRIC_DOTNET_JIT_COMPILED_METHODS = "dotnet.jit.compiled_methods";
    exports.METRIC_DOTNET_MONITOR_LOCK_CONTENTIONS = "dotnet.monitor.lock_contentions";
    exports.METRIC_DOTNET_PROCESS_CPU_COUNT = "dotnet.process.cpu.count";
    exports.METRIC_DOTNET_PROCESS_CPU_TIME = "dotnet.process.cpu.time";
    exports.METRIC_DOTNET_PROCESS_MEMORY_WORKING_SET = "dotnet.process.memory.working_set";
    exports.METRIC_DOTNET_THREAD_POOL_QUEUE_LENGTH = "dotnet.thread_pool.queue.length";
    exports.METRIC_DOTNET_THREAD_POOL_THREAD_COUNT = "dotnet.thread_pool.thread.count";
    exports.METRIC_DOTNET_THREAD_POOL_WORK_ITEM_COUNT = "dotnet.thread_pool.work_item.count";
    exports.METRIC_DOTNET_TIMER_COUNT = "dotnet.timer.count";
    exports.METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
    exports.METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
    exports.METRIC_JVM_CLASS_COUNT = "jvm.class.count";
    exports.METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
    exports.METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
    exports.METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
    exports.METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
    exports.METRIC_JVM_CPU_TIME = "jvm.cpu.time";
    exports.METRIC_JVM_GC_DURATION = "jvm.gc.duration";
    exports.METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
    exports.METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
    exports.METRIC_JVM_MEMORY_USED = "jvm.memory.used";
    exports.METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
    exports.METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
    exports.METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
    exports.METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
    exports.METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
    exports.METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
    exports.METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
    exports.METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
    exports.METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
    exports.METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
    exports.METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
    exports.METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
  }
});

// node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/stable_events.js
var require_stable_events = __commonJS({
  "node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/stable_events.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EVENT_EXCEPTION = void 0;
    exports.EVENT_EXCEPTION = "exception";
  }
});

// node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/index.js
var require_src2 = __commonJS({
  "node_modules/.pnpm/@opentelemetry+semantic-conventions@1.38.0/node_modules/@opentelemetry/semantic-conventions/build/src/index.js"(exports) {
    "use strict";
    init_modules_watch_stub();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_trace2(), exports);
    __exportStar(require_resource(), exports);
    __exportStar(require_stable_attributes(), exports);
    __exportStar(require_stable_metrics(), exports);
    __exportStar(require_stable_events(), exports);
  }
});

// .wrangler/tmp/bundle-jYI8r8/middleware-loader.entry.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/bundle-jYI8r8/middleware-insertion-facade.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// src/cf-worker/index.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { DurableObject as DurableObject2 } from "cloudflare:workers";

// node_modules/.pnpm/@livestore+adapter-cloudflare@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/adapter-cloudflare/dist/mod.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+adapter-cloudflare@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/adapter-cloudflare/dist/make-adapter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/adapter-types.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/Otlp.js
var Otlp_exports = {};
__export(Otlp_exports, {
  layer: () => layer4
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpClientRequest.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpClientRequest.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Effect.js
var Effect_exports = {};
__export(Effect_exports, {
  Do: () => Do5,
  EffectTypeId: () => EffectTypeId4,
  Service: () => Service,
  Tag: () => Tag3,
  acquireRelease: () => acquireRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer3,
  all: () => all8,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen8,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateSpans: () => annotateSpans3,
  ap: () => ap3,
  as: () => as8,
  asSome: () => asSome2,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid5,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind6,
  bindAll: () => bindAll2,
  bindTo: () => bindTo6,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll3,
  catchAllCause: () => catchAllCause3,
  catchAllDefect: () => catchAllDefect2,
  catchIf: () => catchIf2,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag2,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context4,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  delay: () => delay2,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die7,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync4,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect3,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile4,
  either: () => either4,
  ensureErrorType: () => ensureErrorType,
  ensureRequirementsType: () => ensureRequirementsType,
  ensureSuccessType: () => ensureSuccessType,
  ensuring: () => ensuring3,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventually: () => eventually2,
  every: () => every10,
  exists: () => exists4,
  exit: () => exit4,
  fail: () => fail10,
  failCause: () => failCause9,
  failCauseSync: () => failCauseSync4,
  failSync: () => failSync4,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter12,
  filterEffectOrElse: () => filterEffectOrElse2,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterMap: () => filterMap7,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail2,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst8,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap15,
  flatten: () => flatten10,
  flip: () => flip3,
  flipWith: () => flipWith2,
  fn: () => fn,
  fnUntraced: () => fnUntraced2,
  forEach: () => forEach11,
  forever: () => forever3,
  fork: () => fork3,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon2,
  forkIn: () => forkIn2,
  forkScoped: () => forkScoped2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable5,
  functionWithSpan: () => functionWithSpan2,
  gen: () => gen4,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head5,
  if: () => if_2,
  ignore: () => ignore2,
  ignoreLogged: () => ignoreLogged2,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt7,
  interruptWith: () => interruptWith3,
  interruptible: () => interruptible4,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure5,
  isSuccess: () => isSuccess3,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_6,
  liftPredicate: () => liftPredicate5,
  linkSpanCurrent: () => linkSpanCurrent2,
  linkSpans: () => linkSpans2,
  locally: () => locally2,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log5,
  logAnnotations: () => logAnnotations2,
  logDebug: () => logDebug2,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeLatch: () => makeLatch2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map22,
  mapAccum: () => mapAccum4,
  mapBoth: () => mapBoth5,
  mapError: () => mapError4,
  mapErrorCause: () => mapErrorCause3,
  mapInputContext: () => mapInputContext3,
  match: () => match15,
  matchCause: () => matchCause4,
  matchCauseEffect: () => matchCauseEffect3,
  matchEffect: () => matchEffect3,
  merge: () => merge7,
  mergeAll: () => mergeAll5,
  metricLabels: () => metricLabels2,
  negate: () => negate2,
  never: () => never4,
  none: () => none9,
  onError: () => onError2,
  onExit: () => onExit3,
  onInterrupt: () => onInterrupt2,
  once: () => once4,
  option: () => option2,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie3,
  orDieWith: () => orDieWith2,
  orElse: () => orElse7,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed2,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition6,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise2,
  provide: () => provide2,
  provideService: () => provideService4,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race2,
  raceAll: () => raceAll2,
  raceFirst: () => raceFirst2,
  raceWith: () => raceWith2,
  random: () => random3,
  randomWith: () => randomWith2,
  reduce: () => reduce13,
  reduceEffect: () => reduceEffect3,
  reduceRight: () => reduceRight4,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate3,
  replicateEffect: () => replicateEffect2,
  request: () => request,
  retry: () => retry2,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork2,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  runtime: () => runtime4,
  sandbox: () => sandbox2,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope3,
  scopeWith: () => scopeWith2,
  scoped: () => scoped3,
  scopedWith: () => scopedWith2,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption2,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep4,
  spanAnnotations: () => spanAnnotations2,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed11,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend4,
  sync: () => sync7,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile4,
  tap: () => tap4,
  tapBoth: () => tapBoth2,
  tapDefect: () => tapDefect2,
  tapError: () => tapError3,
  tapErrorCause: () => tapErrorCause3,
  tapErrorTag: () => tapErrorTag2,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout2,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutOption: () => timeoutOption2,
  timeoutTo: () => timeoutTo2,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  transposeMapOption: () => transposeMapOption2,
  transposeOption: () => transposeOption2,
  try: () => try_3,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask3,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs3,
  updateService: () => updateService2,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when2,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenLogLevel: () => whenLogLevel2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop3,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency2,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withExecutionPlan: () => withExecutionPlan2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan3,
  withRandom: () => withRandom2,
  withRandomFixed: () => withRandomFixed,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan3,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow4,
  zip: () => zip8,
  zipLeft: () => zipLeft7,
  zipRight: () => zipRight7,
  zipWith: () => zipWith10
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Function.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isFunction = /* @__PURE__ */ __name((input) => typeof input === "function", "isFunction");
var dual = /* @__PURE__ */ __name(function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self2) => body(self2, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self2) {
          return body(self2, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self2) {
          return body(self2, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self2) {
          return body(self2, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self2) {
          return body(self2, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args2 = arguments;
        return function(self2) {
          return body(self2, ...args2);
        };
      };
  }
}, "dual");
var identity = /* @__PURE__ */ __name((a) => a, "identity");
var unsafeCoerce = identity;
var constant = /* @__PURE__ */ __name((value6) => () => value6, "constant");
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constNull = /* @__PURE__ */ constant(null);
var constUndefined = /* @__PURE__ */ constant(void 0);
var constVoid = constUndefined;
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
__name(pipe, "pipe");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/cause.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Array.js
var Array_exports = {};
__export(Array_exports, {
  Do: () => Do3,
  allocate: () => allocate,
  append: () => append,
  appendAll: () => appendAll,
  bind: () => bind4,
  bindTo: () => bindTo4,
  cartesian: () => cartesian,
  cartesianWith: () => cartesianWith,
  chop: () => chop,
  chunksOf: () => chunksOf,
  contains: () => contains2,
  containsWith: () => containsWith2,
  copy: () => copy,
  countBy: () => countBy,
  dedupe: () => dedupe,
  dedupeAdjacent: () => dedupeAdjacent,
  dedupeAdjacentWith: () => dedupeAdjacentWith,
  dedupeWith: () => dedupeWith,
  difference: () => difference,
  differenceWith: () => differenceWith,
  drop: () => drop,
  dropRight: () => dropRight,
  dropWhile: () => dropWhile,
  empty: () => empty3,
  ensure: () => ensure,
  every: () => every2,
  extend: () => extend,
  filter: () => filter3,
  filterMap: () => filterMap2,
  filterMapWhile: () => filterMapWhile,
  findFirst: () => findFirst2,
  findFirstIndex: () => findFirstIndex,
  findFirstWithIndex: () => findFirstWithIndex,
  findLast: () => findLast,
  findLastIndex: () => findLastIndex,
  flatMap: () => flatMap3,
  flatMapNullable: () => flatMapNullable2,
  flatten: () => flatten2,
  forEach: () => forEach,
  fromIterable: () => fromIterable2,
  fromNullable: () => fromNullable3,
  fromOption: () => fromOption3,
  fromRecord: () => fromRecord,
  get: () => get2,
  getEquivalence: () => getEquivalence4,
  getLefts: () => getLefts,
  getOrder: () => getOrder2,
  getRights: () => getRights,
  getSomes: () => getSomes,
  group: () => group3,
  groupBy: () => groupBy,
  groupWith: () => groupWith,
  head: () => head2,
  headNonEmpty: () => headNonEmpty,
  init: () => init,
  initNonEmpty: () => initNonEmpty,
  insertAt: () => insertAt,
  intersection: () => intersection,
  intersectionWith: () => intersectionWith,
  intersperse: () => intersperse,
  isArray: () => isArray,
  isEmptyArray: () => isEmptyArray,
  isEmptyReadonlyArray: () => isEmptyReadonlyArray,
  isNonEmptyArray: () => isNonEmptyArray2,
  isNonEmptyReadonlyArray: () => isNonEmptyReadonlyArray,
  join: () => join,
  last: () => last,
  lastNonEmpty: () => lastNonEmpty,
  length: () => length,
  let: () => let_4,
  liftEither: () => liftEither,
  liftNullable: () => liftNullable2,
  liftOption: () => liftOption,
  liftPredicate: () => liftPredicate3,
  make: () => make4,
  makeBy: () => makeBy,
  map: () => map5,
  mapAccum: () => mapAccum,
  match: () => match3,
  matchLeft: () => matchLeft,
  matchRight: () => matchRight,
  max: () => max2,
  min: () => min2,
  modify: () => modify,
  modifyNonEmptyHead: () => modifyNonEmptyHead,
  modifyNonEmptyLast: () => modifyNonEmptyLast,
  modifyOption: () => modifyOption,
  of: () => of,
  pad: () => pad,
  partition: () => partition,
  partitionMap: () => partitionMap2,
  prepend: () => prepend,
  prependAll: () => prependAll,
  range: () => range,
  reduce: () => reduce,
  reduceRight: () => reduceRight,
  remove: () => remove,
  removeOption: () => removeOption,
  replace: () => replace,
  replaceOption: () => replaceOption,
  replicate: () => replicate,
  reverse: () => reverse,
  rotate: () => rotate,
  scan: () => scan,
  scanRight: () => scanRight,
  separate: () => separate,
  setNonEmptyHead: () => setNonEmptyHead,
  setNonEmptyLast: () => setNonEmptyLast,
  some: () => some4,
  sort: () => sort,
  sortBy: () => sortBy,
  sortWith: () => sortWith,
  span: () => span,
  split: () => split,
  splitAt: () => splitAt,
  splitNonEmptyAt: () => splitNonEmptyAt,
  splitWhere: () => splitWhere,
  tail: () => tail,
  tailNonEmpty: () => tailNonEmpty,
  take: () => take,
  takeRight: () => takeRight,
  takeWhile: () => takeWhile,
  unappend: () => unappend,
  unfold: () => unfold,
  union: () => union,
  unionWith: () => unionWith,
  unprepend: () => unprepend,
  unsafeGet: () => unsafeGet,
  unzip: () => unzip,
  window: () => window2,
  zip: () => zip,
  zipWith: () => zipWith3
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Either.js
var Either_exports = {};
__export(Either_exports, {
  Do: () => Do,
  TypeId: () => TypeId3,
  all: () => all2,
  andThen: () => andThen,
  ap: () => ap,
  bind: () => bind2,
  bindTo: () => bindTo2,
  filterOrLeft: () => filterOrLeft,
  flatMap: () => flatMap,
  flip: () => flip,
  fromNullable: () => fromNullable,
  fromOption: () => fromOption2,
  gen: () => gen,
  getEquivalence: () => getEquivalence,
  getLeft: () => getLeft2,
  getOrElse: () => getOrElse,
  getOrNull: () => getOrNull,
  getOrThrow: () => getOrThrow,
  getOrThrowWith: () => getOrThrowWith,
  getOrUndefined: () => getOrUndefined,
  getRight: () => getRight2,
  isEither: () => isEither2,
  isLeft: () => isLeft2,
  isRight: () => isRight2,
  left: () => left2,
  let: () => let_2,
  liftPredicate: () => liftPredicate,
  map: () => map,
  mapBoth: () => mapBoth,
  mapLeft: () => mapLeft,
  match: () => match,
  merge: () => merge,
  orElse: () => orElse,
  right: () => right2,
  transposeMapOption: () => transposeMapOption,
  transposeOption: () => transposeOption,
  try: () => try_,
  void: () => void_,
  zipWith: () => zipWith
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Equivalence.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var make = /* @__PURE__ */ __name((isEquivalent) => (self2, that) => self2 === that || isEquivalent(self2, that), "make");
var isStrictEquivalent = /* @__PURE__ */ __name((x, y) => x === y, "isStrictEquivalent");
var strict = /* @__PURE__ */ __name(() => isStrictEquivalent, "strict");
var string = /* @__PURE__ */ strict();
var number = /* @__PURE__ */ strict();
var mapInput = /* @__PURE__ */ dual(2, (self2, f) => make((x, y) => self2(f(x), f(y))));
var Date2 = /* @__PURE__ */ mapInput(number, (date4) => date4.getTime());
var array = /* @__PURE__ */ __name((item) => make((self2, that) => {
  if (self2.length !== that.length) {
    return false;
  }
  for (let i = 0; i < self2.length; i++) {
    const isEq = item(self2[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
}), "array");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/doNotation.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var let_ = /* @__PURE__ */ __name((map38) => dual(3, (self2, name, f) => map38(self2, (a) => ({
  ...a,
  [name]: f(a)
}))), "let_");
var bindTo = /* @__PURE__ */ __name((map38) => dual(2, (self2, name) => map38(self2, (a) => ({
  [name]: a
}))), "bindTo");
var bind = /* @__PURE__ */ __name((map38, flatMap25) => dual(3, (self2, name, f) => flatMap25(self2, (a) => map38(f(a), (b) => ({
  ...a,
  [name]: b
})))), "bind");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/either.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Equal.js
var Equal_exports = {};
__export(Equal_exports, {
  equals: () => equals,
  equivalence: () => equivalence,
  isEqual: () => isEqual,
  symbol: () => symbol2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Hash.js
var Hash_exports = {};
__export(Hash_exports, {
  array: () => array2,
  cached: () => cached,
  combine: () => combine,
  hash: () => hash,
  isHash: () => isHash,
  number: () => number2,
  optimize: () => optimize,
  random: () => random,
  string: () => string2,
  structure: () => structure,
  structureKeys: () => structureKeys,
  symbol: () => symbol
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/GlobalValue.js
var GlobalValue_exports = {};
__export(GlobalValue_exports, {
  globalValue: () => globalValue
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = /* @__PURE__ */ __name((id4, compute2) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= /* @__PURE__ */ new Map();
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id4)) {
    globalStore.set(id4, compute2());
  }
  return globalStore.get(id4);
}, "globalValue");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Predicate.js
var Predicate_exports = {};
__export(Predicate_exports, {
  all: () => all,
  and: () => and,
  compose: () => compose,
  eqv: () => eqv,
  every: () => every,
  hasProperty: () => hasProperty,
  implies: () => implies,
  isBigInt: () => isBigInt,
  isBoolean: () => isBoolean,
  isDate: () => isDate,
  isError: () => isError,
  isFunction: () => isFunction2,
  isIterable: () => isIterable,
  isMap: () => isMap,
  isNever: () => isNever,
  isNotNull: () => isNotNull,
  isNotNullable: () => isNotNullable,
  isNotUndefined: () => isNotUndefined,
  isNull: () => isNull,
  isNullable: () => isNullable,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPromise: () => isPromise,
  isPromiseLike: () => isPromiseLike,
  isPropertyKey: () => isPropertyKey,
  isReadonlyRecord: () => isReadonlyRecord,
  isRecord: () => isRecord,
  isRecordOrArray: () => isRecordOrArray,
  isRegExp: () => isRegExp,
  isSet: () => isSet,
  isString: () => isString,
  isSymbol: () => isSymbol,
  isTagged: () => isTagged,
  isTruthy: () => isTruthy,
  isTupleOf: () => isTupleOf,
  isTupleOfAtLeast: () => isTupleOfAtLeast,
  isUint8Array: () => isUint8Array,
  isUndefined: () => isUndefined,
  isUnknown: () => isUnknown,
  mapInput: () => mapInput2,
  nand: () => nand,
  nor: () => nor,
  not: () => not,
  or: () => or,
  product: () => product,
  productMany: () => productMany,
  some: () => some,
  struct: () => struct,
  tuple: () => tuple,
  xor: () => xor
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var mapInput2 = /* @__PURE__ */ dual(2, (self2, f) => (b) => self2(f(b)));
var isTupleOf = /* @__PURE__ */ dual(2, (self2, n) => self2.length === n);
var isTupleOfAtLeast = /* @__PURE__ */ dual(2, (self2, n) => self2.length >= n);
var isTruthy = /* @__PURE__ */ __name((input) => !!input, "isTruthy");
var isSet = /* @__PURE__ */ __name((input) => input instanceof Set, "isSet");
var isMap = /* @__PURE__ */ __name((input) => input instanceof Map, "isMap");
var isString = /* @__PURE__ */ __name((input) => typeof input === "string", "isString");
var isNumber = /* @__PURE__ */ __name((input) => typeof input === "number", "isNumber");
var isBoolean = /* @__PURE__ */ __name((input) => typeof input === "boolean", "isBoolean");
var isBigInt = /* @__PURE__ */ __name((input) => typeof input === "bigint", "isBigInt");
var isSymbol = /* @__PURE__ */ __name((input) => typeof input === "symbol", "isSymbol");
var isPropertyKey = /* @__PURE__ */ __name((u) => isString(u) || isNumber(u) || isSymbol(u), "isPropertyKey");
var isFunction2 = isFunction;
var isUndefined = /* @__PURE__ */ __name((input) => input === void 0, "isUndefined");
var isNotUndefined = /* @__PURE__ */ __name((input) => input !== void 0, "isNotUndefined");
var isNull = /* @__PURE__ */ __name((input) => input === null, "isNull");
var isNotNull = /* @__PURE__ */ __name((input) => input !== null, "isNotNull");
var isNever = /* @__PURE__ */ __name((_) => false, "isNever");
var isUnknown = /* @__PURE__ */ __name((_) => true, "isUnknown");
var isRecordOrArray = /* @__PURE__ */ __name((input) => typeof input === "object" && input !== null, "isRecordOrArray");
var isObject = /* @__PURE__ */ __name((input) => isRecordOrArray(input) || isFunction2(input), "isObject");
var hasProperty = /* @__PURE__ */ dual(2, (self2, property2) => isObject(self2) && property2 in self2);
var isTagged = /* @__PURE__ */ dual(2, (self2, tag8) => hasProperty(self2, "_tag") && self2["_tag"] === tag8);
var isNullable = /* @__PURE__ */ __name((input) => input === null || input === void 0, "isNullable");
var isNotNullable = /* @__PURE__ */ __name((input) => input !== null && input !== void 0, "isNotNullable");
var isError = /* @__PURE__ */ __name((input) => input instanceof Error, "isError");
var isUint8Array = /* @__PURE__ */ __name((input) => input instanceof Uint8Array, "isUint8Array");
var isDate = /* @__PURE__ */ __name((input) => input instanceof Date, "isDate");
var isIterable = /* @__PURE__ */ __name((input) => typeof input === "string" || hasProperty(input, Symbol.iterator), "isIterable");
var isRecord = /* @__PURE__ */ __name((input) => isRecordOrArray(input) && !Array.isArray(input), "isRecord");
var isReadonlyRecord = isRecord;
var isPromise = /* @__PURE__ */ __name((input) => hasProperty(input, "then") && "catch" in input && isFunction2(input.then) && isFunction2(input.catch), "isPromise");
var isPromiseLike = /* @__PURE__ */ __name((input) => hasProperty(input, "then") && isFunction2(input.then), "isPromiseLike");
var isRegExp = /* @__PURE__ */ __name((input) => input instanceof RegExp, "isRegExp");
var compose = /* @__PURE__ */ dual(2, (ab, bc) => (a) => ab(a) && bc(a));
var product = /* @__PURE__ */ __name((self2, that) => ([a, b]) => self2(a) && that(b), "product");
var all = /* @__PURE__ */ __name((collection) => {
  return (as16) => {
    let collectionIndex = 0;
    for (const p of collection) {
      if (collectionIndex >= as16.length) {
        break;
      }
      if (p(as16[collectionIndex]) === false) {
        return false;
      }
      collectionIndex++;
    }
    return true;
  };
}, "all");
var productMany = /* @__PURE__ */ __name((self2, collection) => {
  const rest = all(collection);
  return ([head13, ...tail3]) => self2(head13) === false ? false : rest(tail3);
}, "productMany");
var tuple = /* @__PURE__ */ __name((...elements) => all(elements), "tuple");
var struct = /* @__PURE__ */ __name((fields) => {
  const keys6 = Object.keys(fields);
  return (a) => {
    for (const key of keys6) {
      if (!fields[key](a[key])) {
        return false;
      }
    }
    return true;
  };
}, "struct");
var not = /* @__PURE__ */ __name((self2) => (a) => !self2(a), "not");
var or = /* @__PURE__ */ dual(2, (self2, that) => (a) => self2(a) || that(a));
var and = /* @__PURE__ */ dual(2, (self2, that) => (a) => self2(a) && that(a));
var xor = /* @__PURE__ */ dual(2, (self2, that) => (a) => self2(a) !== that(a));
var eqv = /* @__PURE__ */ dual(2, (self2, that) => (a) => self2(a) === that(a));
var implies = /* @__PURE__ */ dual(2, (antecedent, consequent) => (a) => antecedent(a) ? consequent(a) : true);
var nor = /* @__PURE__ */ dual(2, (self2, that) => (a) => !(self2(a) || that(a)));
var nand = /* @__PURE__ */ dual(2, (self2, that) => (a) => !(self2(a) && that(a)));
var every = /* @__PURE__ */ __name((collection) => (a) => {
  for (const p of collection) {
    if (!p(a)) {
      return false;
    }
  }
  return true;
}, "every");
var some = /* @__PURE__ */ __name((collection) => (a) => {
  for (const p of collection) {
    if (p(a)) {
      return true;
    }
  }
  return false;
}, "some");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Utils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/errors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getBugErrorMessage = /* @__PURE__ */ __name((message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`, "getBugErrorMessage");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Utils.js
var GenKindTypeId = /* @__PURE__ */ Symbol.for("effect/Gen/GenKind");
var isGenKind = /* @__PURE__ */ __name((u) => isObject(u) && GenKindTypeId in u, "isGenKind");
var GenKindImpl = class {
  static {
    __name(this, "GenKindImpl");
  }
  value;
  constructor(value6) {
    this.value = value6;
  }
  /**
   * @since 2.0.0
   */
  get _F() {
    return identity;
  }
  /**
   * @since 2.0.0
   */
  get _R() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _O() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  get _E() {
    return (_) => _;
  }
  /**
   * @since 2.0.0
   */
  [GenKindTypeId] = GenKindTypeId;
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new SingleShotGen(this);
  }
};
var SingleShotGen = class _SingleShotGen {
  static {
    __name(this, "SingleShotGen");
  }
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  /**
   * @since 2.0.0
   */
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  /**
   * @since 2.0.0
   */
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  /**
   * @since 2.0.0
   */
  throw(e) {
    throw e;
  }
  /**
   * @since 2.0.0
   */
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};
var adapter = /* @__PURE__ */ __name(() => function() {
  let x = arguments[0];
  for (let i = 1; i < arguments.length; i++) {
    x = arguments[i](x);
  }
  return new GenKindImpl(x);
}, "adapter");
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;
var PCGRandom = class {
  static {
    __name(this, "PCGRandom");
  }
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  /**
   * Returns a copy of the internal state of this random number generator as a
   * JavaScript Array.
   *
   * @category getters
   * @since 2.0.0
   */
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  /**
   * Restore state previously retrieved using `getState()`.
   *
   * @since 2.0.0
   */
  setState(state2) {
    this._state[0] = state2[0];
    this._state[1] = state2[1];
    this._state[2] = state2[2];
    this._state[3] = state2[3] | 1;
  }
  /**
   * Get a uniformly distributed 32 bit integer between [0, max).
   *
   * @category getter
   * @since 2.0.0
   */
  integer(max9) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max9;
  }
  /**
   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
   * 53 bits of precision (every bit of the mantissa is randomized).
   *
   * @category getters
   * @since 2.0.0
   */
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  /** @internal */
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
};
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
__name(mul64, "mul64");
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
__name(add64, "add64");
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
var YieldWrap = class {
  static {
    __name(this, "YieldWrap");
  }
  /**
   * @since 3.0.6
   */
  #value;
  constructor(value6) {
    this.#value = value6;
  }
  /**
   * @since 3.0.6
   */
  [YieldWrapTypeId]() {
    return this.#value;
  }
};
function yieldWrapGet(self2) {
  if (typeof self2 === "object" && self2 !== null && YieldWrapTypeId in self2) {
    return self2[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
__name(yieldWrapGet, "yieldWrapGet");
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: void 0
}));
var standard = {
  effect_internal_function: /* @__PURE__ */ __name((body) => {
    return body();
  }, "effect_internal_function")
};
var forced = {
  effect_internal_function: /* @__PURE__ */ __name((body) => {
    try {
      return body();
    } finally {
    }
  }, "effect_internal_function")
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;
var isGeneratorFunction = /* @__PURE__ */ __name((u) => isObject(u) && u.constructor === genConstructor, "isGeneratorFunction");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = /* @__PURE__ */ __name((self2) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self2) {
    case "number":
      return number2(self2);
    case "bigint":
      return string2(self2.toString(10));
    case "boolean":
      return string2(String(self2));
    case "symbol":
      return string2(String(self2));
    case "string":
      return string2(self2);
    case "undefined":
      return string2("undefined");
    case "function":
    case "object": {
      if (self2 === null) {
        return string2("null");
      } else if (self2 instanceof Date) {
        if (Number.isNaN(self2.getTime())) {
          return string2("Invalid Date");
        }
        return hash(self2.toISOString());
      } else if (self2 instanceof URL) {
        return hash(self2.href);
      } else if (isHash(self2)) {
        return self2[symbol]();
      } else {
        return random(self2);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self2} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
}, "hash");
var random = /* @__PURE__ */ __name((self2) => {
  if (!randomHashCache.has(self2)) {
    randomHashCache.set(self2, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self2);
}, "random");
var combine = /* @__PURE__ */ __name((b) => (self2) => self2 * 53 ^ b, "combine");
var optimize = /* @__PURE__ */ __name((n) => n & 3221225471 | n >>> 1 & 1073741824, "optimize");
var isHash = /* @__PURE__ */ __name((u) => hasProperty(u, symbol), "isHash");
var number2 = /* @__PURE__ */ __name((n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
}, "number");
var string2 = /* @__PURE__ */ __name((str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
}, "string");
var structureKeys = /* @__PURE__ */ __name((o, keys6) => {
  let h = 12289;
  for (let i = 0; i < keys6.length; i++) {
    h ^= pipe(string2(keys6[i]), combine(hash(o[keys6[i]])));
  }
  return optimize(h);
}, "structureKeys");
var structure = /* @__PURE__ */ __name((o) => structureKeys(o, Object.keys(o)), "structure");
var array2 = /* @__PURE__ */ __name((arr) => {
  let h = 6151;
  for (let i = 0; i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
}, "array");
var cached = /* @__PURE__ */ __name(function() {
  if (arguments.length === 1) {
    const self3 = arguments[0];
    return function(hash6) {
      Object.defineProperty(self3, symbol, {
        value() {
          return hash6;
        },
        enumerable: false
      });
      return hash6;
    };
  }
  const self2 = arguments[0];
  const hash5 = arguments[1];
  Object.defineProperty(self2, symbol, {
    value() {
      return hash5;
    },
    enumerable: false
  });
  return hash5;
}, "cached");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Equal.js
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
function equals() {
  if (arguments.length === 1) {
    return (self2) => compareBoth(self2, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
__name(equals, "equals");
function compareBoth(self2, that) {
  if (self2 === that) {
    return true;
  }
  const selfType = typeof self2;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self2 !== null && that !== null) {
      if (isEqual(self2) && isEqual(that)) {
        if (hash(self2) === hash(that) && self2[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
        }
      } else if (self2 instanceof Date && that instanceof Date) {
        const t1 = self2.getTime();
        const t2 = that.getTime();
        return t1 === t2 || Number.isNaN(t1) && Number.isNaN(t2);
      } else if (self2 instanceof URL && that instanceof URL) {
        return self2.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self2) && Array.isArray(that)) {
        return self2.length === that.length && self2.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self2) === Object.prototype && Object.getPrototypeOf(self2) === Object.prototype) {
        const keysSelf = Object.keys(self2);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!(key in that && compareBoth(self2[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
}
__name(compareBoth, "compareBoth");
var isEqual = /* @__PURE__ */ __name((u) => hasProperty(u, symbol2), "isEqual");
var equivalence = /* @__PURE__ */ __name(() => equals, "equivalence");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Inspectable.js
var Inspectable_exports = {};
__export(Inspectable_exports, {
  BaseProto: () => BaseProto,
  Class: () => Class,
  NodeInspectSymbol: () => NodeInspectSymbol,
  format: () => format,
  formatDate: () => formatDate,
  formatPropertyKey: () => formatPropertyKey,
  formatUnknown: () => formatUnknown,
  isRedactable: () => isRedactable,
  redact: () => redact,
  stringifyCircular: () => stringifyCircular,
  symbolRedactable: () => symbolRedactable,
  toJSON: () => toJSON,
  toStringUnknown: () => toStringUnknown,
  withRedactableContext: () => withRedactableContext
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = /* @__PURE__ */ __name((x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
}, "toJSON");
var CIRCULAR = "[Circular]";
function formatDate(date4) {
  try {
    return date4.toISOString();
  } catch {
    return "Invalid Date";
  }
}
__name(formatDate, "formatDate");
function safeToString(input) {
  try {
    const s = input.toString();
    return typeof s === "string" ? s : String(s);
  } catch {
    return "[toString threw]";
  }
}
__name(safeToString, "safeToString");
function formatPropertyKey(name) {
  return isString(name) ? JSON.stringify(name) : String(name);
}
__name(formatPropertyKey, "formatPropertyKey");
function formatUnknown(input, options4) {
  const space = options4?.space ?? 0;
  const seen = /* @__PURE__ */ new WeakSet();
  const gap = !space ? "" : isNumber(space) ? " ".repeat(space) : space;
  const ind = /* @__PURE__ */ __name((d) => gap.repeat(d), "ind");
  const wrap = /* @__PURE__ */ __name((v, body) => {
    const ctor = v?.constructor;
    return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
  }, "wrap");
  const ownKeys = /* @__PURE__ */ __name((o) => {
    try {
      return Reflect.ownKeys(o);
    } catch {
      return ["[ownKeys threw]"];
    }
  }, "ownKeys");
  function go3(v, d = 0) {
    if (Array.isArray(v)) {
      if (seen.has(v)) return CIRCULAR;
      seen.add(v);
      if (!gap || v.length <= 1) return `[${v.map((x) => go3(x, d)).join(",")}]`;
      const inner = v.map((x) => go3(x, d + 1)).join(",\n" + ind(d + 1));
      return `[
${ind(d + 1)}${inner}
${ind(d)}]`;
    }
    if (isDate(v)) return formatDate(v);
    if (!options4?.ignoreToString && hasProperty(v, "toString") && isFunction2(v["toString"]) && v["toString"] !== Object.prototype.toString && v["toString"] !== Array.prototype.toString) {
      const s = safeToString(v);
      if (v instanceof Error && v.cause) {
        return `${s} (cause: ${go3(v.cause, d)})`;
      }
      return s;
    }
    if (isString(v)) return JSON.stringify(v);
    if (isNumber(v) || v == null || isBoolean(v) || isSymbol(v)) return String(v);
    if (isBigInt(v)) return String(v) + "n";
    if (v instanceof Set || v instanceof Map) {
      if (seen.has(v)) return CIRCULAR;
      seen.add(v);
      return `${v.constructor.name}(${go3(Array.from(v), d)})`;
    }
    if (isObject(v)) {
      if (seen.has(v)) return CIRCULAR;
      seen.add(v);
      const keys6 = ownKeys(v);
      if (!gap || keys6.length <= 1) {
        const body2 = `{${keys6.map((k) => `${formatPropertyKey(k)}:${go3(v[k], d)}`).join(",")}}`;
        return wrap(v, body2);
      }
      const body = `{
${keys6.map((k) => `${ind(d + 1)}${formatPropertyKey(k)}: ${go3(v[k], d + 1)}`).join(",\n")}
${ind(d)}}`;
      return wrap(v, body);
    }
    return String(v);
  }
  __name(go3, "go");
  return go3(input, 0);
}
__name(formatUnknown, "formatUnknown");
var format = /* @__PURE__ */ __name((x) => JSON.stringify(x, null, 2), "format");
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var Class = class {
  static {
    __name(this, "Class");
  }
  /**
   * @since 2.0.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  /**
   * @since 2.0.0
   */
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = /* @__PURE__ */ __name((u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
}, "toStringUnknown");
var stringifyCircular = /* @__PURE__ */ __name((obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value6) => typeof value6 === "object" && value6 !== null ? cache.includes(value6) ? void 0 : cache.push(value6) && (redactableState.fiberRefs !== void 0 && isRedactable(value6) ? value6[symbolRedactable](redactableState.fiberRefs) : value6) : value6, whitespace);
  cache = void 0;
  return retVal;
}, "stringifyCircular");
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = /* @__PURE__ */ __name((u) => typeof u === "object" && u !== null && symbolRedactable in u, "isRedactable");
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: void 0
}));
var withRedactableContext = /* @__PURE__ */ __name((context17, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context17;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
}, "withRedactableContext");
var redact = /* @__PURE__ */ __name((u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
}, "redact");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/effectable.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Pipeable.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var pipeArguments = /* @__PURE__ */ __name((self2, args2) => {
  switch (args2.length) {
    case 0:
      return self2;
    case 1:
      return args2[0](self2);
    case 2:
      return args2[1](args2[0](self2));
    case 3:
      return args2[2](args2[1](args2[0](self2)));
    case 4:
      return args2[3](args2[2](args2[1](args2[0](self2))));
    case 5:
      return args2[4](args2[3](args2[2](args2[1](args2[0](self2)))));
    case 6:
      return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))));
    case 7:
      return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))));
    case 8:
      return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))))));
    case 9:
      return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))))));
    default: {
      let ret = self2;
      for (let i = 0, len = args2.length; i < len; i++) {
        ret = args2[i](ret);
      }
      return ret;
    }
  }
}, "pipeArguments");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/effect.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/version.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var moduleVersion = "3.19.13";
var getCurrentVersion = /* @__PURE__ */ __name(() => moduleVersion, "getCurrentVersion");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _L: /* @__PURE__ */ __name((_) => _, "_L"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var channelVariance = {
  /* c8 ignore next */
  _Env: /* @__PURE__ */ __name((_) => _, "_Env"),
  /* c8 ignore next */
  _InErr: /* @__PURE__ */ __name((_) => _, "_InErr"),
  /* c8 ignore next */
  _InElem: /* @__PURE__ */ __name((_) => _, "_InElem"),
  /* c8 ignore next */
  _InDone: /* @__PURE__ */ __name((_) => _, "_InDone"),
  /* c8 ignore next */
  _OutErr: /* @__PURE__ */ __name((_) => _, "_OutErr"),
  /* c8 ignore next */
  _OutElem: /* @__PURE__ */ __name((_) => _, "_OutElem"),
  /* c8 ignore next */
  _OutDone: /* @__PURE__ */ __name((_) => _, "_OutDone")
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!(key in that && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ (function() {
  function Base4() {
  }
  __name(Base4, "Base");
  Base4.prototype = CommitPrototype;
  return Base4;
})();
var StructuralBase = /* @__PURE__ */ (function() {
  function Base4() {
  }
  __name(Base4, "Base");
  Base4.prototype = StructuralCommitPrototype;
  return Base4;
})();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/option.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = /* @__PURE__ */ __name((input) => hasProperty(input, TypeId), "isOption");
var isNone = /* @__PURE__ */ __name((fa) => fa._tag === "None", "isNone");
var isSome = /* @__PURE__ */ __name((fa) => fa._tag === "Some", "isSome");
var none = /* @__PURE__ */ Object.create(NoneProto);
var some2 = /* @__PURE__ */ __name((value6) => {
  const a = Object.create(SomeProto);
  a.value = value6;
  return a;
}, "some");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: /* @__PURE__ */ __name((_) => _, "_R")
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = /* @__PURE__ */ __name((input) => hasProperty(input, TypeId2), "isEither");
var isLeft = /* @__PURE__ */ __name((ma) => ma._tag === "Left", "isLeft");
var isRight = /* @__PURE__ */ __name((ma) => ma._tag === "Right", "isRight");
var left = /* @__PURE__ */ __name((left3) => {
  const a = Object.create(LeftProto);
  a.left = left3;
  return a;
}, "left");
var right = /* @__PURE__ */ __name((right3) => {
  const a = Object.create(RightProto);
  a.right = right3;
  return a;
}, "right");
var getLeft = /* @__PURE__ */ __name((self2) => isRight(self2) ? none : some2(self2.left), "getLeft");
var getRight = /* @__PURE__ */ __name((self2) => isLeft(self2) ? none : some2(self2.right), "getRight");
var fromOption = /* @__PURE__ */ dual(2, (self2, onNone) => isNone(self2) ? left(onNone()) : right(self2.value));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Either.js
var TypeId3 = TypeId2;
var right2 = right;
var void_ = /* @__PURE__ */ right2(void 0);
var left2 = left;
var fromNullable = /* @__PURE__ */ dual(2, (self2, onNullable) => self2 == null ? left2(onNullable(self2)) : right2(self2));
var fromOption2 = fromOption;
var try_ = /* @__PURE__ */ __name((evaluate3) => {
  if (isFunction2(evaluate3)) {
    try {
      return right2(evaluate3());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate3.try());
    } catch (e) {
      return left2(evaluate3.catch(e));
    }
  }
}, "try_");
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var getRight2 = getRight;
var getLeft2 = getLeft;
var getEquivalence = /* @__PURE__ */ __name(({
  left: left3,
  right: right3
}) => make((x, y) => isLeft2(x) ? isLeft2(y) && left3(x.left, y.left) : isRight2(y) && right3(x.right, y.right)), "getEquivalence");
var mapBoth = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? left2(onLeft(self2.left)) : right2(onRight(self2.right)));
var mapLeft = /* @__PURE__ */ dual(2, (self2, f) => isLeft2(self2) ? left2(f(self2.left)) : right2(self2.right));
var map = /* @__PURE__ */ dual(2, (self2, f) => isRight2(self2) ? right2(f(self2.right)) : left2(self2.left));
var match = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? onLeft(self2.left) : onRight(self2.right));
var liftPredicate = /* @__PURE__ */ dual(3, (a, predicate, orLeftWith) => predicate(a) ? right2(a) : left2(orLeftWith(a)));
var filterOrLeft = /* @__PURE__ */ dual(3, (self2, predicate, orLeftWith) => flatMap(self2, (r) => predicate(r) ? right2(r) : left2(orLeftWith(r))));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});
var getOrElse = /* @__PURE__ */ dual(2, (self2, onLeft) => isLeft2(self2) ? onLeft(self2.left) : self2.right);
var getOrNull = /* @__PURE__ */ getOrElse(constNull);
var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
var getOrThrowWith = /* @__PURE__ */ dual(2, (self2, onLeft) => {
  if (isRight2(self2)) {
    return self2.right;
  }
  throw onLeft(self2.left);
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));
var orElse = /* @__PURE__ */ dual(2, (self2, that) => isLeft2(self2) ? that(self2.left) : right2(self2.right));
var flatMap = /* @__PURE__ */ dual(2, (self2, f) => isLeft2(self2) ? left2(self2.left) : f(self2.right));
var andThen = /* @__PURE__ */ dual(2, (self2, f) => flatMap(self2, (a) => {
  const b = isFunction2(f) ? f(a) : f;
  return isEither2(b) ? b : right2(b);
}));
var zipWith = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap(self2, (r) => map(that, (r2) => f(r, r2))));
var ap = /* @__PURE__ */ dual(2, (self2, that) => zipWith(self2, that, (f, a) => f(a)));
var all2 = /* @__PURE__ */ __name((input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const e of input) {
      if (isLeft2(e)) {
        return e;
      }
      out2.push(e.right);
    }
    return right2(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const e = input[key];
    if (isLeft2(e)) {
      return e;
    }
    out[key] = e.right;
  }
  return right2(out);
}, "all");
var flip = /* @__PURE__ */ __name((self2) => isLeft2(self2) ? right2(self2.left) : left2(self2.right), "flip");
var adapter2 = /* @__PURE__ */ adapter();
var gen = /* @__PURE__ */ __name((...args2) => {
  const f = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f(adapter2);
  let state2 = iterator.next();
  while (!state2.done) {
    const current2 = isGenKind(state2.value) ? state2.value.value : yieldWrapGet(state2.value);
    if (isLeft2(current2)) {
      return current2;
    }
    state2 = iterator.next(current2.right);
  }
  return right2(state2.value);
}, "gen");
var Do = /* @__PURE__ */ right2({});
var bind2 = /* @__PURE__ */ bind(map, flatMap);
var bindTo2 = /* @__PURE__ */ bindTo(map);
var let_2 = /* @__PURE__ */ let_(map);
var transposeOption = /* @__PURE__ */ __name((self2) => {
  return isNone(self2) ? right2(none) : map(self2.value, some2);
}, "transposeOption");
var transposeMapOption = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? right2(none) : map(f(self2.value), some2));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isNonEmptyArray = /* @__PURE__ */ __name((self2) => self2.length > 0, "isNonEmptyArray");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Iterable.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Option.js
var Option_exports = {};
__export(Option_exports, {
  Do: () => Do2,
  TypeId: () => TypeId4,
  all: () => all4,
  andThen: () => andThen2,
  ap: () => ap2,
  as: () => as,
  asVoid: () => asVoid,
  bind: () => bind3,
  bindTo: () => bindTo3,
  composeK: () => composeK,
  contains: () => contains,
  containsWith: () => containsWith,
  exists: () => exists,
  filter: () => filter,
  filterMap: () => filterMap,
  firstSomeOf: () => firstSomeOf,
  flatMap: () => flatMap2,
  flatMapNullable: () => flatMapNullable,
  flatten: () => flatten,
  fromIterable: () => fromIterable,
  fromNullable: () => fromNullable2,
  gen: () => gen2,
  getEquivalence: () => getEquivalence2,
  getLeft: () => getLeft3,
  getOrElse: () => getOrElse2,
  getOrNull: () => getOrNull2,
  getOrThrow: () => getOrThrow2,
  getOrThrowWith: () => getOrThrowWith2,
  getOrUndefined: () => getOrUndefined2,
  getOrder: () => getOrder,
  getRight: () => getRight3,
  isNone: () => isNone2,
  isOption: () => isOption2,
  isSome: () => isSome2,
  let: () => let_3,
  lift2: () => lift2,
  liftNullable: () => liftNullable,
  liftPredicate: () => liftPredicate2,
  liftThrowable: () => liftThrowable,
  map: () => map2,
  match: () => match2,
  mergeWith: () => mergeWith,
  none: () => none2,
  orElse: () => orElse2,
  orElseEither: () => orElseEither,
  orElseSome: () => orElseSome,
  partitionMap: () => partitionMap,
  product: () => product2,
  productMany: () => productMany2,
  reduceCompact: () => reduceCompact,
  some: () => some3,
  tap: () => tap,
  toArray: () => toArray,
  toRefinement: () => toRefinement,
  void: () => void_2,
  zipLeft: () => zipLeft,
  zipRight: () => zipRight,
  zipWith: () => zipWith2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Order.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var make2 = /* @__PURE__ */ __name((compare3) => (self2, that) => self2 === that ? 0 : compare3(self2, that), "make");
var number3 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var bigint2 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var combineMany = /* @__PURE__ */ dual(2, (self2, collection) => make2((a1, a2) => {
  let out = self2(a1, a2);
  if (out !== 0) {
    return out;
  }
  for (const O of collection) {
    out = O(a1, a2);
    if (out !== 0) {
      return out;
    }
  }
  return out;
}));
var empty = /* @__PURE__ */ __name(() => make2(() => 0), "empty");
var combineAll = /* @__PURE__ */ __name((collection) => combineMany(empty(), collection), "combineAll");
var mapInput3 = /* @__PURE__ */ dual(2, (self2, f) => make2((b1, b2) => self2(f(b1), f(b2))));
var all3 = /* @__PURE__ */ __name((collection) => {
  return make2((x, y) => {
    const len = Math.min(x.length, y.length);
    let collectionLength = 0;
    for (const O of collection) {
      if (collectionLength >= len) {
        break;
      }
      const o = O(x[collectionLength], y[collectionLength]);
      if (o !== 0) {
        return o;
      }
      collectionLength++;
    }
    return 0;
  });
}, "all");
var tuple2 = /* @__PURE__ */ __name((...elements) => all3(elements), "tuple");
var array3 = /* @__PURE__ */ __name((O) => make2((self2, that) => {
  const aLen = self2.length;
  const bLen = that.length;
  const len = Math.min(aLen, bLen);
  for (let i = 0; i < len; i++) {
    const o = O(self2[i], that[i]);
    if (o !== 0) {
      return o;
    }
  }
  return number3(aLen, bLen);
}), "array");
var lessThan = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) === -1), "lessThan");
var greaterThan = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) === 1), "greaterThan");
var lessThanOrEqualTo = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) !== 1), "lessThanOrEqualTo");
var greaterThanOrEqualTo = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => O(self2, that) !== -1), "greaterThanOrEqualTo");
var min = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => self2 === that || O(self2, that) < 1 ? self2 : that), "min");
var max = /* @__PURE__ */ __name((O) => dual(2, (self2, that) => self2 === that || O(self2, that) > -1 ? self2 : that), "max");
var clamp = /* @__PURE__ */ __name((O) => dual(2, (self2, options4) => min(O)(options4.maximum, max(O)(options4.minimum, self2))), "clamp");
var between = /* @__PURE__ */ __name((O) => dual(2, (self2, options4) => !lessThan(O)(self2, options4.minimum) && !greaterThan(O)(self2, options4.maximum)), "between");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Option.js
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Option");
var none2 = /* @__PURE__ */ __name(() => none, "none");
var some3 = some2;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self2, {
  onNone,
  onSome
}) => isNone2(self2) ? onNone() : onSome(self2.value));
var toRefinement = /* @__PURE__ */ __name((f) => (a) => isSome2(f(a)), "toRefinement");
var fromIterable = /* @__PURE__ */ __name((collection) => {
  for (const a of collection) {
    return some3(a);
  }
  return none2();
}, "fromIterable");
var getRight3 = getRight;
var getLeft3 = getLeft;
var getOrElse2 = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? onNone() : self2.value);
var orElse2 = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? that() : self2);
var orElseSome = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? some3(onNone()) : self2);
var orElseEither = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? map2(that(), right) : map2(self2, left));
var firstSomeOf = /* @__PURE__ */ __name((collection) => {
  let out = none2();
  for (out of collection) {
    if (isSome2(out)) {
      return out;
    }
  }
  return out;
}, "firstSomeOf");
var fromNullable2 = /* @__PURE__ */ __name((nullableValue) => nullableValue == null ? none2() : some3(nullableValue), "fromNullable");
var liftNullable = /* @__PURE__ */ __name((f) => (...a) => fromNullable2(f(...a)), "liftNullable");
var getOrNull2 = /* @__PURE__ */ getOrElse2(constNull);
var getOrUndefined2 = /* @__PURE__ */ getOrElse2(constUndefined);
var liftThrowable = /* @__PURE__ */ __name((f) => (...a) => {
  try {
    return some3(f(...a));
  } catch {
    return none2();
  }
}, "liftThrowable");
var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self2, onNone) => {
  if (isSome2(self2)) {
    return self2.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : some3(f(self2.value)));
var as = /* @__PURE__ */ dual(2, (self2, b) => map2(self2, () => b));
var asVoid = /* @__PURE__ */ as(void 0);
var void_2 = /* @__PURE__ */ some3(void 0);
var flatMap2 = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : f(self2.value));
var andThen2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap2(self2, (a) => {
  const b = isFunction(f) ? f(a) : f;
  return isOption2(b) ? b : some3(b);
}));
var flatMapNullable = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : fromNullable2(f(self2.value)));
var flatten = /* @__PURE__ */ flatMap2(identity);
var zipRight = /* @__PURE__ */ dual(2, (self2, that) => flatMap2(self2, () => that));
var zipLeft = /* @__PURE__ */ dual(2, (self2, that) => tap(self2, () => that));
var composeK = /* @__PURE__ */ dual(2, (afb, bfc) => (a) => flatMap2(afb(a), bfc));
var tap = /* @__PURE__ */ dual(2, (self2, f) => flatMap2(self2, (a) => map2(f(a), () => a)));
var product2 = /* @__PURE__ */ __name((self2, that) => isSome2(self2) && isSome2(that) ? some3([self2.value, that.value]) : none2(), "product");
var productMany2 = /* @__PURE__ */ __name((self2, collection) => {
  if (isNone2(self2)) {
    return none2();
  }
  const out = [self2.value];
  for (const o of collection) {
    if (isNone2(o)) {
      return none2();
    }
    out.push(o.value);
  }
  return some3(out);
}, "productMany");
var all4 = /* @__PURE__ */ __name((input) => {
  if (Symbol.iterator in input) {
    const out2 = [];
    for (const o of input) {
      if (isNone2(o)) {
        return none2();
      }
      out2.push(o.value);
    }
    return some3(out2);
  }
  const out = {};
  for (const key of Object.keys(input)) {
    const o = input[key];
    if (isNone2(o)) {
      return none2();
    }
    out[key] = o.value;
  }
  return some3(out);
}, "all");
var zipWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => map2(product2(self2, that), ([a, b]) => f(a, b)));
var ap2 = /* @__PURE__ */ dual(2, (self2, that) => zipWith2(self2, that, (f, a) => f(a)));
var reduceCompact = /* @__PURE__ */ dual(3, (self2, b, f) => {
  let out = b;
  for (const oa of self2) {
    if (isSome2(oa)) {
      out = f(out, oa.value);
    }
  }
  return out;
});
var toArray = /* @__PURE__ */ __name((self2) => isNone2(self2) ? [] : [self2.value], "toArray");
var partitionMap = /* @__PURE__ */ dual(2, (self2, f) => {
  if (isNone2(self2)) {
    return [none2(), none2()];
  }
  const e = f(self2.value);
  return isLeft(e) ? [some3(e.left), none2()] : [none2(), some3(e.right)];
});
var filterMap = flatMap2;
var filter = /* @__PURE__ */ dual(2, (self2, predicate) => filterMap(self2, (b) => predicate(b) ? some2(b) : none));
var getEquivalence2 = /* @__PURE__ */ __name((isEquivalent) => make((x, y) => isNone2(x) ? isNone2(y) : isNone2(y) ? false : isEquivalent(x.value, y.value)), "getEquivalence");
var getOrder = /* @__PURE__ */ __name((O) => make2((self2, that) => isSome2(self2) ? isSome2(that) ? O(self2.value, that.value) : 1 : -1), "getOrder");
var lift2 = /* @__PURE__ */ __name((f) => dual(2, (self2, that) => zipWith2(self2, that, f)), "lift2");
var liftPredicate2 = /* @__PURE__ */ dual(2, (b, predicate) => predicate(b) ? some3(b) : none2());
var containsWith = /* @__PURE__ */ __name((isEquivalent) => dual(2, (self2, a) => isNone2(self2) ? false : isEquivalent(self2.value, a)), "containsWith");
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var exists = /* @__PURE__ */ dual(2, (self2, refinement) => isNone2(self2) ? false : refinement(self2.value));
var bindTo3 = /* @__PURE__ */ bindTo(map2);
var let_3 = /* @__PURE__ */ let_(map2);
var bind3 = /* @__PURE__ */ bind(map2, flatMap2);
var Do2 = /* @__PURE__ */ some3({});
var adapter3 = /* @__PURE__ */ adapter();
var gen2 = /* @__PURE__ */ __name((...args2) => {
  const f = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f(adapter3);
  let state2 = iterator.next();
  while (!state2.done) {
    const current2 = isGenKind(state2.value) ? state2.value.value : yieldWrapGet(state2.value);
    if (isNone2(current2)) {
      return current2;
    }
    state2 = iterator.next(current2.value);
  }
  return some3(state2.value);
}, "gen");
var mergeWith = /* @__PURE__ */ __name((f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some3(f(o1.value, o2.value));
}, "mergeWith");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Tuple.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var make3 = /* @__PURE__ */ __name((...elements) => elements, "make");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Iterable.js
var head = /* @__PURE__ */ __name((self2) => {
  const iterator = self2[Symbol.iterator]();
  const result = iterator.next();
  return result.done ? none2() : some3(result.value);
}, "head");
var unsafeHead = /* @__PURE__ */ __name((self2) => {
  const iterator = self2[Symbol.iterator]();
  const result = iterator.next();
  if (result.done) throw new Error("unsafeHead: empty iterable");
  return result.value;
}, "unsafeHead");
var findFirst = /* @__PURE__ */ dual(2, (self2, f) => {
  let i = 0;
  for (const a of self2) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some3(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: void 0
    };
  }
};
var empty2 = /* @__PURE__ */ __name(() => constEmpty, "empty");
var map3 = /* @__PURE__ */ dual(2, (self2, f) => ({
  [Symbol.iterator]() {
    const iterator = self2[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        const result = iterator.next();
        if (result.done) {
          return {
            done: true,
            value: void 0
          };
        }
        return {
          done: false,
          value: f(result.value, i++)
        };
      }
    };
  }
}));
var filter2 = /* @__PURE__ */ dual(2, (self2, predicate) => ({
  [Symbol.iterator]() {
    const iterator = self2[Symbol.iterator]();
    let i = 0;
    return {
      next() {
        let result = iterator.next();
        while (!result.done) {
          if (predicate(result.value, i++)) {
            return {
              done: false,
              value: result.value
            };
          }
          result = iterator.next();
        }
        return {
          done: true,
          value: void 0
        };
      }
    };
  }
}));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Record.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isEmptyRecord = /* @__PURE__ */ __name((self2) => keys(self2).length === 0, "isEmptyRecord");
var collect = /* @__PURE__ */ dual(2, (self2, f) => {
  const out = [];
  for (const key of keys(self2)) {
    out.push(f(key, self2[key]));
  }
  return out;
});
var toEntries = /* @__PURE__ */ collect((key, value6) => [key, value6]);
var has = /* @__PURE__ */ dual(2, (self2, key) => Object.prototype.hasOwnProperty.call(self2, key));
var get = /* @__PURE__ */ dual(2, (self2, key) => has(self2, key) ? some3(self2[key]) : none2());
var map4 = /* @__PURE__ */ dual(2, (self2, f) => {
  const out = {
    ...self2
  };
  for (const key of keys(self2)) {
    out[key] = f(self2[key], key);
  }
  return out;
});
var keys = /* @__PURE__ */ __name((self2) => Object.keys(self2), "keys");
var isSubrecordBy = /* @__PURE__ */ __name((equivalence3) => dual(2, (self2, that) => {
  for (const key of keys(self2)) {
    if (!has(that, key) || !equivalence3(self2[key], that[key])) {
      return false;
    }
  }
  return true;
}), "isSubrecordBy");
var getEquivalence3 = /* @__PURE__ */ __name((equivalence3) => {
  const is4 = isSubrecordBy(equivalence3);
  return (self2, that) => is4(self2, that) && is4(that, self2);
}, "getEquivalence");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Array.js
var make4 = /* @__PURE__ */ __name((...elements) => elements, "make");
var allocate = /* @__PURE__ */ __name((n) => new Array(n), "allocate");
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max9 = Math.max(1, Math.floor(n));
  const out = new Array(max9);
  for (let i = 0; i < max9; i++) {
    out[i] = f(i);
  }
  return out;
});
var range = /* @__PURE__ */ __name((start3, end6) => start3 <= end6 ? makeBy(end6 - start3 + 1, (i) => start3 + i) : [start3], "range");
var replicate = /* @__PURE__ */ dual(2, (a, n) => makeBy(n, () => a));
var fromIterable2 = /* @__PURE__ */ __name((collection) => Array.isArray(collection) ? collection : Array.from(collection), "fromIterable");
var ensure = /* @__PURE__ */ __name((self2) => Array.isArray(self2) ? self2 : [self2], "ensure");
var fromRecord = toEntries;
var fromOption3 = toArray;
var match3 = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(self2) : onEmpty());
var matchLeft = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(headNonEmpty(self2), tailNonEmpty(self2)) : onEmpty());
var matchRight = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(initNonEmpty(self2), lastNonEmpty(self2)) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self2, head13) => [head13, ...self2]);
var prependAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable2(that).concat(fromIterable2(self2)));
var append = /* @__PURE__ */ dual(2, (self2, last5) => [...self2, last5]);
var appendAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable2(self2).concat(fromIterable2(that)));
var scan = /* @__PURE__ */ dual(3, (self2, b, f) => {
  const out = [b];
  let i = 0;
  for (const a of self2) {
    out[i + 1] = f(out[i], a);
    i++;
  }
  return out;
});
var scanRight = /* @__PURE__ */ dual(3, (self2, b, f) => {
  const input = fromIterable2(self2);
  const out = new Array(input.length + 1);
  out[input.length] = b;
  for (let i = input.length - 1; i >= 0; i--) {
    out[i] = f(out[i + 1], input[i]);
  }
  return out;
});
var isArray = Array.isArray;
var isEmptyArray = /* @__PURE__ */ __name((self2) => self2.length === 0, "isEmptyArray");
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var length = /* @__PURE__ */ __name((self2) => self2.length, "length");
var isOutOfBounds = /* @__PURE__ */ __name((i, as16) => i < 0 || i >= as16.length, "isOutOfBounds");
var clamp2 = /* @__PURE__ */ __name((i, as16) => Math.floor(Math.min(Math.max(0, i), as16.length)), "clamp");
var get2 = /* @__PURE__ */ dual(2, (self2, index2) => {
  const i = Math.floor(index2);
  return isOutOfBounds(i, self2) ? none2() : some3(self2[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self2, index2) => {
  const i = Math.floor(index2);
  if (isOutOfBounds(i, self2)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self2[i];
});
var unprepend = /* @__PURE__ */ __name((self2) => [headNonEmpty(self2), tailNonEmpty(self2)], "unprepend");
var unappend = /* @__PURE__ */ __name((self2) => [initNonEmpty(self2), lastNonEmpty(self2)], "unappend");
var head2 = /* @__PURE__ */ get2(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = /* @__PURE__ */ __name((self2) => isNonEmptyReadonlyArray(self2) ? some3(lastNonEmpty(self2)) : none2(), "last");
var lastNonEmpty = /* @__PURE__ */ __name((self2) => self2[self2.length - 1], "lastNonEmpty");
var tail = /* @__PURE__ */ __name((self2) => {
  const input = fromIterable2(self2);
  return isNonEmptyReadonlyArray(input) ? some3(tailNonEmpty(input)) : none2();
}, "tail");
var tailNonEmpty = /* @__PURE__ */ __name((self2) => self2.slice(1), "tailNonEmpty");
var init = /* @__PURE__ */ __name((self2) => {
  const input = fromIterable2(self2);
  return isNonEmptyReadonlyArray(input) ? some3(initNonEmpty(input)) : none2();
}, "init");
var initNonEmpty = /* @__PURE__ */ __name((self2) => self2.slice(0, -1), "initNonEmpty");
var take = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable2(self2);
  return input.slice(0, clamp2(n, input));
});
var takeRight = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable2(self2);
  const i = clamp2(n, input);
  return i === 0 ? [] : input.slice(-i);
});
var takeWhile = /* @__PURE__ */ dual(2, (self2, predicate) => {
  let i = 0;
  const out = [];
  for (const a of self2) {
    if (!predicate(a, i)) {
      break;
    }
    out.push(a);
    i++;
  }
  return out;
});
var spanIndex = /* @__PURE__ */ __name((self2, predicate) => {
  let i = 0;
  for (const a of self2) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
}, "spanIndex");
var span = /* @__PURE__ */ dual(2, (self2, predicate) => splitAt(self2, spanIndex(self2, predicate)));
var drop = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable2(self2);
  return input.slice(clamp2(n, input), input.length);
});
var dropRight = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable2(self2);
  return input.slice(0, input.length - clamp2(n, input));
});
var dropWhile = /* @__PURE__ */ dual(2, (self2, predicate) => fromIterable2(self2).slice(spanIndex(self2, predicate)));
var findFirstIndex = /* @__PURE__ */ dual(2, (self2, predicate) => {
  let i = 0;
  for (const a of self2) {
    if (predicate(a, i)) {
      return some3(i);
    }
    i++;
  }
  return none2();
});
var findLastIndex = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const input = fromIterable2(self2);
  for (let i = input.length - 1; i >= 0; i--) {
    if (predicate(input[i], i)) {
      return some3(i);
    }
  }
  return none2();
});
var findFirst2 = findFirst;
var findLast = /* @__PURE__ */ dual(2, (self2, f) => {
  const input = fromIterable2(self2);
  for (let i = input.length - 1; i >= 0; i--) {
    const a = input[i];
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some3(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
  }
  return none2();
});
var findFirstWithIndex = /* @__PURE__ */ dual(2, (self2, f) => {
  let i = 0;
  for (const a of self2) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some3([a, i]);
      }
    } else {
      if (isSome2(o)) {
        return some3([o.value, i]);
      }
    }
    i++;
  }
  return none2();
});
var countBy = /* @__PURE__ */ dual(2, (self2, f) => {
  let count7 = 0;
  const as16 = fromIterable2(self2);
  for (let i = 0; i < as16.length; i++) {
    const a = as16[i];
    if (f(a, i)) {
      count7++;
    }
  }
  return count7;
});
var insertAt = /* @__PURE__ */ dual(3, (self2, i, b) => {
  const out = Array.from(self2);
  if (i < 0 || i > out.length) {
    return none2();
  }
  out.splice(i, 0, b);
  return some3(out);
});
var replace = /* @__PURE__ */ dual(3, (self2, i, b) => modify(self2, i, () => b));
var replaceOption = /* @__PURE__ */ dual(3, (self2, i, b) => modifyOption(self2, i, () => b));
var modify = /* @__PURE__ */ dual(3, (self2, i, f) => {
  const out = Array.from(self2);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  const b = f(out[i]);
  out[i] = b;
  return out;
});
var modifyOption = /* @__PURE__ */ dual(3, (self2, i, f) => {
  const arr = fromIterable2(self2);
  if (isOutOfBounds(i, arr)) {
    return none2();
  }
  const out = Array.isArray(self2) ? self2.slice() : arr;
  const b = f(arr[i]);
  out[i] = b;
  return some3(out);
});
var remove = /* @__PURE__ */ dual(2, (self2, i) => {
  const out = Array.from(self2);
  if (isOutOfBounds(i, out)) {
    return out;
  }
  out.splice(i, 1);
  return out;
});
var removeOption = /* @__PURE__ */ dual(2, (self2, i) => {
  const arr = fromIterable2(self2);
  if (isOutOfBounds(i, arr)) {
    return none2();
  }
  const out = Array.isArray(self2) ? self2.slice() : arr;
  out.splice(i, 1);
  return some3(out);
});
var reverse = /* @__PURE__ */ __name((self2) => Array.from(self2).reverse(), "reverse");
var sort = /* @__PURE__ */ dual(2, (self2, O) => {
  const out = Array.from(self2);
  out.sort(O);
  return out;
});
var sortWith = /* @__PURE__ */ dual(3, (self2, f, order) => Array.from(self2).map((a) => [a, f(a)]).sort(([, a], [, b]) => order(a, b)).map(([_]) => _));
var sortBy = /* @__PURE__ */ __name((...orders) => {
  const sortByAll = sort(combineAll(orders));
  return (self2) => {
    const input = fromIterable2(self2);
    if (isNonEmptyReadonlyArray(input)) {
      return sortByAll(input);
    }
    return [];
  };
}, "sortBy");
var zip = /* @__PURE__ */ dual(2, (self2, that) => zipWith3(self2, that, make3));
var zipWith3 = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const as16 = fromIterable2(self2);
  const bs = fromIterable2(that);
  if (isNonEmptyReadonlyArray(as16) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as16), headNonEmpty(bs))];
    const len = Math.min(as16.length, bs.length);
    for (let i = 1; i < len; i++) {
      out[i] = f(as16[i], bs[i]);
    }
    return out;
  }
  return [];
});
var unzip = /* @__PURE__ */ __name((self2) => {
  const input = fromIterable2(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const fa = [input[0][0]];
    const fb = [input[0][1]];
    for (let i = 1; i < input.length; i++) {
      fa[i] = input[i][0];
      fb[i] = input[i][1];
    }
    return [fa, fb];
  }
  return [[], []];
}, "unzip");
var intersperse = /* @__PURE__ */ dual(2, (self2, middle) => {
  const input = fromIterable2(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const tail3 = tailNonEmpty(input);
    for (let i = 0; i < tail3.length; i++) {
      if (i < tail3.length) {
        out.push(middle);
      }
      out.push(tail3[i]);
    }
    return out;
  }
  return [];
});
var modifyNonEmptyHead = /* @__PURE__ */ dual(2, (self2, f) => [f(headNonEmpty(self2)), ...tailNonEmpty(self2)]);
var setNonEmptyHead = /* @__PURE__ */ dual(2, (self2, b) => modifyNonEmptyHead(self2, () => b));
var modifyNonEmptyLast = /* @__PURE__ */ dual(2, (self2, f) => append(initNonEmpty(self2), f(lastNonEmpty(self2))));
var setNonEmptyLast = /* @__PURE__ */ dual(2, (self2, b) => modifyNonEmptyLast(self2, () => b));
var rotate = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable2(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const len = input.length;
    const m = Math.round(n) % len;
    if (isOutOfBounds(Math.abs(m), input) || m === 0) {
      return copy(input);
    }
    if (m < 0) {
      const [f, s] = splitNonEmptyAt(input, -m);
      return appendAll(s, f);
    } else {
      return rotate(self2, m - len);
    }
  }
  return [];
});
var containsWith2 = /* @__PURE__ */ __name((isEquivalent) => dual(2, (self2, a) => {
  for (const i of self2) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
}), "containsWith");
var _equivalence2 = /* @__PURE__ */ equivalence();
var contains2 = /* @__PURE__ */ containsWith2(_equivalence2);
var chop = /* @__PURE__ */ dual(2, (self2, f) => {
  const input = fromIterable2(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const [b, rest] = f(input);
    const out = [b];
    let next4 = rest;
    while (isNonEmptyArray(next4)) {
      const [b2, rest2] = f(next4);
      out.push(b2);
      next4 = rest2;
    }
    return out;
  }
  return [];
});
var splitAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = Array.from(self2);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self2.length ? [copy(self2), []] : [prepend(self2.slice(1, _n), headNonEmpty(self2)), self2.slice(_n)];
});
var split = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable2(self2);
  return chunksOf(input, Math.ceil(input.length / Math.floor(n)));
});
var splitWhere = /* @__PURE__ */ dual(2, (self2, predicate) => span(self2, (a, i) => !predicate(a, i)));
var copy = /* @__PURE__ */ __name((self2) => self2.slice(), "copy");
var pad = /* @__PURE__ */ dual(3, (self2, n, fill) => {
  if (self2.length >= n) {
    return take(self2, n);
  }
  return appendAll(self2, makeBy(n - self2.length, () => fill));
});
var chunksOf = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable2(self2);
  if (isNonEmptyReadonlyArray(input)) {
    return chop(input, splitNonEmptyAt(n));
  }
  return [];
});
var window2 = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable2(self2);
  if (n > 0 && isNonEmptyReadonlyArray(input)) {
    return Array.from({
      length: input.length - (n - 1)
    }, (_, index2) => input.slice(index2, index2 + n));
  }
  return [];
});
var groupWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => chop(self2, (as16) => {
  const h = headNonEmpty(as16);
  const out = [h];
  let i = 1;
  for (; i < as16.length; i++) {
    const a = as16[i];
    if (isEquivalent(a, h)) {
      out.push(a);
    } else {
      break;
    }
  }
  return [out, as16.slice(i)];
}));
var group3 = /* @__PURE__ */ groupWith(/* @__PURE__ */ equivalence());
var groupBy = /* @__PURE__ */ dual(2, (self2, f) => {
  const out = {};
  for (const a of self2) {
    const k = f(a);
    if (Object.prototype.hasOwnProperty.call(out, k)) {
      out[k].push(a);
    } else {
      out[k] = [a];
    }
  }
  return out;
});
var unionWith = /* @__PURE__ */ dual(3, (self2, that, isEquivalent) => {
  const a = fromIterable2(self2);
  const b = fromIterable2(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe3 = dedupeWith(isEquivalent);
      return dedupe3(appendAll(a, b));
    }
    return a;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self2, that) => unionWith(self2, that, _equivalence2));
var intersectionWith = /* @__PURE__ */ __name((isEquivalent) => {
  const has12 = containsWith2(isEquivalent);
  return dual(2, (self2, that) => {
    const bs = fromIterable2(that);
    return fromIterable2(self2).filter((a) => has12(bs, a));
  });
}, "intersectionWith");
var intersection = /* @__PURE__ */ intersectionWith(_equivalence2);
var differenceWith = /* @__PURE__ */ __name((isEquivalent) => {
  const has12 = containsWith2(isEquivalent);
  return dual(2, (self2, that) => {
    const bs = fromIterable2(that);
    return fromIterable2(self2).filter((a) => !has12(bs, a));
  });
}, "differenceWith");
var difference = /* @__PURE__ */ differenceWith(_equivalence2);
var empty3 = /* @__PURE__ */ __name(() => [], "empty");
var of = /* @__PURE__ */ __name((a) => [a], "of");
var map5 = /* @__PURE__ */ dual(2, (self2, f) => self2.map(f));
var flatMap3 = /* @__PURE__ */ dual(2, (self2, f) => {
  if (isEmptyReadonlyArray(self2)) {
    return [];
  }
  const out = [];
  for (let i = 0; i < self2.length; i++) {
    const inner = f(self2[i], i);
    for (let j = 0; j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten2 = /* @__PURE__ */ flatMap3(identity);
var filterMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const as16 = fromIterable2(self2);
  const out = [];
  for (let i = 0; i < as16.length; i++) {
    const o = f(as16[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var filterMapWhile = /* @__PURE__ */ dual(2, (self2, f) => {
  let i = 0;
  const out = [];
  for (const a of self2) {
    const b = f(a, i);
    if (isSome2(b)) {
      out.push(b.value);
    } else {
      break;
    }
    i++;
  }
  return out;
});
var partitionMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const left3 = [];
  const right3 = [];
  const as16 = fromIterable2(self2);
  for (let i = 0; i < as16.length; i++) {
    const e = f(as16[i], i);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes = /* @__PURE__ */ filterMap2(identity);
var getLefts = /* @__PURE__ */ __name((self2) => {
  const out = [];
  for (const a of self2) {
    if (isLeft2(a)) {
      out.push(a.left);
    }
  }
  return out;
}, "getLefts");
var getRights = /* @__PURE__ */ __name((self2) => {
  const out = [];
  for (const a of self2) {
    if (isRight2(a)) {
      out.push(a.right);
    }
  }
  return out;
}, "getRights");
var filter3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const as16 = fromIterable2(self2);
  const out = [];
  for (let i = 0; i < as16.length; i++) {
    if (predicate(as16[i], i)) {
      out.push(as16[i]);
    }
  }
  return out;
});
var partition = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const left3 = [];
  const right3 = [];
  const as16 = fromIterable2(self2);
  for (let i = 0; i < as16.length; i++) {
    if (predicate(as16[i], i)) {
      right3.push(as16[i]);
    } else {
      left3.push(as16[i]);
    }
  }
  return [left3, right3];
});
var separate = /* @__PURE__ */ partitionMap2(identity);
var reduce = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable2(self2).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable2(self2).reduceRight((b2, a, i) => f(b2, a, i), b));
var liftPredicate3 = /* @__PURE__ */ __name((predicate) => (b) => predicate(b) ? [b] : [], "liftPredicate");
var liftOption = /* @__PURE__ */ __name((f) => (...a) => fromOption3(f(...a)), "liftOption");
var fromNullable3 = /* @__PURE__ */ __name((a) => a == null ? empty3() : [a], "fromNullable");
var liftNullable2 = /* @__PURE__ */ __name((f) => (...a) => fromNullable3(f(...a)), "liftNullable");
var flatMapNullable2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap3(self2, (a) => fromNullable3(f(a))));
var liftEither = /* @__PURE__ */ __name((f) => (...a) => {
  const e = f(...a);
  return isLeft2(e) ? [] : [e.right];
}, "liftEither");
var every2 = /* @__PURE__ */ dual(2, (self2, refinement) => self2.every(refinement));
var some4 = /* @__PURE__ */ dual(2, (self2, predicate) => self2.some(predicate));
var extend = /* @__PURE__ */ dual(2, (self2, f) => self2.map((_, i, as16) => f(as16.slice(i))));
var min2 = /* @__PURE__ */ dual(2, (self2, O) => self2.reduce(min(O)));
var max2 = /* @__PURE__ */ dual(2, (self2, O) => self2.reduce(max(O)));
var unfold = /* @__PURE__ */ __name((b, f) => {
  const out = [];
  let next4 = b;
  let o;
  while (isSome2(o = f(next4))) {
    const [a, b2] = o.value;
    out.push(a);
    next4 = b2;
  }
  return out;
}, "unfold");
var getOrder2 = array3;
var getEquivalence4 = array;
var forEach = /* @__PURE__ */ dual(2, (self2, f) => fromIterable2(self2).forEach((a, i) => f(a, i)));
var dedupeWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
  const input = fromIterable2(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = /* @__PURE__ */ __name((self2) => dedupeWith(self2, equivalence()), "dedupe");
var dedupeAdjacentWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
  const out = [];
  let lastA = none2();
  for (const a of self2) {
    if (isNone2(lastA) || !isEquivalent(a, lastA.value)) {
      out.push(a);
      lastA = some3(a);
    }
  }
  return out;
});
var dedupeAdjacent = /* @__PURE__ */ dedupeAdjacentWith(/* @__PURE__ */ equivalence());
var join = /* @__PURE__ */ dual(2, (self2, sep) => fromIterable2(self2).join(sep));
var mapAccum = /* @__PURE__ */ dual(3, (self2, s, f) => {
  let i = 0;
  let s1 = s;
  const out = [];
  for (const a of self2) {
    const r = f(s1, a, i);
    s1 = r[0];
    out.push(r[1]);
    i++;
  }
  return [s1, out];
});
var cartesianWith = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap3(self2, (a) => map5(that, (b) => f(a, b))));
var cartesian = /* @__PURE__ */ dual(2, (self2, that) => cartesianWith(self2, that, (a, b) => [a, b]));
var Do3 = /* @__PURE__ */ of({});
var bind4 = /* @__PURE__ */ bind(map5, flatMap3);
var bindTo4 = /* @__PURE__ */ bindTo(map5);
var let_4 = /* @__PURE__ */ let_(map5);

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Chunk.js
var Chunk_exports = {};
__export(Chunk_exports, {
  append: () => append2,
  appendAll: () => appendAll2,
  chunksOf: () => chunksOf2,
  compact: () => compact,
  contains: () => contains3,
  containsWith: () => containsWith3,
  dedupe: () => dedupe2,
  dedupeAdjacent: () => dedupeAdjacent2,
  difference: () => difference2,
  differenceWith: () => differenceWith2,
  drop: () => drop2,
  dropRight: () => dropRight2,
  dropWhile: () => dropWhile2,
  empty: () => empty4,
  every: () => every3,
  filter: () => filter4,
  filterMap: () => filterMap3,
  filterMapWhile: () => filterMapWhile2,
  findFirst: () => findFirst3,
  findFirstIndex: () => findFirstIndex2,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex2,
  flatMap: () => flatMap4,
  flatten: () => flatten3,
  forEach: () => forEach2,
  fromIterable: () => fromIterable3,
  get: () => get3,
  getEquivalence: () => getEquivalence5,
  head: () => head3,
  headNonEmpty: () => headNonEmpty2,
  intersection: () => intersection2,
  isChunk: () => isChunk,
  isEmpty: () => isEmpty,
  isNonEmpty: () => isNonEmpty,
  join: () => join2,
  last: () => last2,
  lastNonEmpty: () => lastNonEmpty2,
  make: () => make5,
  makeBy: () => makeBy2,
  map: () => map6,
  mapAccum: () => mapAccum2,
  modify: () => modify2,
  modifyOption: () => modifyOption2,
  of: () => of2,
  partition: () => partition2,
  partitionMap: () => partitionMap3,
  prepend: () => prepend2,
  prependAll: () => prependAll2,
  range: () => range2,
  reduce: () => reduce2,
  reduceRight: () => reduceRight2,
  remove: () => remove2,
  removeOption: () => removeOption2,
  replace: () => replace2,
  replaceOption: () => replaceOption2,
  reverse: () => reverse2,
  separate: () => separate2,
  size: () => size,
  some: () => some5,
  sort: () => sort2,
  sortWith: () => sortWith2,
  split: () => split2,
  splitAt: () => splitAt2,
  splitNonEmptyAt: () => splitNonEmptyAt2,
  splitWhere: () => splitWhere2,
  tail: () => tail2,
  tailNonEmpty: () => tailNonEmpty2,
  take: () => take2,
  takeRight: () => takeRight2,
  takeWhile: () => takeWhile2,
  toArray: () => toArray2,
  toReadonlyArray: () => toReadonlyArray,
  union: () => union2,
  unsafeFromArray: () => unsafeFromArray,
  unsafeFromNonEmptyArray: () => unsafeFromNonEmptyArray,
  unsafeGet: () => unsafeGet2,
  unsafeHead: () => unsafeHead2,
  unsafeLast: () => unsafeLast,
  unzip: () => unzip2,
  zip: () => zip2,
  zipWith: () => zipWith4
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Chunk");
function copy2(src3, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src3.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src3[i];
  }
  return dest;
}
__name(copy2, "copy");
var emptyArray = [];
var getEquivalence5 = /* @__PURE__ */ __name((isEquivalent) => make((self2, that) => self2.length === that.length && toReadonlyArray(self2).every((value6, i) => isEquivalent(value6, unsafeGet2(that, i)))), "getEquivalence");
var _equivalence3 = /* @__PURE__ */ getEquivalence5(equals);
var ChunkProto = {
  [TypeId5]: {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = /* @__PURE__ */ __name((backing) => {
  const chunk4 = Object.create(ChunkProto);
  chunk4.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk4.length = 0;
      chunk4.depth = 0;
      chunk4.left = chunk4;
      chunk4.right = chunk4;
      break;
    }
    case "IConcat": {
      chunk4.length = backing.left.length + backing.right.length;
      chunk4.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk4.left = backing.left;
      chunk4.right = backing.right;
      break;
    }
    case "IArray": {
      chunk4.length = backing.array.length;
      chunk4.depth = 0;
      chunk4.left = _empty;
      chunk4.right = _empty;
      break;
    }
    case "ISingleton": {
      chunk4.length = 1;
      chunk4.depth = 0;
      chunk4.left = _empty;
      chunk4.right = _empty;
      break;
    }
    case "ISlice": {
      chunk4.length = backing.length;
      chunk4.depth = backing.chunk.depth + 1;
      chunk4.left = _empty;
      chunk4.right = _empty;
      break;
    }
  }
  return chunk4;
}, "makeChunk");
var isChunk = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId5), "isChunk");
var _empty = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty4 = /* @__PURE__ */ __name(() => _empty, "empty");
var make5 = /* @__PURE__ */ __name((...as16) => unsafeFromNonEmptyArray(as16), "make");
var of2 = /* @__PURE__ */ __name((a) => makeChunk({
  _tag: "ISingleton",
  a
}), "of");
var fromIterable3 = /* @__PURE__ */ __name((self2) => isChunk(self2) ? self2 : unsafeFromArray(fromIterable2(self2)), "fromIterable");
var copyToArray = /* @__PURE__ */ __name((self2, array7, initial) => {
  switch (self2.backing._tag) {
    case "IArray": {
      copy2(self2.backing.array, 0, array7, initial, self2.length);
      break;
    }
    case "IConcat": {
      copyToArray(self2.left, array7, initial);
      copyToArray(self2.right, array7, initial + self2.left.length);
      break;
    }
    case "ISingleton": {
      array7[initial] = self2.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self2.length) {
        array7[j] = unsafeGet2(self2, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
}, "copyToArray");
var toArray_ = /* @__PURE__ */ __name((self2) => toReadonlyArray(self2).slice(), "toArray_");
var toArray2 = toArray_;
var toReadonlyArray_ = /* @__PURE__ */ __name((self2) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self2.backing.array;
    }
    default: {
      const arr = new Array(self2.length);
      copyToArray(self2, arr, 0);
      self2.backing = {
        _tag: "IArray",
        array: arr
      };
      self2.left = _empty;
      self2.right = _empty;
      self2.depth = 0;
      return arr;
    }
  }
}, "toReadonlyArray_");
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = /* @__PURE__ */ __name((self2) => {
  switch (self2.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self2;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self2.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self2.backing.right),
        right: reverse2(self2.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self2)));
  }
}, "reverseChunk");
var reverse2 = reverseChunk;
var get3 = /* @__PURE__ */ dual(2, (self2, index2) => index2 < 0 || index2 >= self2.length ? none2() : some3(unsafeGet2(self2, index2)));
var unsafeFromArray = /* @__PURE__ */ __name((self2) => self2.length === 0 ? empty4() : self2.length === 1 ? of2(self2[0]) : makeChunk({
  _tag: "IArray",
  array: self2
}), "unsafeFromArray");
var unsafeFromNonEmptyArray = /* @__PURE__ */ __name((self2) => unsafeFromArray(self2), "unsafeFromNonEmptyArray");
var unsafeGet2 = /* @__PURE__ */ dual(2, (self2, index2) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index2 !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.a;
    }
    case "IArray": {
      if (index2 >= self2.length || index2 < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.array[index2];
    }
    case "IConcat": {
      return index2 < self2.left.length ? unsafeGet2(self2.left, index2) : unsafeGet2(self2.right, index2 - self2.left.length);
    }
    case "ISlice": {
      return unsafeGet2(self2.backing.chunk, index2 + self2.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self2, a) => appendAll2(self2, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self2, elem) => appendAll2(of2(elem), self2));
var take2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return _empty;
  } else if (n >= self2.length) {
    return self2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          length: n,
          offset: self2.backing.offset
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: take2(self2.right, n - self2.left.length)
          });
        }
        return take2(self2.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return self2;
  } else if (n >= self2.length) {
    return _empty;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          offset: self2.backing.offset + n,
          length: self2.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return drop2(self2.right, n - self2.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self2.left, n),
          right: self2.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: n,
          length: self2.length - n
        });
      }
    }
  }
});
var dropRight2 = /* @__PURE__ */ dual(2, (self2, n) => take2(self2, Math.max(0, self2.length - n)));
var dropWhile2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const arr = toReadonlyArray(self2);
  const len = arr.length;
  let i = 0;
  while (i < len && predicate(arr[i])) {
    i++;
  }
  return drop2(self2, i);
});
var prependAll2 = /* @__PURE__ */ dual(2, (self2, that) => appendAll2(that, self2));
var appendAll2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self2;
  }
  const diff9 = that.depth - self2.depth;
  if (Math.abs(diff9) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self2,
      right: that
    });
  } else if (diff9 < -1) {
    if (self2.left.depth >= self2.right.depth) {
      const nr = appendAll2(self2.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self2.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self2.right.right, that);
      if (nrr.depth === self2.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self2.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: self2.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self2, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self2, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var filterMap3 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMap2(self2, f)));
var filter4 = /* @__PURE__ */ dual(2, (self2, predicate) => unsafeFromArray(filter3(self2, predicate)));
var filterMapWhile2 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMapWhile(self2, f)));
var compact = /* @__PURE__ */ __name((self2) => filterMap3(self2, identity), "compact");
var flatMap4 = /* @__PURE__ */ dual(2, (self2, f) => {
  if (self2.backing._tag === "ISingleton") {
    return f(self2.backing.a, 0);
  }
  let out = _empty;
  let i = 0;
  for (const k of self2) {
    out = appendAll2(out, f(k, i++));
  }
  return out;
});
var forEach2 = /* @__PURE__ */ dual(2, (self2, f) => toReadonlyArray(self2).forEach(f));
var flatten3 = /* @__PURE__ */ flatMap4(identity);
var chunksOf2 = /* @__PURE__ */ dual(2, (self2, n) => {
  const gr = [];
  let current2 = [];
  toReadonlyArray(self2).forEach((a) => {
    current2.push(a);
    if (current2.length >= n) {
      gr.push(unsafeFromArray(current2));
      current2 = [];
    }
  });
  if (current2.length > 0) {
    gr.push(unsafeFromArray(current2));
  }
  return unsafeFromArray(gr);
});
var intersection2 = /* @__PURE__ */ dual(2, (self2, that) => unsafeFromArray(intersection(toReadonlyArray(self2), toReadonlyArray(that))));
var isEmpty = /* @__PURE__ */ __name((self2) => self2.length === 0, "isEmpty");
var isNonEmpty = /* @__PURE__ */ __name((self2) => self2.length > 0, "isNonEmpty");
var head3 = /* @__PURE__ */ get3(0);
var unsafeHead2 = /* @__PURE__ */ __name((self2) => unsafeGet2(self2, 0), "unsafeHead");
var headNonEmpty2 = unsafeHead2;
var last2 = /* @__PURE__ */ __name((self2) => get3(self2, self2.length - 1), "last");
var unsafeLast = /* @__PURE__ */ __name((self2) => unsafeGet2(self2, self2.length - 1), "unsafeLast");
var lastNonEmpty2 = unsafeLast;
var map6 = /* @__PURE__ */ dual(2, (self2, f) => self2.backing._tag === "ISingleton" ? of2(f(self2.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self2), map5((a, i) => f(a, i)))));
var mapAccum2 = /* @__PURE__ */ dual(3, (self2, s, f) => {
  const [s1, as16] = mapAccum(self2, s, f);
  return [s1, unsafeFromArray(as16)];
});
var partition2 = /* @__PURE__ */ dual(2, (self2, predicate) => pipe(partition(toReadonlyArray(self2), predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var partitionMap3 = /* @__PURE__ */ dual(2, (self2, f) => pipe(partitionMap2(toReadonlyArray(self2), f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));
var separate2 = /* @__PURE__ */ __name((self2) => pipe(separate(toReadonlyArray(self2)), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]), "separate");
var size = /* @__PURE__ */ __name((self2) => self2.length, "size");
var sort2 = /* @__PURE__ */ dual(2, (self2, O) => unsafeFromArray(sort(toReadonlyArray(self2), O)));
var sortWith2 = /* @__PURE__ */ dual(3, (self2, f, order) => sort2(self2, mapInput3(order, f)));
var splitAt2 = /* @__PURE__ */ dual(2, (self2, n) => [take2(self2, n), drop2(self2, n)]);
var splitNonEmptyAt2 = /* @__PURE__ */ dual(2, (self2, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self2.length ? [self2, empty4()] : [take2(self2, _n), drop2(self2, _n)];
});
var split2 = /* @__PURE__ */ dual(2, (self2, n) => chunksOf2(self2, Math.ceil(self2.length / Math.floor(n))));
var splitWhere2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  let i = 0;
  for (const a of toReadonlyArray(self2)) {
    if (predicate(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt2(self2, i);
});
var tail2 = /* @__PURE__ */ __name((self2) => self2.length > 0 ? some3(drop2(self2, 1)) : none2(), "tail");
var tailNonEmpty2 = /* @__PURE__ */ __name((self2) => drop2(self2, 1), "tailNonEmpty");
var takeRight2 = /* @__PURE__ */ dual(2, (self2, n) => drop2(self2, self2.length - n));
var takeWhile2 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const out = [];
  for (const a of toReadonlyArray(self2)) {
    if (predicate(a)) {
      out.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(out);
});
var union2 = /* @__PURE__ */ dual(2, (self2, that) => unsafeFromArray(union(toReadonlyArray(self2), toReadonlyArray(that))));
var dedupe2 = /* @__PURE__ */ __name((self2) => unsafeFromArray(dedupe(toReadonlyArray(self2))), "dedupe");
var dedupeAdjacent2 = /* @__PURE__ */ __name((self2) => unsafeFromArray(dedupeAdjacent(self2)), "dedupeAdjacent");
var unzip2 = /* @__PURE__ */ __name((self2) => {
  const [left3, right3] = unzip(self2);
  return [unsafeFromArray(left3), unsafeFromArray(right3)];
}, "unzip");
var zipWith4 = /* @__PURE__ */ dual(3, (self2, that, f) => unsafeFromArray(zipWith3(self2, that, f)));
var zip2 = /* @__PURE__ */ dual(2, (self2, that) => zipWith4(self2, that, (a, b) => [a, b]));
var remove2 = /* @__PURE__ */ dual(2, (self2, i) => {
  if (i < 0 || i >= self2.length) return self2;
  return unsafeFromArray(remove(toReadonlyArray(self2), i));
});
var removeOption2 = /* @__PURE__ */ dual(2, (self2, i) => {
  if (i < 0 || i >= self2.length) return none2();
  return some3(unsafeFromArray(remove(toReadonlyArray(self2), i)));
});
var modifyOption2 = /* @__PURE__ */ dual(3, (self2, i, f) => {
  if (i < 0 || i >= self2.length) return none2();
  return some3(unsafeFromArray(modify(toReadonlyArray(self2), i, f)));
});
var modify2 = /* @__PURE__ */ dual(3, (self2, i, f) => getOrElse2(modifyOption2(self2, i, f), () => self2));
var replace2 = /* @__PURE__ */ dual(3, (self2, i, b) => modify2(self2, i, () => b));
var replaceOption2 = /* @__PURE__ */ dual(3, (self2, i, b) => modifyOption2(self2, i, () => b));
var makeBy2 = /* @__PURE__ */ dual(2, (n, f) => fromIterable3(makeBy(n, f)));
var range2 = /* @__PURE__ */ __name((start3, end6) => start3 <= end6 ? makeBy2(end6 - start3 + 1, (i) => start3 + i) : of2(start3), "range");
var contains3 = contains2;
var containsWith3 = containsWith2;
var findFirst3 = findFirst2;
var findFirstIndex2 = findFirstIndex;
var findLast2 = findLast;
var findLastIndex2 = findLastIndex;
var every3 = /* @__PURE__ */ dual(2, (self2, refinement) => fromIterable2(self2).every(refinement));
var some5 = /* @__PURE__ */ dual(2, (self2, predicate) => fromIterable2(self2).some(predicate));
var join2 = join;
var reduce2 = reduce;
var reduceRight2 = reduceRight;
var differenceWith2 = /* @__PURE__ */ __name((isEquivalent) => {
  return dual(2, (self2, that) => unsafeFromArray(differenceWith(isEquivalent)(that, self2)));
}, "differenceWith");
var difference2 = /* @__PURE__ */ dual(2, (self2, that) => unsafeFromArray(difference(that, self2)));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/HashSet.js
var HashSet_exports = {};
__export(HashSet_exports, {
  add: () => add2,
  beginMutation: () => beginMutation3,
  difference: () => difference4,
  empty: () => empty7,
  endMutation: () => endMutation3,
  every: () => every6,
  filter: () => filter7,
  flatMap: () => flatMap7,
  forEach: () => forEach5,
  fromIterable: () => fromIterable6,
  has: () => has4,
  intersection: () => intersection4,
  isHashSet: () => isHashSet2,
  isSubset: () => isSubset2,
  make: () => make9,
  map: () => map9,
  mutate: () => mutate3,
  partition: () => partition4,
  reduce: () => reduce5,
  remove: () => remove5,
  size: () => size4,
  some: () => some8,
  toValues: () => toValues,
  toggle: () => toggle2,
  union: () => union5,
  values: () => values3
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashSet.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/config.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
__name(popcount, "popcount");
function hashFragment(shift2, h) {
  return h >>> shift2 & MASK;
}
__name(hashFragment, "hashFragment");
function toBitmap(x) {
  return 1 << x;
}
__name(toBitmap, "toBitmap");
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}
__name(fromBitmap, "fromBitmap");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/node.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stack.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var make6 = /* @__PURE__ */ __name((value6, previous2) => ({
  value: value6,
  previous: previous2
}), "make");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function arrayUpdate(mutate6, at, v, arr) {
  let out = arr;
  if (!mutate6) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0; i < len; ++i) out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
__name(arrayUpdate, "arrayUpdate");
function arraySpliceOut(mutate6, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate6) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at) out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen) out[g++] = arr[i++];
  if (mutate6) {
    out.length = newLen;
  }
  return out;
}
__name(arraySpliceOut, "arraySpliceOut");
function arraySpliceIn(mutate6, at, v, arr) {
  const len = arr.length;
  if (mutate6) {
    let i2 = len;
    while (i2 >= at) arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at) out[g++] = arr[i++];
  out[at] = v;
  while (i < len) out[++g] = arr[i++];
  return out;
}
__name(arraySpliceIn, "arraySpliceIn");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/node.js
var EmptyNode = class _EmptyNode {
  static {
    __name(this, "EmptyNode");
  }
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash5, key, size22) {
    const v = f(none2());
    if (isNone2(v)) return new _EmptyNode();
    ++size22.value;
    return new LeafNode(edit, hash5, key, v);
  }
};
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
__name(isEmptyNode, "isEmptyNode");
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
__name(isLeafNode, "isLeafNode");
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
__name(canEditNode, "canEditNode");
var LeafNode = class _LeafNode {
  static {
    __name(this, "LeafNode");
  }
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash5, key, value6) {
    this.edit = edit;
    this.hash = hash5;
    this.key = key;
    this.value = value6;
  }
  modify(edit, shift2, f, hash5, key, size22) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value) return this;
      else if (isNone2(v2)) {
        --size22.value;
        return new EmptyNode();
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new _LeafNode(edit, hash5, key, v2);
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size22.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash5, new _LeafNode(edit, hash5, key, v));
  }
};
var CollisionNode = class _CollisionNode {
  static {
    __name(this, "CollisionNode");
  }
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash5, children3) {
    this.edit = edit;
    this.hash = hash5;
    this.children = children3;
  }
  modify(edit, shift2, f, hash5, key, size22) {
    if (hash5 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size22);
      if (list === this.children) return this;
      return list.length > 1 ? new _CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v)) return this;
    ++size22.value;
    return mergeLeaves(edit, shift2, this.hash, this, hash5, new LeafNode(edit, hash5, key, v));
  }
  updateCollisionList(mutate6, edit, hash5, list, f, key, size22) {
    const len = list.length;
    for (let i = 0; i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value6 = child.value;
        const newValue2 = f(value6);
        if (newValue2 === value6) return list;
        if (isNone2(newValue2)) {
          --size22.value;
          return arraySpliceOut(mutate6, i, list);
        }
        return arrayUpdate(mutate6, i, new LeafNode(edit, hash5, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue)) return list;
    ++size22.value;
    return arrayUpdate(mutate6, len, new LeafNode(edit, hash5, key, newValue), list);
  }
};
var IndexedNode = class _IndexedNode {
  static {
    __name(this, "IndexedNode");
  }
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children3) {
    this.edit = edit;
    this.mask = mask;
    this.children = children3;
  }
  modify(edit, shift2, f, hash5, key, size22) {
    const mask = this.mask;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash5);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists7 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists7) {
      const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f, hash5, key, size22);
      if (!_newChild) return this;
      return children3.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children3) : new _IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children3));
    }
    const current2 = children3[indx];
    const child = current2.modify(edit, shift2 + SIZE, f, hash5, key, size22);
    if (current2 === child) return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return new EmptyNode();
      if (children3.length <= 2 && isLeafNode(children3[indx ^ 1])) {
        return children3[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children3);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children3);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new _IndexedNode(edit, bitmap, newChildren);
  }
};
var ArrayNode = class _ArrayNode {
  static {
    __name(this, "ArrayNode");
  }
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size22, children3) {
    this.edit = edit;
    this.size = size22;
    this.children = children3;
  }
  modify(edit, shift2, f, hash5, key, size22) {
    let count7 = this.size;
    const children3 = this.children;
    const frag = hashFragment(shift2, hash5);
    const child = children3[frag];
    const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f, hash5, key, size22);
    if (child === newChild) return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count7;
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count7;
      if (count7 <= MIN_ARRAY_NODE) {
        return pack(edit, count7, frag, children3);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children3);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children3);
    }
    if (canEdit) {
      this.size = count7;
      this.children = newChildren;
      return this;
    }
    return new _ArrayNode(edit, count7, newChildren);
  }
};
function pack(edit, count7, removed, elements) {
  const children3 = new Array(count7 - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length; i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children3[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children3);
}
__name(pack, "pack");
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count7 = 0;
  for (let i = 0; bit; ++i) {
    if (bit & 1) arr[i] = subNodes[count7++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count7 + 1, arr);
}
__name(expand, "expand");
function mergeLeavesInner(edit, shift2, h1, n1, h2, n2) {
  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift2, h1);
  const subH2 = hashFragment(shift2, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children3 = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children3);
  }
}
__name(mergeLeavesInner, "mergeLeavesInner");
function mergeLeaves(edit, shift2, h1, n1, h2, n2) {
  let stack = void 0;
  let currentShift = shift2;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make6(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}
__name(mergeLeaves, "mergeLeaves");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash5 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash5 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash5);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = /* @__PURE__ */ __name((editable, edit, root, size22) => {
  const map38 = Object.create(HashMapProto);
  map38._editable = editable;
  map38._edit = edit;
  map38._root = root;
  map38._size = size22;
  return map38;
}, "makeImpl");
var HashMapIterator = class _HashMapIterator {
  static {
    __name(this, "HashMapIterator");
  }
  map;
  f;
  v;
  constructor(map38, f) {
    this.map = map38;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, void 0);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: void 0
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new _HashMapIterator(this.map, this.f);
  }
};
var applyCont = /* @__PURE__ */ __name((cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2(), "applyCont");
var visitLazy = /* @__PURE__ */ __name((node, f, cont = void 0) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some3({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children3 = node.children;
      return visitLazyChildren(children3.length, children3, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
}, "visitLazy");
var visitLazyChildren = /* @__PURE__ */ __name((len, children3, i, f, cont) => {
  while (i < len) {
    const child = children3[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children3, i, f, cont]);
    }
  }
  return applyCont(cont);
}, "visitLazyChildren");
var _empty2 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
var empty5 = /* @__PURE__ */ __name(() => _empty2, "empty");
var make7 = /* @__PURE__ */ __name((...entries3) => fromIterable4(entries3), "make");
var fromIterable4 = /* @__PURE__ */ __name((entries3) => {
  const map38 = beginMutation(empty5());
  for (const entry of entries3) {
    set(map38, entry[0], entry[1]);
  }
  return endMutation(map38);
}, "fromIterable");
var isHashMap = /* @__PURE__ */ __name((u) => hasProperty(u, HashMapTypeId), "isHashMap");
var isEmpty2 = /* @__PURE__ */ __name((self2) => self2 && isEmptyNode(self2._root), "isEmpty");
var get4 = /* @__PURE__ */ dual(2, (self2, key) => getHash(self2, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self2, key, hash5) => {
  let node = self2._root;
  let shift2 = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash5 === node.hash) {
          const children3 = node.children;
          for (let i = 0, len = children3.length; i < len; ++i) {
            const child = children3[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift2, hash5);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift2, hash5)];
        if (node) {
          shift2 += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var unsafeGet3 = /* @__PURE__ */ dual(2, (self2, key) => {
  const element2 = getHash(self2, key, hash(key));
  if (isNone2(element2)) {
    throw new Error("Expected map to contain key");
  }
  return element2.value;
});
var has2 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(getHash(self2, key, hash(key))));
var hasHash = /* @__PURE__ */ dual(3, (self2, key, hash5) => isSome2(getHash(self2, key, hash5)));
var hasBy = /* @__PURE__ */ dual(2, (self2, predicate) => isSome2(findFirst4(self2, predicate)));
var set = /* @__PURE__ */ dual(3, (self2, key, value6) => modifyAt(self2, key, () => some3(value6)));
var setTree = /* @__PURE__ */ dual(3, (self2, newRoot, newSize) => {
  if (self2._editable) {
    ;
    self2._root = newRoot;
    self2._size = newSize;
    return self2;
  }
  return newRoot === self2._root ? self2 : makeImpl(self2._editable, self2._edit, newRoot, newSize);
});
var keys2 = /* @__PURE__ */ __name((self2) => new HashMapIterator(self2, (key) => key), "keys");
var values = /* @__PURE__ */ __name((self2) => new HashMapIterator(self2, (_, value6) => value6), "values");
var entries = /* @__PURE__ */ __name((self2) => new HashMapIterator(self2, (key, value6) => [key, value6]), "entries");
var size2 = /* @__PURE__ */ __name((self2) => self2._size, "size");
var countBy2 = /* @__PURE__ */ dual(2, (self2, f) => {
  let count7 = 0;
  for (const [k, a] of self2) {
    if (f(a, k)) {
      count7++;
    }
  }
  return count7;
});
var beginMutation = /* @__PURE__ */ __name((self2) => makeImpl(true, self2._edit + 1, self2._root, self2._size), "beginMutation");
var endMutation = /* @__PURE__ */ __name((self2) => {
  ;
  self2._editable = false;
  return self2;
}, "endMutation");
var mutate = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation(self2);
  f(transient);
  return endMutation(transient);
});
var modifyAt = /* @__PURE__ */ dual(3, (self2, key, f) => modifyHash(self2, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self2, key, hash5, f) => {
  const size22 = {
    value: self2._size
  };
  const newRoot = self2._root.modify(self2._editable ? self2._edit : NaN, 0, f, hash5, key, size22);
  return pipe(self2, setTree(newRoot, size22.value));
});
var modify3 = /* @__PURE__ */ dual(3, (self2, key, f) => modifyAt(self2, key, map2(f)));
var union3 = /* @__PURE__ */ dual(2, (self2, that) => {
  const result = beginMutation(self2);
  forEach3(that, (v, k) => set(result, k, v));
  return endMutation(result);
});
var remove3 = /* @__PURE__ */ dual(2, (self2, key) => modifyAt(self2, key, none2));
var removeMany = /* @__PURE__ */ dual(2, (self2, keys6) => mutate(self2, (map38) => {
  for (const key of keys6) {
    remove3(key)(map38);
  }
}));
var map7 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, empty5(), (map38, value6, key) => set(map38, key, f(value6, key))));
var flatMap5 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, empty5(), (zero3, value6, key) => mutate(zero3, (map38) => forEach3(f(value6, key), (value7, key2) => set(map38, key2, value7)))));
var forEach3 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, void 0, (_, value6, key) => f(value6, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self2, zero3, f) => {
  const root = self2._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children3;
  while (children3 = toVisit.pop()) {
    for (let i = 0, len = children3.length; i < len; ) {
      const child = children3[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero3 = f(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});
var filter5 = /* @__PURE__ */ dual(2, (self2, f) => mutate(empty5(), (map38) => {
  for (const [k, a] of self2) {
    if (f(a, k)) {
      set(map38, k, a);
    }
  }
}));
var compact2 = /* @__PURE__ */ __name((self2) => filterMap4(self2, identity), "compact");
var filterMap4 = /* @__PURE__ */ dual(2, (self2, f) => mutate(empty5(), (map38) => {
  for (const [k, a] of self2) {
    const option9 = f(a, k);
    if (isSome2(option9)) {
      set(map38, k, option9.value);
    }
  }
}));
var findFirst4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  for (const ka of self2) {
    if (predicate(ka[1], ka[0])) {
      return some3(ka);
    }
  }
  return none2();
});
var some6 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  for (const ka of self2) {
    if (predicate(ka[1], ka[0])) {
      return true;
    }
  }
  return false;
});
var every4 = /* @__PURE__ */ dual(2, (self2, predicate) => !some6(self2, (a, k) => !predicate(a, k)));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys2(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size2(this._keyMap) === size2(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = /* @__PURE__ */ __name((keyMap) => {
  const set20 = Object.create(HashSetProto);
  set20._keyMap = keyMap;
  return set20;
}, "makeImpl");
var isHashSet = /* @__PURE__ */ __name((u) => hasProperty(u, HashSetTypeId), "isHashSet");
var _empty3 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty5());
var empty6 = /* @__PURE__ */ __name(() => _empty3, "empty");
var fromIterable5 = /* @__PURE__ */ __name((elements) => {
  const set20 = beginMutation2(empty6());
  for (const value6 of elements) {
    add(set20, value6);
  }
  return endMutation2(set20);
}, "fromIterable");
var make8 = /* @__PURE__ */ __name((...elements) => {
  const set20 = beginMutation2(empty6());
  for (const value6 of elements) {
    add(set20, value6);
  }
  return endMutation2(set20);
}, "make");
var has3 = /* @__PURE__ */ dual(2, (self2, value6) => has2(self2._keyMap, value6));
var some7 = /* @__PURE__ */ dual(2, (self2, f) => {
  let found = false;
  for (const value6 of self2) {
    found = f(value6);
    if (found) {
      break;
    }
  }
  return found;
});
var every5 = /* @__PURE__ */ dual(2, (self2, refinement) => !some7(self2, (a) => !refinement(a)));
var isSubset = /* @__PURE__ */ dual(2, (self2, that) => every5(self2, (value6) => has3(that, value6)));
var values2 = /* @__PURE__ */ __name((self2) => keys2(self2._keyMap), "values");
var size3 = /* @__PURE__ */ __name((self2) => size2(self2._keyMap), "size");
var beginMutation2 = /* @__PURE__ */ __name((self2) => makeImpl2(beginMutation(self2._keyMap)), "beginMutation");
var endMutation2 = /* @__PURE__ */ __name((self2) => {
  ;
  self2._keyMap._editable = false;
  return self2;
}, "endMutation");
var mutate2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation2(self2);
  f(transient);
  return endMutation2(transient);
});
var add = /* @__PURE__ */ dual(2, (self2, value6) => self2._keyMap._editable ? (set(value6, true)(self2._keyMap), self2) : makeImpl2(set(value6, true)(self2._keyMap)));
var remove4 = /* @__PURE__ */ dual(2, (self2, value6) => self2._keyMap._editable ? (remove3(value6)(self2._keyMap), self2) : makeImpl2(remove3(value6)(self2._keyMap)));
var difference3 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(self2, (set20) => {
  for (const value6 of that) {
    remove4(set20, value6);
  }
}));
var intersection3 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty6(), (set20) => {
  for (const value6 of that) {
    if (has3(value6)(self2)) {
      add(value6)(set20);
    }
  }
}));
var union4 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty6(), (set20) => {
  forEach4(self2, (value6) => add(set20, value6));
  for (const value6 of that) {
    add(set20, value6);
  }
}));
var toggle = /* @__PURE__ */ dual(2, (self2, value6) => has3(self2, value6) ? remove4(self2, value6) : add(self2, value6));
var map8 = /* @__PURE__ */ dual(2, (self2, f) => mutate2(empty6(), (set20) => {
  forEach4(self2, (a) => {
    const b = f(a);
    if (!has3(set20, b)) {
      add(set20, b);
    }
  });
}));
var flatMap6 = /* @__PURE__ */ dual(2, (self2, f) => mutate2(empty6(), (set20) => {
  forEach4(self2, (a) => {
    for (const b of f(a)) {
      if (!has3(set20, b)) {
        add(set20, b);
      }
    }
  });
}));
var forEach4 = /* @__PURE__ */ dual(2, (self2, f) => forEach3(self2._keyMap, (_, k) => f(k)));
var reduce4 = /* @__PURE__ */ dual(3, (self2, zero3, f) => reduce3(self2._keyMap, zero3, (z, _, a) => f(z, a)));
var filter6 = /* @__PURE__ */ dual(2, (self2, f) => {
  return mutate2(empty6(), (set20) => {
    const iterator = values2(self2);
    let next4;
    while (!(next4 = iterator.next()).done) {
      const value6 = next4.value;
      if (f(value6)) {
        add(set20, value6);
      }
    }
  });
});
var partition3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const iterator = values2(self2);
  let next4;
  const right3 = beginMutation2(empty6());
  const left3 = beginMutation2(empty6());
  while (!(next4 = iterator.next()).done) {
    const value6 = next4.value;
    if (predicate(value6)) {
      add(right3, value6);
    } else {
      add(left3, value6);
    }
  }
  return [endMutation2(left3), endMutation2(right3)];
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/HashSet.js
var isHashSet2 = isHashSet;
var empty7 = empty6;
var fromIterable6 = fromIterable5;
var make9 = make8;
var has4 = has3;
var some8 = some7;
var every6 = every5;
var isSubset2 = isSubset;
var values3 = values2;
var toValues = /* @__PURE__ */ __name((self2) => Array.from(values3(self2)), "toValues");
var size4 = size3;
var beginMutation3 = beginMutation2;
var endMutation3 = endMutation2;
var mutate3 = mutate2;
var add2 = add;
var remove5 = remove4;
var difference4 = difference3;
var intersection4 = intersection3;
var union5 = union4;
var toggle2 = toggle;
var map9 = map8;
var flatMap7 = flatMap6;
var forEach5 = forEach4;
var reduce5 = reduce4;
var filter7 = filter6;
var partition4 = partition3;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/cause.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E")
};
var proto = {
  [CauseTypeId]: variance,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty8 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = /* @__PURE__ */ __name((error5) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error5;
  return o;
}, "fail");
var die = /* @__PURE__ */ __name((defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
}, "die");
var interrupt = /* @__PURE__ */ __name((fiberId5) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId5;
  return o;
}, "interrupt");
var parallel = /* @__PURE__ */ __name((left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
}, "parallel");
var sequential = /* @__PURE__ */ __name((left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
}, "sequential");
var isCause = /* @__PURE__ */ __name((u) => hasProperty(u, CauseTypeId), "isCause");
var isEmptyType = /* @__PURE__ */ __name((self2) => self2._tag === OP_EMPTY, "isEmptyType");
var isFailType = /* @__PURE__ */ __name((self2) => self2._tag === OP_FAIL, "isFailType");
var isDieType = /* @__PURE__ */ __name((self2) => self2._tag === OP_DIE, "isDieType");
var isInterruptType = /* @__PURE__ */ __name((self2) => self2._tag === OP_INTERRUPT, "isInterruptType");
var isSequentialType = /* @__PURE__ */ __name((self2) => self2._tag === OP_SEQUENTIAL, "isSequentialType");
var isParallelType = /* @__PURE__ */ __name((self2) => self2._tag === OP_PARALLEL, "isParallelType");
var size5 = /* @__PURE__ */ __name((self2) => reduceWithContext(self2, void 0, SizeCauseReducer), "size");
var isEmpty3 = /* @__PURE__ */ __name((self2) => {
  if (self2._tag === OP_EMPTY) {
    return true;
  }
  return reduce6(self2, true, (acc, cause3) => {
    switch (cause3._tag) {
      case OP_EMPTY: {
        return some3(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some3(false);
      }
      default: {
        return none2();
      }
    }
  });
}, "isEmpty");
var isFailure = /* @__PURE__ */ __name((self2) => isSome2(failureOption(self2)), "isFailure");
var isDie = /* @__PURE__ */ __name((self2) => isSome2(dieOption(self2)), "isDie");
var isInterrupted = /* @__PURE__ */ __name((self2) => isSome2(interruptOption(self2)), "isInterrupted");
var isInterruptedOnly = /* @__PURE__ */ __name((self2) => reduceWithContext(void 0, IsInterruptedOnlyCauseReducer)(self2), "isInterruptedOnly");
var failures = /* @__PURE__ */ __name((self2) => reverse2(reduce6(self2, empty4(), (list, cause3) => cause3._tag === OP_FAIL ? some3(pipe(list, prepend2(cause3.error))) : none2())), "failures");
var defects = /* @__PURE__ */ __name((self2) => reverse2(reduce6(self2, empty4(), (list, cause3) => cause3._tag === OP_DIE ? some3(pipe(list, prepend2(cause3.defect))) : none2())), "defects");
var interruptors = /* @__PURE__ */ __name((self2) => reduce6(self2, empty7(), (set20, cause3) => cause3._tag === OP_INTERRUPT ? some3(pipe(set20, add2(cause3.fiberId))) : none2()), "interruptors");
var failureOption = /* @__PURE__ */ __name((self2) => find(self2, (cause3) => cause3._tag === OP_FAIL ? some3(cause3.error) : none2()), "failureOption");
var failureOrCause = /* @__PURE__ */ __name((self2) => {
  const option9 = failureOption(self2);
  switch (option9._tag) {
    case "None": {
      return right2(self2);
    }
    case "Some": {
      return left2(option9.value);
    }
  }
}, "failureOrCause");
var dieOption = /* @__PURE__ */ __name((self2) => find(self2, (cause3) => cause3._tag === OP_DIE ? some3(cause3.defect) : none2()), "dieOption");
var flipCauseOption = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: some3(empty8),
  onFail: map2(fail),
  onDie: /* @__PURE__ */ __name((defect) => some3(die(defect)), "onDie"),
  onInterrupt: /* @__PURE__ */ __name((fiberId5) => some3(interrupt(fiberId5)), "onInterrupt"),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), "flipCauseOption");
var interruptOption = /* @__PURE__ */ __name((self2) => find(self2, (cause3) => cause3._tag === OP_INTERRUPT ? some3(cause3.fiberId) : none2()), "interruptOption");
var keepDefects = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: none2(),
  onFail: /* @__PURE__ */ __name(() => none2(), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => some3(die(defect)), "onDie"),
  onInterrupt: /* @__PURE__ */ __name(() => none2(), "onInterrupt"),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), "keepDefects");
var keepDefectsAndElectFailures = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: none2(),
  onFail: /* @__PURE__ */ __name((failure) => some3(die(failure)), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => some3(die(defect)), "onDie"),
  onInterrupt: /* @__PURE__ */ __name(() => none2(), "onInterrupt"),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}), "keepDefectsAndElectFailures");
var linearize = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: empty7(),
  onFail: /* @__PURE__ */ __name((error5) => make9(fail(error5)), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => make9(die(defect)), "onDie"),
  onInterrupt: /* @__PURE__ */ __name((fiberId5) => make9(interrupt(fiberId5)), "onInterrupt"),
  onSequential: /* @__PURE__ */ __name((leftSet, rightSet) => flatMap7(leftSet, (leftCause) => map9(rightSet, (rightCause) => sequential(leftCause, rightCause))), "onSequential"),
  onParallel: /* @__PURE__ */ __name((leftSet, rightSet) => flatMap7(leftSet, (leftCause) => map9(rightSet, (rightCause) => parallel(leftCause, rightCause))), "onParallel")
}), "linearize");
var stripFailures = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: empty8,
  onFail: /* @__PURE__ */ __name(() => empty8, "onFail"),
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
}), "stripFailures");
var electFailures = /* @__PURE__ */ __name((self2) => match4(self2, {
  onEmpty: empty8,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
}), "electFailures");
var stripSomeDefects = /* @__PURE__ */ dual(2, (self2, pf) => match4(self2, {
  onEmpty: some3(empty8),
  onFail: /* @__PURE__ */ __name((error5) => some3(fail(error5)), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => {
    const option9 = pf(defect);
    return isSome2(option9) ? none2() : some3(die(defect));
  }, "onDie"),
  onInterrupt: /* @__PURE__ */ __name((fiberId5) => some3(interrupt(fiberId5)), "onInterrupt"),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
}));
var as2 = /* @__PURE__ */ dual(2, (self2, error5) => map10(self2, () => error5));
var map10 = /* @__PURE__ */ dual(2, (self2, f) => flatMap8(self2, (e) => fail(f(e))));
var flatMap8 = /* @__PURE__ */ dual(2, (self2, f) => match4(self2, {
  onEmpty: empty8,
  onFail: /* @__PURE__ */ __name((error5) => f(error5), "onFail"),
  onDie: /* @__PURE__ */ __name((defect) => die(defect), "onDie"),
  onInterrupt: /* @__PURE__ */ __name((fiberId5) => interrupt(fiberId5), "onInterrupt"),
  onSequential: /* @__PURE__ */ __name((left3, right3) => sequential(left3, right3), "onSequential"),
  onParallel: /* @__PURE__ */ __name((left3, right3) => parallel(left3, right3), "onParallel")
}));
var flatten4 = /* @__PURE__ */ __name((self2) => flatMap8(self2, identity), "flatten");
var andThen3 = /* @__PURE__ */ dual(2, (self2, f) => isFunction2(f) ? flatMap8(self2, f) : flatMap8(self2, () => f));
var contains4 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (that._tag === OP_EMPTY || self2 === that) {
    return true;
  }
  return reduce6(self2, false, (accumulator, cause3) => {
    return some3(accumulator || causeEquals(cause3, that));
  });
});
var causeEquals = /* @__PURE__ */ __name((left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty(leftStack) && isNonEmpty(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce6([empty7(), empty4()], ([parallel5, sequential5], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some3([pipe(parallel5, union5(par2)), pipe(sequential5, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce6([empty7(), empty4()], ([parallel5, sequential5], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return some3([pipe(parallel5, union5(par2)), pipe(sequential5, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
}, "causeEquals");
var flattenCause = /* @__PURE__ */ __name((cause3) => {
  return flattenCauseLoop(of2(cause3), empty4());
}, "flattenCause");
var flattenCauseLoop = /* @__PURE__ */ __name((causes, flattened) => {
  while (1) {
    const [parallel5, sequential5] = pipe(causes, reduce([empty7(), empty4()], ([parallel6, sequential6], cause3) => {
      const [par2, seq2] = evaluateCause(cause3);
      return [pipe(parallel6, union5(par2)), pipe(sequential6, appendAll2(seq2))];
    }));
    const updated = size4(parallel5) > 0 ? pipe(flattened, prepend2(parallel5)) : flattened;
    if (isEmpty(sequential5)) {
      return reverse2(updated);
    }
    causes = sequential5;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
}, "flattenCauseLoop");
var find = /* @__PURE__ */ dual(2, (self2, pf) => {
  const stack = [self2];
  while (stack.length > 0) {
    const item = stack.pop();
    const option9 = pf(item);
    switch (option9._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option9;
      }
    }
  }
  return none2();
});
var filter8 = /* @__PURE__ */ dual(2, (self2, predicate) => reduceWithContext(self2, void 0, FilterCauseReducer(predicate)));
var evaluateCause = /* @__PURE__ */ __name((self2) => {
  let cause3 = self2;
  const stack = [];
  let _parallel = empty7();
  let _sequential = empty4();
  while (cause3 !== void 0) {
    switch (cause3._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add2(_parallel, make5(cause3._tag, cause3.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add2(_parallel, make5(cause3._tag, cause3.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add2(_parallel, make5(cause3._tag, cause3.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause3 = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause3.left._tag) {
          case OP_EMPTY: {
            cause3 = cause3.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause3 = sequential(cause3.left.left, sequential(cause3.left.right, cause3.right));
            break;
          }
          case OP_PARALLEL: {
            cause3 = parallel(sequential(cause3.left.left, cause3.right), sequential(cause3.left.right, cause3.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause3.right);
            cause3 = cause3.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
}, "evaluateCause");
var SizeCauseReducer = {
  emptyCase: /* @__PURE__ */ __name(() => 0, "emptyCase"),
  failCase: /* @__PURE__ */ __name(() => 1, "failCase"),
  dieCase: /* @__PURE__ */ __name(() => 1, "dieCase"),
  interruptCase: /* @__PURE__ */ __name(() => 1, "interruptCase"),
  sequentialCase: /* @__PURE__ */ __name((_, left3, right3) => left3 + right3, "sequentialCase"),
  parallelCase: /* @__PURE__ */ __name((_, left3, right3) => left3 + right3, "parallelCase")
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: /* @__PURE__ */ __name((_, left3, right3) => left3 && right3, "sequentialCase"),
  parallelCase: /* @__PURE__ */ __name((_, left3, right3) => left3 && right3, "parallelCase")
};
var FilterCauseReducer = /* @__PURE__ */ __name((predicate) => ({
  emptyCase: /* @__PURE__ */ __name(() => empty8, "emptyCase"),
  failCase: /* @__PURE__ */ __name((_, error5) => fail(error5), "failCase"),
  dieCase: /* @__PURE__ */ __name((_, defect) => die(defect), "dieCase"),
  interruptCase: /* @__PURE__ */ __name((_, fiberId5) => interrupt(fiberId5), "interruptCase"),
  sequentialCase: /* @__PURE__ */ __name((_, left3, right3) => {
    if (predicate(left3)) {
      if (predicate(right3)) {
        return sequential(left3, right3);
      }
      return left3;
    }
    if (predicate(right3)) {
      return right3;
    }
    return empty8;
  }, "sequentialCase"),
  parallelCase: /* @__PURE__ */ __name((_, left3, right3) => {
    if (predicate(left3)) {
      if (predicate(right3)) {
        return parallel(left3, right3);
      }
      return left3;
    }
    if (predicate(right3)) {
      return right3;
    }
    return empty8;
  }, "parallelCase")
}), "FilterCauseReducer");
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match4 = /* @__PURE__ */ dual(2, (self2, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt: onInterrupt3,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self2, void 0, {
    emptyCase: /* @__PURE__ */ __name(() => onEmpty, "emptyCase"),
    failCase: /* @__PURE__ */ __name((_, error5) => onFail(error5), "failCase"),
    dieCase: /* @__PURE__ */ __name((_, defect) => onDie(defect), "dieCase"),
    interruptCase: /* @__PURE__ */ __name((_, fiberId5) => onInterrupt3(fiberId5), "interruptCase"),
    sequentialCase: /* @__PURE__ */ __name((_, left3, right3) => onSequential(left3, right3), "sequentialCase"),
    parallelCase: /* @__PURE__ */ __name((_, left3, right3) => onParallel(left3, right3), "parallelCase")
  });
});
var reduce6 = /* @__PURE__ */ dual(3, (self2, zero3, pf) => {
  let accumulator = zero3;
  let cause3 = self2;
  const causes = [];
  while (cause3 !== void 0) {
    const option9 = pf(accumulator, cause3);
    accumulator = isSome2(option9) ? option9.value : accumulator;
    switch (cause3._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause3.right);
        cause3 = cause3.left;
        break;
      }
      default: {
        cause3 = void 0;
        break;
      }
    }
    if (cause3 === void 0 && causes.length > 0) {
      cause3 = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self2, context17, reducer) => {
  const input = [self2];
  const output = [];
  while (input.length > 0) {
    const cause3 = input.pop();
    switch (cause3._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context17)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context17, cause3.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context17, cause3.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context17, cause3.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause3.right);
        input.push(cause3.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either12 = output.pop();
    switch (either12._tag) {
      case "Left": {
        switch (either12.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.sequentialCase(context17, left3, right3);
            accumulator.push(value6);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.parallelCase(context17, left3, right3);
            accumulator.push(value6);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either12.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = /* @__PURE__ */ __name((cause3, options4) => {
  if (isInterruptedOnly(cause3)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause3).map(function(e) {
    if (options4?.renderErrorCause !== true || e.cause === void 0) {
      return e.stack;
    }
    return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
  }).join("\n");
}, "pretty");
var renderErrorCause = /* @__PURE__ */ __name((cause3, prefix) => {
  const lines = cause3.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length; i < len; i++) {
    stack += `
${prefix}${lines[i]}`;
  }
  if (cause3.cause) {
    stack += ` {
${renderErrorCause(cause3.cause, `${prefix}  `)}
${prefix}}`;
  }
  return stack;
}, "renderErrorCause");
var PrettyError = class _PrettyError extends globalThis.Error {
  static {
    __name(this, "PrettyError");
  }
  span = void 0;
  constructor(originalError2) {
    const originalErrorIsObject = typeof originalError2 === "object" && originalError2 !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError2), originalErrorIsObject && "cause" in originalError2 && typeof originalError2.cause !== "undefined" ? {
      cause: new _PrettyError(originalError2.cause)
    } : void 0);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError2 instanceof Error ? originalError2.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError2) {
        this.span = originalError2[spanSymbol];
      }
      Object.keys(originalError2).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError2[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError2 instanceof Error && originalError2.stack ? originalError2.stack : "", this.span);
  }
};
var prettyErrorMessage = /* @__PURE__ */ __name((u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
}, "prettyErrorMessage");
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
var prettyErrorStack = /* @__PURE__ */ __name((message, stack, span4) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1; i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span4) {
    let current2 = span4;
    let i = 0;
    while (current2 && current2._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current2);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match24 = false;
          for (const [, location2] of locationMatchAll) {
            match24 = true;
            out.push(`    at ${current2.name} (${location2})`);
          }
          if (!match24) {
            out.push(`    at ${current2.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current2.name}`);
        }
      } else {
        out.push(`    at ${current2.name}`);
      }
      current2 = getOrUndefined2(current2.parent);
      i++;
    }
  }
  return out.join("\n");
}, "prettyErrorStack");
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = /* @__PURE__ */ __name((cause3) => reduceWithContext(cause3, void 0, {
  emptyCase: /* @__PURE__ */ __name(() => [], "emptyCase"),
  dieCase: /* @__PURE__ */ __name((_, unknownError) => {
    return [new PrettyError(unknownError)];
  }, "dieCase"),
  failCase: /* @__PURE__ */ __name((_, error5) => {
    return [new PrettyError(error5)];
  }, "failCase"),
  interruptCase: /* @__PURE__ */ __name(() => [], "interruptCase"),
  parallelCase: /* @__PURE__ */ __name((_, l, r) => [...l, ...r], "parallelCase"),
  sequentialCase: /* @__PURE__ */ __name((_, l, r) => [...l, ...r], "sequentialCase")
}), "prettyErrors");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/console.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Context.js
var Context_exports = {};
__export(Context_exports, {
  GenericTag: () => GenericTag,
  Reference: () => Reference2,
  ReferenceTypeId: () => ReferenceTypeId2,
  Tag: () => Tag2,
  TagTypeId: () => TagTypeId2,
  add: () => add4,
  empty: () => empty10,
  get: () => get6,
  getOption: () => getOption2,
  getOrElse: () => getOrElse4,
  isContext: () => isContext2,
  isReference: () => isReference2,
  isTag: () => isTag2,
  make: () => make11,
  merge: () => merge3,
  mergeAll: () => mergeAll2,
  omit: () => omit2,
  pick: () => pick2,
  unsafeGet: () => unsafeGet5,
  unsafeMake: () => unsafeMake
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/context.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: /* @__PURE__ */ __name((_) => _, "_Service"),
    _Identifier: /* @__PURE__ */ __name((_) => _, "_Identifier")
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self2) {
    return self2;
  },
  context(self2) {
    return make10(this, self2);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = /* @__PURE__ */ __name((key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  const tag8 = Object.create(TagProto);
  Object.defineProperty(tag8, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag8.key = key;
  return tag8;
}, "makeGenericTag");
var Tag = /* @__PURE__ */ __name((id4) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  __name(TagClass, "TagClass");
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id4;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
}, "Tag");
var Reference = /* @__PURE__ */ __name(() => (id4, options4) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  __name(ReferenceClass, "ReferenceClass");
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id4;
  ReferenceClass.defaultValue = options4.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
}, "Reference");
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId6]: {
    _Services: /* @__PURE__ */ __name((_) => _, "_Services")
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = /* @__PURE__ */ __name((unsafeMap) => {
  const context17 = Object.create(ContextProto);
  context17.unsafeMap = unsafeMap;
  return context17;
}, "makeContext");
var serviceNotFoundError = /* @__PURE__ */ __name((tag8) => {
  const error5 = new Error(`Service not found${tag8.key ? `: ${String(tag8.key)}` : ""}`);
  if (tag8.stack) {
    const lines = tag8.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error5.message = error5.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error5.stack) {
    const lines = error5.stack.split("\n");
    lines.splice(1, 3);
    error5.stack = lines.join("\n");
  }
  return error5;
}, "serviceNotFoundError");
var isContext = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId6), "isContext");
var isTag = /* @__PURE__ */ __name((u) => hasProperty(u, TagTypeId), "isTag");
var isReference = /* @__PURE__ */ __name((u) => hasProperty(u, ReferenceTypeId), "isReference");
var _empty4 = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
var empty9 = /* @__PURE__ */ __name(() => _empty4, "empty");
var make10 = /* @__PURE__ */ __name((tag8, service3) => makeContext(/* @__PURE__ */ new Map([[tag8.key, service3]])), "make");
var add3 = /* @__PURE__ */ dual(3, (self2, tag8, service3) => {
  const map38 = new Map(self2.unsafeMap);
  map38.set(tag8.key, service3);
  return makeContext(map38);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
var getDefaultValue = /* @__PURE__ */ __name((tag8) => {
  if (defaultValueCache.has(tag8.key)) {
    return defaultValueCache.get(tag8.key);
  }
  const value6 = tag8.defaultValue();
  defaultValueCache.set(tag8.key, value6);
  return value6;
}, "getDefaultValue");
var unsafeGetReference = /* @__PURE__ */ __name((self2, tag8) => {
  return self2.unsafeMap.has(tag8.key) ? self2.unsafeMap.get(tag8.key) : getDefaultValue(tag8);
}, "unsafeGetReference");
var unsafeGet4 = /* @__PURE__ */ dual(2, (self2, tag8) => {
  if (!self2.unsafeMap.has(tag8.key)) {
    if (ReferenceTypeId in tag8) return getDefaultValue(tag8);
    throw serviceNotFoundError(tag8);
  }
  return self2.unsafeMap.get(tag8.key);
});
var get5 = unsafeGet4;
var getOrElse3 = /* @__PURE__ */ dual(3, (self2, tag8, orElse19) => {
  if (!self2.unsafeMap.has(tag8.key)) {
    return isReference(tag8) ? getDefaultValue(tag8) : orElse19();
  }
  return self2.unsafeMap.get(tag8.key);
});
var getOption = /* @__PURE__ */ dual(2, (self2, tag8) => {
  if (!self2.unsafeMap.has(tag8.key)) {
    return isReference(tag8) ? some2(getDefaultValue(tag8)) : none;
  }
  return some2(self2.unsafeMap.get(tag8.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self2, that) => {
  const map38 = new Map(self2.unsafeMap);
  for (const [tag8, s] of that.unsafeMap) {
    map38.set(tag8, s);
  }
  return makeContext(map38);
});
var mergeAll = /* @__PURE__ */ __name((...ctxs) => {
  const map38 = /* @__PURE__ */ new Map();
  for (let i = 0; i < ctxs.length; i++) {
    ctxs[i].unsafeMap.forEach((value6, key) => {
      map38.set(key, value6);
    });
  }
  return makeContext(map38);
}, "mergeAll");
var pick = /* @__PURE__ */ __name((...tags3) => (self2) => {
  const tagSet = new Set(tags3.map((_) => _.key));
  const newEnv = /* @__PURE__ */ new Map();
  for (const [tag8, s] of self2.unsafeMap.entries()) {
    if (tagSet.has(tag8)) {
      newEnv.set(tag8, s);
    }
  }
  return makeContext(newEnv);
}, "pick");
var omit = /* @__PURE__ */ __name((...tags3) => (self2) => {
  const newEnv = new Map(self2.unsafeMap);
  for (const tag8 of tags3) {
    newEnv.delete(tag8.key);
  }
  return makeContext(newEnv);
}, "omit");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Context.js
var TagTypeId2 = TagTypeId;
var ReferenceTypeId2 = ReferenceTypeId;
var GenericTag = makeGenericTag;
var unsafeMake = makeContext;
var isContext2 = isContext;
var isTag2 = isTag;
var isReference2 = isReference;
var empty10 = empty9;
var make11 = make10;
var add4 = add3;
var get6 = get5;
var getOrElse4 = getOrElse3;
var unsafeGet5 = unsafeGet4;
var getOption2 = getOption;
var merge3 = merge2;
var mergeAll2 = mergeAll;
var pick2 = pick;
var omit2 = omit;
var Tag2 = Tag;
var Reference2 = Reference;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/core.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Duration.js
var Duration_exports = {};
__export(Duration_exports, {
  Equivalence: () => Equivalence,
  Order: () => Order,
  between: () => between2,
  clamp: () => clamp3,
  days: () => days,
  decode: () => decode,
  decodeUnknown: () => decodeUnknown,
  divide: () => divide,
  equals: () => equals2,
  format: () => format2,
  formatIso: () => formatIso,
  fromIso: () => fromIso,
  greaterThan: () => greaterThan2,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo2,
  hours: () => hours,
  infinity: () => infinity,
  isDuration: () => isDuration,
  isFinite: () => isFinite,
  isZero: () => isZero,
  lessThan: () => lessThan2,
  lessThanOrEqualTo: () => lessThanOrEqualTo2,
  match: () => match5,
  matchWith: () => matchWith,
  max: () => max3,
  micros: () => micros,
  millis: () => millis,
  min: () => min3,
  minutes: () => minutes,
  nanos: () => nanos,
  parts: () => parts,
  seconds: () => seconds,
  subtract: () => subtract,
  sum: () => sum,
  times: () => times,
  toDays: () => toDays,
  toHours: () => toHours,
  toHrTime: () => toHrTime,
  toMillis: () => toMillis,
  toMinutes: () => toMinutes,
  toNanos: () => toNanos,
  toSeconds: () => toSeconds,
  toWeeks: () => toWeeks,
  unsafeDivide: () => unsafeDivide,
  unsafeFormatIso: () => unsafeFormatIso,
  unsafeToNanos: () => unsafeToNanos,
  weeks: () => weeks,
  zero: () => zero
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1e3);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = /* @__PURE__ */ __name((input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match24 = DURATION_REGEX.exec(input);
    if (match24) {
      const [_, valueStr, unit] = match24;
      const value6 = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value6);
        case "second":
        case "seconds":
          return seconds(value6);
        case "minute":
        case "minutes":
          return minutes(value6);
        case "hour":
        case "hours":
          return hours(value6);
        case "day":
        case "days":
          return days(value6);
        case "week":
        case "weeks":
          return weeks(value6);
      }
    }
  }
  throw new Error("Invalid DurationInput");
}, "decode");
var decodeUnknown = /* @__PURE__ */ liftThrowable(decode);
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId7]: TypeId7,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals2(this, that);
  },
  toString() {
    return `Duration(${format2(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make12 = /* @__PURE__ */ __name((input) => {
  const duration4 = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration4.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration4.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration4.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration4.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration4.value = zeroValue;
  } else {
    duration4.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration4;
}, "make");
var isDuration = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId7), "isDuration");
var isFinite = /* @__PURE__ */ __name((self2) => self2.value._tag !== "Infinity", "isFinite");
var isZero = /* @__PURE__ */ __name((self2) => {
  switch (self2.value._tag) {
    case "Millis": {
      return self2.value.millis === 0;
    }
    case "Nanos": {
      return self2.value.nanos === bigint0;
    }
    case "Infinity": {
      return false;
    }
  }
}, "isZero");
var zero = /* @__PURE__ */ make12(0);
var infinity = /* @__PURE__ */ make12(Infinity);
var nanos = /* @__PURE__ */ __name((nanos2) => make12(nanos2), "nanos");
var micros = /* @__PURE__ */ __name((micros2) => make12(micros2 * bigint1e3), "micros");
var millis = /* @__PURE__ */ __name((millis2) => make12(millis2), "millis");
var seconds = /* @__PURE__ */ __name((seconds2) => make12(seconds2 * 1e3), "seconds");
var minutes = /* @__PURE__ */ __name((minutes2) => make12(minutes2 * 6e4), "minutes");
var hours = /* @__PURE__ */ __name((hours2) => make12(hours2 * 36e5), "hours");
var days = /* @__PURE__ */ __name((days2) => make12(days2 * 864e5), "days");
var weeks = /* @__PURE__ */ __name((weeks2) => make12(weeks2 * 6048e5), "weeks");
var toMillis = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: /* @__PURE__ */ __name((millis2) => millis2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos2) => Number(nanos2) / 1e6, "onNanos")
}), "toMillis");
var toSeconds = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: /* @__PURE__ */ __name((millis2) => millis2 / 1e3, "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos2) => Number(nanos2) / 1e9, "onNanos")
}), "toSeconds");
var toMinutes = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: /* @__PURE__ */ __name((millis2) => millis2 / 6e4, "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos2) => Number(nanos2) / 6e10, "onNanos")
}), "toMinutes");
var toHours = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: /* @__PURE__ */ __name((millis2) => millis2 / 36e5, "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos2) => Number(nanos2) / 36e11, "onNanos")
}), "toHours");
var toDays = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: /* @__PURE__ */ __name((millis2) => millis2 / 864e5, "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos2) => Number(nanos2) / 864e11, "onNanos")
}), "toDays");
var toWeeks = /* @__PURE__ */ __name((self2) => match5(self2, {
  onMillis: /* @__PURE__ */ __name((millis2) => millis2 / 6048e5, "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos2) => Number(nanos2) / 6048e11, "onNanos")
}), "toWeeks");
var toNanos = /* @__PURE__ */ __name((self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return none2();
    case "Nanos":
      return some3(_self.value.nanos);
    case "Millis":
      return some3(BigInt(Math.round(_self.value.millis * 1e6)));
  }
}, "toNanos");
var unsafeToNanos = /* @__PURE__ */ __name((self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
}, "unsafeToNanos");
var toHrTime = /* @__PURE__ */ __name((self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
  }
}, "toHrTime");
var match5 = /* @__PURE__ */ dual(2, (self2, options4) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Nanos":
      return options4.onNanos(_self.value.nanos);
    case "Infinity":
      return options4.onMillis(Infinity);
    case "Millis":
      return options4.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self2, that, options4) => {
  const _self = decode(self2);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options4.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options4.onNanos(selfNanos, thatNanos);
  }
  return options4.onMillis(_self.value.millis, _that.value.millis);
});
var Order = /* @__PURE__ */ make2((self2, that) => matchWith(self2, that, {
  onMillis: /* @__PURE__ */ __name((self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0, "onNanos")
}));
var between2 = /* @__PURE__ */ between(/* @__PURE__ */ mapInput3(Order, decode));
var Equivalence = /* @__PURE__ */ __name((self2, that) => matchWith(self2, that, {
  onMillis: /* @__PURE__ */ __name((self3, that2) => self3 === that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self3, that2) => self3 === that2, "onNanos")
}), "Equivalence");
var _min = /* @__PURE__ */ min(Order);
var min3 = /* @__PURE__ */ dual(2, (self2, that) => _min(decode(self2), decode(that)));
var _max = /* @__PURE__ */ max(Order);
var max3 = /* @__PURE__ */ dual(2, (self2, that) => _max(decode(self2), decode(that)));
var _clamp = /* @__PURE__ */ clamp(Order);
var clamp3 = /* @__PURE__ */ dual(2, (self2, options4) => _clamp(decode(self2), {
  minimum: decode(options4.minimum),
  maximum: decode(options4.maximum)
}));
var divide = /* @__PURE__ */ dual(2, (self2, by) => match5(self2, {
  onMillis: /* @__PURE__ */ __name((millis2) => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return none2();
    }
    return some3(make12(millis2 / by));
  }, "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos2) => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return none2();
    }
    try {
      return some3(make12(nanos2 / BigInt(by)));
    } catch {
      return none2();
    }
  }, "onNanos")
}));
var unsafeDivide = /* @__PURE__ */ dual(2, (self2, by) => match5(self2, {
  onMillis: /* @__PURE__ */ __name((millis2) => make12(millis2 / by), "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos2) => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return make12(nanos2 / BigInt(by));
  }, "onNanos")
}));
var times = /* @__PURE__ */ dual(2, (self2, times2) => match5(self2, {
  onMillis: /* @__PURE__ */ __name((millis2) => make12(millis2 * times2), "onMillis"),
  onNanos: /* @__PURE__ */ __name((nanos2) => make12(nanos2 * BigInt(times2)), "onNanos")
}));
var subtract = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: /* @__PURE__ */ __name((self3, that2) => make12(self3 - that2), "onMillis"),
  onNanos: /* @__PURE__ */ __name((self3, that2) => make12(self3 - that2), "onNanos")
}));
var sum = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: /* @__PURE__ */ __name((self3, that2) => make12(self3 + that2), "onMillis"),
  onNanos: /* @__PURE__ */ __name((self3, that2) => make12(self3 + that2), "onNanos")
}));
var lessThan2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: /* @__PURE__ */ __name((self3, that2) => self3 < that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self3, that2) => self3 < that2, "onNanos")
}));
var lessThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: /* @__PURE__ */ __name((self3, that2) => self3 <= that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self3, that2) => self3 <= that2, "onNanos")
}));
var greaterThan2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: /* @__PURE__ */ __name((self3, that2) => self3 > that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self3, that2) => self3 > that2, "onNanos")
}));
var greaterThanOrEqualTo2 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: /* @__PURE__ */ __name((self3, that2) => self3 >= that2, "onMillis"),
  onNanos: /* @__PURE__ */ __name((self3, that2) => self3 >= that2, "onNanos")
}));
var equals2 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence(decode(self2), decode(that)));
var parts = /* @__PURE__ */ __name((self2) => {
  const duration4 = decode(self2);
  if (duration4.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration4);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min6 = sec / bigint60;
  const hr = min6 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min6 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
}, "parts");
var format2 = /* @__PURE__ */ __name((self2) => {
  const duration4 = decode(self2);
  if (duration4.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero(duration4)) {
    return "0";
  }
  const fragments = parts(duration4);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
}, "format");
var unsafeFormatIso = /* @__PURE__ */ __name((self2) => {
  const duration4 = decode(self2);
  if (!isFinite(duration4)) {
    throw new RangeError("Cannot format infinite duration");
  }
  const fragments = [];
  const {
    days: days2,
    hours: hours2,
    millis: millis2,
    minutes: minutes2,
    nanos: nanos2,
    seconds: seconds2
  } = parts(duration4);
  let rest = days2;
  if (rest >= 365) {
    const years = Math.floor(rest / 365);
    rest %= 365;
    fragments.push(`${years}Y`);
  }
  if (rest >= 30) {
    const months = Math.floor(rest / 30);
    rest %= 30;
    fragments.push(`${months}M`);
  }
  if (rest >= 7) {
    const weeks2 = Math.floor(rest / 7);
    rest %= 7;
    fragments.push(`${weeks2}W`);
  }
  if (rest > 0) {
    fragments.push(`${rest}D`);
  }
  if (hours2 !== 0 || minutes2 !== 0 || seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
    fragments.push("T");
    if (hours2 !== 0) {
      fragments.push(`${hours2}H`);
    }
    if (minutes2 !== 0) {
      fragments.push(`${minutes2}M`);
    }
    if (seconds2 !== 0 || millis2 !== 0 || nanos2 !== 0) {
      const total = BigInt(seconds2) * bigint1e9 + BigInt(millis2) * bigint1e6 + BigInt(nanos2);
      const str = (Number(total) / 1e9).toFixed(9).replace(/\.?0+$/, "");
      fragments.push(`${str}S`);
    }
  }
  return `P${fragments.join("") || "T0S"}`;
}, "unsafeFormatIso");
var formatIso = /* @__PURE__ */ __name((self2) => {
  const duration4 = decode(self2);
  return isFinite(duration4) ? some3(unsafeFormatIso(duration4)) : none2();
}, "formatIso");
var fromIso = /* @__PURE__ */ __name((iso) => {
  const result = DURATION_ISO_REGEX.exec(iso);
  if (result == null) {
    return none2();
  }
  const [years, months, weeks2, days2, hours2, mins, secs] = result.slice(1, 8).map((_) => _ ? Number(_) : 0);
  const value6 = years * 365 * 24 * 60 * 60 + months * 30 * 24 * 60 * 60 + weeks2 * 7 * 24 * 60 * 60 + days2 * 24 * 60 * 60 + hours2 * 60 * 60 + mins * 60 + secs;
  return some3(seconds(value6));
}, "fromIso");
var DURATION_ISO_REGEX = /^P(?!$)(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?(?:T(?!$)(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?)?$/;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberId.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberId.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/MutableRef.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId8]: TypeId8,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make13 = /* @__PURE__ */ __name((value6) => {
  const ref2 = Object.create(MutableRefProto);
  ref2.current = value6;
  return ref2;
}, "make");
var compareAndSet = /* @__PURE__ */ dual(3, (self2, oldValue, newValue) => {
  if (equals(oldValue, self2.current)) {
    self2.current = newValue;
    return true;
  }
  return false;
});
var get7 = /* @__PURE__ */ __name((self2) => self2.current, "get");
var set2 = /* @__PURE__ */ dual(2, (self2, value6) => {
  self2.current = value6;
  return self2;
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string2(`${FiberIdSymbolKey}-${OP_NONE}`);
var None = class {
  static {
    __name(this, "None");
  }
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Runtime = class {
  static {
    __name(this, "Runtime");
  }
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id4, startTimeMillis) {
    this.id = id4;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string2(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var Composite = class {
  static {
    __name(this, "Composite");
  }
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol]() {
    return pipe(string2(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var none3 = /* @__PURE__ */ new None();
var runtime = /* @__PURE__ */ __name((id4, startTimeMillis) => {
  return new Runtime(id4, startTimeMillis);
}, "runtime");
var composite = /* @__PURE__ */ __name((left3, right3) => {
  return new Composite(left3, right3);
}, "composite");
var isFiberId = /* @__PURE__ */ __name((self2) => hasProperty(self2, FiberIdTypeId), "isFiberId");
var isNone3 = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_NONE || pipe(toSet(self2), every6((id4) => isNone3(id4)));
}, "isNone");
var combine2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self2;
  }
  return new Composite(self2, that);
});
var combineAll2 = /* @__PURE__ */ __name((fiberIds) => {
  return pipe(fiberIds, reduce5(none3, (a, b) => combine2(b)(a)));
}, "combineAll");
var getOrElse5 = /* @__PURE__ */ dual(2, (self2, that) => isNone3(self2) ? that : self2);
var ids = /* @__PURE__ */ __name((self2) => {
  switch (self2._tag) {
    case OP_NONE: {
      return empty7();
    }
    case OP_RUNTIME: {
      return make9(self2.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self2.left), union5(ids(self2.right)));
    }
  }
}, "ids");
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make13(0));
var make14 = /* @__PURE__ */ __name((id4, startTimeSeconds) => {
  return new Runtime(id4, startTimeSeconds);
}, "make");
var threadName = /* @__PURE__ */ __name((self2) => {
  const identifiers = Array.from(ids(self2)).map((n) => `#${n}`).join(",");
  return identifiers;
}, "threadName");
var toSet = /* @__PURE__ */ __name((self2) => {
  switch (self2._tag) {
    case OP_NONE: {
      return empty7();
    }
    case OP_RUNTIME: {
      return make9(self2);
    }
    case OP_COMPOSITE: {
      return pipe(toSet(self2.left), union5(toSet(self2.right)));
    }
  }
}, "toSet");
var unsafeMake2 = /* @__PURE__ */ __name(() => {
  const id4 = get7(_fiberCounter);
  pipe(_fiberCounter, set2(id4 + 1));
  return new Runtime(id4, Date.now());
}, "unsafeMake");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var isFiberId2 = isFiberId;
var combine3 = combine2;
var combineAll3 = combineAll2;
var getOrElse6 = getOrElse5;
var ids2 = ids;
var make15 = make14;
var threadName2 = threadName;
var toSet2 = toSet;
var unsafeMake3 = unsafeMake2;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/HashMap.js
var HashMap_exports = {};
__export(HashMap_exports, {
  beginMutation: () => beginMutation4,
  compact: () => compact3,
  countBy: () => countBy3,
  empty: () => empty11,
  endMutation: () => endMutation4,
  entries: () => entries2,
  every: () => every7,
  filter: () => filter9,
  filterMap: () => filterMap5,
  findFirst: () => findFirst5,
  flatMap: () => flatMap9,
  forEach: () => forEach6,
  fromIterable: () => fromIterable7,
  get: () => get8,
  getHash: () => getHash2,
  has: () => has5,
  hasBy: () => hasBy2,
  hasHash: () => hasHash2,
  isEmpty: () => isEmpty4,
  isHashMap: () => isHashMap2,
  keySet: () => keySet2,
  keys: () => keys3,
  make: () => make16,
  map: () => map11,
  modify: () => modify4,
  modifyAt: () => modifyAt2,
  modifyHash: () => modifyHash2,
  mutate: () => mutate4,
  reduce: () => reduce7,
  remove: () => remove6,
  removeMany: () => removeMany2,
  set: () => set3,
  size: () => size6,
  some: () => some9,
  toEntries: () => toEntries2,
  toValues: () => toValues2,
  union: () => union6,
  unsafeGet: () => unsafeGet6,
  values: () => values4
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/hashMap/keySet.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function keySet(self2) {
  return makeImpl2(self2);
}
__name(keySet, "keySet");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/HashMap.js
var isHashMap2 = isHashMap;
var empty11 = empty5;
var make16 = make7;
var fromIterable7 = fromIterable4;
var isEmpty4 = isEmpty2;
var get8 = get4;
var getHash2 = getHash;
var unsafeGet6 = unsafeGet3;
var has5 = has2;
var hasHash2 = hasHash;
var hasBy2 = hasBy;
var set3 = set;
var keys3 = keys2;
var keySet2 = keySet;
var values4 = values;
var toValues2 = /* @__PURE__ */ __name((self2) => Array.from(values4(self2)), "toValues");
var entries2 = entries;
var toEntries2 = /* @__PURE__ */ __name((self2) => Array.from(entries2(self2)), "toEntries");
var size6 = size2;
var countBy3 = countBy2;
var beginMutation4 = beginMutation;
var endMutation4 = endMutation;
var mutate4 = mutate;
var modifyAt2 = modifyAt;
var modifyHash2 = modifyHash;
var modify4 = modify3;
var union6 = union3;
var remove6 = remove3;
var removeMany2 = removeMany;
var map11 = map7;
var flatMap9 = flatMap5;
var forEach6 = forEach3;
var reduce7 = reduce3;
var filter9 = filter5;
var compact3 = compact2;
var filterMap5 = filterMap4;
var findFirst5 = findFirst4;
var some9 = some6;
var every7 = every4;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/List.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray3 = /* @__PURE__ */ __name((self2) => fromIterable2(self2), "toArray");
var getEquivalence6 = /* @__PURE__ */ __name((isEquivalent) => mapInput(getEquivalence4(isEquivalent), toArray3), "getEquivalence");
var _equivalence4 = /* @__PURE__ */ getEquivalence6(equals);
var ConsProto = {
  [TypeId9]: TypeId9,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray3(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray3(this)));
  },
  [Symbol.iterator]() {
    let done12 = false;
    let self2 = this;
    return {
      next() {
        if (done12) {
          return this.return();
        }
        if (self2._tag === "Nil") {
          done12 = true;
          return this.return();
        }
        const value6 = self2.head;
        self2 = self2.tail;
        return {
          done: done12,
          value: value6
        };
      },
      return(value6) {
        if (!done12) {
          done12 = true;
        }
        return {
          done: true,
          value: value6
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = /* @__PURE__ */ __name((head13, tail3) => {
  const cons2 = Object.create(ConsProto);
  cons2.head = head13;
  cons2.tail = tail3;
  return cons2;
}, "makeCons");
var NilHash = /* @__PURE__ */ string2("Nil");
var NilProto = {
  [TypeId9]: TypeId9,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: void 0
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId9), "isList");
var isNil = /* @__PURE__ */ __name((self2) => self2._tag === "Nil", "isNil");
var isCons = /* @__PURE__ */ __name((self2) => self2._tag === "Cons", "isCons");
var nil = /* @__PURE__ */ __name(() => _Nil, "nil");
var cons = /* @__PURE__ */ __name((head13, tail3) => makeCons(head13, tail3), "cons");
var empty12 = nil;
var of3 = /* @__PURE__ */ __name((value6) => makeCons(value6, _Nil), "of");
var fromIterable8 = /* @__PURE__ */ __name((prefix) => {
  const iterator = prefix[Symbol.iterator]();
  let next4;
  if ((next4 = iterator.next()) && !next4.done) {
    const result = makeCons(next4.value, _Nil);
    let curr = result;
    while ((next4 = iterator.next()) && !next4.done) {
      const temp = makeCons(next4.value, _Nil);
      curr.tail = temp;
      curr = temp;
    }
    return result;
  } else {
    return _Nil;
  }
}, "fromIterable");
var appendAll3 = /* @__PURE__ */ dual(2, (self2, that) => prependAll3(that, self2));
var prepend3 = /* @__PURE__ */ dual(2, (self2, element2) => cons(element2, self2));
var prependAll3 = /* @__PURE__ */ dual(2, (self2, prefix) => {
  if (isNil(self2)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self2;
  } else {
    const result = makeCons(prefix.head, self2);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self2);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce8 = /* @__PURE__ */ dual(3, (self2, zero3, f) => {
  let acc = zero3;
  let these = self2;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = /* @__PURE__ */ __name((self2) => {
  let result = empty12();
  let these = self2;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
}, "reverse");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/runtimeFlags.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/differ.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/data.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ (function() {
  function Structural3(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  __name(Structural3, "Structural");
  Structural3.prototype = StructuralPrototype;
  return Structural3;
})();
var struct2 = /* @__PURE__ */ __name((as16) => Object.assign(Object.create(StructuralPrototype), as16), "struct");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/differ/contextPatch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
function variance2(a) {
  return a;
}
__name(variance2, "variance");
var PatchProto = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty13 = /* @__PURE__ */ __name(() => _empty5, "empty");
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AndThen"
});
var makeAndThen = /* @__PURE__ */ __name((first2, second) => {
  const o = Object.create(AndThenProto);
  o.first = first2;
  o.second = second;
  return o;
}, "makeAndThen");
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "AddService"
});
var makeAddService = /* @__PURE__ */ __name((key, service3) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service3;
  return o;
}, "makeAddService");
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "RemoveService"
});
var makeRemoveService = /* @__PURE__ */ __name((key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
}, "makeRemoveService");
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
  _tag: "UpdateService"
});
var makeUpdateService = /* @__PURE__ */ __name((key, update9) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update9;
  return o;
}, "makeUpdateService");
var diff = /* @__PURE__ */ __name((oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch12 = empty13();
  for (const [tag8, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag8)) {
      const old = missingServices.get(tag8);
      missingServices.delete(tag8);
      if (!equals(old, newService)) {
        patch12 = combine4(makeUpdateService(tag8, () => newService))(patch12);
      }
    } else {
      missingServices.delete(tag8);
      patch12 = combine4(makeAddService(tag8, newService))(patch12);
    }
  }
  for (const [tag8] of missingServices.entries()) {
    patch12 = combine4(makeRemoveService(tag8))(patch12);
  }
  return patch12;
}, "diff");
var combine4 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen(self2, that));
var patch = /* @__PURE__ */ dual(2, (self2, context17) => {
  if (self2._tag === "Empty") {
    return context17;
  }
  let wasServiceUpdated = false;
  let patches = of2(self2);
  const updatedContext = new Map(context17.unsafeMap);
  while (isNonEmpty(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail3 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail3;
        break;
      }
      case "AddService": {
        updatedContext.set(head13.key, head13.service);
        patches = tail3;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail3, head13.second), head13.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head13.key);
        patches = tail3;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head13.key, head13.update(updatedContext.get(head13.key)));
        wasServiceUpdated = true;
        patches = tail3;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map38 = /* @__PURE__ */ new Map();
  for (const [tag8] of context17.unsafeMap) {
    if (updatedContext.has(tag8)) {
      map38.set(tag8, updatedContext.get(tag8));
      updatedContext.delete(tag8);
    }
  }
  for (const [tag8, s] of updatedContext) {
    map38.set(tag8, s);
  }
  return makeContext(map38);
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
function variance3(a) {
  return a;
}
__name(variance3, "variance");
var PatchProto2 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty14 = /* @__PURE__ */ __name(() => _empty6, "empty");
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen2 = /* @__PURE__ */ __name((first2, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first2;
  o.second = second;
  return o;
}, "makeAndThen");
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Add"
});
var makeAdd = /* @__PURE__ */ __name((value6) => {
  const o = Object.create(AddProto);
  o.value = value6;
  return o;
}, "makeAdd");
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Remove"
});
var makeRemove = /* @__PURE__ */ __name((value6) => {
  const o = Object.create(RemoveProto);
  o.value = value6;
  return o;
}, "makeRemove");
var diff2 = /* @__PURE__ */ __name((oldValue, newValue) => {
  const [removed, patch12] = reduce5([oldValue, empty14()], ([set20, patch13], value6) => {
    if (has4(value6)(set20)) {
      return [remove5(value6)(set20), patch13];
    }
    return [set20, combine5(makeAdd(value6))(patch13)];
  })(newValue);
  return reduce5(patch12, (patch13, value6) => combine5(makeRemove(value6))(patch13))(removed);
}, "diff");
var combine5 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen2(self2, that));
var patch2 = /* @__PURE__ */ dual(2, (self2, oldValue) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let set20 = oldValue;
  let patches = of2(self2);
  while (isNonEmpty(patches)) {
    const head13 = headNonEmpty2(patches);
    const tail3 = tailNonEmpty2(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail3;
        break;
      }
      case "AndThen": {
        patches = prepend2(head13.first)(prepend2(head13.second)(tail3));
        break;
      }
      case "Add": {
        set20 = add2(head13.value)(set20);
        patches = tail3;
        break;
      }
      case "Remove": {
        set20 = remove5(head13.value)(set20);
        patches = tail3;
      }
    }
  }
  return set20;
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
function variance4(a) {
  return a;
}
__name(variance4, "variance");
var PatchProto3 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance4,
    _Patch: variance4
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty15 = /* @__PURE__ */ __name(() => _empty7, "empty");
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "AndThen"
});
var makeAndThen3 = /* @__PURE__ */ __name((first2, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first2;
  o.second = second;
  return o;
}, "makeAndThen");
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Append"
});
var makeAppend = /* @__PURE__ */ __name((values6) => {
  const o = Object.create(AppendProto);
  o.values = values6;
  return o;
}, "makeAppend");
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Slice"
});
var makeSlice = /* @__PURE__ */ __name((from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
}, "makeSlice");
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto3), {
  _tag: "Update"
});
var makeUpdate = /* @__PURE__ */ __name((index2, patch12) => {
  const o = Object.create(UpdateProto);
  o.index = index2;
  o.patch = patch12;
  return o;
}, "makeUpdate");
var diff3 = /* @__PURE__ */ __name((options4) => {
  let i = 0;
  let patch12 = empty15();
  while (i < options4.oldValue.length && i < options4.newValue.length) {
    const oldElement = options4.oldValue[i];
    const newElement = options4.newValue[i];
    const valuePatch = options4.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options4.differ.empty)) {
      patch12 = combine6(patch12, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options4.oldValue.length) {
    patch12 = combine6(patch12, makeSlice(0, i));
  }
  if (i < options4.newValue.length) {
    patch12 = combine6(patch12, makeAppend(drop(i)(options4.newValue)));
  }
  return patch12;
}, "diff");
var combine6 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen3(self2, that));
var patch3 = /* @__PURE__ */ dual(3, (self2, oldValue, differ3) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray2 = oldValue.slice();
  let patches = of(self2);
  while (isNonEmptyArray2(patches)) {
    const head13 = headNonEmpty(patches);
    const tail3 = tailNonEmpty(patches);
    switch (head13._tag) {
      case "Empty": {
        patches = tail3;
        break;
      }
      case "AndThen": {
        tail3.unshift(head13.first, head13.second);
        patches = tail3;
        break;
      }
      case "Append": {
        for (const value6 of head13.values) {
          readonlyArray2.push(value6);
        }
        patches = tail3;
        break;
      }
      case "Slice": {
        readonlyArray2 = readonlyArray2.slice(head13.from, head13.until);
        patches = tail3;
        break;
      }
      case "Update": {
        readonlyArray2[head13.index] = differ3.patch(head13.patch, readonlyArray2[head13.index]);
        patches = tail3;
        break;
      }
    }
  }
  return readonlyArray2;
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make17 = /* @__PURE__ */ __name((params2) => {
  const differ3 = Object.create(DifferProto);
  differ3.empty = params2.empty;
  differ3.diff = params2.diff;
  differ3.combine = params2.combine;
  differ3.patch = params2.patch;
  return differ3;
}, "make");
var environment = /* @__PURE__ */ __name(() => make17({
  empty: empty13(),
  combine: /* @__PURE__ */ __name((first2, second) => combine4(second)(first2), "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff(oldValue, newValue), "diff"),
  patch: /* @__PURE__ */ __name((patch12, oldValue) => patch(oldValue)(patch12), "patch")
}), "environment");
var hashSet = /* @__PURE__ */ __name(() => make17({
  empty: empty14(),
  combine: /* @__PURE__ */ __name((first2, second) => combine5(second)(first2), "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff2(oldValue, newValue), "diff"),
  patch: /* @__PURE__ */ __name((patch12, oldValue) => patch2(oldValue)(patch12), "patch")
}), "hashSet");
var readonlyArray = /* @__PURE__ */ __name((differ3) => make17({
  empty: empty15(),
  combine: /* @__PURE__ */ __name((first2, second) => combine6(first2, second), "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ: differ3
  }), "diff"),
  patch: /* @__PURE__ */ __name((patch12, oldValue) => patch3(patch12, oldValue, differ3), "patch")
}), "readonlyArray");
var update = /* @__PURE__ */ __name(() => updateWith((_, a) => a), "update");
var updateWith = /* @__PURE__ */ __name((f) => make17({
  empty: identity,
  combine: /* @__PURE__ */ __name((first2, second) => {
    if (first2 === identity) {
      return second;
    }
    if (second === identity) {
      return first2;
    }
    return (a) => second(first2(a));
  }, "combine"),
  diff: /* @__PURE__ */ __name((oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  }, "diff"),
  patch: /* @__PURE__ */ __name((patch12, oldValue) => f(oldValue, patch12(oldValue)), "patch")
}), "updateWith");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = /* @__PURE__ */ __name((patch12) => patch12 & BIT_MASK, "active");
var enabled = /* @__PURE__ */ __name((patch12) => patch12 >> BIT_SHIFT & BIT_MASK, "enabled");
var make18 = /* @__PURE__ */ __name((active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT), "make");
var empty16 = /* @__PURE__ */ make18(0, 0);
var enable = /* @__PURE__ */ __name((flag) => make18(flag, flag), "enable");
var disable = /* @__PURE__ */ __name((flag) => make18(flag, 0), "disable");
var exclude = /* @__PURE__ */ dual(2, (self2, flag) => make18(active(self2) & ~flag, enabled(self2)));
var andThen4 = /* @__PURE__ */ dual(2, (self2, that) => self2 | that);
var invert = /* @__PURE__ */ __name((n) => ~n >>> 0 & BIT_MASK, "invert");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = /* @__PURE__ */ __name((self2) => isEnabled(self2, CooperativeYielding), "cooperativeYielding");
var disable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 & ~flag);
var enable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 | flag);
var interruptible = /* @__PURE__ */ __name((self2) => interruption(self2) && !windDown(self2), "interruptible");
var interruption = /* @__PURE__ */ __name((self2) => isEnabled(self2, Interruption), "interruption");
var isEnabled = /* @__PURE__ */ dual(2, (self2, flag) => (self2 & flag) !== 0);
var make19 = /* @__PURE__ */ __name((...flags) => flags.reduce((a, b) => a | b, 0), "make");
var none5 = /* @__PURE__ */ make19(None2);
var runtimeMetrics = /* @__PURE__ */ __name((self2) => isEnabled(self2, RuntimeMetrics), "runtimeMetrics");
var windDown = /* @__PURE__ */ __name((self2) => isEnabled(self2, WindDown), "windDown");
var diff4 = /* @__PURE__ */ dual(2, (self2, that) => make18(self2 ^ that, that));
var patch4 = /* @__PURE__ */ dual(2, (self2, patch12) => self2 & (invert(active(patch12)) | enabled(patch12)) | active(patch12) & enabled(patch12));
var differ = /* @__PURE__ */ make17({
  empty: empty16,
  diff: /* @__PURE__ */ __name((oldValue, newValue) => diff4(oldValue, newValue), "diff"),
  combine: /* @__PURE__ */ __name((first2, second) => andThen4(second)(first2), "combine"),
  patch: /* @__PURE__ */ __name((_patch, oldValue) => patch4(oldValue, _patch), "patch")
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty17 = empty16;
var enable3 = enable;
var disable3 = disable;
var exclude2 = exclude;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/blockedRequests.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var empty18 = {
  _tag: "Empty"
};
var par = /* @__PURE__ */ __name((self2, that) => ({
  _tag: "Par",
  left: self2,
  right: that
}), "par");
var seq = /* @__PURE__ */ __name((self2, that) => ({
  _tag: "Seq",
  left: self2,
  right: that
}), "seq");
var single = /* @__PURE__ */ __name((dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
}), "single");
var flatten5 = /* @__PURE__ */ __name((self2) => {
  let current2 = of3(self2);
  let updated = empty12();
  while (1) {
    const [parallel5, sequential5] = reduce8(current2, [parallelCollectionEmpty(), empty12()], ([parallel6, sequential6], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel6, par2), appendAll3(sequential6, seq2)];
    });
    updated = merge4(updated, parallel5);
    if (isNil(sequential5)) {
      return reverse3(updated);
    }
    current2 = sequential5;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "flatten");
var step = /* @__PURE__ */ __name((requests) => {
  let current2 = requests;
  let parallel5 = parallelCollectionEmpty();
  let stack = empty12();
  let sequential5 = empty12();
  while (1) {
    switch (current2._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current2.right, stack);
        current2 = current2.left;
        break;
      }
      case "Seq": {
        const left3 = current2.left;
        const right3 = current2.right;
        switch (left3._tag) {
          case "Empty": {
            current2 = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current2 = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current2 = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current2 = left3;
            sequential5 = cons(right3, sequential5);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel5 = parallelCollectionAdd(parallel5, current2);
        if (isNil(stack)) {
          return [parallel5, sequential5];
        }
        current2 = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "step");
var merge4 = /* @__PURE__ */ __name((sequential5, parallel5) => {
  if (isNil(sequential5)) {
    return of3(parallelCollectionToSequentialCollection(parallel5));
  }
  if (parallelCollectionIsEmpty(parallel5)) {
    return sequential5;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential5.head);
  const parKeys = parallelCollectionKeys(parallel5);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential5.head, parallelCollectionToSequentialCollection(parallel5)), sequential5.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel5), sequential5);
}, "merge");
var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");
var EntryImpl = class {
  static {
    __name(this, "EntryImpl");
  }
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request2, result, listeners2, ownerId, state2) {
    this.request = request2;
    this.result = result;
    this.listeners = listeners2;
    this.ownerId = ownerId;
    this.state = state2;
  }
};
var blockedRequestVariance = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var makeEntry = /* @__PURE__ */ __name((options4) => new EntryImpl(options4.request, options4.result, options4.listeners, options4.ownerId, options4.state), "makeEntry");
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var ParallelImpl = class {
  static {
    __name(this, "ParallelImpl");
  }
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map38) {
    this.map = map38;
  }
};
var parallelCollectionEmpty = /* @__PURE__ */ __name(() => new ParallelImpl(empty11()), "parallelCollectionEmpty");
var parallelCollectionAdd = /* @__PURE__ */ __name((self2, blockedRequest) => new ParallelImpl(modifyAt2(self2.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest)))), "parallelCollectionAdd");
var parallelCollectionCombine = /* @__PURE__ */ __name((self2, that) => new ParallelImpl(reduce7(self2.map, that.map, (map38, value6, key) => set3(map38, key, match2(get8(map38, key), {
  onNone: /* @__PURE__ */ __name(() => value6, "onNone"),
  onSome: /* @__PURE__ */ __name((other) => appendAll2(value6, other), "onSome")
})))), "parallelCollectionCombine");
var parallelCollectionIsEmpty = /* @__PURE__ */ __name((self2) => isEmpty4(self2.map), "parallelCollectionIsEmpty");
var parallelCollectionKeys = /* @__PURE__ */ __name((self2) => Array.from(keys3(self2.map)), "parallelCollectionKeys");
var parallelCollectionToSequentialCollection = /* @__PURE__ */ __name((self2) => sequentialCollectionMake(map11(self2.map, (x) => of2(x))), "parallelCollectionToSequentialCollection");
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var SequentialImpl = class {
  static {
    __name(this, "SequentialImpl");
  }
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map38) {
    this.map = map38;
  }
};
var sequentialCollectionMake = /* @__PURE__ */ __name((map38) => new SequentialImpl(map38), "sequentialCollectionMake");
var sequentialCollectionCombine = /* @__PURE__ */ __name((self2, that) => new SequentialImpl(reduce7(that.map, self2.map, (map38, value6, key) => set3(map38, key, match2(get8(map38, key), {
  onNone: /* @__PURE__ */ __name(() => empty4(), "onNone"),
  onSome: /* @__PURE__ */ __name((a) => appendAll2(a, value6), "onSome")
})))), "sequentialCollectionCombine");
var sequentialCollectionKeys = /* @__PURE__ */ __name((self2) => Array.from(keys3(self2.map)), "sequentialCollectionKeys");
var sequentialCollectionToChunk = /* @__PURE__ */ __name((self2) => Array.from(self2.map), "sequentialCollectionToChunk");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/deferred.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/deferred.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var pending = /* @__PURE__ */ __name((joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
}, "pending");
var done = /* @__PURE__ */ __name((effect4) => {
  return {
    _tag: OP_STATE_DONE,
    effect: effect4
  };
}, "done");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/singleShotGen.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SingleShotGen2 = class _SingleShotGen {
  static {
    __name(this, "SingleShotGen");
  }
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new _SingleShotGen(this.self);
  }
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/core.js
var blocked = /* @__PURE__ */ __name((blockedRequests, _continue3) => {
  const effect4 = new EffectPrimitive("Blocked");
  effect4.effect_instruction_i0 = blockedRequests;
  effect4.effect_instruction_i1 = _continue3;
  return effect4;
}, "blocked");
var runRequestBlock = /* @__PURE__ */ __name((blockedRequests) => {
  const effect4 = new EffectPrimitive("RunBlocked");
  effect4.effect_instruction_i0 = blockedRequests;
  return effect4;
}, "runRequestBlock");
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");
var RevertFlags = class {
  static {
    __name(this, "RevertFlags");
  }
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch12, op) {
    this.patch = patch12;
    this.op = op;
  }
};
var EffectPrimitive = class {
  static {
    __name(this, "EffectPrimitive");
  }
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveFailure = class {
  static {
    __name(this, "EffectPrimitiveFailure");
  }
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var EffectPrimitiveSuccess = class {
  static {
    __name(this, "EffectPrimitiveSuccess");
  }
  _op;
  effect_instruction_i0 = void 0;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  trace = void 0;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
    equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(
      // @ts-expect-error
      string2(this._tag),
      // @ts-expect-error
      combine(hash(this.effect_instruction_i0)),
      cached(this)
    );
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
};
var isEffect = /* @__PURE__ */ __name((u) => hasProperty(u, EffectTypeId2), "isEffect");
var withFiberRuntime = /* @__PURE__ */ __name((withRuntime) => {
  const effect4 = new EffectPrimitive(OP_WITH_RUNTIME);
  effect4.effect_instruction_i0 = withRuntime;
  return effect4;
}, "withFiberRuntime");
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use3, release2) => uninterruptibleMask((restore) => flatMap10(acquire, (a) => flatMap10(exit2(suspend(() => restore(use3(a)))), (exit5) => {
  return suspend(() => release2(a, exit5)).pipe(matchCauseEffect({
    onFailure: /* @__PURE__ */ __name((cause3) => {
      switch (exit5._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit5.effect_instruction_i0, cause3));
        case OP_SUCCESS:
          return failCause(cause3);
      }
    }, "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => exit5, "onSuccess")
  }));
}))));
var as3 = /* @__PURE__ */ dual(2, (self2, value6) => flatMap10(self2, () => succeed(value6)));
var asVoid2 = /* @__PURE__ */ __name((self2) => as3(self2, void 0), "asVoid");
var custom = /* @__PURE__ */ __name(function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
}, "custom");
var unsafeAsync = /* @__PURE__ */ __name((register, blockingOn = none4) => {
  const effect4 = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = void 0;
  effect4.effect_instruction_i0 = (resume2) => {
    cancelerRef = register(resume2);
  };
  effect4.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect4, (_) => isEffect(cancelerRef) ? cancelerRef : void_3);
}, "unsafeAsync");
var asyncInterrupt = /* @__PURE__ */ __name((register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn)), "asyncInterrupt");
var async_ = /* @__PURE__ */ __name((resume2, blockingOn = none4) => {
  return custom(resume2, function() {
    let backingResume = void 0;
    let pendingEffect = void 0;
    function proxyResume(effect5) {
      if (backingResume) {
        backingResume(effect5);
      } else if (pendingEffect === void 0) {
        pendingEffect = effect5;
      }
    }
    __name(proxyResume, "proxyResume");
    const effect4 = new EffectPrimitive(OP_ASYNC);
    effect4.effect_instruction_i0 = (resume3) => {
      backingResume = resume3;
      if (pendingEffect) {
        resume3(pendingEffect);
      }
    };
    effect4.effect_instruction_i1 = blockingOn;
    let cancelerRef = void 0;
    let controllerRef = void 0;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController();
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect4, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_3;
    }) : effect4;
  });
}, "async_");
var catchAllCause = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect4 = new EffectPrimitive(OP_ON_FAILURE);
  effect4.effect_instruction_i0 = self2;
  effect4.effect_instruction_i1 = f;
  return effect4;
});
var catchAll = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self2, predicate, f) => catchAllCause(self2, (cause3) => {
  const either12 = failureOrCause(cause3);
  switch (either12._tag) {
    case "Left":
      return predicate(either12.left) ? f(either12.left) : failCause(cause3);
    case "Right":
      return failCause(either12.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause3) => {
  const either12 = failureOrCause(cause3);
  switch (either12._tag) {
    case "Left":
      return pipe(pf(either12.left), getOrElse2(() => failCause(cause3)));
    case "Right":
      return failCause(either12.right);
  }
}));
var checkInterruptible = /* @__PURE__ */ __name((f) => withFiberRuntime((_, status3) => f(interruption(status3.runtimeFlags))), "checkInterruptible");
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var originalInstance = /* @__PURE__ */ __name((obj) => {
  if (hasProperty(obj, originalSymbol)) {
    return obj[originalSymbol];
  }
  return obj;
}, "originalInstance");
var capture = /* @__PURE__ */ __name((obj, span4) => {
  if (isSome2(span4)) {
    return new Proxy(obj, {
      has(target3, p) {
        return p === spanSymbol || p === originalSymbol || p in target3;
      },
      get(target3, p) {
        if (p === spanSymbol) {
          return span4.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target3[p];
      }
    });
  }
  return obj;
}, "capture");
var die2 = /* @__PURE__ */ __name((defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect)), "die");
var dieMessage = /* @__PURE__ */ __name((message) => failCauseSync(() => die(new RuntimeException(message))), "dieMessage");
var dieSync = /* @__PURE__ */ __name((evaluate3) => flatMap10(sync(evaluate3), die2), "dieSync");
var either2 = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
  onFailure: /* @__PURE__ */ __name((e) => succeed(left2(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed(right2(a)), "onSuccess")
}), "either");
var exit2 = /* @__PURE__ */ __name((self2) => matchCause(self2, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
}), "exit");
var fail2 = /* @__PURE__ */ __name((error5) => isObject(error5) && !(spanSymbol in error5) ? withFiberRuntime((fiber) => failCause(fail(capture(error5, currentSpanFromFiber(fiber))))) : failCause(fail(error5)), "fail");
var failSync = /* @__PURE__ */ __name((evaluate3) => flatMap10(sync(evaluate3), fail2), "failSync");
var failCause = /* @__PURE__ */ __name((cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
}, "failCause");
var failCauseSync = /* @__PURE__ */ __name((evaluate3) => flatMap10(sync(evaluate3), failCause), "failCauseSync");
var fiberId = /* @__PURE__ */ withFiberRuntime((state2) => succeed(state2.id()));
var fiberIdWith = /* @__PURE__ */ __name((f) => withFiberRuntime((state2) => f(state2.id())), "fiberIdWith");
var flatMap10 = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS);
  effect4.effect_instruction_i0 = self2;
  effect4.effect_instruction_i1 = f;
  return effect4;
});
var andThen5 = /* @__PURE__ */ dual(2, (self2, f) => flatMap10(self2, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((a2) => resume2(succeed(a2)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = /* @__PURE__ */ __name((self2) => {
  const effect4 = new EffectPrimitive("OnStep");
  effect4.effect_instruction_i0 = self2;
  return effect4;
}, "step");
var flatten6 = /* @__PURE__ */ __name((self2) => flatMap10(self2, identity), "flatten");
var flip2 = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
  onFailure: succeed,
  onSuccess: fail2
}), "flip");
var matchCause = /* @__PURE__ */ dual(2, (self2, options4) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => succeed(options4.onFailure(cause3)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed(options4.onSuccess(a)), "onSuccess")
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self2, options4) => {
  const effect4 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect4.effect_instruction_i0 = self2;
  effect4.effect_instruction_i1 = options4.onFailure;
  effect4.effect_instruction_i2 = options4.onSuccess;
  return effect4;
});
var matchEffect = /* @__PURE__ */ dual(2, (self2, options4) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => {
    const defects3 = defects(cause3);
    if (defects3.length > 0) {
      return failCause(electFailures(cause3));
    }
    const failures3 = failures(cause3);
    if (failures3.length > 0) {
      return options4.onFailure(unsafeHead2(failures3));
    }
    return failCause(cause3);
  }, "onFailure"),
  onSuccess: options4.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable2(self2);
  const ret = allocate(arr.length);
  let i = 0;
  return as3(whileLoop({
    while: /* @__PURE__ */ __name(() => i < arr.length, "while"),
    body: /* @__PURE__ */ __name(() => f(arr[i], i), "body"),
    step: /* @__PURE__ */ __name((b) => {
      ret[i++] = b;
    }, "step")
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable2(self2);
  let i = 0;
  return whileLoop({
    while: /* @__PURE__ */ __name(() => i < arr.length, "while"),
    body: /* @__PURE__ */ __name(() => f(arr[i], i), "body"),
    step: /* @__PURE__ */ __name(() => {
      i++;
    }, "step")
  });
}));
var if_ = /* @__PURE__ */ dual((args2) => typeof args2[0] === "boolean" || isEffect(args2[0]), (self2, options4) => isEffect(self2) ? flatMap10(self2, (b) => b ? options4.onTrue() : options4.onFalse()) : self2 ? options4.onTrue() : options4.onFalse());
var interrupt2 = /* @__PURE__ */ flatMap10(fiberId, (fiberId5) => interruptWith(fiberId5));
var interruptWith = /* @__PURE__ */ __name((fiberId5) => failCause(interrupt(fiberId5)), "interruptWith");
var interruptible2 = /* @__PURE__ */ __name((self2) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = () => self2;
  return effect4;
}, "interruptible");
var interruptibleMask = /* @__PURE__ */ __name((f) => custom(f, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = enable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
}), "interruptibleMask");
var intoDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => uninterruptibleMask((restore) => flatMap10(exit2(restore(self2)), (exit5) => deferredDone(deferred, exit5))));
var map12 = /* @__PURE__ */ dual(2, (self2, f) => flatMap10(self2, (a) => sync(() => f(a))));
var mapBoth2 = /* @__PURE__ */ dual(2, (self2, options4) => matchEffect(self2, {
  onFailure: /* @__PURE__ */ __name((e) => failSync(() => options4.onFailure(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => sync(() => options4.onSuccess(a)), "onSuccess")
}));
var mapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => {
    const either12 = failureOrCause(cause3);
    switch (either12._tag) {
      case "Left": {
        return failSync(() => f(either12.left));
      }
      case "Right": {
        return failCause(either12.right);
      }
    }
  }, "onFailure"),
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, (exit5) => exitIsSuccess(exit5) ? void_3 : cleanup(exit5.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self2, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: /* @__PURE__ */ __name((cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: /* @__PURE__ */ __name((cause22) => exitFailCause(sequential(cause1, cause22)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => result, "onSuccess")
    });
  }, "onFailure"),
  onSuccess: /* @__PURE__ */ __name((success) => {
    const result = exitSucceed(success);
    return zipRight2(cleanup(result), result);
  }, "onSuccess")
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, exitMatch({
  onFailure: /* @__PURE__ */ __name((cause3) => isInterruptedOnly(cause3) ? asVoid2(cleanup(interruptors(cause3))) : void_3, "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => void_3, "onSuccess")
})));
var orElse3 = /* @__PURE__ */ dual(2, (self2, that) => attemptOrElse(self2, that, succeed));
var orDie = /* @__PURE__ */ __name((self2) => orDieWith(self2, identity), "orDie");
var orDieWith = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: /* @__PURE__ */ __name((e) => die2(f(e)), "onFailure"),
  onSuccess: succeed
}));
var partitionMap4 = partitionMap2;
var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status3) => succeed(status3.runtimeFlags));
var succeed = /* @__PURE__ */ __name((value6) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value6;
  return effect4;
}, "succeed");
var suspend = /* @__PURE__ */ __name((evaluate3) => {
  const effect4 = new EffectPrimitive(OP_COMMIT);
  effect4.commit = evaluate3;
  return effect4;
}, "suspend");
var sync = /* @__PURE__ */ __name((thunk) => {
  const effect4 = new EffectPrimitive(OP_SYNC);
  effect4.effect_instruction_i0 = thunk;
  return effect4;
}, "sync");
var tap2 = /* @__PURE__ */ dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && "onlyEffect" in args2[1]), (self2, f) => flatMap10(self2, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as3(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume2) => {
      b.then((_) => resume2(succeed(a)), (e) => resume2(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = /* @__PURE__ */ __name((f) => withFiberRuntime((state2) => {
  const scopeOverride = state2.getFiberRef(currentForkScopeOverride);
  const scope5 = pipe(scopeOverride, getOrElse2(() => state2.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some3(scope5)));
}), "transplant");
var attemptOrElse = /* @__PURE__ */ dual(3, (self2, that, onSuccess) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => {
    const defects3 = defects(cause3);
    if (defects3.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause3)));
    }
    return that();
  }, "onFailure"),
  onSuccess
}));
var uninterruptible = /* @__PURE__ */ __name((self2) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = () => self2;
  return effect4;
}, "uninterruptible");
var uninterruptibleMask = /* @__PURE__ */ __name((f) => custom(f, function() {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = disable3(Interruption);
  effect4.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect4;
}), "uninterruptibleMask");
var void_3 = /* @__PURE__ */ succeed(void 0);
var updateRuntimeFlags = /* @__PURE__ */ __name((patch12) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = patch12;
  effect4.effect_instruction_i1 = void 0;
  return effect4;
}, "updateRuntimeFlags");
var whenEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap10(condition, (b) => {
  if (b) {
    return pipe(self2, map12(some3));
  }
  return succeed(none2());
}));
var whileLoop = /* @__PURE__ */ __name((options4) => {
  const effect4 = new EffectPrimitive(OP_WHILE);
  effect4.effect_instruction_i0 = options4.while;
  effect4.effect_instruction_i1 = options4.body;
  effect4.effect_instruction_i2 = options4.step;
  return effect4;
}, "whileLoop");
var fromIterator = /* @__PURE__ */ __name((iterator) => suspend(() => {
  const effect4 = new EffectPrimitive(OP_ITERATOR);
  effect4.effect_instruction_i0 = iterator();
  return effect4;
}), "fromIterator");
var gen3 = /* @__PURE__ */ __name(function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
}, "gen");
var fnUntraced = /* @__PURE__ */ __name((body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
  return fromIterator(() => body.apply(this, args2));
} : function(...args2) {
  let effect4 = fromIterator(() => body.apply(this, args2));
  for (const x of pipeables) {
    effect4 = x(effect4, ...args2);
  }
  return effect4;
}, "length", {
  value: body.length,
  configurable: true
}), "fnUntraced");
var withConcurrency = /* @__PURE__ */ dual(2, (self2, concurrency) => fiberRefLocally(self2, currentConcurrency, concurrency));
var withRequestBatching = /* @__PURE__ */ dual(2, (self2, requestBatching) => fiberRefLocally(self2, currentRequestBatching, requestBatching));
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self2, update9) => {
  const effect4 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect4.effect_instruction_i0 = update9;
  effect4.effect_instruction_i1 = () => self2;
  return effect4;
});
var withTracerEnabled = /* @__PURE__ */ dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerEnabled, enabled2));
var withTracerTiming = /* @__PURE__ */ dual(2, (effect4, enabled2) => fiberRefLocally(effect4, currentTracerTimingEnabled, enabled2));
var yieldNow = /* @__PURE__ */ __name((options4) => {
  const effect4 = new EffectPrimitive(OP_YIELD);
  return typeof options4?.priority !== "undefined" ? withSchedulingPriority(effect4, options4.priority) : effect4;
}, "yieldNow");
var zip3 = /* @__PURE__ */ dual(2, (self2, that) => flatMap10(self2, (a) => map12(that, (b) => [a, b])));
var zipLeft2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap10(self2, (a) => as3(that, a)));
var zipRight2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap10(self2, () => that));
var zipWith5 = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap10(self2, (a) => map12(that, (b) => f(a, b))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = /* @__PURE__ */ __name((self2) => flatMap10(fiberId, (fiberId5) => pipe(self2, interruptAsFiber(fiberId5))), "interruptFiber");
var interruptAsFiber = /* @__PURE__ */ dual(2, (self2, fiberId5) => flatMap10(self2.interruptAsFork(fiberId5), () => self2.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 5e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 4e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 3e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 2e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var allLogLevels = [logLevelAll, logLevelTrace, logLevelDebug, logLevelInfo, logLevelWarning, logLevelError, logLevelFatal, logLevelNone];
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var fiberRefGet = /* @__PURE__ */ __name((self2) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self2))), "fiberRefGet");
var fiberRefGetAndSet = /* @__PURE__ */ dual(2, (self2, value6) => fiberRefModify(self2, (v) => [v, value6]));
var fiberRefGetAndUpdate = /* @__PURE__ */ dual(2, (self2, f) => fiberRefModify(self2, (v) => [v, f(v)]));
var fiberRefGetAndUpdateSome = /* @__PURE__ */ dual(2, (self2, pf) => fiberRefModify(self2, (v) => [v, getOrElse2(pf(v), () => v)]));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self2, f) => flatMap10(fiberRefGet(self2), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self2, value6) => fiberRefModify(self2, () => [void 0, value6]));
var fiberRefDelete = /* @__PURE__ */ __name((self2) => withFiberRuntime((state2) => {
  state2.unsafeDeleteFiberRef(self2);
  return void_3;
}), "fiberRefDelete");
var fiberRefReset = /* @__PURE__ */ __name((self2) => fiberRefSet(self2, self2.initial), "fiberRefReset");
var fiberRefModify = /* @__PURE__ */ dual(2, (self2, f) => withFiberRuntime((state2) => {
  const [b, a] = f(state2.getFiberRef(self2));
  state2.setFiberRef(self2, a);
  return succeed(b);
}));
var fiberRefModifySome = /* @__PURE__ */ __name((self2, def, f) => fiberRefModify(self2, (v) => getOrElse2(f(v), () => [def, v])), "fiberRefModifySome");
var fiberRefUpdate = /* @__PURE__ */ dual(2, (self2, f) => fiberRefModify(self2, (v) => [void 0, f(v)]));
var fiberRefUpdateSome = /* @__PURE__ */ dual(2, (self2, pf) => fiberRefModify(self2, (v) => [void 0, getOrElse2(pf(v), () => v)]));
var fiberRefUpdateAndGet = /* @__PURE__ */ dual(2, (self2, f) => fiberRefModify(self2, (v) => {
  const result = f(v);
  return [result, result];
}));
var fiberRefUpdateSomeAndGet = /* @__PURE__ */ dual(2, (self2, pf) => fiberRefModify(self2, (v) => {
  const result = getOrElse2(pf(v), () => v);
  return [result, result];
}));
var RequestResolverSymbolKey = "effect/RequestResolver";
var RequestResolverTypeId = /* @__PURE__ */ Symbol.for(RequestResolverSymbolKey);
var requestResolverVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var RequestResolverImpl = class _RequestResolverImpl {
  static {
    __name(this, "RequestResolverImpl");
  }
  runAll;
  target;
  [RequestResolverTypeId] = requestResolverVariance;
  constructor(runAll, target3) {
    this.runAll = runAll;
    this.target = target3;
  }
  [symbol]() {
    return cached(this, this.target ? hash(this.target) : random(this));
  }
  [symbol2](that) {
    return this.target ? isRequestResolver(that) && equals(this.target, that.target) : this === that;
  }
  identified(...ids3) {
    return new _RequestResolverImpl(this.runAll, fromIterable3(ids3));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isRequestResolver = /* @__PURE__ */ __name((u) => hasProperty(u, RequestResolverTypeId), "isRequestResolver");
var fiberRefLocally = /* @__PURE__ */ dual(3, (use3, self2, value6) => acquireUseRelease(zipLeft2(fiberRefGet(self2), fiberRefSet(self2, value6)), () => use3, (oldValue) => fiberRefSet(self2, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use3, self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocally(use3, self2, f(a))));
var fiberRefUnsafeMake = /* @__PURE__ */ __name((initial, options4) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options4?.fork ?? identity,
  join: options4?.join
}), "fiberRefUnsafeMake");
var fiberRefUnsafeMakeHashSet = /* @__PURE__ */ __name((initial) => {
  const differ3 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
}, "fiberRefUnsafeMakeHashSet");
var fiberRefUnsafeMakeReadonlyArray = /* @__PURE__ */ __name((initial) => {
  const differ3 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
}, "fiberRefUnsafeMakeReadonlyArray");
var fiberRefUnsafeMakeContext = /* @__PURE__ */ __name((initial) => {
  const differ3 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ3,
    fork: differ3.empty
  });
}, "fiberRefUnsafeMakeContext");
var fiberRefUnsafeMakePatch = /* @__PURE__ */ __name((initial, options4) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: /* @__PURE__ */ __name((oldValue, newValue) => options4.differ.diff(oldValue, newValue), "diff"),
    combine: /* @__PURE__ */ __name((first2, second) => options4.differ.combine(first2, second), "combine"),
    patch: /* @__PURE__ */ __name((patch12) => (oldValue) => options4.differ.patch(patch12, oldValue), "patch"),
    fork: options4.fork,
    join: options4.join ?? ((_, n) => n)
  };
  return _fiberRef;
}, "fiberRefUnsafeMakePatch");
var fiberRefUnsafeMakeRuntimeFlags = /* @__PURE__ */ __name((initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
}), "fiberRefUnsafeMakeRuntimeFlags");
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty10()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty11()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty12()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self2, scheduler2) => fiberRefLocally(self2, currentSchedulingPriority, scheduler2));
var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self2, scheduler2) => fiberRefLocally(self2, currentMaxOpsBeforeYield, scheduler2));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some3(logLevelDebug)));
var currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some3(logLevelWarning)));
var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(self2, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty3()));
var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: /* @__PURE__ */ __name(() => none2(), "fork"),
  join: /* @__PURE__ */ __name((parent, _) => parent, "join")
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty8, {
  fork: /* @__PURE__ */ __name(() => empty8, "fork"),
  join: /* @__PURE__ */ __name((parent, _) => parent, "join")
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty11()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty4()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = /* @__PURE__ */ __name((self2, finalizer3) => self2.addFinalizer(() => asVoid2(finalizer3)), "scopeAddFinalizer");
var scopeAddFinalizerExit = /* @__PURE__ */ __name((self2, finalizer3) => self2.addFinalizer(finalizer3), "scopeAddFinalizerExit");
var scopeClose = /* @__PURE__ */ __name((self2, exit5) => self2.close(exit5), "scopeClose");
var scopeFork = /* @__PURE__ */ __name((self2, strategy) => self2.fork(strategy), "scopeFork");
var causeSquash = /* @__PURE__ */ __name((self2) => {
  return causeSquashWith(identity)(self2);
}, "causeSquash");
var causeSquashWith = /* @__PURE__ */ dual(2, (self2, f) => {
  const option9 = pipe(self2, failureOption, map2(f));
  switch (option9._tag) {
    case "None": {
      return pipe(defects(self2), head3, match2({
        onNone: /* @__PURE__ */ __name(() => {
          const interrupts = fromIterable2(interruptors(self2)).flatMap((fiberId5) => fromIterable2(ids2(fiberId5)).map((id4) => `#${id4}`));
          return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
        }, "onNone"),
        onSome: identity
      }));
    }
    case "Some": {
      return option9.value;
    }
  }
});
var YieldableError = /* @__PURE__ */ (function() {
  class YieldableError3 extends globalThis.Error {
    static {
      __name(this, "YieldableError");
    }
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message) obj.message = this.message;
      if (this.cause) obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError3.prototype, StructuralCommitPrototype);
  return YieldableError3;
})();
var makeException = /* @__PURE__ */ __name((proto14, tag8) => {
  class Base4 extends YieldableError {
    static {
      __name(this, "Base");
    }
    _tag = tag8;
  }
  Object.assign(Base4.prototype, proto14);
  Base4.prototype.name = tag8;
  return Base4;
}, "makeException");
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var isRuntimeException = /* @__PURE__ */ __name((u) => hasProperty(u, RuntimeExceptionTypeId), "isRuntimeException");
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = /* @__PURE__ */ __name((u) => hasProperty(u, InterruptedExceptionTypeId), "isInterruptedException");
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var isIllegalArgumentException = /* @__PURE__ */ __name((u) => hasProperty(u, IllegalArgumentExceptionTypeId), "isIllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = /* @__PURE__ */ __name((u) => hasProperty(u, NoSuchElementExceptionTypeId), "isNoSuchElementException");
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var isExceededCapacityException = /* @__PURE__ */ __name((u) => hasProperty(u, ExceededCapacityExceptionTypeId), "isExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = /* @__PURE__ */ __name((duration4) => new TimeoutException(`Operation timed out after '${format2(duration4)}'`), "timeoutExceptionFromDuration");
var isTimeoutException = /* @__PURE__ */ __name((u) => hasProperty(u, TimeoutExceptionTypeId), "isTimeoutException");
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ (function() {
  class UnknownException3 extends YieldableError {
    static {
      __name(this, "UnknownException");
    }
    _tag = "UnknownException";
    error;
    constructor(cause3, message) {
      super(message ?? "An unknown error occurred", {
        cause: cause3
      });
      this.error = cause3;
    }
  }
  Object.assign(UnknownException3.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException3;
})();
var isUnknownException = /* @__PURE__ */ __name((u) => hasProperty(u, UnknownExceptionTypeId), "isUnknownException");
var exitIsExit = /* @__PURE__ */ __name((u) => isEffect(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure"), "exitIsExit");
var exitIsFailure = /* @__PURE__ */ __name((self2) => self2._tag === "Failure", "exitIsFailure");
var exitIsSuccess = /* @__PURE__ */ __name((self2) => self2._tag === "Success", "exitIsSuccess");
var exitIsInterrupted = /* @__PURE__ */ __name((self2) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return isInterrupted(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return false;
  }
}, "exitIsInterrupted");
var exitAs = /* @__PURE__ */ dual(2, (self2, value6) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value6);
    }
  }
});
var exitAsVoid = /* @__PURE__ */ __name((self2) => exitAs(self2, void 0), "exitAsVoid");
var exitCauseOption = /* @__PURE__ */ __name((self2) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return some3(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return none2();
  }
}, "exitCauseOption");
var exitCollectAll = /* @__PURE__ */ __name((exits, options4) => exitCollectAllInternal(exits, options4?.parallel ? parallel : sequential), "exitCollectAll");
var exitDie = /* @__PURE__ */ __name((defect) => exitFailCause(die(defect)), "exitDie");
var exitExists = /* @__PURE__ */ dual(2, (self2, refinement) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return false;
    case OP_SUCCESS:
      return refinement(self2.effect_instruction_i0);
  }
});
var exitFail = /* @__PURE__ */ __name((error5) => exitFailCause(fail(error5)), "exitFail");
var exitFailCause = /* @__PURE__ */ __name((cause3) => {
  const effect4 = new EffectPrimitiveFailure(OP_FAILURE);
  effect4.effect_instruction_i0 = cause3;
  return effect4;
}, "exitFailCause");
var exitFlatMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f(self2.effect_instruction_i0);
    }
  }
});
var exitFlatMapEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self2.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return f(self2.effect_instruction_i0);
    }
  }
});
var exitFlatten = /* @__PURE__ */ __name((self2) => pipe(self2, exitFlatMap(identity)), "exitFlatten");
var exitForEachEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return succeed(exitFailCause(self2.effect_instruction_i0));
    }
    case OP_SUCCESS: {
      return exit2(f(self2.effect_instruction_i0));
    }
  }
});
var exitFromEither = /* @__PURE__ */ __name((either12) => {
  switch (either12._tag) {
    case "Left":
      return exitFail(either12.left);
    case "Right":
      return exitSucceed(either12.right);
  }
}, "exitFromEither");
var exitFromOption = /* @__PURE__ */ __name((option9) => {
  switch (option9._tag) {
    case "None":
      return exitFail(void 0);
    case "Some":
      return exitSucceed(option9.value);
  }
}, "exitFromOption");
var exitGetOrElse = /* @__PURE__ */ dual(2, (self2, orElse19) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return orElse19(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return self2.effect_instruction_i0;
  }
});
var exitInterrupt = /* @__PURE__ */ __name((fiberId5) => exitFailCause(interrupt(fiberId5)), "exitInterrupt");
var exitMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self2.effect_instruction_i0));
  }
});
var exitMapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self2.effect_instruction_i0, map10(onFailure)));
    case OP_SUCCESS:
      return exitSucceed(onSuccess(self2.effect_instruction_i0));
  }
});
var exitMapError = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(pipe(self2.effect_instruction_i0, map10(f)));
    case OP_SUCCESS:
      return exitSucceed(self2.effect_instruction_i0);
  }
});
var exitMapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(f(self2.effect_instruction_i0));
    case OP_SUCCESS:
      return exitSucceed(self2.effect_instruction_i0);
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitSucceed = /* @__PURE__ */ __name((value6) => {
  const effect4 = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect4.effect_instruction_i0 = value6;
  return effect4;
}, "exitSucceed");
var exitVoid = /* @__PURE__ */ exitSucceed(void 0);
var exitZip = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: /* @__PURE__ */ __name((a, a2) => [a, a2], "onSuccess"),
  onFailure: sequential
}));
var exitZipLeft = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: /* @__PURE__ */ __name((a, _) => a, "onSuccess"),
  onFailure: sequential
}));
var exitZipRight = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: /* @__PURE__ */ __name((_, a2) => a2, "onSuccess"),
  onFailure: sequential
}));
var exitZipPar = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: /* @__PURE__ */ __name((a, a2) => [a, a2], "onSuccess"),
  onFailure: parallel
}));
var exitZipParLeft = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: /* @__PURE__ */ __name((a, _) => a, "onSuccess"),
  onFailure: parallel
}));
var exitZipParRight = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
  onSuccess: /* @__PURE__ */ __name((_, a2) => a2, "onSuccess"),
  onFailure: parallel
}));
var exitZipWith = /* @__PURE__ */ dual(3, (self2, that, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self2.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self2.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self2.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = /* @__PURE__ */ __name((exits, combineCauses) => {
  const list = fromIterable3(exits);
  if (!isNonEmpty(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current2) => pipe(accumulator, exitZipWith(current2, {
    onSuccess: /* @__PURE__ */ __name((list2, value6) => pipe(list2, prepend2(value6)), "onSuccess"),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk4) => toReadonlyArray(chunk4)), some3);
}, "exitCollectAllInternal");
var deferredUnsafeMake = /* @__PURE__ */ __name((fiberId5) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make13(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId5
  };
  return _deferred;
}, "deferredUnsafeMake");
var deferredMake = /* @__PURE__ */ __name(() => flatMap10(fiberId, (id4) => deferredMakeAs(id4)), "deferredMake");
var deferredMakeAs = /* @__PURE__ */ __name((fiberId5) => sync(() => deferredUnsafeMake(fiberId5)), "deferredMakeAs");
var deferredAwait = /* @__PURE__ */ __name((self2) => asyncInterrupt((resume2) => {
  const state2 = get7(self2.state);
  switch (state2._tag) {
    case OP_STATE_DONE: {
      return resume2(state2.effect);
    }
    case OP_STATE_PENDING: {
      state2.joiners.push(resume2);
      return deferredInterruptJoiner(self2, resume2);
    }
  }
}, self2.blockingOn), "deferredAwait");
var deferredComplete = /* @__PURE__ */ dual(2, (self2, effect4) => intoDeferred(effect4, self2));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self2, effect4) => sync(() => {
  const state2 = get7(self2.state);
  switch (state2._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set2(self2.state, done(effect4));
      for (let i = 0, len = state2.joiners.length; i < len; i++) {
        state2.joiners[i](effect4);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self2, exit5) => deferredCompleteWith(self2, exit5));
var deferredFail = /* @__PURE__ */ dual(2, (self2, error5) => deferredCompleteWith(self2, fail2(error5)));
var deferredFailSync = /* @__PURE__ */ dual(2, (self2, evaluate3) => deferredCompleteWith(self2, failSync(evaluate3)));
var deferredFailCause = /* @__PURE__ */ dual(2, (self2, cause3) => deferredCompleteWith(self2, failCause(cause3)));
var deferredFailCauseSync = /* @__PURE__ */ dual(2, (self2, evaluate3) => deferredCompleteWith(self2, failCauseSync(evaluate3)));
var deferredDie = /* @__PURE__ */ dual(2, (self2, defect) => deferredCompleteWith(self2, die2(defect)));
var deferredDieSync = /* @__PURE__ */ dual(2, (self2, evaluate3) => deferredCompleteWith(self2, dieSync(evaluate3)));
var deferredInterrupt = /* @__PURE__ */ __name((self2) => flatMap10(fiberId, (fiberId5) => deferredCompleteWith(self2, interruptWith(fiberId5))), "deferredInterrupt");
var deferredInterruptWith = /* @__PURE__ */ dual(2, (self2, fiberId5) => deferredCompleteWith(self2, interruptWith(fiberId5)));
var deferredIsDone = /* @__PURE__ */ __name((self2) => sync(() => get7(self2.state)._tag === OP_STATE_DONE), "deferredIsDone");
var deferredPoll = /* @__PURE__ */ __name((self2) => sync(() => {
  const state2 = get7(self2.state);
  switch (state2._tag) {
    case OP_STATE_DONE: {
      return some3(state2.effect);
    }
    case OP_STATE_PENDING: {
      return none2();
    }
  }
}), "deferredPoll");
var deferredSucceed = /* @__PURE__ */ dual(2, (self2, value6) => deferredCompleteWith(self2, succeed(value6)));
var deferredSync = /* @__PURE__ */ dual(2, (self2, evaluate3) => deferredCompleteWith(self2, sync(evaluate3)));
var deferredUnsafeDone = /* @__PURE__ */ __name((self2, effect4) => {
  const state2 = get7(self2.state);
  if (state2._tag === OP_STATE_PENDING) {
    set2(self2.state, done(effect4));
    for (let i = 0, len = state2.joiners.length; i < len; i++) {
      state2.joiners[i](effect4);
    }
  }
}, "deferredUnsafeDone");
var deferredInterruptJoiner = /* @__PURE__ */ __name((self2, joiner) => sync(() => {
  const state2 = get7(self2.state);
  if (state2._tag === OP_STATE_PENDING) {
    const index2 = state2.joiners.indexOf(joiner);
    if (index2 >= 0) {
      state2.joiners.splice(index2, 1);
    }
  }
}), "deferredInterruptJoiner");
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context2 = /* @__PURE__ */ __name(() => constContext, "context");
var contextWithEffect = /* @__PURE__ */ __name((f) => flatMap10(context2(), f), "contextWithEffect");
var provideContext = /* @__PURE__ */ dual(2, (self2, context17) => fiberRefLocally(currentContext, context17)(self2));
var provideSomeContext = /* @__PURE__ */ dual(2, (self2, context17) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context17))(self2));
var mapInputContext = /* @__PURE__ */ dual(2, (self2, f) => contextWithEffect((context17) => provideContext(self2, f(context17))));
var filterEffectOrElse = /* @__PURE__ */ dual(2, (self2, options4) => flatMap10(self2, (a) => flatMap10(options4.predicate(a), (pass) => pass ? succeed(a) : options4.orElse(a))));
var filterEffectOrFail = /* @__PURE__ */ dual(2, (self2, options4) => filterEffectOrElse(self2, {
  predicate: options4.predicate,
  orElse: /* @__PURE__ */ __name((a) => fail2(options4.orFailWith(a)), "orElse")
}));
var currentSpanFromFiber = /* @__PURE__ */ __name((fiber) => {
  const span4 = fiber.currentSpan;
  return span4 !== void 0 && span4._tag === "Span" ? some3(span4) : none2();
}, "currentSpanFromFiber");
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map(),
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = /* @__PURE__ */ __name((options4) => Object.assign(Object.create(NoopSpanProto), options4), "noopSpan");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/defaultServices.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/clock.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration4) {
    const millis2 = toMillis(duration4);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ (function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined" || typeof performance.now !== "function") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === void 0) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
})();
var processOrPerformanceNow = /* @__PURE__ */ (function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
})();
var ClockImpl = class {
  static {
    __name(this, "ClockImpl");
  }
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration4) {
    return async_((resume2) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_3), duration4);
      return asVoid2(sync(canceler));
    });
  }
};
var make20 = /* @__PURE__ */ __name(() => new ClockImpl(), "make");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/configProvider.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Number.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Order2 = number3;
var clamp4 = /* @__PURE__ */ clamp(Order2);
var remainder = /* @__PURE__ */ dual(2, (dividend, divisor) => {
  const selfDecCount = (dividend.toString().split(".")[1] || "").length;
  const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
  const selfInt = parseInt(dividend.toFixed(decCount).replace(".", ""));
  const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
  return selfInt % divisorInt / Math.pow(10, decCount);
});
var nextPow2 = /* @__PURE__ */ __name((n) => {
  const nextPow = Math.ceil(Math.log(n) / Math.log(2));
  return Math.max(Math.pow(2, nextPow), 2);
}, "nextPow2");
var parse = /* @__PURE__ */ __name((s) => {
  if (s === "NaN") {
    return some2(NaN);
  }
  if (s === "Infinity") {
    return some2(Infinity);
  }
  if (s === "-Infinity") {
    return some2(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some2(n);
}, "parse");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/RegExp.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var escape = /* @__PURE__ */ __name((string7) => string7.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&"), "escape");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/configError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/configError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = /* @__PURE__ */ __name((self2, that) => {
  const error5 = Object.create(proto2);
  error5._op = OP_AND;
  error5.left = self2;
  error5.right = that;
  Object.defineProperty(error5, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error5, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error5;
}, "And");
var Or = /* @__PURE__ */ __name((self2, that) => {
  const error5 = Object.create(proto2);
  error5._op = OP_OR;
  error5.left = self2;
  error5.right = that;
  Object.defineProperty(error5, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error5, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error5;
}, "Or");
var InvalidData = /* @__PURE__ */ __name((path, message, options4 = {
  pathDelim: "."
}) => {
  const error5 = Object.create(proto2);
  error5._op = OP_INVALID_DATA;
  error5.path = path;
  error5.message = message;
  Object.defineProperty(error5, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options4.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error5;
}, "InvalidData");
var MissingData = /* @__PURE__ */ __name((path, message, options4 = {
  pathDelim: "."
}) => {
  const error5 = Object.create(proto2);
  error5._op = OP_MISSING_DATA;
  error5.path = path;
  error5.message = message;
  Object.defineProperty(error5, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options4.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error5;
}, "MissingData");
var SourceUnavailable = /* @__PURE__ */ __name((path, message, cause3, options4 = {
  pathDelim: "."
}) => {
  const error5 = Object.create(proto2);
  error5._op = OP_SOURCE_UNAVAILABLE;
  error5.path = path;
  error5.message = message;
  error5.cause = cause3;
  Object.defineProperty(error5, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options4.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error5;
}, "SourceUnavailable");
var Unsupported = /* @__PURE__ */ __name((path, message, options4 = {
  pathDelim: "."
}) => {
  const error5 = Object.create(proto2);
  error5._op = OP_UNSUPPORTED;
  error5.path = path;
  error5.message = message;
  Object.defineProperty(error5, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options4.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error5;
}, "Unsupported");
var prefixed = /* @__PURE__ */ dual(2, (self2, prefix) => {
  switch (self2._op) {
    case OP_AND: {
      return And(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self2.path], self2.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self2.path], self2.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self2.path], self2.message, self2.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self2.path], self2.message);
    }
  }
});
var IsMissingDataOnlyReducer = {
  andCase: /* @__PURE__ */ __name((_, left3, right3) => left3 && right3, "andCase"),
  orCase: /* @__PURE__ */ __name((_, left3, right3) => left3 && right3, "orCase"),
  invalidDataCase: constFalse,
  missingDataCase: constTrue,
  sourceUnavailableCase: constFalse,
  unsupportedCase: constFalse
};
var reduceWithContext2 = /* @__PURE__ */ dual(3, (self2, context17, reducer) => {
  const input = [self2];
  const output = [];
  while (input.length > 0) {
    const error5 = input.pop();
    switch (error5._op) {
      case OP_AND: {
        input.push(error5.right);
        input.push(error5.left);
        output.push(left2({
          _op: "AndCase"
        }));
        break;
      }
      case OP_OR: {
        input.push(error5.right);
        input.push(error5.left);
        output.push(left2({
          _op: "OrCase"
        }));
        break;
      }
      case OP_INVALID_DATA: {
        output.push(right2(reducer.invalidDataCase(context17, error5.path, error5.message)));
        break;
      }
      case OP_MISSING_DATA: {
        output.push(right2(reducer.missingDataCase(context17, error5.path, error5.message)));
        break;
      }
      case OP_SOURCE_UNAVAILABLE: {
        output.push(right2(reducer.sourceUnavailableCase(context17, error5.path, error5.message, error5.cause)));
        break;
      }
      case OP_UNSUPPORTED: {
        output.push(right2(reducer.unsupportedCase(context17, error5.path, error5.message)));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either12 = output.pop();
    switch (either12._op) {
      case "Left": {
        switch (either12.left._op) {
          case "AndCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.andCase(context17, left3, right3);
            accumulator.push(value6);
            break;
          }
          case "OrCase": {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value6 = reducer.orCase(context17, left3, right3);
            accumulator.push(value6);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either12.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var isMissingDataOnly = /* @__PURE__ */ __name((self2) => reduceWithContext2(self2, void 0, IsMissingDataOnlyReducer), "isMissingDataOnly");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var empty19 = {
  _tag: "Empty"
};
var patch5 = /* @__PURE__ */ dual(2, (path, patch12) => {
  let input = of3(patch12);
  let output = path;
  while (isCons(input)) {
    const patch13 = input.head;
    switch (patch13._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch13.first, cons(patch13.second, input.tail));
        break;
      }
      case "MapName": {
        output = map5(output, patch13.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch13.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head2(output), contains(patch13.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch13.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/config.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/configProvider.js
var concat = /* @__PURE__ */ __name((l, r) => [...l, ...r], "concat");
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make21 = /* @__PURE__ */ __name((options4) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options4
}), "make");
var makeFlat = /* @__PURE__ */ __name((options4) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options4.patch,
  load: /* @__PURE__ */ __name((path, config3, split6 = true) => options4.load(path, config3, split6), "load"),
  enumerateChildren: options4.enumerateChildren
}), "makeFlat");
var fromFlat = /* @__PURE__ */ __name((flat) => make21({
  load: /* @__PURE__ */ __name((config3) => flatMap10(fromFlatLoop(flat, empty3(), config3, false), (chunk4) => match2(head2(chunk4), {
    onNone: /* @__PURE__ */ __name(() => fail2(MissingData(empty3(), `Expected a single value having structure: ${config3}`)), "onNone"),
    onSome: succeed
  })), "load"),
  flattened: flat
}), "fromFlat");
var fromEnv = /* @__PURE__ */ __name((options4) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options4);
  const makePathString = /* @__PURE__ */ __name((path) => pipe(path, join(pathDelim)), "makePathString");
  const unmakePathString = /* @__PURE__ */ __name((pathString) => pathString.split(pathDelim), "unmakePathString");
  const getEnv = /* @__PURE__ */ __name(() => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {}, "getEnv");
  const load = /* @__PURE__ */ __name((path, primitive2, split6 = true) => {
    const pathString = makePathString(path);
    const current2 = getEnv();
    const valueOpt = pathString in current2 ? some3(current2[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap10((value6) => parsePrimitive(value6, path, primitive2, seqDelim, split6)));
  }, "load");
  const enumerateChildren = /* @__PURE__ */ __name((path) => sync(() => {
    const current2 = getEnv();
    const keys6 = Object.keys(current2);
    const keyPaths = keys6.map((value6) => unmakePathString(value6.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === void 0 || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable6(filteredKeyPaths);
  }), "enumerateChildren");
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty19
  }));
}, "fromEnv");
var extend2 = /* @__PURE__ */ __name((leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index2) => index2 >= right3.length ? none2() : some3([leftDef(index2), index2 + 1]));
  const rightPad = unfold(right3.length, (index2) => index2 >= left3.length ? none2() : some3([rightDef(index2), index2 + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
}, "extend");
var appendConfigPath = /* @__PURE__ */ __name((path, config3) => {
  let op = config3;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
}, "appendConfigPath");
var fromFlatLoop = /* @__PURE__ */ __name((flat, prefix, config3, split6) => {
  const op = config3;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split6));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split6)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split6), catchAll((error22) => fail2(Or(error1, error22))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split6));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split6), flatMap10(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split6));
    }
    case OP_PRIMITIVE: {
      return pipe(patch5(prefix, flat.patch), flatMap10((prefix2) => pipe(flat.load(prefix2, op, split6), flatMap10((values6) => {
        if (values6.length === 0) {
          const name = pipe(last(prefix2), getOrElse2(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values6);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch5(prefix, flat.patch), flatMap10((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap10(indicesFrom), flatMap10((indices) => {
        if (indices.length === 0) {
          return suspend(() => map12(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index2) => fromFlatLoop(flat, append(prefix, `[${index2}]`), op.config, true)), map12((chunkChunk) => {
          const flattened = flatten2(chunkChunk);
          if (flattened.length === 0) {
            return of(empty3());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch5(prefix, flat.patch), flatMap10((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap10((keys6) => {
        return pipe(keys6, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split6)), map12((matrix) => {
          if (matrix.length === 0) {
            return of(empty11());
          }
          return pipe(transpose(matrix), map5((values6) => fromIterable7(zip(fromIterable2(keys6), values6))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split6), either2, flatMap10((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split6), either2, flatMap10((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix, join("."));
          const fail22 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend2(fail22, fail22, pipe(left3.right, map5(right2)), pipe(right3.right, map5(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip3(left4, right4), map12(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
}, "fromFlatLoop");
var fromFlatLoopFail = /* @__PURE__ */ __name((prefix, path) => (index2) => left2(MissingData(prefix, `The element at index ${index2} in a sequence at path "${path}" was missing`)), "fromFlatLoopFail");
var splitPathString = /* @__PURE__ */ __name((text7, delim) => {
  const split6 = text7.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split6;
}, "splitPathString");
var parsePrimitive = /* @__PURE__ */ __name((text7, path, primitive2, delimiter, split6) => {
  if (!split6) {
    return pipe(primitive2.parse(text7), mapBoth2({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text7, delimiter), forEachSequential((char2) => primitive2.parse(char2.trim())), mapError(prefixed(path)));
}, "parsePrimitive");
var transpose = /* @__PURE__ */ __name((array7) => {
  return Object.keys(array7[0]).map((column4) => array7.map((row) => row[column4]));
}, "transpose");
var indicesFrom = /* @__PURE__ */ __name((quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth2({
  onFailure: /* @__PURE__ */ __name(() => empty3(), "onFailure"),
  onSuccess: sort(Order2)
}), either2, map12(merge)), "indicesFrom");
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = /* @__PURE__ */ __name((str) => {
  const match24 = str.match(QUOTED_INDEX_REGEX);
  if (match24 !== null) {
    const matchedIndex = match24[2];
    return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some3(matchedIndex) : none2(), flatMap2(parseInteger));
  }
  return none2();
}, "parseQuotedIndex");
var parseInteger = /* @__PURE__ */ __name((str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some3(parsedIndex);
}, "parseInteger");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/defaultServices/console.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId10]: TypeId10,
  assert(condition, ...args2) {
    return sync(() => {
      console.assert(condition, ...args2);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args2) {
    return sync(() => {
      console.debug(...args2);
    });
  },
  dir(item, options4) {
    return sync(() => {
      console.dir(item, options4);
    });
  },
  dirxml(...args2) {
    return sync(() => {
      console.dirxml(...args2);
    });
  },
  error(...args2) {
    return sync(() => {
      console.error(...args2);
    });
  },
  group(options4) {
    return options4?.collapsed ? sync(() => console.groupCollapsed(options4?.label)) : sync(() => console.group(options4?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args2) {
    return sync(() => {
      console.info(...args2);
    });
  },
  log(...args2) {
    return sync(() => {
      console.log(...args2);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args2) {
    return sync(() => {
      console.timeLog(label, ...args2);
    });
  },
  trace(...args2) {
    return sync(() => {
      console.trace(...args2);
    });
  },
  warn(...args2) {
    return sync(() => {
      console.warn(...args2);
    });
  },
  unsafe: console
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/random.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");
var RandomImpl = class {
  static {
    __name(this, "RandomImpl");
  }
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map12(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min6, max9) {
    return map12(this.next, (n) => (max9 - min6) * n + min6);
  }
  nextIntBetween(min6, max9) {
    return sync(() => this.PRNG.integer(max9 - min6) + min6);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var shuffleWith = /* @__PURE__ */ __name((elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap10((buffer4) => {
    const numbers = [];
    for (let i = buffer4.length; i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map12((k) => swap(buffer4, n - 1, k)))), as3(fromIterable3(buffer4)));
  })));
}, "shuffleWith");
var swap = /* @__PURE__ */ __name((buffer4, index1, index2) => {
  const tmp = buffer4[index1];
  buffer4[index1] = buffer4[index2];
  buffer4[index2] = tmp;
  return buffer4;
}, "swap");
var make22 = /* @__PURE__ */ __name((seed) => new RandomImpl(hash(seed)), "make");
var FixedRandomImpl = class {
  static {
    __name(this, "FixedRandomImpl");
  }
  values;
  [RandomTypeId] = RandomTypeId;
  index = 0;
  constructor(values6) {
    this.values = values6;
    if (values6.length === 0) {
      throw new Error("Requires at least one value");
    }
  }
  getNextValue() {
    const value6 = this.values[this.index];
    this.index = (this.index + 1) % this.values.length;
    return value6;
  }
  get next() {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "number") {
        return Math.max(0, Math.min(1, value6));
      }
      return hash(value6) / 2147483647;
    });
  }
  get nextBoolean() {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "boolean") {
        return value6;
      }
      return hash(value6) % 2 === 0;
    });
  }
  get nextInt() {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "number" && Number.isFinite(value6)) {
        return Math.round(value6);
      }
      return Math.abs(hash(value6));
    });
  }
  nextRange(min6, max9) {
    return map12(this.next, (n) => (max9 - min6) * n + min6);
  }
  nextIntBetween(min6, max9) {
    return sync(() => {
      const value6 = this.getNextValue();
      if (typeof value6 === "number" && Number.isFinite(value6)) {
        return Math.max(min6, Math.min(max9 - 1, Math.round(value6)));
      }
      const hash5 = Math.abs(hash(value6));
      return min6 + hash5 % (max9 - min6);
    });
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var fixed = /* @__PURE__ */ __name((values6) => new FixedRandomImpl(values6), "fixed");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/tracer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make23 = /* @__PURE__ */ __name((options4) => ({
  [TracerTypeId]: TracerTypeId,
  ...options4
}), "make");
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ (function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length5) {
    let result = "";
    for (let i = 0; i < length5; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
})();
var NativeSpan = class {
  static {
    __name(this, "NativeSpan");
  }
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context17, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context17;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = /* @__PURE__ */ new Map();
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit5) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit5,
      startTime: this.status.startTime
    };
  }
  attribute(key, value6) {
    this.attributes.set(key, value6);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
};
var nativeTracer = /* @__PURE__ */ make23({
  span: /* @__PURE__ */ __name((name, parent, context17, links, startTime, kind) => new NativeSpan(name, parent, context17, links, startTime, kind), "span"),
  context: /* @__PURE__ */ __name((f) => f(), "context")
});
var externalSpan = /* @__PURE__ */ __name((options4) => ({
  _tag: "ExternalSpan",
  spanId: options4.spanId,
  traceId: options4.traceId,
  sampled: options4.sampled ?? true,
  context: options4.context ?? empty10()
}), "externalSpan");
var addSpanStackTrace = /* @__PURE__ */ __name((options4) => {
  if (options4?.captureStackTrace === false) {
    return options4;
  } else if (options4?.captureStackTrace !== void 0 && typeof options4.captureStackTrace !== "boolean") {
    return options4;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error();
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options4,
    captureStackTrace: /* @__PURE__ */ __name(() => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== void 0) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== void 0) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }, "captureStackTrace")
  };
}, "addSpanStackTrace");
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty10(), /* @__PURE__ */ add4(clockTag, /* @__PURE__ */ make20()), /* @__PURE__ */ add4(consoleTag, defaultConsole), /* @__PURE__ */ add4(randomTag, /* @__PURE__ */ make22(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add4(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add4(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = /* @__PURE__ */ __name((duration4) => {
  const decodedDuration = decode(duration4);
  return clockWith((clock3) => clock3.sleep(decodedDuration));
}, "sleep");
var defaultServicesWith = /* @__PURE__ */ __name((f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices)), "defaultServicesWith");
var clockWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key))), "clockWith");
var currentTimeMillis = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeMillis);
var currentTimeNanos = /* @__PURE__ */ clockWith((clock3) => clock3.currentTimeNanos);
var withClock = /* @__PURE__ */ dual(2, (effect4, c) => fiberRefLocallyWith(currentServices, add4(clockTag, c))(effect4));
var withConfigProvider = /* @__PURE__ */ dual(2, (self2, provider) => fiberRefLocallyWith(currentServices, add4(configProviderTag, provider))(self2));
var configProviderWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key))), "configProviderWith");
var config2 = /* @__PURE__ */ __name((config3) => configProviderWith((_) => _.load(config3)), "config");
var randomWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key))), "randomWith");
var withRandom = /* @__PURE__ */ dual(2, (effect4, value6) => fiberRefLocallyWith(currentServices, add4(randomTag, value6))(effect4));
var next = /* @__PURE__ */ randomWith((random4) => random4.next);
var tracerWith = /* @__PURE__ */ __name((f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key))), "tracerWith");
var withTracer = /* @__PURE__ */ dual(2, (effect4, value6) => fiberRefLocallyWith(currentServices, add4(tracerTag, value6))(effect4));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberRuntime.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Boolean.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var not2 = /* @__PURE__ */ __name((self2) => !self2, "not");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Effectable.js
var Effectable_exports = {};
__export(Effectable_exports, {
  ChannelTypeId: () => ChannelTypeId2,
  Class: () => Class2,
  CommitPrototype: () => CommitPrototype2,
  EffectPrototype: () => EffectPrototype2,
  EffectTypeId: () => EffectTypeId3,
  SinkTypeId: () => SinkTypeId2,
  StreamTypeId: () => StreamTypeId2,
  StructuralClass: () => StructuralClass,
  StructuralCommitPrototype: () => StructuralCommitPrototype2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var EffectTypeId3 = EffectTypeId;
var StreamTypeId2 = StreamTypeId;
var SinkTypeId2 = SinkTypeId;
var ChannelTypeId2 = ChannelTypeId;
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var StructuralCommitPrototype2 = StructuralCommitPrototype;
var Base2 = Base;
var StructuralBase2 = StructuralBase;
var Class2 = class extends Base2 {
  static {
    __name(this, "Class");
  }
};
var StructuralClass = class extends StructuralBase2 {
  static {
    __name(this, "StructuralClass");
  }
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ExecutionStrategy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/executionStrategy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = /* @__PURE__ */ __name((parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
}), "parallelN");
var isSequential = /* @__PURE__ */ __name((self2) => self2._tag === OP_SEQUENTIAL2, "isSequential");
var isParallel = /* @__PURE__ */ __name((self2) => self2._tag === OP_PARALLEL2, "isParallel");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberRefs.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberRefs.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function unsafeMake4(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
__name(unsafeMake4, "unsafeMake");
function empty20() {
  return unsafeMake4(/* @__PURE__ */ new Map());
}
__name(empty20, "empty");
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
var FiberRefsImpl = class {
  static {
    __name(this, "FiberRefsImpl");
  }
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var findAncestor = /* @__PURE__ */ __name((_ref, _parentStack, _childStack, _childModified = false) => {
  const ref2 = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = void 0;
  while (ret === void 0) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref2.initial, true];
    }
  }
  return ret;
}, "findAncestor");
var joinAs = /* @__PURE__ */ dual(3, (self2, fiberId5, that) => {
  const parentFiberRefs = new Map(self2.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId5)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId5, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch12 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch12)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId5)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId5, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self2, childId) => {
  const map38 = /* @__PURE__ */ new Map();
  unsafeForkAs(self2, map38, childId);
  return new FiberRefsImpl(map38);
});
var unsafeForkAs = /* @__PURE__ */ __name((self2, map38, fiberId5) => {
  self2.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map38.set(fiberRef, stack);
    } else {
      map38.set(fiberRef, [[fiberId5, newValue], ...stack]);
    }
  });
}, "unsafeForkAs");
var fiberRefs = /* @__PURE__ */ __name((self2) => fromIterable6(self2.locals.keys()), "fiberRefs");
var setAll = /* @__PURE__ */ __name((self2) => forEachSequentialDiscard(fiberRefs(self2), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self2, fiberRef))), "setAll");
var delete_ = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  const locals = new Map(self2.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get9 = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  if (!self2.locals.has(fiberRef)) {
    return none2();
  }
  return some3(headNonEmpty(self2.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self2, fiberRef) => pipe(get9(self2, fiberRef), getOrElse2(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self2, {
  fiberId: fiberId5,
  fiberRef,
  value: value6
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId5, value6]]]]));
  }
  const locals = new Map(self2.locals);
  unsafeUpdateAs(locals, fiberId5, fiberRef, value6);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = /* @__PURE__ */ __name((locals, fiberId5, fiberRef, value6) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId5)) {
      if (equals(currentValue, value6)) {
        return;
      } else {
        newStack = [[fiberId5, value6], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId5, value6], ...oldStack];
    }
  } else {
    newStack = [[fiberId5, value6]];
  }
  locals.set(fiberRef, newStack);
}, "unsafeUpdateAs");
var updateManyAs = /* @__PURE__ */ dual(2, (self2, {
  entries: entries3,
  forkAs: forkAs2
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries3));
  }
  const locals = new Map(self2.locals);
  if (forkAs2 !== void 0) {
    unsafeForkAs(self2, locals, forkAs2);
  }
  entries3.forEach(([fiberRef, values6]) => {
    if (values6.length === 1) {
      unsafeUpdateAs(locals, values6[0][0], fiberRef, values6[0][1]);
    } else {
      values6.forEach(([fiberId5, value6]) => {
        unsafeUpdateAs(locals, fiberId5, fiberRef, value6);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberRefs.js
var delete_2 = delete_;
var get10 = get9;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateAs2 = updateAs;
var updateManyAs2 = updateManyAs;
var empty21 = empty20;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberRefsPatch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberRefs/patch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty22 = {
  _tag: OP_EMPTY2
};
var diff5 = /* @__PURE__ */ __name((oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch12 = empty22;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== void 0) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch12 = combine7({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch12);
      }
    } else {
      patch12 = combine7({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch12);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch12 = combine7({
      _tag: OP_REMOVE,
      fiberRef
    })(patch12);
  }
  return patch12;
}, "diff");
var combine7 = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: OP_AND_THEN,
  first: self2,
  second: that
}));
var patch6 = /* @__PURE__ */ dual(3, (self2, fiberId5, oldValue) => {
  let fiberRefs3 = oldValue;
  let patches = of(self2);
  while (isNonEmptyReadonlyArray(patches)) {
    const head13 = headNonEmpty(patches);
    const tail3 = tailNonEmpty(patches);
    switch (head13._tag) {
      case OP_EMPTY2: {
        patches = tail3;
        break;
      }
      case OP_ADD: {
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId5,
          fiberRef: head13.fiberRef,
          value: head13.value
        });
        patches = tail3;
        break;
      }
      case OP_REMOVE: {
        fiberRefs3 = delete_(fiberRefs3, head13.fiberRef);
        patches = tail3;
        break;
      }
      case OP_UPDATE: {
        const value6 = getOrDefault(fiberRefs3, head13.fiberRef);
        fiberRefs3 = updateAs(fiberRefs3, {
          fiberId: fiberId5,
          fiberRef: head13.fiberRef,
          value: head13.fiberRef.patch(head13.patch)(value6)
        });
        patches = tail3;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head13.first)(prepend(head13.second)(tail3));
        break;
      }
    }
  }
  return fiberRefs3;
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberRefsPatch.js
var diff6 = diff5;
var patch7 = patch6;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberStatus.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberStatus.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string2(`${FiberStatusSymbolKey}-${OP_DONE}`);
var Done = class {
  static {
    __name(this, "Done");
  }
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
};
var Running = class {
  static {
    __name(this, "Running");
  }
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
};
var Suspended = class {
  static {
    __name(this, "Suspended");
  }
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
};
var done2 = /* @__PURE__ */ new Done();
var running = /* @__PURE__ */ __name((runtimeFlags2) => new Running(runtimeFlags2), "running");
var suspended = /* @__PURE__ */ __name((runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn), "suspended");
var isFiberStatus = /* @__PURE__ */ __name((u) => hasProperty(u, FiberStatusTypeId), "isFiberStatus");
var isDone = /* @__PURE__ */ __name((self2) => self2._tag === OP_DONE, "isDone");
var isRunning = /* @__PURE__ */ __name((self2) => self2._tag === OP_RUNNING, "isRunning");
var isSuspended = /* @__PURE__ */ __name((self2) => self2._tag === OP_SUSPENDED, "isSuspended");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberStatus.js
var done3 = done2;
var running2 = running;
var suspended2 = suspended;
var isDone2 = isDone;
var isRunning2 = isRunning;
var isSuspended2 = isSuspended;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/LogLevel.js
var LogLevel_exports = {};
__export(LogLevel_exports, {
  All: () => All,
  Debug: () => Debug,
  Error: () => Error2,
  Fatal: () => Fatal,
  Info: () => Info,
  None: () => None3,
  Order: () => Order3,
  Trace: () => Trace,
  Warning: () => Warning,
  allLevels: () => allLevels,
  fromLiteral: () => fromLiteral,
  greaterThan: () => greaterThan3,
  greaterThanEqual: () => greaterThanEqual,
  lessThan: () => lessThan3,
  lessThanEqual: () => lessThanEqual,
  locally: () => locally
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var allLevels = allLogLevels;
var locally = /* @__PURE__ */ dual(2, (use3, self2) => fiberRefLocally(use3, currentLogLevel, self2));
var Order3 = /* @__PURE__ */ pipe(Order2, /* @__PURE__ */ mapInput3((level) => level.ordinal));
var lessThan3 = /* @__PURE__ */ lessThan(Order3);
var lessThanEqual = /* @__PURE__ */ lessThanOrEqualTo(Order3);
var greaterThan3 = /* @__PURE__ */ greaterThan(Order3);
var greaterThanEqual = /* @__PURE__ */ greaterThanOrEqualTo(Order3);
var fromLiteral = /* @__PURE__ */ __name((literal2) => {
  switch (literal2) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
}, "fromLiteral");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Micro.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};
var MicroCauseImpl = class extends globalThis.Error {
  static {
    __name(this, "MicroCauseImpl");
  }
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError2, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError2 instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError2.name}`;
      message = originalError2.message;
      const messageLines = message.split("\n").length;
      stack = originalError2.stack ? `(${causeName}) ${originalError2.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError2, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `
    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
};
var Die = class extends MicroCauseImpl {
  static {
    __name(this, "Die");
  }
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
};
var causeDie = /* @__PURE__ */ __name((defect, traces = []) => new Die(defect, traces), "causeDie");
var Interrupt = class extends MicroCauseImpl {
  static {
    __name(this, "Interrupt");
  }
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
};
var causeInterrupt = /* @__PURE__ */ __name((traces = []) => new Interrupt(traces), "causeInterrupt");
var causeIsInterrupt = /* @__PURE__ */ __name((self2) => self2._tag === "Interrupt", "causeIsInterrupt");
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};
var MicroFiberImpl = class {
  static {
    __name(this, "MicroFiberImpl");
  }
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context17, interruptible5 = true) {
    this.context = context17;
    this.interruptible = interruptible5;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref2) {
    return unsafeGetReference(this.context, ref2);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index2 = this._observers.indexOf(cb);
      if (index2 >= 0) {
        this._observers.splice(index2, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect4) {
    if (this._exit) {
      return;
    } else if (this._yielded !== void 0) {
      const yielded = this._yielded;
      this._yielded = void 0;
      yielded();
    }
    const exit5 = this.runLoop(effect4);
    if (exit5 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== void 0) {
      return this.evaluate(flatMap11(interruptChildren, () => exit5));
    }
    this._exit = exit5;
    for (let i = 0; i < this._observers.length; i++) {
      this._observers[i](exit5);
    }
    this._observers.length = 0;
  }
  runLoop(effect4) {
    let yielding = false;
    let current2 = effect4;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current2;
          current2 = flatMap11(yieldNow2, () => prev);
        }
        current2 = current2[evaluate](this);
        if (current2 === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = void 0;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error5) {
      if (!hasProperty(current2, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current2)}`);
      }
      return exitDie2(error5);
    }
  }
  getCont(symbol6) {
    while (true) {
      const op = this._stack.pop();
      if (!op) return void 0;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont) return {
        [symbol6]: cont
      };
      if (op[symbol6]) return op;
    }
  }
  // cancel the yielded operation, or for the yielded exit value
  _yielded = void 0;
  yieldWith(value6) {
    this._yielded = value6;
    return Yield;
  }
  children() {
    return this._children ??= /* @__PURE__ */ new Set();
  }
};
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: void 0
}));
var fiberInterruptAll = /* @__PURE__ */ __name((fibers) => suspend2(() => {
  for (const fiber of fibers) fiber.unsafeInterrupt();
  const iter = fibers[Symbol.iterator]();
  const wait = suspend2(() => {
    let result = iter.next();
    while (!result.done) {
      if (result.value.unsafePoll()) {
        result = iter.next();
        continue;
      }
      const fiber = result.value;
      return async((resume2) => {
        fiber.addObserver((_) => {
          resume2(wait);
        });
      });
    }
    return exitVoid2;
  });
  return wait;
}), "fiberInterruptAll");
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId11]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : void 0
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
__name(defaultEvaluate, "defaultEvaluate");
var makePrimitiveProto = /* @__PURE__ */ __name((options4) => ({
  ...MicroProto,
  [identifier]: options4.op,
  [evaluate]: options4.eval ?? defaultEvaluate,
  [successCont]: options4.contA,
  [failureCont]: options4.contE,
  [ensureCont]: options4.ensure
}), "makePrimitiveProto");
var makePrimitive = /* @__PURE__ */ __name((options4) => {
  const Proto11 = makePrimitiveProto(options4);
  return function() {
    const self2 = Object.create(Proto11);
    self2[args] = options4.single === false ? arguments : arguments[0];
    return self2;
  };
}, "makePrimitive");
var makeExit = /* @__PURE__ */ __name((options4) => {
  const Proto11 = {
    ...makePrimitiveProto(options4),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options4.op,
    get [options4.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options4.op,
        [options4.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options4.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string2(options4.op))(hash(this[args])));
    }
  };
  return function(value6) {
    const self2 = Object.create(Proto11);
    self2[args] = value6;
    self2[successCont] = void 0;
    self2[failureCont] = void 0;
    self2[ensureCont] = void 0;
    return self2;
  };
}, "makeExit");
var succeed2 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause2 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var sync2 = /* @__PURE__ */ makePrimitive({
  op: "Sync",
  eval(fiber) {
    const value6 = this[args]();
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](value6, fiber) : fiber.yieldWith(exitSucceed2(value6));
  }
});
var suspend2 = /* @__PURE__ */ makePrimitive({
  op: "Suspend",
  eval(_fiber) {
    return this[args]();
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed) return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_4 = /* @__PURE__ */ succeed2(void 0);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var asyncOptions = /* @__PURE__ */ makePrimitive({
  op: "Async",
  single: false,
  eval(fiber) {
    const register = this[args][0];
    let resumed = false;
    let yielded = false;
    const controller = this[args][1] ? new AbortController() : void 0;
    const onCancel = register((effect4) => {
      if (resumed) return;
      resumed = true;
      if (yielded) {
        fiber.evaluate(effect4);
      } else {
        yielded = effect4;
      }
    }, controller?.signal);
    if (yielded !== false) return yielded;
    yielded = true;
    fiber._yielded = () => {
      resumed = true;
    };
    if (controller === void 0 && onCancel === void 0) {
      return Yield;
    }
    fiber._stack.push(asyncFinalizer(() => {
      resumed = true;
      controller?.abort();
      return onCancel ?? exitVoid2;
    }));
    return Yield;
  }
});
var asyncFinalizer = /* @__PURE__ */ makePrimitive({
  op: "AsyncFinalizer",
  ensure(fiber) {
    if (fiber.interruptible) {
      fiber.interruptible = false;
      fiber._stack.push(setInterruptible(true));
    }
  },
  contE(cause3, _fiber) {
    return causeIsInterrupt(cause3) ? flatMap11(this[args](), () => failCause2(cause3)) : failCause2(cause3);
  }
});
var async = /* @__PURE__ */ __name((register) => asyncOptions(register, register.length >= 2), "async");
var as4 = /* @__PURE__ */ dual(2, (self2, value6) => map13(self2, (_) => value6));
var exit3 = /* @__PURE__ */ __name((self2) => matchCause2(self2, {
  onFailure: exitFailCause2,
  onSuccess: exitSucceed2
}), "exit");
var flatMap11 = /* @__PURE__ */ dual(2, (self2, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self2;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var map13 = /* @__PURE__ */ dual(2, (self2, f) => flatMap11(self2, (a) => succeed2(f(a))));
var isMicroExit = /* @__PURE__ */ __name((u) => hasProperty(u, MicroExitTypeId), "isMicroExit");
var exitSucceed2 = succeed2;
var exitFailCause2 = failCause2;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = /* @__PURE__ */ __name((defect) => exitFailCause2(causeDie(defect)), "exitDie");
var exitVoid2 = /* @__PURE__ */ exitSucceed2(void 0);
var exitVoidAll = /* @__PURE__ */ __name((exits) => {
  for (const exit5 of exits) {
    if (exit5._tag === "Failure") {
      return exit5;
    }
  }
  return exitVoid2;
}, "exitVoidAll");
var setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
var MicroSchedulerDefault = class {
  static {
    __name(this, "MicroSchedulerDefault");
  }
  tasks = [];
  running = false;
  /**
   * @since 3.5.9
   */
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate(this.afterScheduled);
    }
  }
  /**
   * @since 3.5.9
   */
  afterScheduled = /* @__PURE__ */ __name(() => {
    this.running = false;
    this.runTasks();
  }, "afterScheduled");
  /**
   * @since 3.5.9
   */
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length; i < len; i++) {
      tasks[i]();
    }
  }
  /**
   * @since 3.5.9
   */
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  /**
   * @since 3.5.9
   */
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
};
var updateContext = /* @__PURE__ */ dual(2, (self2, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self2, () => {
    fiber.context = prev;
    return void_4;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self2, provided) => updateContext(self2, merge3(provided)));
var MaxOpsBeforeYield = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: /* @__PURE__ */ __name(() => 2048, "defaultValue")
})) {
  static {
    __name(this, "MaxOpsBeforeYield");
  }
};
var CurrentConcurrency = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentConcurrency", {
  defaultValue: /* @__PURE__ */ __name(() => "unbounded", "defaultValue")
})) {
  static {
    __name(this, "CurrentConcurrency");
  }
};
var CurrentScheduler = class extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: /* @__PURE__ */ __name(() => new MicroSchedulerDefault(), "defaultValue")
})) {
  static {
    __name(this, "CurrentScheduler");
  }
};
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self2, options4) => {
  const primitive2 = Object.create(OnSuccessAndFailureProto);
  primitive2[args] = self2;
  primitive2[successCont] = options4.onSuccess;
  primitive2[failureCont] = options4.onFailure;
  return primitive2;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var matchCause2 = /* @__PURE__ */ dual(2, (self2, options4) => matchCauseEffect2(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => sync2(() => options4.onFailure(cause3)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((value6) => sync2(() => options4.onSuccess(value6)), "onSuccess")
}));
var MicroScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroScope");
var MicroScopeImpl = class _MicroScopeImpl {
  static {
    __name(this, "MicroScopeImpl");
  }
  [MicroScopeTypeId];
  state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Set()
  };
  constructor() {
    this[MicroScopeTypeId] = MicroScopeTypeId;
  }
  unsafeAddFinalizer(finalizer3) {
    if (this.state._tag === "Open") {
      this.state.finalizers.add(finalizer3);
    }
  }
  addFinalizer(finalizer3) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        this.state.finalizers.add(finalizer3);
        return void_4;
      }
      return finalizer3(this.state.exit);
    });
  }
  unsafeRemoveFinalizer(finalizer3) {
    if (this.state._tag === "Open") {
      this.state.finalizers.delete(finalizer3);
    }
  }
  close(microExit) {
    return suspend2(() => {
      if (this.state._tag === "Open") {
        const finalizers = Array.from(this.state.finalizers).reverse();
        this.state = {
          _tag: "Closed",
          exit: microExit
        };
        return flatMap11(forEach7(finalizers, (finalizer3) => exit3(finalizer3(microExit))), exitVoidAll);
      }
      return void_4;
    });
  }
  get fork() {
    return sync2(() => {
      const newScope = new _MicroScopeImpl();
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      function fin(exit5) {
        return newScope.close(exit5);
      }
      __name(fin, "fin");
      this.state.finalizers.add(fin);
      newScope.unsafeAddFinalizer((_) => sync2(() => this.unsafeRemoveFinalizer(fin)));
      return newScope;
    });
  }
};
var onExit2 = /* @__PURE__ */ dual(2, (self2, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self2), {
  onFailure: /* @__PURE__ */ __name((cause3) => flatMap11(f(exitFailCause2(cause3)), () => failCause2(cause3)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => flatMap11(f(exitSucceed2(a)), () => succeed2(a)), "onSuccess")
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = /* @__PURE__ */ __name((self2) => withMicroFiber((fiber) => {
  if (fiber.interruptible) return self2;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted) return exitInterrupt2;
  return self2;
}), "interruptible");
var uninterruptibleMask2 = /* @__PURE__ */ __name((f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible) return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
}), "uninterruptibleMask");
var whileLoop2 = /* @__PURE__ */ makePrimitive({
  op: "While",
  contA(value6, fiber) {
    this[args].step(value6);
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  },
  eval(fiber) {
    if (this[args].while()) {
      fiber._stack.push(this);
      return this[args].body();
    }
    return exitVoid2;
  }
});
var forEach7 = /* @__PURE__ */ __name((iterable, f, options4) => withMicroFiber((parent) => {
  const concurrencyOption = options4?.concurrency === "inherit" ? parent.getRef(CurrentConcurrency) : options4?.concurrency ?? 1;
  const concurrency = concurrencyOption === "unbounded" ? Number.POSITIVE_INFINITY : Math.max(1, concurrencyOption);
  const items = fromIterable2(iterable);
  let length5 = items.length;
  if (length5 === 0) {
    return options4?.discard ? void_4 : succeed2([]);
  }
  const out = options4?.discard ? void 0 : new Array(length5);
  let index2 = 0;
  if (concurrency === 1) {
    return as4(whileLoop2({
      while: /* @__PURE__ */ __name(() => index2 < items.length, "while"),
      body: /* @__PURE__ */ __name(() => f(items[index2], index2), "body"),
      step: out ? (b) => out[index2++] = b : (_) => index2++
    }), out);
  }
  return async((resume2) => {
    const fibers = /* @__PURE__ */ new Set();
    let result = void 0;
    let inProgress = 0;
    let doneCount = 0;
    let pumping = false;
    let interrupted4 = false;
    function pump() {
      pumping = true;
      while (inProgress < concurrency && index2 < length5) {
        const currentIndex = index2;
        const item = items[currentIndex];
        index2++;
        inProgress++;
        try {
          const child = unsafeFork(parent, f(item, currentIndex), true, true);
          fibers.add(child);
          child.addObserver((exit5) => {
            fibers.delete(child);
            if (interrupted4) {
              return;
            } else if (exit5._tag === "Failure") {
              if (result === void 0) {
                result = exit5;
                length5 = index2;
                fibers.forEach((fiber) => fiber.unsafeInterrupt());
              }
            } else if (out !== void 0) {
              out[currentIndex] = exit5.value;
            }
            doneCount++;
            inProgress--;
            if (doneCount === length5) {
              resume2(result ?? succeed2(out));
            } else if (!pumping && inProgress < concurrency) {
              pump();
            }
          });
        } catch (err) {
          result = exitDie2(err);
          length5 = index2;
          fibers.forEach((fiber) => fiber.unsafeInterrupt());
        }
      }
      pumping = false;
    }
    __name(pump, "pump");
    pump();
    return suspend2(() => {
      interrupted4 = true;
      index2 = length5;
      return fiberInterruptAll(fibers);
    });
  });
}), "forEach");
var unsafeFork = /* @__PURE__ */ __name((parent, effect4, immediate = false, daemon = false) => {
  const child = new MicroFiberImpl(parent.context, parent.interruptible);
  if (!daemon) {
    parent.children().add(child);
    child.addObserver(() => parent.children().delete(child));
  }
  if (immediate) {
    child.evaluate(effect4);
  } else {
    parent.getRef(CurrentScheduler).scheduleTask(() => child.evaluate(effect4), 0);
  }
  return child;
}, "unsafeFork");
var runFork = /* @__PURE__ */ __name((effect4, options4) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options4?.scheduler ?? new MicroSchedulerDefault()));
  fiber.evaluate(effect4);
  if (options4?.signal) {
    if (options4.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort2 = /* @__PURE__ */ __name(() => fiber.unsafeInterrupt(), "abort");
      options4.signal.addEventListener("abort", abort2, {
        once: true
      });
      fiber.addObserver(() => options4.signal.removeEventListener("abort", abort2));
    }
  }
  return fiber;
}, "runFork");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Ref.js
var Ref_exports = {};
__export(Ref_exports, {
  RefTypeId: () => RefTypeId2,
  get: () => get12,
  getAndSet: () => getAndSet2,
  getAndUpdate: () => getAndUpdate2,
  getAndUpdateSome: () => getAndUpdateSome2,
  make: () => make26,
  modify: () => modify6,
  modifySome: () => modifySome2,
  set: () => set5,
  setAndGet: () => setAndGet2,
  unsafeMake: () => unsafeMake6,
  update: () => update3,
  updateAndGet: () => updateAndGet2,
  updateSome: () => updateSome2,
  updateSomeAndGet: () => updateSomeAndGet2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/ref.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Readable.js
var Readable_exports = {};
__export(Readable_exports, {
  TypeId: () => TypeId12,
  isReadable: () => isReadable,
  make: () => make24,
  map: () => map14,
  mapEffect: () => mapEffect,
  unwrap: () => unwrap
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId12 = /* @__PURE__ */ Symbol.for("effect/Readable");
var isReadable = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId12), "isReadable");
var Proto = {
  [TypeId12]: TypeId12,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make24 = /* @__PURE__ */ __name((get29) => {
  const self2 = Object.create(Proto);
  self2.get = get29;
  return self2;
}, "make");
var map14 = /* @__PURE__ */ dual(2, (self2, f) => make24(map12(self2.get, f)));
var mapEffect = /* @__PURE__ */ dual(2, (self2, f) => make24(flatMap10(self2.get, f)));
var unwrap = /* @__PURE__ */ __name((effect4) => make24(flatMap10(effect4, (s) => s.get)), "unwrap");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var RefImpl = class extends Class2 {
  static {
    __name(this, "RefImpl");
  }
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId12] = TypeId12;
  constructor(ref2) {
    super();
    this.ref = ref2;
    this.get = sync(() => get7(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current2 = get7(this.ref);
      const [b, a] = f(current2);
      if (current2 !== a) {
        set2(a)(this.ref);
      }
      return b;
    });
  }
};
var unsafeMake5 = /* @__PURE__ */ __name((value6) => new RefImpl(make13(value6)), "unsafeMake");
var make25 = /* @__PURE__ */ __name((value6) => sync(() => unsafeMake5(value6)), "make");
var get11 = /* @__PURE__ */ __name((self2) => self2.get, "get");
var set4 = /* @__PURE__ */ dual(2, (self2, value6) => self2.modify(() => [void 0, value6]));
var getAndSet = /* @__PURE__ */ dual(2, (self2, value6) => self2.modify((a) => [a, value6]));
var getAndUpdate = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [a, f(a)]));
var getAndUpdateSome = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value6) => {
  const option9 = pf(value6);
  switch (option9._tag) {
    case "None": {
      return [value6, value6];
    }
    case "Some": {
      return [value6, option9.value];
    }
  }
}));
var setAndGet = /* @__PURE__ */ dual(2, (self2, value6) => self2.modify(() => [value6, value6]));
var modify5 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
var modifySome = /* @__PURE__ */ dual(3, (self2, fallback, pf) => self2.modify((value6) => {
  const option9 = pf(value6);
  switch (option9._tag) {
    case "None": {
      return [fallback, value6];
    }
    case "Some": {
      return option9.value;
    }
  }
}));
var update2 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [void 0, f(a)]));
var updateAndGet = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => {
  const result = f(a);
  return [result, result];
}));
var updateSome = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [void 0, match2(f(a), {
  onNone: /* @__PURE__ */ __name(() => a, "onNone"),
  onSome: /* @__PURE__ */ __name((b) => b, "onSome")
})]));
var updateSomeAndGet = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value6) => {
  const option9 = pf(value6);
  switch (option9._tag) {
    case "None": {
      return [value6, value6];
    }
    case "Some": {
      return [option9.value, option9.value];
    }
  }
}));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Ref.js
var RefTypeId2 = RefTypeId;
var make26 = make25;
var get12 = get11;
var getAndSet2 = getAndSet;
var getAndUpdate2 = getAndUpdate;
var getAndUpdateSome2 = getAndUpdateSome;
var modify6 = modify5;
var modifySome2 = modifySome;
var set5 = set4;
var setAndGet2 = setAndGet;
var update3 = update2;
var updateAndGet2 = updateAndGet;
var updateSome2 = updateSome;
var updateSomeAndGet2 = updateSomeAndGet;
var unsafeMake6 = unsafeMake5;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Scheduler.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PriorityBuckets = class {
  static {
    __name(this, "PriorityBuckets");
  }
  /**
   * @since 2.0.0
   */
  buckets = [];
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    const length5 = this.buckets.length;
    let bucket = void 0;
    let index2 = 0;
    for (; index2 < length5; index2++) {
      if (this.buckets[index2][0] <= priority) {
        bucket = this.buckets[index2];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index2 === length5) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index2, 0, [priority, [task]]);
    }
  }
};
var MixedScheduler = class {
  static {
    __name(this, "MixedScheduler");
  }
  maxNextTickBeforeTimer;
  /**
   * @since 2.0.0
   */
  running = false;
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  /**
   * @since 2.0.0
   */
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0; i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  /**
   * @since 2.0.0
   */
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
};
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
var SyncScheduler = class {
  static {
    __name(this, "SyncScheduler");
  }
  /**
   * @since 2.0.0
   */
  tasks = /* @__PURE__ */ new PriorityBuckets();
  /**
   * @since 2.0.0
   */
  deferred = false;
  /**
   * @since 2.0.0
   */
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  /**
   * @since 2.0.0
   */
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  /**
   * @since 2.0.0
   */
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
};
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = /* @__PURE__ */ dual(2, (self2, scheduler2) => fiberRefLocally(self2, currentScheduler, scheduler2));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/completedRequestMap.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/concurrency.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var match7 = /* @__PURE__ */ __name((concurrency, sequential5, unbounded9, bounded9) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return unbounded9();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded9() : concurrency2 > 1 ? bounded9(concurrency2) : sequential5());
    default:
      return concurrency > 1 ? bounded9(concurrency) : sequential5();
  }
}, "match");
var matchSimple = /* @__PURE__ */ __name((concurrency, sequential5, concurrent) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential5());
    default:
      return concurrency > 1 ? concurrent() : sequential5();
  }
}, "matchSimple");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/core-effect.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Clock.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/LogSpan.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/logSpan.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var make27 = /* @__PURE__ */ __name((label, startTime) => ({
  label,
  startTime
}), "make");
var formatLabel = /* @__PURE__ */ __name((key) => key.replace(/[\s="]/g, "_"), "formatLabel");
var render = /* @__PURE__ */ __name((now2) => (self2) => {
  const label = formatLabel(self2.label);
  return `${label}=${now2 - self2.startTime}ms`;
}, "render");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/LogSpan.js
var make28 = make27;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Tracer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ParentSpan = spanTag;
var make29 = make23;
var externalSpan2 = externalSpan;
var tracerWith2 = tracerWith;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/label.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
var MetricLabelImpl = class {
  static {
    __name(this, "MetricLabelImpl");
  }
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value6) {
    this.key = key;
    this.value = value6;
    this._hash = string2(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make30 = /* @__PURE__ */ __name((key, value6) => {
  return new MetricLabelImpl(key, value6);
}, "make");
var isMetricLabel = /* @__PURE__ */ __name((u) => hasProperty(u, MetricLabelTypeId), "isMetricLabel");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set3(acc, key, value6), annotations3));
});
var asSome = /* @__PURE__ */ __name((self2) => map12(self2, some3), "asSome");
var asSomeError = /* @__PURE__ */ __name((self2) => mapError(self2, some3), "asSomeError");
var try_2 = /* @__PURE__ */ __name((arg) => {
  let evaluate3;
  let onFailure = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate3));
    } catch (error5) {
      return fail2(onFailure ? internalCall(() => onFailure(error5)) : new UnknownException(error5, "An unknown error occurred in Effect.try"));
    }
  });
}, "try_");
var _catch = /* @__PURE__ */ dual(3, (self2, tag8, options4) => catchAll(self2, (e) => {
  if (hasProperty(e, tag8) && e[tag8] === options4.failure) {
    return options4.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause3) => {
  const option9 = find(cause3, (_) => isDieType(_) ? some3(_) : none2());
  switch (option9._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      return f(option9.value.defect);
    }
  }
}));
var catchSomeCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => {
    const option9 = f(cause3);
    switch (option9._tag) {
      case "None": {
        return failCause(cause3);
      }
      case "Some": {
        return option9.value;
      }
    }
  }, "onFailure"),
  onSuccess: succeed
}));
var catchSomeDefect = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause3) => {
  const option9 = find(cause3, (_) => isDieType(_) ? some3(_) : none2());
  switch (option9._tag) {
    case "None": {
      return failCause(cause3);
    }
    case "Some": {
      const optionEffect = pf(option9.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause3);
    }
  }
}));
var catchTag = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, ...args2) => {
  const f = args2[args2.length - 1];
  let predicate;
  if (args2.length === 2) {
    predicate = isTagged(args2[0]);
  } else {
    predicate = /* @__PURE__ */ __name((e) => {
      const tag8 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
      if (!tag8) return false;
      for (let i = 0; i < args2.length - 1; i++) {
        if (args2[i] === tag8) return true;
      }
      return false;
    }, "predicate");
  }
  return catchIf(self2, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self2, cases) => {
  let keys6;
  return catchIf(self2, (e) => {
    keys6 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys6.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = /* @__PURE__ */ __name((self2) => matchCause(self2, {
  onFailure: identity,
  onSuccess: /* @__PURE__ */ __name(() => empty8, "onSuccess")
}), "cause");
var clockWith3 = clockWith2;
var clock = /* @__PURE__ */ clockWith3(succeed);
var delay = /* @__PURE__ */ dual(2, (self2, duration4) => zipRight2(sleep2(duration4), self2));
var descriptorWith = /* @__PURE__ */ __name((f) => withFiberRuntime((state2, status3) => f({
  id: state2.id(),
  status: status3,
  interruptors: interruptors(state2.getFiberRef(currentInterruptedCause))
})), "descriptorWith");
var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor3) => size4(descriptor3.interruptors) > 0 ? interrupt2 : void_3);
var descriptor = /* @__PURE__ */ descriptorWith(succeed);
var diffFiberRefs = /* @__PURE__ */ __name((self2) => summarized(self2, fiberRefs2, diff5), "diffFiberRefs");
var diffFiberRefsAndRuntimeFlags = /* @__PURE__ */ __name((self2) => summarized(self2, zip3(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff5(refs, refsNew), diff4(flags, flagsNew)]), "diffFiberRefsAndRuntimeFlags");
var Do4 = /* @__PURE__ */ succeed({});
var bind5 = /* @__PURE__ */ bind(map12, flatMap10);
var bindTo5 = /* @__PURE__ */ bindTo(map12);
var let_5 = /* @__PURE__ */ let_(map12);
var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next4;
  let dropping8 = succeed(false);
  let i = 0;
  while ((next4 = iterator.next()) && !next4.done) {
    const a = next4.value;
    const index2 = i++;
    dropping8 = flatMap10(dropping8, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index2);
    });
  }
  return map12(dropping8, () => builder);
}));
var dropWhile3 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next4;
  let dropping8 = succeed(true);
  let i = 0;
  while ((next4 = iterator.next()) && !next4.done) {
    const a = next4.value;
    const index2 = i++;
    dropping8 = flatMap10(dropping8, (d) => map12(d ? predicate(a, index2) : succeed(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map12(dropping8, () => builder);
}));
var contextWith = /* @__PURE__ */ __name((f) => map12(context2(), f), "contextWith");
var eventually = /* @__PURE__ */ __name((self2) => orElse3(self2, () => flatMap10(yieldNow(), () => eventually(self2))), "eventually");
var filterMap6 = /* @__PURE__ */ dual(2, (elements, pf) => map12(forEachSequential(elements, identity), filterMap2(pf)));
var filterOrDie = /* @__PURE__ */ dual(3, (self2, predicate, orDieWith8) => filterOrElse(self2, predicate, (a) => dieSync(() => orDieWith8(a))));
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self2, predicate, message) => filterOrElse(self2, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self2, predicate, orElse19) => flatMap10(self2, (a) => predicate(a) ? succeed(a) : orElse19(a)));
var liftPredicate4 = /* @__PURE__ */ dual(3, (self2, predicate, orFailWith) => suspend(() => predicate(self2) ? succeed(self2) : fail2(orFailWith(self2))));
var filterOrFail = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, predicate, orFailWith) => filterOrElse(self2, predicate, (a) => orFailWith === void 0 ? fail2(new NoSuchElementException()) : failSync(() => orFailWith(a))));
var findFirst6 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next4 = iterator.next();
  if (!next4.done) {
    return findLoop(iterator, 0, predicate, next4.value);
  }
  return succeed(none2());
}));
var findLoop = /* @__PURE__ */ __name((iterator, index2, f, value6) => flatMap10(f(value6, index2), (result) => {
  if (result) {
    return succeed(some3(value6));
  }
  const next4 = iterator.next();
  if (!next4.done) {
    return findLoop(iterator, index2 + 1, f, next4.value);
  }
  return succeed(none2());
}), "findLoop");
var firstSuccessOf = /* @__PURE__ */ __name((effects) => suspend(() => {
  const list = fromIterable3(effects);
  if (!isNonEmpty(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse3(left3, () => right3)));
}), "firstSuccessOf");
var flipWith = /* @__PURE__ */ dual(2, (self2, f) => flip2(f(flip2(self2))));
var match8 = /* @__PURE__ */ dual(2, (self2, options4) => matchEffect(self2, {
  onFailure: /* @__PURE__ */ __name((e) => succeed(options4.onFailure(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed(options4.onSuccess(a)), "onSuccess")
}));
var every8 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = /* @__PURE__ */ __name((iterator, index2, f) => {
  const next4 = iterator.next();
  return next4.done ? succeed(true) : flatMap10(f(next4.value, index2), (b) => b ? forAllLoop(iterator, index2 + 1, f) : succeed(b));
}, "forAllLoop");
var forever = /* @__PURE__ */ __name((self2) => {
  const loop5 = flatMap10(flatMap10(self2, () => yieldNow()), () => loop5);
  return loop5;
}, "forever");
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state2) => succeed(state2.getFiberRefs()));
var head4 = /* @__PURE__ */ __name((self2) => flatMap10(self2, (as16) => {
  const iterator = as16[Symbol.iterator]();
  const next4 = iterator.next();
  if (next4.done) {
    return fail2(new NoSuchElementException());
  }
  return succeed(next4.value);
}), "head");
var ignore = /* @__PURE__ */ __name((self2) => match8(self2, {
  onFailure: constVoid,
  onSuccess: constVoid
}), "ignore");
var ignoreLogged = /* @__PURE__ */ __name((self2) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => logDebug(cause3, "An error was silently ignored because it is not anticipated to be useful"), "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => void_3, "onSuccess")
}), "ignoreLogged");
var inheritFiberRefs = /* @__PURE__ */ __name((childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs)), "inheritFiberRefs");
var isFailure2 = /* @__PURE__ */ __name((self2) => match8(self2, {
  onFailure: constTrue,
  onSuccess: constFalse
}), "isFailure");
var isSuccess = /* @__PURE__ */ __name((self2) => match8(self2, {
  onFailure: constFalse,
  onSuccess: constTrue
}), "isSuccess");
var iterate = /* @__PURE__ */ __name((initial, options4) => suspend(() => {
  if (options4.while(initial)) {
    return flatMap10(options4.body(initial), (z2) => iterate(z2, options4));
  }
  return succeed(initial);
}), "iterate");
var logWithLevel = /* @__PURE__ */ __name((level) => (...message) => {
  const levelOption = fromNullable2(level);
  let cause3 = void 0;
  for (let i = 0, len = message.length; i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause3 !== void 0) {
        cause3 = sequential(cause3, msg);
      } else {
        cause3 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause3 === void 0) {
    cause3 = empty8;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause3, levelOption);
    return void_3;
  });
}, "logWithLevel");
var log3 = /* @__PURE__ */ logWithLevel();
var logTrace = /* @__PURE__ */ logWithLevel(Trace);
var logDebug = /* @__PURE__ */ logWithLevel(Debug);
var logInfo = /* @__PURE__ */ logWithLevel(Info);
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
var withLogSpan = /* @__PURE__ */ dual(2, (effect4, label) => flatMap10(currentTimeMillis2, (now2) => fiberRefLocallyWith(effect4, currentLogSpan, prepend3(make28(label, now2)))));
var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
var loop = /* @__PURE__ */ __name((initial, options4) => options4.discard ? loopDiscard(initial, options4.while, options4.step, options4.body) : map12(loopInternal(initial, options4.while, options4.step, options4.body), fromIterable2), "loop");
var loopInternal = /* @__PURE__ */ __name((initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap10(body(initial), (a) => map12(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty12())), "loopInternal");
var loopDiscard = /* @__PURE__ */ __name((initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap10(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_3), "loopDiscard");
var mapAccum3 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next4;
  let i = 0;
  while (!(next4 = iterator.next()).done) {
    const index2 = i++;
    const value6 = next4.value;
    result = flatMap10(result, (state2) => map12(f(state2, value6, index2), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map12(result, (z) => [z, builder]);
}));
var mapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((c) => failCauseSync(() => f(c)), "onFailure"),
  onSuccess: succeed
}));
var memoize = /* @__PURE__ */ __name((self2) => pipe(deferredMake(), flatMap10((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self2), intoDeferred(deferred), once2, map12((complete4) => zipRight2(complete4, pipe(deferredAwait(deferred), flatMap10(([patch12, a]) => as3(zip3(patchFiberRefs(patch12[0]), updateRuntimeFlags(patch12[1])), a)))))))), "memoize");
var merge5 = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
  onFailure: /* @__PURE__ */ __name((e) => succeed(e), "onFailure"),
  onSuccess: succeed
}), "merge");
var negate = /* @__PURE__ */ __name((self2) => map12(self2, (b) => !b), "negate");
var none6 = /* @__PURE__ */ __name((self2) => flatMap10(self2, (option9) => {
  switch (option9._tag) {
    case "None":
      return void_3;
    case "Some":
      return fail2(new NoSuchElementException());
  }
}), "none");
var once2 = /* @__PURE__ */ __name((self2) => map12(make26(true), (ref2) => asVoid2(whenEffect(self2, getAndSet2(ref2, false)))), "once");
var option = /* @__PURE__ */ __name((self2) => matchEffect(self2, {
  onFailure: /* @__PURE__ */ __name(() => succeed(none2()), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed(some3(a)), "onSuccess")
}), "option");
var orElseFail = /* @__PURE__ */ dual(2, (self2, evaluate3) => orElse3(self2, () => failSync(evaluate3)));
var orElseSucceed = /* @__PURE__ */ dual(2, (self2, evaluate3) => orElse3(self2, () => sync(evaluate3)));
var parallelErrors = /* @__PURE__ */ __name((self2) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => {
    const errors4 = fromIterable2(failures(cause3));
    return errors4.length === 0 ? failCause(cause3) : fail2(errors4);
  }, "onFailure"),
  onSuccess: succeed
}), "parallelErrors");
var patchFiberRefs = /* @__PURE__ */ __name((patch12) => updateFiberRefs((fiberId5, fiberRefs3) => pipe(patch12, patch6(fiberId5, fiberRefs3))), "patchFiberRefs");
var promise = /* @__PURE__ */ __name((evaluate3) => evaluate3.length >= 1 ? async_((resolve3, signal) => {
  try {
    evaluate3(signal).then((a) => resolve3(succeed(a)), (e) => resolve3(die2(e)));
  } catch (e) {
    resolve3(die2(e));
  }
}) : async_((resolve3) => {
  try {
    ;
    evaluate3().then((a) => resolve3(succeed(a)), (e) => resolve3(die2(e)));
  } catch (e) {
    resolve3(die2(e));
  }
}), "promise");
var provideService = /* @__PURE__ */ dual(3, (self2, tag8, service3) => contextWithEffect((env3) => provideContext(self2, add4(env3, tag8, service3))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self2, tag8, effect4) => contextWithEffect((env3) => flatMap10(effect4, (service3) => provideContext(self2, pipe(env3, add4(tag8, service3))))));
var random2 = /* @__PURE__ */ randomWith(succeed);
var reduce9 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable2(elements).reduce((acc, el, i) => flatMap10(acc, (a) => f(a, el, i)), succeed(zero3)));
var reduceRight3 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable2(elements).reduceRight((acc, el, i) => flatMap10(acc, (a) => f(el, a, i)), succeed(zero3)));
var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero3, options4) => flatMap10(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options4.while, options4.body)));
var reduceWhileLoop = /* @__PURE__ */ __name((iterator, index2, state2, predicate, f) => {
  const next4 = iterator.next();
  if (!next4.done && predicate(state2)) {
    return flatMap10(f(state2, next4.value, index2), (nextState) => reduceWhileLoop(iterator, index2 + 1, nextState, predicate, f));
  }
  return succeed(state2);
}, "reduceWhileLoop");
var repeatN = /* @__PURE__ */ dual(2, (self2, n) => suspend(() => repeatNLoop(self2, n)));
var repeatNLoop = /* @__PURE__ */ __name((self2, n) => flatMap10(self2, (a) => n <= 0 ? succeed(a) : zipRight2(yieldNow(), repeatNLoop(self2, n - 1))), "repeatNLoop");
var sandbox = /* @__PURE__ */ __name((self2) => matchCauseEffect(self2, {
  onFailure: fail2,
  onSuccess: succeed
}), "sandbox");
var setFiberRefs = /* @__PURE__ */ __name((fiberRefs3) => suspend(() => setAll2(fiberRefs3)), "setFiberRefs");
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var succeedSome = /* @__PURE__ */ __name((value6) => succeed(some3(value6)), "succeedSome");
var summarized = /* @__PURE__ */ dual(3, (self2, summary6, f) => flatMap10(summary6, (start3) => flatMap10(self2, (value6) => map12(summary6, (end6) => [f(start3, end6), value6]))));
var tagMetrics = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make30(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make30(k, v)));
});
var labelMetrics = /* @__PURE__ */ dual(2, (self2, labels) => fiberRefLocallyWith(self2, currentMetricLabels, (old) => union(old, labels)));
var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next4;
  let effect4 = succeed(false);
  let i = 0;
  while ((next4 = iterator.next()) && !next4.done) {
    const a = next4.value;
    const index2 = i++;
    effect4 = flatMap10(effect4, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index2);
    });
  }
  return map12(effect4, () => builder);
}));
var takeWhile3 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next4;
  let taking = succeed(true);
  let i = 0;
  while ((next4 = iterator.next()) && !next4.done) {
    const a = next4.value;
    const index2 = i++;
    taking = flatMap10(taking, (taking2) => pipe(taking2 ? predicate(a, index2) : succeed(false), map12((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map12(taking, () => builder);
}));
var tapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => {
    const either12 = failureOrCause(cause3);
    switch (either12._tag) {
      case "Left": {
        return zipRight2(onFailure(either12.left), failCause(cause3));
      }
      case "Right": {
        return failCause(cause3);
      }
    }
  }, "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => as3(onSuccess(a), a), "onSuccess")
}));
var tapDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause3) => match2(keepDefects(cause3), {
  onNone: /* @__PURE__ */ __name(() => failCause(cause3), "onNone"),
  onSome: /* @__PURE__ */ __name((a) => zipRight2(f(a), failCause(cause3)), "onSome")
})));
var tapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => {
    const either12 = failureOrCause(cause3);
    switch (either12._tag) {
      case "Left":
        return zipRight2(f(either12.left), failCause(cause3));
      case "Right":
        return failCause(cause3);
    }
  }, "onFailure"),
  onSuccess: succeed
}));
var tapErrorTag = /* @__PURE__ */ dual(3, (self2, k, f) => tapError(self2, (e) => {
  if (isTagged(e, k)) {
    return f(e);
  }
  return void_3;
}));
var tapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => zipRight2(f(cause3), failCause(cause3)), "onFailure"),
  onSuccess: succeed
}));
var timed = /* @__PURE__ */ __name((self2) => timedWith(self2, currentTimeNanos2), "timed");
var timedWith = /* @__PURE__ */ dual(2, (self2, nanos2) => summarized(self2, nanos2, (start3, end6) => nanos(end6 - start3)));
var tracerWith3 = tracerWith2;
var tracer = /* @__PURE__ */ tracerWith3(succeed);
var tryPromise = /* @__PURE__ */ __name((arg) => {
  let evaluate3;
  let catcher = void 0;
  if (typeof arg === "function") {
    evaluate3 = arg;
  } else {
    evaluate3 = arg.try;
    catcher = arg.catch;
  }
  const fail22 = /* @__PURE__ */ __name((e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise")), "fail");
  if (evaluate3.length >= 1) {
    return async_((resolve3, signal) => {
      try {
        evaluate3(signal).then((a) => resolve3(succeed(a)), (e) => resolve3(fail22(e)));
      } catch (e) {
        resolve3(fail22(e));
      }
    });
  }
  return async_((resolve3) => {
    try {
      evaluate3().then((a) => resolve3(succeed(a)), (e) => resolve3(fail22(e)));
    } catch (e) {
      resolve3(fail22(e));
    }
  });
}, "tryPromise");
var tryMap = /* @__PURE__ */ dual(2, (self2, options4) => flatMap10(self2, (a) => try_2({
  try: /* @__PURE__ */ __name(() => options4.try(a), "try"),
  catch: options4.catch
})));
var tryMapPromise = /* @__PURE__ */ dual(2, (self2, options4) => flatMap10(self2, (a) => tryPromise({
  try: options4.try.length >= 1 ? (signal) => options4.try(a, signal) : () => options4.try(a),
  catch: options4.catch
})));
var unless = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? succeedNone : asSome(self2)));
var unlessEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap10(condition, (b) => b ? succeedNone : asSome(self2)));
var unsandbox = /* @__PURE__ */ __name((self2) => mapErrorCause(self2, flatten4), "unsandbox");
var updateFiberRefs = /* @__PURE__ */ __name((f) => withFiberRuntime((state2) => {
  state2.setFiberRefs(f(state2.id(), state2.getFiberRefs()));
  return void_3;
}), "updateFiberRefs");
var updateService = /* @__PURE__ */ dual(3, (self2, tag8, f) => mapInputContext(self2, (context17) => add4(context17, tag8, f(unsafeGet5(context17, tag8)))));
var when = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? map12(self2, some3) : succeed(none2())));
var whenFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, predicate) => flatMap10(fiberRefGet(fiberRef), (s) => predicate(s) ? map12(self2, (a) => [s, some3(a)]) : succeed([s, none2()])));
var whenRef = /* @__PURE__ */ dual(3, (self2, ref2, predicate) => flatMap10(get12(ref2), (s) => predicate(s) ? map12(self2, (a) => [s, some3(a)]) : succeed([s, none2()])));
var withMetric = /* @__PURE__ */ dual(2, (self2, metric) => metric(self2));
var serviceFunctionEffect = /* @__PURE__ */ __name((getService, f) => (...args2) => flatMap10(getService, (a) => f(a)(...args2)), "serviceFunctionEffect");
var serviceFunction = /* @__PURE__ */ __name((getService, f) => (...args2) => map12(getService, (a) => f(a)(...args2)), "serviceFunction");
var serviceFunctions = /* @__PURE__ */ __name((getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args2) => flatMap10(getService, (s) => s[prop](...args2));
  }
}), "serviceFunctions");
var serviceConstants = /* @__PURE__ */ __name((getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap10(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
}), "serviceConstants");
var serviceMembers = /* @__PURE__ */ __name((getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
}), "serviceMembers");
var serviceOption = /* @__PURE__ */ __name((tag8) => map12(context2(), getOption2(tag8)), "serviceOption");
var serviceOptional = /* @__PURE__ */ __name((tag8) => flatMap10(context2(), getOption2(tag8)), "serviceOptional");
var annotateCurrentSpan = /* @__PURE__ */ __name(function() {
  const args2 = arguments;
  return ignore(flatMap10(currentSpan, (span4) => sync(() => {
    if (typeof args2[0] === "string") {
      span4.attribute(args2[0], args2[1]);
    } else {
      for (const key in args2[0]) {
        span4.attribute(key, args2[0][key]);
      }
    }
  })));
}, "annotateCurrentSpan");
var linkSpanCurrent = /* @__PURE__ */ __name(function() {
  const args2 = arguments;
  const links = Array.isArray(args2[0]) ? args2[0] : [{
    _tag: "SpanLink",
    span: args2[0],
    attributes: args2[1] ?? {}
  }];
  return ignore(flatMap10(currentSpan, (span4) => sync(() => span4.addLinks(links))));
}, "linkSpanCurrent");
var annotateSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set3(acc, key, value6), annotations3));
});
var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
var currentSpan = /* @__PURE__ */ flatMap10(/* @__PURE__ */ context2(), (context17) => {
  const span4 = context17.unsafeMap.get(spanTag.key);
  return span4 !== void 0 && span4._tag === "Span" ? succeed(span4) : fail2(new NoSuchElementException());
});
var linkSpans = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, span4, attributes) => fiberRefLocallyWith(self2, currentTracerSpanLinks, append2({
  _tag: "SpanLink",
  span: span4,
  attributes: attributes ?? {}
})));
var bigint02 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap2((span4) => get6(span4.context, DisablePropagation) ? span4._tag === "Span" ? filterDisablePropagation(span4.parent) : none2() : some3(span4));
var unsafeMakeSpan = /* @__PURE__ */ __name((fiber, name, options4) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options4.context && get6(options4.context, DisablePropagation);
  const context17 = fiber.getFiberRef(currentContext);
  const parent = options4.parent ? some3(options4.parent) : options4.root ? none2() : filterDisablePropagation(getOption2(context17, spanTag));
  let span4;
  if (disablePropagation) {
    span4 = noopSpan({
      name,
      parent,
      context: add4(options4.context ?? empty10(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer4 = get6(services, tracerTag);
    const clock3 = get6(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get10(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get10(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options4.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options4.links ?? []] : toReadonlyArray(linksFromEnv.value) : options4.links ?? empty3();
    span4 = tracer4.span(name, parent, options4.context ?? empty10(), links, timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, options4.kind ?? "internal", options4);
    if (annotationsFromEnv._tag === "Some") {
      forEach6(annotationsFromEnv.value, (value6, key) => span4.attribute(key, value6));
    }
    if (options4.attributes !== void 0) {
      Object.entries(options4.attributes).forEach(([k, v]) => span4.attribute(k, v));
    }
  }
  if (typeof options4.captureStackTrace === "function") {
    spanToTrace.set(span4, options4.captureStackTrace);
  }
  return span4;
}, "unsafeMakeSpan");
var makeSpan = /* @__PURE__ */ __name((name, options4) => {
  options4 = addSpanStackTrace(options4);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options4)));
}, "makeSpan");
var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
var endSpan = /* @__PURE__ */ __name((span4, exit5, clock3, timingEnabled) => sync(() => {
  if (span4.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit5) && spanToTrace.has(span4)) {
    span4.attribute("code.stacktrace", spanToTrace.get(span4)());
  }
  span4.end(timingEnabled ? clock3.unsafeCurrentTimeNanos() : bigint02, exit5);
}), "endSpan");
var useSpan = /* @__PURE__ */ __name((name, ...args2) => {
  const options4 = addSpanStackTrace(args2.length === 1 ? void 0 : args2[0]);
  const evaluate3 = args2[args2.length - 1];
  return withFiberRuntime((fiber) => {
    const span4 = unsafeMakeSpan(fiber, name, options4);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock3 = get6(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate3(span4), (exit5) => endSpan(span4, exit5, clock3, timingEnabled));
  });
}, "useSpan");
var withParentSpan = /* @__PURE__ */ dual(2, (self2, span4) => provideService(self2, spanTag, span4));
var withSpan = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options4 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return useSpan(name, options4, (span4) => withParentSpan(self2, span4));
  }
  return (self2) => useSpan(name, options4, (span4) => withParentSpan(self2, span4));
}, "withSpan");
var functionWithSpan = /* @__PURE__ */ __name((options4) => function() {
  let captureStackTrace = options4.captureStackTrace ?? false;
  if (options4.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error5 = new Error();
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = /* @__PURE__ */ __name(() => {
      if (cache !== false) {
        return cache;
      }
      if (error5.stack) {
        const stack = error5.stack.trim().split("\n");
        cache = stack.slice(2).join("\n").trim();
        return cache;
      }
    }, "captureStackTrace");
  }
  return suspend(() => {
    const opts = typeof options4.options === "function" ? options4.options.apply(null, arguments) : options4.options;
    return withSpan(suspend(() => internalCall(() => options4.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
}, "functionWithSpan");
var fromNullable4 = /* @__PURE__ */ __name((value6) => value6 == null ? fail2(new NoSuchElementException()) : succeed(value6), "fromNullable");
var optionFromOptional = /* @__PURE__ */ __name((self2) => catchAll(map12(self2, some3), (error5) => isNoSuchElementException(error5) ? succeedNone : fail2(error5)), "optionFromOptional");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiber.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Exit.js
var Exit_exports = {};
__export(Exit_exports, {
  all: () => all5,
  as: () => as5,
  asVoid: () => asVoid3,
  causeOption: () => causeOption,
  die: () => die3,
  exists: () => exists2,
  fail: () => fail3,
  failCause: () => failCause3,
  flatMap: () => flatMap12,
  flatMapEffect: () => flatMapEffect,
  flatten: () => flatten7,
  forEachEffect: () => forEachEffect,
  fromEither: () => fromEither,
  fromOption: () => fromOption4,
  getOrElse: () => getOrElse7,
  interrupt: () => interrupt3,
  isExit: () => isExit,
  isFailure: () => isFailure3,
  isInterrupted: () => isInterrupted2,
  isSuccess: () => isSuccess2,
  map: () => map15,
  mapBoth: () => mapBoth3,
  mapError: () => mapError2,
  mapErrorCause: () => mapErrorCause2,
  match: () => match9,
  matchEffect: () => matchEffect2,
  succeed: () => succeed3,
  void: () => void_5,
  zip: () => zip4,
  zipLeft: () => zipLeft3,
  zipPar: () => zipPar,
  zipParLeft: () => zipParLeft,
  zipParRight: () => zipParRight,
  zipRight: () => zipRight3,
  zipWith: () => zipWith6
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isExit = exitIsExit;
var isFailure3 = exitIsFailure;
var isSuccess2 = exitIsSuccess;
var isInterrupted2 = exitIsInterrupted;
var as5 = exitAs;
var asVoid3 = exitAsVoid;
var causeOption = exitCauseOption;
var all5 = exitCollectAll;
var die3 = exitDie;
var exists2 = exitExists;
var fail3 = exitFail;
var failCause3 = exitFailCause;
var flatMap12 = exitFlatMap;
var flatMapEffect = exitFlatMapEffect;
var flatten7 = exitFlatten;
var forEachEffect = exitForEachEffect;
var fromEither = exitFromEither;
var fromOption4 = exitFromOption;
var getOrElse7 = exitGetOrElse;
var interrupt3 = exitInterrupt;
var map15 = exitMap;
var mapBoth3 = exitMapBoth;
var mapError2 = exitMapError;
var mapErrorCause2 = exitMapErrorCause;
var match9 = exitMatch;
var matchEffect2 = exitMatchEffect;
var succeed3 = exitSucceed;
var void_5 = exitVoid;
var zip4 = exitZip;
var zipLeft3 = exitZipLeft;
var zipRight3 = exitZipRight;
var zipPar = exitZipPar;
var zipParLeft = exitZipParLeft;
var zipParRight = exitZipParRight;
var zipWith6 = exitZipWith;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberScope.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberMessage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = /* @__PURE__ */ __name((cause3) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause3
}), "interruptSignal");
var stateful = /* @__PURE__ */ __name((onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
}), "stateful");
var resume = /* @__PURE__ */ __name((effect4) => ({
  _tag: OP_RESUME,
  effect: effect4
}), "resume");
var yieldNow3 = /* @__PURE__ */ __name(() => ({
  _tag: OP_YIELD_NOW
}), "yieldNow");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
var Global = class {
  static {
    __name(this, "Global");
  }
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set();
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
};
var Local = class {
  static {
    __name(this, "Local");
  }
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId5, parent) {
    this.fiberId = fiberId5;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
};
var unsafeMake7 = /* @__PURE__ */ __name((fiber) => {
  return new Local(fiber.id(), fiber);
}, "unsafeMake");
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var Order4 = /* @__PURE__ */ pipe(/* @__PURE__ */ tuple2(Order2, Order2), /* @__PURE__ */ mapInput3((fiber) => [fiber.id().startTimeMillis, fiber.id().id]));
var isFiber = /* @__PURE__ */ __name((u) => hasProperty(u, FiberTypeId), "isFiber");
var isRuntimeFiber = /* @__PURE__ */ __name((self2) => RuntimeFiberTypeId in self2, "isRuntimeFiber");
var _await = /* @__PURE__ */ __name((self2) => self2.await, "_await");
var children = /* @__PURE__ */ __name((self2) => self2.children, "children");
var done4 = /* @__PURE__ */ __name((exit5) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: /* @__PURE__ */ __name(() => none4, "id"),
    await: succeed(exit5),
    children: succeed([]),
    inheritAll: void_3,
    poll: succeed(some3(exit5)),
    interruptAsFork: /* @__PURE__ */ __name(() => void_3, "interruptAsFork")
  };
  return _fiber;
}, "done");
var dump = /* @__PURE__ */ __name((self2) => map12(self2.status, (status3) => ({
  id: self2.id(),
  status: status3
})), "dump");
var dumpAll = /* @__PURE__ */ __name((fibers) => forEachSequential(fibers, dump), "dumpAll");
var fail4 = /* @__PURE__ */ __name((error5) => done4(fail3(error5)), "fail");
var failCause4 = /* @__PURE__ */ __name((cause3) => done4(failCause3(cause3)), "failCause");
var fromEffect = /* @__PURE__ */ __name((effect4) => map12(exit2(effect4), done4), "fromEffect");
var id = /* @__PURE__ */ __name((self2) => self2.id(), "id");
var inheritAll = /* @__PURE__ */ __name((self2) => self2.inheritAll, "inheritAll");
var interrupted = /* @__PURE__ */ __name((fiberId5) => done4(interrupt3(fiberId5)), "interrupted");
var interruptAll = /* @__PURE__ */ __name((fibers) => flatMap10(fiberId, (fiberId5) => pipe(fibers, interruptAllAs(fiberId5))), "interruptAll");
var interruptAllAs = /* @__PURE__ */ dual(2, /* @__PURE__ */ fnUntraced(function* (fibers, fiberId5) {
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber)) {
      fiber.unsafeInterruptAsFork(fiberId5);
      continue;
    }
    yield* fiber.interruptAsFork(fiberId5);
  }
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {
      continue;
    }
    yield* fiber.await;
  }
}));
var interruptAsFork = /* @__PURE__ */ dual(2, (self2, fiberId5) => self2.interruptAsFork(fiberId5));
var join3 = /* @__PURE__ */ __name((self2) => zipLeft2(flatten6(self2.await), self2.inheritAll), "join");
var map16 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect2(self2, (a) => sync(() => f(a))));
var mapEffect2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const _fiber = {
    ...CommitPrototype,
    commit() {
      return join3(this);
    },
    ...fiberProto,
    id: /* @__PURE__ */ __name(() => self2.id(), "id"),
    await: flatMap10(self2.await, forEachEffect(f)),
    children: self2.children,
    inheritAll: self2.inheritAll,
    poll: flatMap10(self2.poll, (result) => {
      switch (result._tag) {
        case "None":
          return succeed(none2());
        case "Some":
          return pipe(forEachEffect(result.value, f), map12(some3));
      }
    }),
    interruptAsFork: /* @__PURE__ */ __name((id4) => self2.interruptAsFork(id4), "interruptAsFork")
  };
  return _fiber;
});
var mapFiber = /* @__PURE__ */ dual(2, (self2, f) => map12(self2.await, match9({
  onFailure: /* @__PURE__ */ __name((cause3) => failCause4(cause3), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => f(a), "onSuccess")
})));
var match10 = /* @__PURE__ */ dual(2, (self2, {
  onFiber,
  onRuntimeFiber
}) => {
  if (isRuntimeFiber(self2)) {
    return onRuntimeFiber(self2);
  }
  return onFiber(self2);
});
var _never = {
  ...CommitPrototype,
  commit() {
    return join3(this);
  },
  ...fiberProto,
  id: /* @__PURE__ */ __name(() => none4, "id"),
  await: never,
  children: /* @__PURE__ */ succeed([]),
  inheritAll: never,
  poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
  interruptAsFork: /* @__PURE__ */ __name(() => never, "interruptAsFork")
};
var never2 = _never;
var orElse4 = /* @__PURE__ */ dual(2, (self2, that) => ({
  ...CommitPrototype,
  commit() {
    return join3(this);
  },
  ...fiberProto,
  id: /* @__PURE__ */ __name(() => getOrElse6(self2.id(), that.id()), "id"),
  await: zipWith5(self2.await, that.await, (exit1, exit22) => isSuccess2(exit1) ? exit1 : exit22),
  children: self2.children,
  inheritAll: zipRight2(that.inheritAll, self2.inheritAll),
  poll: zipWith5(self2.poll, that.poll, (option1, option22) => {
    switch (option1._tag) {
      case "None": {
        return none2();
      }
      case "Some": {
        return isSuccess2(option1.value) ? option1 : option22;
      }
    }
  }),
  interruptAsFork: /* @__PURE__ */ __name((id4) => pipe(interruptAsFiber(self2, id4), zipRight2(pipe(that, interruptAsFiber(id4))), asVoid2), "interruptAsFork")
}));
var orElseEither2 = /* @__PURE__ */ dual(2, (self2, that) => orElse4(map16(self2, left2), map16(that, right2)));
var poll = /* @__PURE__ */ __name((self2) => self2.poll, "poll");
var parseMs = /* @__PURE__ */ __name((milliseconds) => {
  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;
  return {
    days: roundTowardsZero(milliseconds / 864e5),
    hours: roundTowardsZero(milliseconds / 36e5) % 24,
    minutes: roundTowardsZero(milliseconds / 6e4) % 60,
    seconds: roundTowardsZero(milliseconds / 1e3) % 60,
    milliseconds: roundTowardsZero(milliseconds) % 1e3,
    microseconds: roundTowardsZero(milliseconds * 1e3) % 1e3,
    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1e3
  };
}, "parseMs");
var renderStatus = /* @__PURE__ */ __name((status3) => {
  if (isDone2(status3)) {
    return "Done";
  }
  if (isRunning2(status3)) {
    return "Running";
  }
  const isInterruptible = interruptible(status3.runtimeFlags) ? "interruptible" : "uninterruptible";
  return `Suspended(${isInterruptible})`;
}, "renderStatus");
var pretty2 = /* @__PURE__ */ __name((self2) => flatMap10(currentTimeMillis2, (now2) => map12(dump(self2), (dump3) => {
  const time4 = now2 - dump3.id.startTimeMillis;
  const {
    days: days2,
    hours: hours2,
    milliseconds,
    minutes: minutes2,
    seconds: seconds2
  } = parseMs(time4);
  const lifeMsg = (days2 === 0 ? "" : `${days2}d`) + (days2 === 0 && hours2 === 0 ? "" : `${hours2}h`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 ? "" : `${minutes2}m`) + (days2 === 0 && hours2 === 0 && minutes2 === 0 && seconds2 === 0 ? "" : `${seconds2}s`) + `${milliseconds}ms`;
  const waitMsg = isSuspended2(dump3.status) ? (() => {
    const ids3 = ids2(dump3.status.blockingOn);
    return size4(ids3) > 0 ? `waiting on ` + Array.from(ids3).map((id4) => `${id4}`).join(", ") : "";
  })() : "";
  const statusMsg = renderStatus(dump3.status);
  return `[Fiber](#${dump3.id.id}) (${lifeMsg}) ${waitMsg}
   Status: ${statusMsg}`;
})), "pretty");
var unsafeRoots = /* @__PURE__ */ __name(() => Array.from(globalScope.roots), "unsafeRoots");
var roots = /* @__PURE__ */ sync(unsafeRoots);
var status = /* @__PURE__ */ __name((self2) => self2.status, "status");
var succeed4 = /* @__PURE__ */ __name((value6) => done4(succeed3(value6)), "succeed");
var void_6 = /* @__PURE__ */ succeed4(void 0);
var currentFiberURI = "effect/FiberCurrent";
var getCurrentFiber = /* @__PURE__ */ __name(() => fromNullable2(globalThis[currentFiberURI]), "getCurrentFiber");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/logger.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  /* c8 ignore next */
  _Message: /* @__PURE__ */ __name((_) => _, "_Message"),
  /* c8 ignore next */
  _Output: /* @__PURE__ */ __name((_) => _, "_Output")
};
var makeLogger = /* @__PURE__ */ __name((log8) => ({
  [LoggerTypeId]: loggerVariance,
  log: log8,
  pipe() {
    return pipeArguments(this, arguments);
  }
}), "makeLogger");
var mapInput4 = /* @__PURE__ */ dual(2, (self2, f) => makeLogger((options4) => self2.log({
  ...options4,
  message: f(options4.message)
})));
var mapInputOptions = /* @__PURE__ */ dual(2, (self2, f) => makeLogger((options4) => self2.log(f(options4))));
var filterLogLevel = /* @__PURE__ */ dual(2, (self2, f) => makeLogger((options4) => f(options4.logLevel) ? some3(self2.log(options4)) : none2()));
var map17 = /* @__PURE__ */ dual(2, (self2, f) => makeLogger((options4) => f(self2.log(options4))));
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var simple = /* @__PURE__ */ __name((log8) => ({
  [LoggerTypeId]: loggerVariance,
  log: /* @__PURE__ */ __name(({
    message
  }) => log8(message), "log"),
  pipe() {
    return pipeArguments(this, arguments);
  }
}), "simple");
var succeed5 = /* @__PURE__ */ __name((value6) => {
  return simple(() => value6);
}, "succeed");
var sync3 = /* @__PURE__ */ __name((evaluate3) => {
  return simple(evaluate3);
}, "sync");
var zip5 = /* @__PURE__ */ dual(2, (self2, that) => makeLogger((options4) => [self2.log(options4), that.log(options4)]));
var zipLeft4 = /* @__PURE__ */ dual(2, (self2, that) => map17(zip5(self2, that), (tuple5) => tuple5[0]));
var zipRight4 = /* @__PURE__ */ dual(2, (self2, that) => map17(zip5(self2, that), (tuple5) => tuple5[1]));
var textOnly = /^[^\s"=]*$/;
var format3 = /* @__PURE__ */ __name((quoteValue, whitespace) => ({
  annotations: annotations3,
  cause: cause3,
  date: date4,
  fiberId: fiberId5,
  logLevel: logLevel2,
  message,
  spans
}) => {
  const formatValue = /* @__PURE__ */ __name((value6) => value6.match(textOnly) ? value6 : quoteValue(value6), "formatValue");
  const format8 = /* @__PURE__ */ __name((label, value6) => `${formatLabel(label)}=${formatValue(value6)}`, "format");
  const append6 = /* @__PURE__ */ __name((label, value6) => " " + format8(label, value6), "append");
  let out = format8("timestamp", date4.toISOString());
  out += append6("level", logLevel2.label);
  out += append6("fiber", threadName(fiberId5));
  const messages = ensure(message);
  for (let i = 0; i < messages.length; i++) {
    out += append6("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause3)) {
    out += append6("cause", pretty(cause3, {
      renderErrorCause: true
    }));
  }
  for (const span4 of spans) {
    out += " " + render(date4.getTime())(span4);
  }
  for (const [label, value6] of annotations3) {
    out += append6(label, toStringUnknown(value6, whitespace));
  }
  return out;
}, "format");
var escapeDoubleQuotes = /* @__PURE__ */ __name((s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`, "escapeDoubleQuotes");
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(escapeDoubleQuotes));
var logfmtLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format3(JSON.stringify, 0));
var structuredLogger = /* @__PURE__ */ makeLogger(({
  annotations: annotations3,
  cause: cause3,
  date: date4,
  fiberId: fiberId5,
  logLevel: logLevel2,
  message,
  spans
}) => {
  const now2 = date4.getTime();
  const annotationsObj = {};
  const spansObj = {};
  if (size6(annotations3) > 0) {
    for (const [k, v] of annotations3) {
      annotationsObj[k] = structuredMessage(v);
    }
  }
  if (isCons(spans)) {
    for (const span4 of spans) {
      spansObj[span4.label] = now2 - span4.startTime;
    }
  }
  const messageArr = ensure(message);
  return {
    message: messageArr.length === 1 ? structuredMessage(messageArr[0]) : messageArr.map(structuredMessage),
    logLevel: logLevel2.label,
    timestamp: date4.toISOString(),
    cause: isEmpty3(cause3) ? void 0 : pretty(cause3, {
      renderErrorCause: true
    }),
    annotations: annotationsObj,
    spans: spansObj,
    fiberId: threadName(fiberId5)
  };
});
var structuredMessage = /* @__PURE__ */ __name((u) => {
  switch (typeof u) {
    case "bigint":
    case "function":
    case "symbol": {
      return String(u);
    }
    default: {
      return toJSON(u);
    }
  }
}, "structuredMessage");
var jsonLogger = /* @__PURE__ */ map17(structuredLogger, stringifyCircular);
var isLogger = /* @__PURE__ */ __name((u) => {
  return typeof u === "object" && u != null && LoggerTypeId in u;
}, "isLogger");
var withColor = /* @__PURE__ */ __name((text7, ...colors2) => {
  let out = "";
  for (let i = 0; i < colors2.length; i++) {
    out += `\x1B[${colors2[i]}m`;
  }
  return out + text7 + "\x1B[0m";
}, "withColor");
var withColorNoop = /* @__PURE__ */ __name((text7, ..._colors) => text7, "withColorNoop");
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var logLevelStyle = {
  None: "",
  All: "",
  Trace: "color:gray",
  Debug: "color:blue",
  Info: "color:green",
  Warning: "color:orange",
  Error: "color:red",
  Fatal: "background-color:red;color:white"
};
var defaultDateFormat = /* @__PURE__ */ __name((date4) => `${date4.getHours().toString().padStart(2, "0")}:${date4.getMinutes().toString().padStart(2, "0")}:${date4.getSeconds().toString().padStart(2, "0")}.${date4.getMilliseconds().toString().padStart(3, "0")}`, "defaultDateFormat");
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
var prettyLogger = /* @__PURE__ */ __name((options4) => {
  const mode_ = options4?.mode ?? "auto";
  const mode = mode_ === "auto" ? hasProcessStdoutOrDeno ? "tty" : "browser" : mode_;
  const isBrowser = mode === "browser";
  const showColors = typeof options4?.colors === "boolean" ? options4.colors : processStdoutIsTTY || isBrowser;
  const formatDate2 = options4?.formatDate ?? defaultDateFormat;
  return isBrowser ? prettyLoggerBrowser({
    colors: showColors,
    formatDate: formatDate2
  }) : prettyLoggerTty({
    colors: showColors,
    formatDate: formatDate2,
    stderr: options4?.stderr === true
  });
}, "prettyLogger");
var prettyLoggerTty = /* @__PURE__ */ __name((options4) => {
  const color = options4.colors ? withColor : withColorNoop;
  return makeLogger(({
    annotations: annotations3,
    cause: cause3,
    context: context17,
    date: date4,
    fiberId: fiberId5,
    logLevel: logLevel2,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context17, currentServices);
    const console4 = get6(services, consoleTag).unsafe;
    const log8 = options4.stderr === true ? console4.error : console4.log;
    const message = ensure(message_);
    let firstLine = color(`[${options4.formatDate(date4)}]`, colors.white) + ` ${color(logLevel2.label, ...logLevelColors[logLevel2._tag])} (${threadName(fiberId5)})`;
    if (isCons(spans)) {
      const now2 = date4.getTime();
      const render2 = render(now2);
      for (const span4 of spans) {
        firstLine += " " + render2(span4);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += " " + color(firstMaybeString, colors.bold, colors.cyan);
        messageIndex++;
      }
    }
    log8(firstLine);
    console4.group();
    if (!isEmpty3(cause3)) {
      log8(pretty(cause3, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        log8(redact(message[messageIndex]));
      }
    }
    if (size6(annotations3) > 0) {
      for (const [key, value6] of annotations3) {
        log8(color(`${key}:`, colors.bold, colors.white), redact(value6));
      }
    }
    console4.groupEnd();
  });
}, "prettyLoggerTty");
var prettyLoggerBrowser = /* @__PURE__ */ __name((options4) => {
  const color = options4.colors ? "%c" : "";
  return makeLogger(({
    annotations: annotations3,
    cause: cause3,
    context: context17,
    date: date4,
    fiberId: fiberId5,
    logLevel: logLevel2,
    message: message_,
    spans
  }) => {
    const services = getOrDefault2(context17, currentServices);
    const console4 = get6(services, consoleTag).unsafe;
    const message = ensure(message_);
    let firstLine = `${color}[${options4.formatDate(date4)}]`;
    const firstParams = [];
    if (options4.colors) {
      firstParams.push("color:gray");
    }
    firstLine += ` ${color}${logLevel2.label}${color} (${threadName(fiberId5)})`;
    if (options4.colors) {
      firstParams.push(logLevelStyle[logLevel2._tag], "");
    }
    if (isCons(spans)) {
      const now2 = date4.getTime();
      const render2 = render(now2);
      for (const span4 of spans) {
        firstLine += " " + render2(span4);
      }
    }
    firstLine += ":";
    let messageIndex = 0;
    if (message.length > 0) {
      const firstMaybeString = structuredMessage(message[0]);
      if (typeof firstMaybeString === "string") {
        firstLine += ` ${color}${firstMaybeString}`;
        if (options4.colors) {
          firstParams.push("color:deepskyblue");
        }
        messageIndex++;
      }
    }
    console4.groupCollapsed(firstLine, ...firstParams);
    if (!isEmpty3(cause3)) {
      console4.error(pretty(cause3, {
        renderErrorCause: true
      }));
    }
    if (messageIndex < message.length) {
      for (; messageIndex < message.length; messageIndex++) {
        console4.log(redact(message[messageIndex]));
      }
    }
    if (size6(annotations3) > 0) {
      for (const [key, value6] of annotations3) {
        const redacted2 = redact(value6);
        if (options4.colors) {
          console4.log(`%c${key}:`, "color:gray", redacted2);
        } else {
          console4.log(`${key}:`, redacted2);
        }
      }
    }
    console4.groupEnd();
  });
}, "prettyLoggerBrowser");
var prettyLoggerDefault = /* @__PURE__ */ globalValue("effect/Logger/prettyLoggerDefault", () => prettyLogger());

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/boundaries.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
var MetricBoundariesImpl = class {
  static {
    __name(this, "MetricBoundariesImpl");
  }
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values6) {
    this.values = values6;
    this._hash = pipe(string2(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricBoundaries = /* @__PURE__ */ __name((u) => hasProperty(u, MetricBoundariesTypeId), "isMetricBoundaries");
var fromIterable9 = /* @__PURE__ */ __name((iterable) => {
  const values6 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values6);
}, "fromIterable");
var exponential = /* @__PURE__ */ __name((options4) => pipe(makeBy(options4.count - 1, (i) => options4.start * Math.pow(options4.factor, i)), unsafeFromArray, fromIterable9), "exponential");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/key.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/keyType.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var CounterKeyType = class {
  static {
    __name(this, "CounterKeyType");
  }
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint4) {
    this.incremental = incremental;
    this.bigint = bigint4;
    this._hash = string2(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FrequencyKeyTypeHash = /* @__PURE__ */ string2(FrequencyKeyTypeSymbolKey);
var FrequencyKeyType = class {
  static {
    __name(this, "FrequencyKeyType");
  }
  preregisteredWords;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [FrequencyKeyTypeTypeId] = FrequencyKeyTypeTypeId;
  constructor(preregisteredWords) {
    this.preregisteredWords = preregisteredWords;
  }
  [symbol]() {
    return FrequencyKeyTypeHash;
  }
  [symbol2](that) {
    return isFrequencyKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeKeyTypeHash = /* @__PURE__ */ string2(GaugeKeyTypeSymbolKey);
var GaugeKeyType = class {
  static {
    __name(this, "GaugeKeyType");
  }
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [GaugeKeyTypeTypeId] = GaugeKeyTypeTypeId;
  constructor(bigint4) {
    this.bigint = bigint4;
  }
  [symbol]() {
    return GaugeKeyTypeHash;
  }
  [symbol2](that) {
    return isGaugeKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramKeyType = class {
  static {
    __name(this, "HistogramKeyType");
  }
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string2(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryKeyType = class {
  static {
    __name(this, "SummaryKeyType");
  }
  maxAge;
  maxSize;
  error;
  quantiles;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [SummaryKeyTypeTypeId] = SummaryKeyTypeTypeId;
  constructor(maxAge, maxSize, error5, quantiles) {
    this.maxAge = maxAge;
    this.maxSize = maxSize;
    this.error = error5;
    this.quantiles = quantiles;
    this._hash = pipe(string2(SummaryKeyTypeSymbolKey), combine(hash(this.maxAge)), combine(hash(this.maxSize)), combine(hash(this.error)), combine(array2(this.quantiles)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isSummaryKey(that) && equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && equals(this.quantiles, that.quantiles);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter = /* @__PURE__ */ __name((options4) => new CounterKeyType(options4?.incremental ?? false, options4?.bigint ?? false), "counter");
var histogram = /* @__PURE__ */ __name((boundaries) => {
  return new HistogramKeyType(boundaries);
}, "histogram");
var isCounterKey = /* @__PURE__ */ __name((u) => hasProperty(u, CounterKeyTypeTypeId), "isCounterKey");
var isFrequencyKey = /* @__PURE__ */ __name((u) => hasProperty(u, FrequencyKeyTypeTypeId), "isFrequencyKey");
var isGaugeKey = /* @__PURE__ */ __name((u) => hasProperty(u, GaugeKeyTypeTypeId), "isGaugeKey");
var isHistogramKey = /* @__PURE__ */ __name((u) => hasProperty(u, HistogramKeyTypeTypeId), "isHistogramKey");
var isSummaryKey = /* @__PURE__ */ __name((u) => hasProperty(u, SummaryKeyTypeTypeId), "isSummaryKey");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  /* c8 ignore next */
  _Type: /* @__PURE__ */ __name((_) => _, "_Type")
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence4(equals);
var MetricKeyImpl = class {
  static {
    __name(this, "MetricKeyImpl");
  }
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags3 = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags3;
    this._hash = pipe(string2(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isMetricKey = /* @__PURE__ */ __name((u) => hasProperty(u, MetricKeyTypeId), "isMetricKey");
var counter2 = /* @__PURE__ */ __name((name, options4) => new MetricKeyImpl(name, counter(options4), fromNullable2(options4?.description)), "counter");
var histogram2 = /* @__PURE__ */ __name((name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable2(description)), "histogram");
var taggedWithLabels = /* @__PURE__ */ dual(2, (self2, extraTags) => extraTags.length === 0 ? self2 : new MetricKeyImpl(self2.name, self2.keyType, self2.description, union(self2.tags, extraTags)));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/registry.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/MutableHashMap.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId13]: TypeId13,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MutableHashMapIterator = class _MutableHashMapIterator {
  static {
    __name(this, "MutableHashMapIterator");
  }
  self;
  referentialIterator;
  bucketIterator;
  constructor(self2) {
    this.self = self2;
    this.referentialIterator = self2.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== void 0) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new _MutableHashMapIterator(this.self);
  }
};
var BucketIterator = class {
  static {
    __name(this, "BucketIterator");
  }
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === void 0) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = void 0;
      return this.next();
    }
    return result;
  }
};
var empty23 = /* @__PURE__ */ __name(() => {
  const self2 = Object.create(MutableHashMapProto);
  self2.referential = /* @__PURE__ */ new Map();
  self2.buckets = /* @__PURE__ */ new Map();
  self2.bucketsSize = 0;
  return self2;
}, "empty");
var get13 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    return self2.referential.has(key) ? some3(self2.referential.get(key)) : none2();
  }
  const hash5 = key[symbol]();
  const bucket = self2.buckets.get(hash5);
  if (bucket === void 0) {
    return none2();
  }
  return getFromBucket(self2, bucket, key);
});
var getFromBucket = /* @__PURE__ */ __name((self2, bucket, key, remove16 = false) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value6 = bucket[i][1];
      if (remove16) {
        bucket.splice(i, 1);
        self2.bucketsSize--;
      }
      return some3(value6);
    }
  }
  return none2();
}, "getFromBucket");
var has6 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(get13(self2, key)));
var set6 = /* @__PURE__ */ dual(3, (self2, key, value6) => {
  if (isEqual(key) === false) {
    self2.referential.set(key, value6);
    return self2;
  }
  const hash5 = key[symbol]();
  const bucket = self2.buckets.get(hash5);
  if (bucket === void 0) {
    self2.buckets.set(hash5, [[key, value6]]);
    self2.bucketsSize++;
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  bucket.push([key, value6]);
  self2.bucketsSize++;
  return self2;
});
var removeFromBucket = /* @__PURE__ */ __name((self2, bucket, key) => {
  for (let i = 0, len = bucket.length; i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self2.bucketsSize--;
      return;
    }
  }
}, "removeFromBucket");
var remove7 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    self2.referential.delete(key);
    return self2;
  }
  const hash5 = key[symbol]();
  const bucket = self2.buckets.get(hash5);
  if (bucket === void 0) {
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  if (bucket.length === 0) {
    self2.buckets.delete(hash5);
  }
  return self2;
});
var size7 = /* @__PURE__ */ __name((self2) => {
  return self2.referential.size + self2.bucketsSize;
}, "size");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/hook.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/state.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var CounterState = class {
  static {
    __name(this, "CounterState");
  }
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count7) {
    this.count = count7;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var arrayEquals = /* @__PURE__ */ getEquivalence4(equals);
var FrequencyState = class {
  static {
    __name(this, "FrequencyState");
  }
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string2(FrequencyStateSymbolKey), combine(array2(fromIterable2(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable2(this.occurrences.entries()), fromIterable2(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var GaugeState = class {
  static {
    __name(this, "GaugeState");
  }
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value6) {
    this.value = value6;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var HistogramState = class {
  static {
    __name(this, "HistogramState");
  }
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count7, min6, max9, sum3) {
    this.buckets = buckets;
    this.count = count7;
    this.min = min6;
    this.max = max9;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var SummaryState = class {
  static {
    __name(this, "SummaryState");
  }
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error5, quantiles, count7, min6, max9, sum3) {
    this.error = error5;
    this.quantiles = quantiles;
    this.count = count7;
    this.min = min6;
    this.max = max9;
    this.sum = sum3;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var counter3 = /* @__PURE__ */ __name((count7) => new CounterState(count7), "counter");
var frequency2 = /* @__PURE__ */ __name((occurrences) => {
  return new FrequencyState(occurrences);
}, "frequency");
var gauge2 = /* @__PURE__ */ __name((count7) => new GaugeState(count7), "gauge");
var histogram3 = /* @__PURE__ */ __name((options4) => new HistogramState(options4.buckets, options4.count, options4.min, options4.max, options4.sum), "histogram");
var summary2 = /* @__PURE__ */ __name((options4) => new SummaryState(options4.error, options4.quantiles, options4.count, options4.min, options4.max, options4.sum), "summary");
var isCounterState = /* @__PURE__ */ __name((u) => hasProperty(u, CounterStateTypeId), "isCounterState");
var isFrequencyState = /* @__PURE__ */ __name((u) => hasProperty(u, FrequencyStateTypeId), "isFrequencyState");
var isGaugeState = /* @__PURE__ */ __name((u) => hasProperty(u, GaugeStateTypeId), "isGaugeState");
var isHistogramState = /* @__PURE__ */ __name((u) => hasProperty(u, HistogramStateTypeId), "isHistogramState");
var isSummaryState = /* @__PURE__ */ __name((u) => hasProperty(u, SummaryStateTypeId), "isSummaryState");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var make31 = /* @__PURE__ */ __name((options4) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options4
}), "make");
var bigint03 = /* @__PURE__ */ BigInt(0);
var counter4 = /* @__PURE__ */ __name((key) => {
  let sum3 = key.keyType.bigint ? bigint03 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value6) => value6 >= bigint03 : (value6) => value6 >= 0 : (_value) => true;
  const update9 = /* @__PURE__ */ __name((value6) => {
    if (canUpdate(value6)) {
      sum3 = sum3 + value6;
    }
  }, "update");
  return make31({
    get: /* @__PURE__ */ __name(() => counter3(sum3), "get"),
    update: update9,
    modify: update9
  });
}, "counter");
var frequency3 = /* @__PURE__ */ __name((key) => {
  const values6 = /* @__PURE__ */ new Map();
  for (const word of key.keyType.preregisteredWords) {
    values6.set(word, 0);
  }
  const update9 = /* @__PURE__ */ __name((word) => {
    const slotCount = values6.get(word) ?? 0;
    values6.set(word, slotCount + 1);
  }, "update");
  return make31({
    get: /* @__PURE__ */ __name(() => frequency2(values6), "get"),
    update: update9,
    modify: update9
  });
}, "frequency");
var gauge3 = /* @__PURE__ */ __name((_key, startAt) => {
  let value6 = startAt;
  return make31({
    get: /* @__PURE__ */ __name(() => gauge2(value6), "get"),
    update: /* @__PURE__ */ __name((v) => {
      value6 = v;
    }, "update"),
    modify: /* @__PURE__ */ __name((v) => {
      value6 = value6 + v;
    }, "modify")
  });
}, "gauge");
var histogram4 = /* @__PURE__ */ __name((key) => {
  const bounds = key.keyType.boundaries.values;
  const size22 = bounds.length;
  const values6 = new Uint32Array(size22 + 1);
  const boundaries = new Float64Array(size22);
  let count7 = 0;
  let sum3 = 0;
  let min6 = Number.MAX_VALUE;
  let max9 = Number.MIN_VALUE;
  pipe(bounds, sort(Order2), map5((n, i) => {
    boundaries[i] = n;
  }));
  const update9 = /* @__PURE__ */ __name((value6) => {
    let from = 0;
    let to = size22;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value6 <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value6 <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values6[from] = values6[from] + 1;
    count7 = count7 + 1;
    sum3 = sum3 + value6;
    if (value6 < min6) {
      min6 = value6;
    }
    if (value6 > max9) {
      max9 = value6;
    }
  }, "update");
  const getBuckets = /* @__PURE__ */ __name(() => {
    const builder = allocate(size22);
    let cumulated = 0;
    for (let i = 0; i < size22; i++) {
      const boundary = boundaries[i];
      const value6 = values6[i];
      cumulated = cumulated + value6;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  }, "getBuckets");
  return make31({
    get: /* @__PURE__ */ __name(() => histogram3({
      buckets: getBuckets(),
      count: count7,
      min: min6,
      max: max9,
      sum: sum3
    }), "get"),
    update: update9,
    modify: update9
  });
}, "histogram");
var summary3 = /* @__PURE__ */ __name((key) => {
  const {
    error: error5,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order2));
  const values6 = allocate(maxSize);
  let head13 = 0;
  let count7 = 0;
  let sum3 = 0;
  let min6 = 0;
  let max9 = 0;
  const snapshot2 = /* @__PURE__ */ __name((now2) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values6[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now2 - t);
        if (greaterThanOrEqualTo2(age, zero) && lessThanOrEqualTo2(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error5, sortedQuantiles, sort(builder, Order2));
  }, "snapshot");
  const observe = /* @__PURE__ */ __name((value6, timestamp) => {
    if (maxSize > 0) {
      head13 = head13 + 1;
      const target3 = head13 % maxSize;
      values6[target3] = [timestamp, value6];
    }
    min6 = count7 === 0 ? value6 : Math.min(min6, value6);
    max9 = count7 === 0 ? value6 : Math.max(max9, value6);
    count7 = count7 + 1;
    sum3 = sum3 + value6;
  }, "observe");
  return make31({
    get: /* @__PURE__ */ __name(() => summary2({
      error: error5,
      quantiles: snapshot2(Date.now()),
      count: count7,
      min: min6,
      max: max9,
      sum: sum3
    }), "get"),
    update: /* @__PURE__ */ __name(([value6, timestamp]) => observe(value6, timestamp), "update"),
    modify: /* @__PURE__ */ __name(([value6, timestamp]) => observe(value6, timestamp), "modify")
  });
}, "summary");
var calculateQuantiles = /* @__PURE__ */ __name((error5, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty3();
  }
  const head13 = sortedQuantiles[0];
  const tail3 = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error5, sampleCount, none2(), 0, head13, sortedSamples);
  const resolved = of(resolvedHead);
  tail3.forEach((quantile) => {
    resolved.push(resolveQuantile(error5, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map5(resolved, (rq) => [rq.quantile, rq.value]);
}, "calculateQuantiles");
var resolveQuantile = /* @__PURE__ */ __name((error5, sampleCount, current2, consumed, quantile, rest) => {
  let error_1 = error5;
  let sampleCount_1 = sampleCount;
  let current_1 = current2;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error5;
  let sampleCount_2 = sampleCount;
  let current_2 = current2;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (1) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some3(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head2(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some3(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head2(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head2(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some3(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
}, "resolveQuantile");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/pair.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  /* c8 ignore next */
  _Type: /* @__PURE__ */ __name((_) => _, "_Type")
};
var unsafeMake8 = /* @__PURE__ */ __name((metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
}, "unsafeMake");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
var MetricRegistryImpl = class {
  static {
    __name(this, "MetricRegistryImpl");
  }
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty23();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake8(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get13(key), getOrUndefined2);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value6 = pipe(this.map, get13(key), getOrUndefined2);
    if (value6 == null) {
      const counter6 = counter4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, counter6));
      }
      value6 = counter6;
    }
    return value6;
  }
  getFrequency(key) {
    let value6 = pipe(this.map, get13(key), getOrUndefined2);
    if (value6 == null) {
      const frequency6 = frequency3(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, frequency6));
      }
      value6 = frequency6;
    }
    return value6;
  }
  getGauge(key) {
    let value6 = pipe(this.map, get13(key), getOrUndefined2);
    if (value6 == null) {
      const gauge6 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, gauge6));
      }
      value6 = gauge6;
    }
    return value6;
  }
  getHistogram(key) {
    let value6 = pipe(this.map, get13(key), getOrUndefined2);
    if (value6 == null) {
      const histogram6 = histogram4(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, histogram6));
      }
      value6 = histogram6;
    }
    return value6;
  }
  getSummary(key) {
    let value6 = pipe(this.map, get13(key), getOrUndefined2);
    if (value6 == null) {
      const summary6 = summary3(key);
      if (!pipe(this.map, has6(key))) {
        pipe(this.map, set6(key, summary6));
      }
      value6 = summary6;
    }
    return value6;
  }
};
var make32 = /* @__PURE__ */ __name(() => {
  return new MetricRegistryImpl();
}, "make");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  /* c8 ignore next */
  _Type: /* @__PURE__ */ __name((_) => _, "_Type"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make32());
var make33 = /* @__PURE__ */ __name(function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect4) => tap2(effect4, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
}, "make");
var counter5 = /* @__PURE__ */ __name((name, options4) => fromMetricKey(counter2(name, options4)), "counter");
var fromMetricKey = /* @__PURE__ */ __name((key) => {
  let untaggedHook;
  const hookCache = /* @__PURE__ */ new WeakMap();
  const hook = /* @__PURE__ */ __name((extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== void 0) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== void 0) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  }, "hook");
  return make33(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
}, "fromMetricKey");
var histogram5 = /* @__PURE__ */ __name((name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description)), "histogram");
var tagged = /* @__PURE__ */ dual(3, (self2, key, value6) => taggedWithLabels2(self2, [make30(key, value6)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self2, extraTags) => {
  return make33(self2.keyType, (input, extraTags1) => self2.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self2.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self2.unsafeModify(input, union(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self2, input) => fiberRefGetWith(currentMetricLabels, (tags3) => sync(() => self2.unsafeUpdate(input, tags3))));
var unsafeSnapshot = /* @__PURE__ */ __name(() => globalMetricRegistry.snapshot(), "unsafeSnapshot");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/request.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var requestVariance = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = /* @__PURE__ */ __name((u) => hasProperty(u, RequestTypeId), "isRequest");
var Class3 = /* @__PURE__ */ (function() {
  function Class7(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  __name(Class7, "Class");
  Class7.prototype = RequestPrototype;
  return Class7;
})();
var complete = /* @__PURE__ */ dual(2, (self2, result) => fiberRefGetWith(currentRequestMap, (map38) => sync(() => {
  if (map38.has(self2)) {
    const entry = map38.get(self2);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
var Listeners = class {
  static {
    __name(this, "Listeners");
  }
  count = 0;
  observers = /* @__PURE__ */ new Set();
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/supervisor.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/SortedSet.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/RedBlackTree.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/redBlackTree.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};
var RedBlackTreeIterator = class _RedBlackTreeIterator {
  static {
    __name(this, "RedBlackTreeIterator");
  }
  self;
  stack;
  direction;
  count = 0;
  constructor(self2, stack, direction) {
    this.self = self2;
    this.stack = stack;
    this.direction = direction;
  }
  /**
   * Clones the iterator
   */
  clone() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  /**
   * Reverse the traversal direction
   */
  reversed() {
    return new _RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  /**
   * Iterator next
   */
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  /**
   * Returns the key
   */
  get key() {
    if (this.stack.length > 0) {
      return some3(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  /**
   * Returns the value
   */
  get value() {
    if (this.stack.length > 0) {
      return some3(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  /**
   * Returns the key
   */
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  /**
   * Returns the position of this iterator in the sorted list
   */
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2; s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  /**
   * Advances iterator to next element in list
   */
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a next element
   */
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  /**
   * Advances iterator to previous element in list
   */
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  /**
   * Checks if there is a previous element
   */
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1; s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/redBlackTree/node.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Color = {
  Red: 0,
  Black: 1 << 0
};
var clone = /* @__PURE__ */ __name(({
  color,
  count: count7,
  key,
  left: left3,
  right: right3,
  value: value6
}) => ({
  color,
  key,
  value: value6,
  left: left3,
  right: right3,
  count: count7
}), "clone");
function swap2(n, v) {
  n.key = v.key;
  n.value = v.value;
  n.left = v.left;
  n.right = v.right;
  n.color = v.color;
  n.count = v.count;
}
__name(swap2, "swap");
var repaint = /* @__PURE__ */ __name(({
  count: count7,
  key,
  left: left3,
  right: right3,
  value: value6
}, color) => ({
  color,
  key,
  value: value6,
  left: left3,
  right: right3,
  count: count7
}), "repaint");
var recount = /* @__PURE__ */ __name((node) => {
  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
}, "recount");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  /* c8 ignore next */
  _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
  /* c8 ignore next */
  _Value: /* @__PURE__ */ __name((_) => _, "_Value")
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol]() {
    let hash5 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash5 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash5);
  },
  [symbol2](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries3 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries3[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = /* @__PURE__ */ __name((ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
}, "makeImpl");
var isRedBlackTree = /* @__PURE__ */ __name((u) => hasProperty(u, RedBlackTreeTypeId), "isRedBlackTree");
var empty24 = /* @__PURE__ */ __name((ord) => makeImpl3(ord, void 0), "empty");
var fromIterable10 = /* @__PURE__ */ dual(2, (entries3, ord) => {
  let tree = empty24(ord);
  for (const [key, value6] of entries3) {
    tree = insert(tree, key, value6);
  }
  return tree;
});
var findFirst7 = /* @__PURE__ */ dual(2, (self2, key) => {
  const cmp = self2._ord;
  let node = self2._root;
  while (node !== void 0) {
    const d = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some3(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var has7 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(findFirst7(self2, key)));
var insert = /* @__PURE__ */ dual(3, (self2, key, value6) => {
  const cmp = self2._ord;
  let n = self2._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value: value6,
    left: void 0,
    right: void 0,
    count: 1
  });
  for (let s = n_stack.length - 2; s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1; s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p.right;
          p.color = Color.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p.left;
          p.color = Color.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self2._ord, n_stack[0]);
});
var keysForward = /* @__PURE__ */ __name((self2) => keys4(self2, Direction.Forward), "keysForward");
var keys4 = /* @__PURE__ */ __name((self2, direction) => {
  const begin = self2[Symbol.iterator]();
  let count7 = 0;
  return {
    [Symbol.iterator]: () => keys4(self2, direction),
    next: /* @__PURE__ */ __name(() => {
      count7++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count7
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }, "next")
  };
}, "keys");
var removeFirst = /* @__PURE__ */ dual(2, (self2, key) => {
  if (!has7(self2, key)) {
    return self2;
  }
  const ord = self2._ord;
  const cmp = ord;
  let node = self2._root;
  const stack = [];
  while (node !== void 0) {
    const d = cmp(key, node.key);
    stack.push(node);
    if (equals(key, node.key)) {
      node = void 0;
    } else if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  if (stack.length === 0) {
    return self2;
  }
  const cstack = new Array(stack.length);
  let n = stack[stack.length - 1];
  cstack[cstack.length - 1] = {
    color: n.color,
    key: n.key,
    value: n.value,
    left: n.left,
    right: n.right,
    count: n.count
  };
  for (let i = stack.length - 2; i >= 0; --i) {
    n = stack[i];
    if (n.left === stack[i + 1]) {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: cstack[i + 1],
        right: n.right,
        count: n.count
      };
    } else {
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
  }
  n = cstack[cstack.length - 1];
  if (n.left !== void 0 && n.right !== void 0) {
    const split6 = cstack.length;
    n = n.left;
    while (n.right != null) {
      cstack.push(n);
      n = n.right;
    }
    const v = cstack[split6 - 1];
    cstack.push({
      color: n.color,
      key: v.key,
      value: v.value,
      left: n.left,
      right: n.right,
      count: n.count
    });
    cstack[split6 - 1].key = n.key;
    cstack[split6 - 1].value = n.value;
    for (let i = cstack.length - 2; i >= split6; --i) {
      n = cstack[i];
      cstack[i] = {
        color: n.color,
        key: n.key,
        value: n.value,
        left: n.left,
        right: cstack[i + 1],
        count: n.count
      };
    }
    cstack[split6 - 1].left = cstack[split6];
  }
  n = cstack[cstack.length - 1];
  if (n.color === Color.Red) {
    const p = cstack[cstack.length - 2];
    if (p.left === n) {
      p.left = void 0;
    } else if (p.right === n) {
      p.right = void 0;
    }
    cstack.pop();
    for (let i = 0; i < cstack.length; ++i) {
      cstack[i].count--;
    }
    return makeImpl3(ord, cstack[0]);
  } else {
    if (n.left !== void 0 || n.right !== void 0) {
      if (n.left !== void 0) {
        swap2(n, n.left);
      } else if (n.right !== void 0) {
        swap2(n, n.right);
      }
      n.color = Color.Black;
      for (let i = 0; i < cstack.length - 1; ++i) {
        cstack[i].count--;
      }
      return makeImpl3(ord, cstack[0]);
    } else if (cstack.length === 1) {
      return makeImpl3(ord, void 0);
    } else {
      for (let i = 0; i < cstack.length; ++i) {
        cstack[i].count--;
      }
      const parent = cstack[cstack.length - 2];
      fixDoubleBlack(cstack);
      if (parent.left === n) {
        parent.left = void 0;
      } else {
        parent.right = void 0;
      }
    }
  }
  return makeImpl3(ord, cstack[0]);
});
var fixDoubleBlack = /* @__PURE__ */ __name((stack) => {
  let n, p, s, z;
  for (let i = stack.length - 1; i >= 0; --i) {
    n = stack[i];
    if (i === 0) {
      n.color = Color.Black;
      return;
    }
    p = stack[i - 1];
    if (p.left === n) {
      s = p.right;
      if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.right = clone(s);
        z = s.right = clone(s.right);
        p.right = s.left;
        s.left = p;
        s.right = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.right = clone(s);
        z = s.left = clone(s.left);
        p.right = z.left;
        s.left = z.right;
        z.left = p;
        z.right = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = z;
          } else {
            pp.right = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.right = repaint(s, Color.Red);
          return;
        } else {
          p.right = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p.right = s.left;
        s.left = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.left === p) {
            pp.left = s;
          } else {
            pp.right = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    } else {
      s = p.left;
      if (s !== void 0 && s.left !== void 0 && s.left.color === Color.Red) {
        s = p.left = clone(s);
        z = s.left = clone(s.left);
        p.left = s.right;
        s.right = p;
        s.left = z;
        s.color = p.color;
        n.color = Color.Black;
        p.color = Color.Black;
        z.color = Color.Black;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        return;
      } else if (s !== void 0 && s.right !== void 0 && s.right.color === Color.Red) {
        s = p.left = clone(s);
        z = s.right = clone(s.right);
        p.left = z.right;
        s.right = z.left;
        z.right = p;
        z.left = s;
        z.color = p.color;
        p.color = Color.Black;
        s.color = Color.Black;
        n.color = Color.Black;
        recount(p);
        recount(s);
        recount(z);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = z;
          } else {
            pp.left = z;
          }
        }
        stack[i - 1] = z;
        return;
      }
      if (s !== void 0 && s.color === Color.Black) {
        if (p.color === Color.Red) {
          p.color = Color.Black;
          p.left = repaint(s, Color.Red);
          return;
        } else {
          p.left = repaint(s, Color.Red);
          continue;
        }
      } else if (s !== void 0) {
        s = clone(s);
        p.left = s.right;
        s.right = p;
        s.color = p.color;
        p.color = Color.Red;
        recount(p);
        recount(s);
        if (i > 1) {
          const pp = stack[i - 2];
          if (pp.right === p) {
            pp.right = s;
          } else {
            pp.left = s;
          }
        }
        stack[i - 1] = s;
        stack[i] = p;
        if (i + 1 < stack.length) {
          stack[i + 1] = n;
        } else {
          stack.push(n);
        }
        i = i + 2;
      }
    }
  }
}, "fixDoubleBlack");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/RedBlackTree.js
var fromIterable11 = fromIterable10;
var has8 = has7;
var insert2 = insert;
var keys5 = keysForward;
var removeFirst2 = removeFirst;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/SortedSet.js
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId14]: {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  },
  [symbol]() {
    return pipe(hash(this.keyTree), combine(hash(TypeId14)), cached(this));
  },
  [symbol2](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys5(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = /* @__PURE__ */ __name((keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
}, "fromTree");
var isSortedSet = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId14), "isSortedSet");
var fromIterable12 = /* @__PURE__ */ dual(2, (iterable, ord) => fromTree(fromIterable11(Array.from(iterable).map((k) => [k, true]), ord)));
var add5 = /* @__PURE__ */ dual(2, (self2, value6) => has8(self2.keyTree, value6) ? self2 : fromTree(insert2(self2.keyTree, value6, true)));
var every9 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  for (const value6 of self2) {
    if (!predicate(value6)) {
      return false;
    }
  }
  return true;
});
var has9 = /* @__PURE__ */ dual(2, (self2, value6) => has8(self2.keyTree, value6));
var isSubset3 = /* @__PURE__ */ dual(2, (self2, that) => every9(self2, (a) => has9(that, a)));
var remove8 = /* @__PURE__ */ dual(2, (self2, value6) => fromTree(removeFirst2(self2.keyTree, value6)));
var values5 = /* @__PURE__ */ __name((self2) => keys5(self2.keyTree), "values");
var getEquivalence7 = /* @__PURE__ */ __name(() => (a, b) => isSubset3(a, b) && isSubset3(b, a), "getEquivalence");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  /* c8 ignore next */
  _T: /* @__PURE__ */ __name((_) => _, "_T")
};
var ProxySupervisor = class _ProxySupervisor {
  static {
    __name(this, "ProxySupervisor");
  }
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context17, effect4, parent, fiber) {
    this.underlying.onStart(context17, effect4, parent, fiber);
  }
  onEnd(value6, fiber) {
    this.underlying.onEnd(value6, fiber);
  }
  onEffect(fiber, effect4) {
    this.underlying.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new _ProxySupervisor(this, pipe(this.value, map12(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
};
var Zip = class _Zip {
  static {
    __name(this, "Zip");
  }
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip3(this.left.value, this.right.value);
  }
  onStart(context17, effect4, parent, fiber) {
    this.left.onStart(context17, effect4, parent, fiber);
    this.right.onStart(context17, effect4, parent, fiber);
  }
  onEnd(value6, fiber) {
    this.left.onEnd(value6, fiber);
    this.right.onEnd(value6, fiber);
  }
  onEffect(fiber, effect4) {
    this.left.onEffect(fiber, effect4);
    this.right.onEffect(fiber, effect4);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map12(f)));
  }
  zip(right3) {
    return new _Zip(this, right3);
  }
};
var isZip = /* @__PURE__ */ __name((self2) => hasProperty(self2, SupervisorTypeId) && isTagged(self2, "Zip"), "isZip");
var Track = class {
  static {
    __name(this, "Track");
  }
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set();
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map12(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var Const = class {
  static {
    __name(this, "Const");
  }
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect4) {
    this.effect = effect4;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map12(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var FibersIn = class {
  static {
    __name(this, "FibersIn");
  }
  ref;
  [SupervisorTypeId] = supervisorVariance;
  constructor(ref2) {
    this.ref = ref2;
  }
  get value() {
    return sync(() => get7(this.ref));
  }
  onStart(_context, _effect, _parent, fiber) {
    pipe(this.ref, set2(pipe(get7(this.ref), add5(fiber))));
  }
  onEnd(_value, fiber) {
    pipe(this.ref, set2(pipe(get7(this.ref), remove8(fiber))));
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map12(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
};
var unsafeTrack = /* @__PURE__ */ __name(() => {
  return new Track();
}, "unsafeTrack");
var track = /* @__PURE__ */ sync(unsafeTrack);
var fromEffect2 = /* @__PURE__ */ __name((effect4) => {
  return new Const(effect4);
}, "fromEffect");
var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect2(void_3));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/supervisor/patch.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Differ.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var make35 = make17;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty26 = {
  _tag: OP_EMPTY3
};
var combine8 = /* @__PURE__ */ __name((self2, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self2,
    second: that
  };
}, "combine");
var patch8 = /* @__PURE__ */ __name((self2, supervisor) => {
  return patchLoop(supervisor, of2(self2));
}, "patch");
var patchLoop = /* @__PURE__ */ __name((_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty(patches)) {
    const head13 = headNonEmpty2(patches);
    switch (head13._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head13.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head13.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head13.first)(prepend2(head13.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
}, "patchLoop");
var removeSupervisor = /* @__PURE__ */ __name((self2, that) => {
  if (equals(self2, that)) {
    return none8;
  } else {
    if (isZip(self2)) {
      return removeSupervisor(self2.left, that).zip(removeSupervisor(self2.right, that));
    } else {
      return self2;
    }
  }
}, "removeSupervisor");
var toSet3 = /* @__PURE__ */ __name((self2) => {
  if (equals(self2, none8)) {
    return empty7();
  } else {
    if (isZip(self2)) {
      return pipe(toSet3(self2.left), union5(toSet3(self2.right)));
    } else {
      return make9(self2);
    }
  }
}, "toSet");
var diff7 = /* @__PURE__ */ __name((oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty26;
  }
  const oldSupervisors = toSet3(oldValue);
  const newSupervisors = toSet3(newValue);
  const added = pipe(newSupervisors, difference4(oldSupervisors), reduce5(empty26, (patch12, supervisor) => combine8(patch12, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference4(newSupervisors), reduce5(empty26, (patch12, supervisor) => combine8(patch12, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine8(added, removed);
}, "diff");
var differ2 = /* @__PURE__ */ make35({
  empty: empty26,
  patch: patch8,
  combine: combine8,
  diff: diff7
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var absurd = /* @__PURE__ */ __name((_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
}, "absurd");
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value6) => {
    return internalCall(() => cont.effect_instruction_i1(value6));
  },
  ["OnStep"]: /* @__PURE__ */ __name((_, _cont, value6) => {
    return exitSucceed(exitSucceed(value6));
  }, "OnStep"),
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value6) => {
    return internalCall(() => cont.effect_instruction_i2(value6));
  },
  [OP_REVERT_FLAGS]: (self2, cont, value6) => {
    self2.patchRuntimeFlags(self2.currentRuntimeFlags, cont.patch);
    if (interruptible(self2.currentRuntimeFlags) && self2.isInterrupted()) {
      return exitFailCause(self2.getInterruptedCause());
    } else {
      return exitSucceed(value6);
    }
  },
  [OP_WHILE]: (self2, cont, value6) => {
    internalCall(() => cont.effect_instruction_i2(value6));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self2.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_3;
    }
  },
  [OP_ITERATOR]: (self2, cont, value6) => {
    while (true) {
      const state2 = internalCall(() => cont.effect_instruction_i0.next(value6));
      if (state2.done) {
        return exitSucceed(state2.value);
      }
      const primitive2 = yieldWrapGet(state2.value);
      if (!exitIsExit(primitive2)) {
        self2.pushStack(cont);
        return primitive2;
      } else if (primitive2._tag === "Failure") {
        return primitive2;
      }
      value6 = primitive2.value;
    }
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self2, runtimeFlags2, cur, message) => {
    self2.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self2, runtimeFlags2, cur, message) => {
    message.onFiber(self2, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap10(yieldNow(), () => cur);
  }
};
var runBlockedRequests = /* @__PURE__ */ __name((self2) => forEachSequentialDiscard(flatten5(self2), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential5]) => {
  const map38 = /* @__PURE__ */ new Map();
  const arr = [];
  for (const block of sequential5) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map38.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map38);
}, false, false)), "runBlockedRequests");
var _version = /* @__PURE__ */ getCurrentVersion();
var FiberRuntime = class extends Class2 {
  static {
    __name(this, "FiberRuntime");
  }
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array();
  _children = null;
  _observers = /* @__PURE__ */ new Array();
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId5, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId5;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags3 = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags3);
      fiberActive.unsafeUpdate(1, tags3);
    }
    this.refreshRefCache();
  }
  commit() {
    return join3(this);
  }
  /**
   * The identity of the fiber.
   */
  id() {
    return this._fiberId;
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background. This can be called to "kick off" execution of a fiber after
   * it has been created.
   */
  resume(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * The status of the fiber.
   */
  get status() {
    return this.ask((_, status3) => status3);
  }
  /**
   * Gets the fiber runtime flags.
   */
  get runtimeFlags() {
    return this.ask((state2, status3) => {
      if (isDone2(status3)) {
        return state2.currentRuntimeFlags;
      }
      return status3.runtimeFlags;
    });
  }
  /**
   * Returns the current `FiberScope` for the fiber.
   */
  scope() {
    return unsafeMake7(this);
  }
  /**
   * Retrieves the immediate children of the fiber.
   */
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  /**
   * Gets the fiber's set of children.
   */
  getChildren() {
    if (this._children === null) {
      this._children = /* @__PURE__ */ new Set();
    }
    return this._children;
  }
  /**
   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
   * if the fiber has not been interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  /**
   * Retrieves the whole set of fiber refs.
   */
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  /**
   * Returns an effect that will contain information computed from the fiber
   * state and status while running on the fiber.
   *
   * This allows the outside world to interact safely with mutable fiber state
   * without locks or immutable data.
   */
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status3) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status3)));
      }));
      return deferredAwait(deferred);
    });
  }
  /**
   * Adds a message to be processed by the fiber on the fiber.
   */
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = /* @__PURE__ */ __name((exit5) => resume2(succeed(exit5)), "cb");
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch12 = pipe(
        diff4(parentRuntimeFlags, updatedRuntimeFlags),
        // Do not inherit WindDown or Interruption!
        exclude2(Interruption),
        exclude2(WindDown)
      );
      return updateRuntimeFlags(patch12);
    });
  }
  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  get poll() {
    return sync(() => fromNullable2(this._exitValue));
  }
  /**
   * Unsafely observes the fiber, but returns immediately if it is not
   * already done.
   */
  unsafePoll() {
    return this._exitValue;
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  interruptAsFork(fiberId5) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId5))));
  }
  /**
   * In the background, interrupts the fiber as if interrupted from the specified fiber.
   */
  unsafeInterruptAsFork(fiberId5) {
    this.tell(interruptSignal(interrupt(fiberId5)));
  }
  /**
   * Adds an observer to the list of observers.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  /**
   * Removes the specified observer from the list of observers that will be
   * notified when the fiber exits.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  /**
   * Retrieves all fiber refs of the fiber.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  /**
   * Deletes the specified fiber ref.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  /**
   * Retrieves the state of the fiber ref, or else its initial value.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  /**
   * Sets the fiber ref to the specified value.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRef(fiberRef, value6) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value: value6
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  /**
   * Wholesale replaces all fiber refs of this fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  /**
   * Adds a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addChild(child) {
    this.getChildren().add(child);
  }
  /**
   * Removes a reference to the specified fiber inside the children set.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  removeChild(child) {
    this.getChildren().delete(child);
  }
  /**
   * Transfers all children of this fiber that are currently running to the
   * specified fiber scope.
   *
   * **NOTE**: This method must be invoked by the fiber itself after it has
   * evaluated the effects but prior to exiting.
   */
  transferChildren(scope5) {
    const children3 = this._children;
    this._children = null;
    if (children3 !== null && children3.size > 0) {
      for (const child of children3) {
        if (child._exitValue === null) {
          scope5.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  /**
   * On the current thread, executes all messages in the fiber's inbox. This
   * method may return before all work is done, in the event the fiber executes
   * an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  /**
   * Schedules the execution of all messages in the fiber's inbox.
   *
   * This method will return immediately after the scheduling
   * operation is completed, but potentially before such messages have been
   * executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  /**
   * Drains the fiber's message queue while the fiber is actively running,
   * returning the next effect to execute, which may be the input effect if no
   * additional effect needs to be executed.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  /**
   * Determines if the fiber is interrupted.
   *
   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
   * on this fiber, then values derived from the fiber's state (including the
   * log annotations and log level) may not be up-to-date.
   */
  isInterrupted() {
    return !isEmpty3(this.getFiberRef(currentInterruptedCause));
  }
  /**
   * Adds an interruptor to the set of interruptors that are interrupting this
   * fiber.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  addInterruptedCause(cause3) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause3));
  }
  /**
   * Processes a new incoming interrupt signal.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  processNewInterruptSignal(cause3) {
    this.addInterruptedCause(cause3);
    this.sendInterruptSignalToAllChildren();
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  /**
   * Interrupts all children of the current fiber, returning an effect that will
   * await the exit of the children. This method will return null if the fiber
   * has no children.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone7 = false;
      const body = /* @__PURE__ */ __name(() => {
        const next4 = it.next();
        if (!next4.done) {
          return asVoid2(next4.value.await);
        } else {
          return sync(() => {
            isDone7 = true;
          });
        }
      }, "body");
      return whileLoop({
        while: /* @__PURE__ */ __name(() => !isDone7, "while"),
        body,
        step: /* @__PURE__ */ __name(() => {
        }, "step")
      });
    }
    return null;
  }
  reportExitValue(exit5) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags3 = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags3);
      fiberActive.unsafeUpdate(-1, tags3);
      switch (exit5._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags3);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags3);
          break;
        }
      }
    }
    if (exit5._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit5.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit5.cause, level);
      }
    }
  }
  setExitValue(exit5) {
    this._exitValue = exit5;
    this.reportExitValue(exit5);
    for (let i = this._observers.length - 1; i >= 0; i--) {
      this._observers[i](exit5);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause3, overrideLogLevel) {
    const logLevel2 = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel3 = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel3, logLevel2)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations3 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size4(loggers) > 0) {
      const clockService = get6(this.getFiberRef(currentServices), clockTag);
      const date4 = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger3 of loggers) {
          logger3.log({
            fiberId: this.id(),
            logLevel: logLevel2,
            message,
            cause: cause3,
            context: contextMap,
            spans,
            annotations: annotations3,
            date: date4
          });
        }
      });
    }
  }
  /**
   * Evaluates a single message on the current thread, while the fiber is
   * suspended. This method should only be called while evaluation of the
   * fiber's effect is suspended due to an asynchronous operation.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done3 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  /**
   * Evaluates an effect until completion, potentially asynchronously.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect4 = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect4 !== null) {
        const eff = effect4;
        const exit5 = this.runLoop(eff);
        if (exit5 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect4 = null;
            } else {
              effect4 = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect4 = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect4 = flatMap10(interruption2, () => exit5);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit5);
            } else {
              this.tell(resume(exit5));
            }
            effect4 = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on the current
   * thread. This can be called to "kick off" execution of a fiber after it has
   * been created, in hopes that the effect can be executed synchronously.
   *
   * This is not the normal way of starting a fiber, but it is useful when the
   * express goal of executing the fiber is to synchronously produce its exit.
   */
  start(effect4) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect4);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect4));
    }
  }
  /**
   * Begins execution of the effect associated with this fiber on in the
   * background, and on the correct thread pool. This can be called to "kick
   * off" execution of a fiber after it has been created, in hopes that the
   * effect can be executed synchronously.
   */
  startFork(effect4) {
    this.tell(resume(effect4));
  }
  /**
   * Takes the current runtime flags, patches them to return the new runtime
   * flags, and then makes any changes necessary to fiber state based on the
   * specified patch.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  patchRuntimeFlags(oldRuntimeFlags, patch12) {
    const newRuntimeFlags = patch4(oldRuntimeFlags, patch12);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  /**
   * Initiates an asynchronous operation, by building a callback that will
   * resume execution, and then feeding that callback to the registration
   * function, handling error cases and repeated resumptions appropriately.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = /* @__PURE__ */ __name((effect4) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect4));
      }
    }, "callback");
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet5(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException());
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit5) => {
        if (exit5._tag === "Success") {
          return resume2(exitSucceed(exit5.value));
        }
        switch (exit5.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit5.cause.error));
          }
          case "Die": {
            return resume2(die2(exit5.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = /* @__PURE__ */ __name((_) => {
          abortResume(void_3);
        }, "resume");
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value6 = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value6);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value6);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== void 0) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause3 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== void 0) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause3));
          } else {
            return exitFailCause(stripFailures(cause3));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause3, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause3);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause3);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff6(snap.refs, refs);
      const patchFlags = diff4(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch7(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch4(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap10(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch4(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff4(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check6 = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check6()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, void 0);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  /**
   * The main run-loop for evaluating effects.
   *
   * **NOTE**: This method must be invoked by the fiber itself.
   */
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap10(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
            if (level._tag === "Some") {
              const effectVersion = cur[EffectTypeId2]._V;
              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty8, level);
            }
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = /* @__PURE__ */ __name(() => {
    this.drainQueueOnCurrentThread();
  }, "run");
};
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = /* @__PURE__ */ __name((self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get6(services, consoleTag).unsafe.log(self2.log(opts));
}), "loggerWithConsoleLog");
var loggerWithLeveledLog = /* @__PURE__ */ __name((self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  const unsafeLogger = get6(services, consoleTag).unsafe;
  switch (opts.logLevel._tag) {
    case "Debug":
      return unsafeLogger.debug(self2.log(opts));
    case "Info":
      return unsafeLogger.info(self2.log(opts));
    case "Trace":
      return unsafeLogger.trace(self2.log(opts));
    case "Warning":
      return unsafeLogger.warn(self2.log(opts));
    case "Error":
    case "Fatal":
      return unsafeLogger.error(self2.log(opts));
    default:
      return unsafeLogger.log(self2.log(opts));
  }
}), "loggerWithLeveledLog");
var loggerWithConsoleError = /* @__PURE__ */ __name((self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get6(services, consoleTag).unsafe.error(self2.log(opts));
}), "loggerWithConsoleError");
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var jsonLogger2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/jsonLogger"), () => loggerWithConsoleLog(jsonLogger));
var logFmtLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/logFmtLogger"), () => loggerWithConsoleLog(logfmtLogger));
var prettyLogger2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/prettyLogger"), () => prettyLoggerDefault);
var structuredLogger2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/structuredLogger"), () => loggerWithConsoleLog(structuredLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations3,
  cause: cause3,
  context: context17,
  fiberId: fiberId5,
  logLevel: logLevel2,
  message
}) => {
  const span4 = getOption2(getOrDefault(context17, currentContext), spanTag);
  if (span4._tag === "None" || span4.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet5(getOrDefault(context17, currentServices), clockTag);
  const attributes = {};
  for (const [key, value6] of annotations3) {
    attributes[key] = value6;
  }
  attributes["effect.fiberId"] = threadName2(fiberId5);
  attributes["effect.logLevel"] = logLevel2.label;
  if (cause3 !== null && cause3._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause3, {
      renderErrorCause: true
    });
  }
  span4.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var loggerWithSpanAnnotations = /* @__PURE__ */ __name((self2) => mapInputOptions(self2, (options4) => {
  const span4 = flatMap2(get9(options4.context, currentContext), getOption2(spanTag));
  if (span4._tag === "None") {
    return options4;
  }
  return {
    ...options4,
    annotations: pipe(options4.annotations, set3("effect.traceId", span4.value.traceId), set3("effect.spanId", span4.value.spanId), span4.value._tag === "Span" ? set3("effect.spanName", span4.value.name) : identity)
  };
}), "loggerWithSpanAnnotations");
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make9(defaultLogger, tracerLogger)));
var batchedLogger = /* @__PURE__ */ dual(3, (self2, window3, f) => flatMap10(scope, (scope5) => {
  let buffer4 = [];
  const flush = suspend(() => {
    if (buffer4.length === 0) {
      return void_3;
    }
    const arr = buffer4;
    buffer4 = [];
    return f(arr);
  });
  return uninterruptibleMask((restore) => pipe(sleep3(window3), zipRight2(flush), forever, restore, forkDaemon, flatMap10((fiber) => scopeAddFinalizer(scope5, interruptFiber(fiber))), zipRight2(addFinalizer(() => flush)), as3(makeLogger((options4) => {
    buffer4.push(self2.log(options4));
  }))));
}));
var annotateLogsScoped = /* @__PURE__ */ __name(function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set3(arguments[0], arguments[1]));
  }
  const entries3 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate4((annotations3) => {
    for (let i = 0; i < entries3.length; i++) {
      const [key, value6] = entries3[i];
      set3(annotations3, key, value6);
    }
    return annotations3;
  }));
}, "annotateLogsScoped");
var whenLogLevel = /* @__PURE__ */ dual(2, (effect4, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel3 = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan3(minimumLogLevel3, requiredLogLevel)) {
      return succeed(none2());
    }
    return map12(effect4, some3);
  });
});
var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release2) => uninterruptible(tap2(acquire, (a) => addFinalizer((exit5) => release2(a, exit5)))));
var acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release2) => ensuring(acquire, addFinalizer((exit5) => release2(exit5))));
var addFinalizer = /* @__PURE__ */ __name((finalizer3) => withFiberRuntime((runtime8) => {
  const acquireRefs = runtime8.getFiberRefs();
  const acquireFlags = disable2(runtime8.currentRuntimeFlags, Interruption);
  return flatMap10(scope, (scope5) => scopeAddFinalizerExit(scope5, (exit5) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff6(preRefs, acquireRefs);
    const patchFlags = diff4(preFlags, acquireFlags);
    const inverseRefs = diff6(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch7(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer3(exit5), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch7(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
}), "addFinalizer");
var daemonChildren = /* @__PURE__ */ __name((self2) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some3(globalScope));
  return forkScope(self2);
}, "daemonChildren");
var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
var exists3 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options4) => matchSimple(options4?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach10(elements, (a, i) => if_(predicate(a, i), {
  onTrue: /* @__PURE__ */ __name(() => fail2(_existsParFound), "onTrue"),
  onFalse: /* @__PURE__ */ __name(() => void_3, "onFalse")
}), options4), {
  onFailure: /* @__PURE__ */ __name((e) => e === _existsParFound ? succeed(true) : fail2(e), "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => succeed(false), "onSuccess")
})));
var existsLoop = /* @__PURE__ */ __name((iterator, index2, f) => {
  const next4 = iterator.next();
  if (next4.done) {
    return succeed(false);
  }
  return flatMap10(f(next4.value, index2), (b) => b ? succeed(b) : existsLoop(iterator, index2 + 1, f));
}, "existsLoop");
var filter10 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options4) => {
  const predicate_ = options4?.negate ? (a, i) => map12(predicate(a, i), not2) : predicate;
  return matchSimple(options4?.concurrency, () => suspend(() => fromIterable2(elements).reduceRight((effect4, a, i) => zipWith5(effect4, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array()))), () => map12(forEach10(elements, (a, i) => map12(predicate_(a, i), (b) => b ? some3(a) : none2()), options4), getSomes));
});
var allResolveInput = /* @__PURE__ */ __name((input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys6 = Object.keys(input);
  const size22 = keys6.length;
  return [keys6.map((k) => input[k]), some3((values6) => {
    const res = {};
    for (let i = 0; i < size22; i++) {
      ;
      res[keys6[i]] = values6[i];
    }
    return res;
  })];
}, "allResolveInput");
var allValidate = /* @__PURE__ */ __name((effects, reconcile, options4) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either2(effect4));
  }
  return flatMap10(forEach10(eitherEffects, identity, {
    concurrency: options4?.concurrency,
    batching: options4?.batching,
    concurrentFinalizers: options4?.concurrentFinalizers
  }), (eithers) => {
    const none13 = none2();
    const size22 = eithers.length;
    const errors4 = new Array(size22);
    const successes = new Array(size22);
    let errored = false;
    for (let i = 0; i < size22; i++) {
      const either12 = eithers[i];
      if (either12._tag === "Left") {
        errors4[i] = some3(either12.left);
        errored = true;
      } else {
        successes[i] = either12.right;
        errors4[i] = none13;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors4)) : fail2(errors4);
    } else if (options4?.discard) {
      return void_3;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
}, "allValidate");
var allEither = /* @__PURE__ */ __name((effects, reconcile, options4) => {
  const eitherEffects = [];
  for (const effect4 of effects) {
    eitherEffects.push(either2(effect4));
  }
  if (options4?.discard) {
    return forEach10(eitherEffects, identity, {
      concurrency: options4?.concurrency,
      batching: options4?.batching,
      discard: true,
      concurrentFinalizers: options4?.concurrentFinalizers
    });
  }
  return map12(forEach10(eitherEffects, identity, {
    concurrency: options4?.concurrency,
    batching: options4?.batching,
    concurrentFinalizers: options4?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
}, "allEither");
var all6 = /* @__PURE__ */ __name((arg, options4) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options4?.mode === "validate") {
    return allValidate(effects, reconcile, options4);
  } else if (options4?.mode === "either") {
    return allEither(effects, reconcile, options4);
  }
  return options4?.discard !== true && reconcile._tag === "Some" ? map12(forEach10(effects, identity, options4), reconcile.value) : forEach10(effects, identity, options4);
}, "all");
var allWith = /* @__PURE__ */ __name((options4) => (arg) => all6(arg, options4), "allWith");
var allSuccesses = /* @__PURE__ */ __name((elements, options4) => map12(all6(fromIterable2(elements).map(exit2), options4), filterMap2((exit5) => exitIsSuccess(exit5) ? some3(exit5.effect_instruction_i0) : none2())), "allSuccesses");
var replicate2 = /* @__PURE__ */ dual(2, (self2, n) => Array.from({
  length: n
}, () => self2));
var replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, n, options4) => all6(replicate2(self2, n), options4));
var forEach10 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self2, f, options4) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options4?.batching === true || options4?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options4?.discard) {
    return match7(options4.concurrency, () => finalizersMaskInternal(sequential3, options4?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options4?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options4?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match7(options4?.concurrency, () => finalizersMaskInternal(sequential3, options4?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self2, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options4?.concurrentFinalizers)((restore) => forEachParUnbounded(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options4?.concurrentFinalizers)((restore) => forEachParN(self2, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = /* @__PURE__ */ __name((self2, f, batching) => suspend(() => {
  const as16 = fromIterable2(self2);
  const array7 = new Array(as16.length);
  const fn2 = /* @__PURE__ */ __name((a, i) => flatMap10(f(a, i), (b) => sync(() => array7[i] = b)), "fn");
  return zipRight2(forEachConcurrentDiscard(as16, fn2, batching, false), succeed(array7));
}), "forEachParUnbounded");
var forEachConcurrentDiscard = /* @__PURE__ */ __name((self2, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self2).reverse();
  let target3 = todos.length;
  if (target3 === 0) {
    return void_3;
  }
  let counter6 = 0;
  let interrupted4 = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = /* @__PURE__ */ new Set();
  const results = new Array();
  const interruptAll3 = /* @__PURE__ */ __name(() => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  }), "interruptAll");
  const startOrder = new Array();
  const joinOrder = new Array();
  const residual = new Array();
  const collectExits = /* @__PURE__ */ __name(() => {
    const exits = results.filter(({
      exit: exit5
    }) => exit5._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit5
    }) => exit5);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  }, "collectExits");
  const runFiber = /* @__PURE__ */ __name((eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  }, "runFiber");
  const onInterruptSignal = /* @__PURE__ */ __name(() => {
    if (!processAll) {
      target3 -= todos.length;
      todos = [];
    }
    interrupted4 = true;
    interruptAll3();
  }, "onInterruptSignal");
  const stepOrExit = batching ? step2 : exit2;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = /* @__PURE__ */ __name((res, index2) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index: index2,
          exit: res
        });
        if (res._op === "Failure" && !interrupted4) {
          onInterruptSignal();
        }
      }
    }, "pushResult");
    const next4 = /* @__PURE__ */ __name(() => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index2 = counter6++;
        const returnNextElement = /* @__PURE__ */ __name(() => {
          const a2 = todos.pop();
          index2 = counter6++;
          return flatMap10(yieldNow(), () => flatMap10(stepOrExit(restore(f(a2, index2))), onRes));
        }, "returnNextElement");
        const onRes = /* @__PURE__ */ __name((res) => {
          if (todos.length > 0) {
            pushResult(res, index2);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        }, "onRes");
        const todo = flatMap10(stepOrExit(restore(f(a, index2))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted4) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit5;
          if (wrapped._op === "Failure") {
            exit5 = wrapped;
          } else {
            exit5 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit5, index2);
          if (results.length === target3) {
            resume2(succeed(getOrElse2(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target3) {
            const exits = collectExits();
            const requests = residual.map((blocked3) => blocked3.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse2(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked3) => blocked3.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next4();
          }
        });
      }
    }, "next");
    for (let i = 0; i < fibersCount; i++) {
      next4();
    }
  }));
  return asVoid2(onExit(flatten6(restore(join3(processingFiber))), exitMatch({
    onFailure: /* @__PURE__ */ __name((cause3) => {
      onInterruptSignal();
      const target4 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count7 = 0;
        let index2 = 0;
        const check6 = /* @__PURE__ */ __name((index3, hitNext) => (exit5) => {
          exits[index3] = exit5;
          count7++;
          if (count7 === target4) {
            cb(exitSucceed(exitFailCause(cause3)));
          }
          if (toPop.length > 0 && hitNext) {
            next4();
          }
        }, "check");
        const next4 = /* @__PURE__ */ __name(() => {
          runFiber(toPop.pop(), true).addObserver(check6(index2, true));
          index2++;
        }, "next");
        processingFiber.addObserver(check6(index2, false));
        index2++;
        for (let i = 0; i < concurrency; i++) {
          next4();
        }
      });
    }, "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => forEachSequential(joinOrder, (f2) => f2.inheritAll), "onSuccess")
  })));
}))), "forEachConcurrentDiscard");
var forEachParN = /* @__PURE__ */ __name((self2, n, f, batching) => suspend(() => {
  const as16 = fromIterable2(self2);
  const array7 = new Array(as16.length);
  const fn2 = /* @__PURE__ */ __name((a, i) => map12(f(a, i), (b) => array7[i] = b), "fn");
  return zipRight2(forEachConcurrentDiscard(as16, fn2, batching, false, n), succeed(array7));
}), "forEachParN");
var fork = /* @__PURE__ */ __name((self2) => withFiberRuntime((state2, status3) => succeed(unsafeFork2(self2, state2, status3.runtimeFlags))), "fork");
var forkDaemon = /* @__PURE__ */ __name((self2) => forkWithScopeOverride(self2, globalScope), "forkDaemon");
var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self2, handler) => fork(onError(self2, (cause3) => {
  const either12 = failureOrCause(cause3);
  switch (either12._tag) {
    case "Left":
      return handler(either12.left);
    case "Right":
      return failCause(either12.right);
  }
})));
var unsafeFork2 = /* @__PURE__ */ __name((effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect4);
  return childFiber;
}, "unsafeFork");
var unsafeForkUnstarted = /* @__PURE__ */ __name((effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect4, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
}, "unsafeForkUnstarted");
var unsafeMakeChildFiber = /* @__PURE__ */ __name((effect4, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect4, some3(parentFiber), childFiber);
  childFiber.addObserver((exit5) => supervisor.onEnd(exit5, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse2(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
}, "unsafeMakeChildFiber");
var forkWithScopeOverride = /* @__PURE__ */ __name((self2, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork2(self2, parentFiber, parentStatus.runtimeFlags, scopeOverride))), "forkWithScopeOverride");
var mergeAll3 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero3, f, options4) => matchSimple(options4?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith5(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero3)), () => flatMap10(make26(zero3), (acc) => flatMap10(forEach10(elements, (effect4, i) => flatMap10(effect4, (a) => update3(acc, (b) => f(b, a, i))), options4), () => get12(acc)))));
var partition5 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options4) => pipe(forEach10(elements, (a, i) => either2(f(a, i)), options4), map12((chunk4) => partitionMap4(chunk4, identity))));
var validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options4) => flatMap10(partition5(elements, f, {
  concurrency: options4?.concurrency,
  batching: options4?.batching,
  concurrentFinalizers: options4?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options4?.discard ? void_3 : succeed(bs)));
var raceAll = /* @__PURE__ */ __name((all14) => withFiberRuntime((state2, status3) => async_((resume2) => {
  const fibers = /* @__PURE__ */ new Set();
  let winner;
  let failures3 = empty8;
  const interruptAll3 = /* @__PURE__ */ __name(() => {
    for (const fiber of fibers) {
      fiber.unsafeInterruptAsFork(state2.id());
    }
  }, "interruptAll");
  let latch = false;
  let empty45 = true;
  for (const self2 of all14) {
    empty45 = false;
    const fiber = unsafeFork2(interruptible2(self2), state2, status3.runtimeFlags);
    fibers.add(fiber);
    fiber.addObserver((exit5) => {
      fibers.delete(fiber);
      if (!winner) {
        if (exit5._tag === "Success") {
          latch = true;
          winner = fiber;
          failures3 = empty8;
          interruptAll3();
        } else {
          failures3 = parallel(exit5.cause, failures3);
        }
      }
      if (latch && fibers.size === 0) {
        resume2(winner ? zipRight2(inheritAll(winner), winner.unsafePoll()) : failCause(failures3));
      }
    });
    if (winner) break;
  }
  if (empty45) {
    return resume2(dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`)));
  }
  latch = true;
  return interruptAllAs(fibers, state2.id());
})), "raceAll");
var reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero3, f, options4) => matchSimple(options4?.concurrency, () => fromIterable2(elements).reduce((acc, a, i) => zipWith5(acc, a, (acc2, a2) => f(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll3([zero3, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some3(elem);
    }
    case "Some": {
      return some3(f(acc.value, elem, i));
    }
  }
}, options4), map12((option9) => {
  switch (option9._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option9.value;
    }
  }
})))));
var parallelFinalizers = /* @__PURE__ */ __name((self2) => contextWithEffect((context17) => match2(getOption2(context17, scopeTag), {
  onNone: /* @__PURE__ */ __name(() => self2, "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    switch (scope5.strategy._tag) {
      case "Parallel":
        return self2;
      case "Sequential":
      case "ParallelN":
        return flatMap10(scopeFork(scope5, parallel3), (inner) => scopeExtend(self2, inner));
    }
  }, "onSome")
})), "parallelFinalizers");
var parallelNFinalizers = /* @__PURE__ */ __name((parallelism) => (self2) => contextWithEffect((context17) => match2(getOption2(context17, scopeTag), {
  onNone: /* @__PURE__ */ __name(() => self2, "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    if (scope5.strategy._tag === "ParallelN" && scope5.strategy.parallelism === parallelism) {
      return self2;
    }
    return flatMap10(scopeFork(scope5, parallelN2(parallelism)), (inner) => scopeExtend(self2, inner));
  }, "onSome")
})), "parallelNFinalizers");
var finalizersMask = /* @__PURE__ */ __name((strategy) => (self2) => finalizersMaskInternal(strategy, true)(self2), "finalizersMask");
var finalizersMaskInternal = /* @__PURE__ */ __name((strategy, concurrentFinalizers) => (self2) => contextWithEffect((context17) => match2(getOption2(context17, scopeTag), {
  onNone: /* @__PURE__ */ __name(() => self2(identity), "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    if (concurrentFinalizers === true) {
      const patch12 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope5.strategy._tag) {
        case "Parallel":
          return patch12(self2(parallelFinalizers));
        case "Sequential":
          return patch12(self2(sequentialFinalizers));
        case "ParallelN":
          return patch12(self2(parallelNFinalizers(scope5.strategy.parallelism)));
      }
    } else {
      return self2(identity);
    }
  }, "onSome")
})), "finalizersMaskInternal");
var scopeWith = /* @__PURE__ */ __name((f) => flatMap10(scopeTag, f), "scopeWith");
var scopedWith = /* @__PURE__ */ __name((f) => flatMap10(scopeMake(), (scope5) => onExit(f(scope5), (exit5) => scope5.close(exit5))), "scopedWith");
var scopedEffect = /* @__PURE__ */ __name((effect4) => flatMap10(scopeMake(), (scope5) => scopeUse(effect4, scope5)), "scopedEffect");
var sequentialFinalizers = /* @__PURE__ */ __name((self2) => contextWithEffect((context17) => match2(getOption2(context17, scopeTag), {
  onNone: /* @__PURE__ */ __name(() => self2, "onNone"),
  onSome: /* @__PURE__ */ __name((scope5) => {
    switch (scope5.strategy._tag) {
      case "Sequential":
        return self2;
      case "Parallel":
      case "ParallelN":
        return flatMap10(scopeFork(scope5, sequential3), (inner) => scopeExtend(self2, inner));
    }
  }, "onSome")
})), "sequentialFinalizers");
var tagMetricsScoped = /* @__PURE__ */ __name((key, value6) => labelMetricsScoped([make30(key, value6)]), "tagMetricsScoped");
var labelMetricsScoped = /* @__PURE__ */ __name((labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels)), "labelMetricsScoped");
var using = /* @__PURE__ */ dual(2, (self2, use3) => scopedWith((scope5) => flatMap10(scopeExtend(self2, scope5), use3)));
var validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options4) => validateWith(self2, that, (a, b) => [a, b], options4));
var validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options4) => flatten6(zipWithOptions(exit2(self2), exit2(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: /* @__PURE__ */ __name((ca, cb) => options4?.concurrent ? parallel(ca, cb) : sequential(ca, cb), "onFailure")
}), options4)));
var validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options4) => flip2(forEach10(elements, (a, i) => flip2(f(a, i)), options4)));
var withClockScoped = /* @__PURE__ */ __name((c) => fiberRefLocallyScopedWith(currentServices, add4(clockTag, c)), "withClockScoped");
var withRandomScoped = /* @__PURE__ */ __name((value6) => fiberRefLocallyScopedWith(currentServices, add4(randomTag, value6)), "withRandomScoped");
var withConfigProviderScoped = /* @__PURE__ */ __name((provider) => fiberRefLocallyScopedWith(currentServices, add4(configProviderTag, provider)), "withConfigProviderScoped");
var withEarlyRelease = /* @__PURE__ */ __name((self2) => scopeWith((parent) => flatMap10(scopeFork(parent, sequential2), (child) => pipe(self2, scopeExtend(child), map12((value6) => [fiberIdWith((fiberId5) => scopeClose(child, exitInterrupt(fiberId5))), value6])))), "withEarlyRelease");
var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options4) => zipWithOptions(self2, that, (a, b) => [a, b], options4));
var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options4) => {
  if (options4?.concurrent !== true && (options4?.batching === void 0 || options4.batching === false)) {
    return zipLeft2(self2, that);
  }
  return zipWithOptions(self2, that, (a, _) => a, options4);
});
var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options4) => {
  if (options4?.concurrent !== true && (options4?.batching === void 0 || options4.batching === false)) {
    return zipRight2(self2, that);
  }
  return zipWithOptions(self2, that, (_, b) => b, options4);
});
var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options4) => map12(all6([self2, that], {
  concurrency: options4?.concurrent ? 2 : 1,
  batching: options4?.batching,
  concurrentFinalizers: options4?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped = /* @__PURE__ */ __name((update9) => {
  if (update9 === empty17) {
    return void_3;
  }
  return pipe(runtimeFlags, flatMap10((runtimeFlags2) => {
    const updatedRuntimeFlags = patch4(runtimeFlags2, update9);
    const revertRuntimeFlags = diff4(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update9), zipRight2(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid2);
  }), uninterruptible);
}, "withRuntimeFlagsScoped");
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = /* @__PURE__ */ __name((scope5, fin) => {
  if (scope5.state._tag === "Open") {
    scope5.state.finalizers.set({}, fin);
  }
}, "scopeUnsafeAddFinalizer");
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = /* @__PURE__ */ __name((exit5) => newScope.close(exit5), "fin");
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit5) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_3;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit5
      };
      if (finalizers.length === 0) {
        return void_3;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit2(fin(exit5))), flatMap10((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse2(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit2(fin(exit5)), false), flatMap10((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse2(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit2(fin(exit5)), false), flatMap10((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse2(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_3;
    });
  }
};
var scopeUnsafeMake = /* @__PURE__ */ __name((strategy = sequential2) => {
  const scope5 = Object.create(ScopeImplProto);
  scope5.strategy = strategy;
  scope5.state = {
    _tag: "Open",
    finalizers: /* @__PURE__ */ new Map()
  };
  return scope5;
}, "scopeUnsafeMake");
var scopeMake = /* @__PURE__ */ __name((strategy = sequential2) => sync(() => scopeUnsafeMake(strategy)), "scopeMake");
var scopeExtend = /* @__PURE__ */ dual(2, (effect4, scope5) => mapInputContext(
  effect4,
  // @ts-expect-error
  merge3(make11(scopeTag, scope5))
));
var scopeUse = /* @__PURE__ */ dual(2, (effect4, scope5) => pipe(effect4, scopeExtend(scope5), onExit((exit5) => scope5.close(exit5))));
var fiberRefUnsafeMakeSupervisor = /* @__PURE__ */ __name((initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty26
}), "fiberRefUnsafeMakeSupervisor");
var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self2, value6) => asVoid2(acquireRelease(flatMap10(fiberRefGet(self2), (oldValue) => as3(fiberRefSet(self2, value6), oldValue)), (oldValue) => fiberRefSet(self2, oldValue))));
var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocallyScoped(self2, f(a))));
var fiberRefMake = /* @__PURE__ */ __name((initial, options4) => fiberRefMakeWith(() => fiberRefUnsafeMake(initial, options4)), "fiberRefMake");
var fiberRefMakeWith = /* @__PURE__ */ __name((ref2) => acquireRelease(tap2(sync(ref2), (ref3) => fiberRefUpdate(ref3, identity)), (fiberRef) => fiberRefDelete(fiberRef)), "fiberRefMakeWith");
var fiberRefMakeContext = /* @__PURE__ */ __name((initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeContext(initial)), "fiberRefMakeContext");
var fiberRefMakeRuntimeFlags = /* @__PURE__ */ __name((initial) => fiberRefMakeWith(() => fiberRefUnsafeMakeRuntimeFlags(initial)), "fiberRefMakeRuntimeFlags");
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = /* @__PURE__ */ __name((fibers) => forEach10(fibers, _await), "fiberAwaitAll");
var fiberAll = /* @__PURE__ */ __name((fibers) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join3(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: /* @__PURE__ */ __name(() => fromIterable2(fibers).reduce((id4, fiber) => combine3(id4, fiber.id()), none4), "id"),
    await: exit2(forEachParUnbounded(fibers, (fiber) => flatten6(fiber.await), false)),
    children: map12(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten2),
    inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
    poll: map12(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some3(exitSucceed(new Array())), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some3(exitZipWith(optionA.value, optionB.value, {
                onSuccess: /* @__PURE__ */ __name((a, chunk4) => [a, ...chunk4], "onSuccess"),
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: /* @__PURE__ */ __name((fiberId5) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId5)), "interruptAsFork")
  };
  return _fiberAll;
}, "fiberAll");
var fiberInterruptFork = /* @__PURE__ */ __name((self2) => asVoid2(forkDaemon(interruptFiber(self2))), "fiberInterruptFork");
var fiberJoinAll = /* @__PURE__ */ __name((fibers) => join3(fiberAll(fibers)), "fiberJoinAll");
var fiberScoped = /* @__PURE__ */ __name((self2) => acquireRelease(succeed(self2), interruptFiber), "fiberScoped");
var raceWith = /* @__PURE__ */ dual(3, (self2, other, options4) => raceFibersWith(self2, other, {
  onSelfWin: /* @__PURE__ */ __name((winner, loser) => flatMap10(winner.await, (exit5) => {
    switch (exit5._tag) {
      case OP_SUCCESS: {
        return flatMap10(winner.inheritAll, () => options4.onSelfDone(exit5, loser));
      }
      case OP_FAILURE: {
        return options4.onSelfDone(exit5, loser);
      }
    }
  }), "onSelfWin"),
  onOtherWin: /* @__PURE__ */ __name((winner, loser) => flatMap10(winner.await, (exit5) => {
    switch (exit5._tag) {
      case OP_SUCCESS: {
        return flatMap10(winner.inheritAll, () => options4.onOtherDone(exit5, loser));
      }
      case OP_FAILURE: {
        return options4.onOtherDone(exit5, loser);
      }
    }
  }), "onOtherWin")
}));
var disconnect2 = /* @__PURE__ */ __name((self2) => uninterruptibleMask((restore) => fiberIdWith((fiberId5) => flatMap10(forkDaemon(restore(self2)), (fiber) => pipe(restore(join3(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId5))))))), "disconnect");
var race = /* @__PURE__ */ dual(2, (self2, that) => fiberIdWith((parentFiberId) => raceWith(self2, that, {
  onSelfDone: /* @__PURE__ */ __name((exit5, right3) => exitMatchEffect(exit5, {
    onFailure: /* @__PURE__ */ __name((cause3) => pipe(join3(right3), mapErrorCause((cause22) => parallel(cause3, cause22))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((value6) => pipe(right3, interruptAsFiber(parentFiberId), as3(value6)), "onSuccess")
  }), "onSelfDone"),
  onOtherDone: /* @__PURE__ */ __name((exit5, left3) => exitMatchEffect(exit5, {
    onFailure: /* @__PURE__ */ __name((cause3) => pipe(join3(left3), mapErrorCause((cause22) => parallel(cause22, cause3))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((value6) => pipe(left3, interruptAsFiber(parentFiberId), as3(value6)), "onSuccess")
  }), "onOtherDone")
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self2, other, options4) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make13(true);
  const leftFiber = unsafeMakeChildFiber(self2, parentFiber, parentRuntimeFlags, options4.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options4.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options4.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options4.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self2);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = /* @__PURE__ */ __name((winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
}, "completeRace");
var ensuring = /* @__PURE__ */ dual(2, (self2, finalizer3) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: /* @__PURE__ */ __name((cause1) => matchCauseEffect(finalizer3, {
    onFailure: /* @__PURE__ */ __name((cause22) => failCause(sequential(cause1, cause22)), "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => failCause(cause1), "onSuccess")
  }), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => as3(finalizer3, a), "onSuccess")
})));
var invokeWithInterrupt = /* @__PURE__ */ __name((self2, entries3, onInterrupt3) => fiberIdWith((id4) => flatMap10(flatMap10(forkDaemon(interruptible2(self2)), (processing) => async_((cb) => {
  const counts = entries3.map((_) => _.listeners.count);
  const checkDone = /* @__PURE__ */ __name(() => {
    if (counts.every((count7) => count7 === 0)) {
      if (entries3.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt3?.();
        cb(interruptFiber(processing));
      }
    }
  }, "checkDone");
  processing.addObserver((exit5) => {
    cleanup.forEach((f) => f());
    cb(exit5);
  });
  const cleanup = entries3.map((r, i) => {
    const observer = /* @__PURE__ */ __name((count7) => {
      counts[i] = count7;
      checkDone();
    }, "observer");
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries3.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id4)));
}))), "invokeWithInterrupt");
var makeSpanScoped = /* @__PURE__ */ __name((name, options4) => {
  options4 = addSpanStackTrace(options4);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope5 = unsafeGet5(fiber.getFiberRef(currentContext), scopeTag);
    const span4 = unsafeMakeSpan(fiber, name, options4);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get6(fiber.getFiberRef(currentServices), clockTag);
    return as3(scopeAddFinalizerExit(scope5, (exit5) => endSpan(span4, exit5, clock_, timingEnabled)), span4);
  }));
}, "makeSpanScoped");
var withTracerScoped = /* @__PURE__ */ __name((value6) => fiberRefLocallyScopedWith(currentServices, add4(tracerTag, value6)), "withTracerScoped");
var withSpanScoped = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options4 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return flatMap10(makeSpanScoped(name, addSpanStackTrace(options4)), (span4) => provideService(self2, spanTag, span4));
  }
  return (self2) => flatMap10(makeSpanScoped(name, addSpanStackTrace(options4)), (span4) => provideService(self2, spanTag, span4));
}, "withSpanScoped");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/layer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Cause.js
var Cause_exports = {};
__export(Cause_exports, {
  CauseTypeId: () => CauseTypeId2,
  ExceededCapacityException: () => ExceededCapacityException2,
  ExceededCapacityExceptionTypeId: () => ExceededCapacityExceptionTypeId2,
  IllegalArgumentException: () => IllegalArgumentException2,
  IllegalArgumentExceptionTypeId: () => IllegalArgumentExceptionTypeId2,
  InterruptedException: () => InterruptedException2,
  InterruptedExceptionTypeId: () => InterruptedExceptionTypeId2,
  InvalidPubSubCapacityExceptionTypeId: () => InvalidPubSubCapacityExceptionTypeId2,
  NoSuchElementException: () => NoSuchElementException2,
  NoSuchElementExceptionTypeId: () => NoSuchElementExceptionTypeId2,
  RuntimeException: () => RuntimeException2,
  RuntimeExceptionTypeId: () => RuntimeExceptionTypeId2,
  TimeoutException: () => TimeoutException2,
  TimeoutExceptionTypeId: () => TimeoutExceptionTypeId2,
  UnknownException: () => UnknownException2,
  UnknownExceptionTypeId: () => UnknownExceptionTypeId2,
  YieldableError: () => YieldableError2,
  andThen: () => andThen6,
  as: () => as6,
  contains: () => contains5,
  defects: () => defects2,
  die: () => die4,
  dieOption: () => dieOption2,
  empty: () => empty27,
  fail: () => fail5,
  failureOption: () => failureOption2,
  failureOrCause: () => failureOrCause2,
  failures: () => failures2,
  filter: () => filter11,
  find: () => find2,
  flatMap: () => flatMap13,
  flatten: () => flatten8,
  flipCauseOption: () => flipCauseOption2,
  interrupt: () => interrupt4,
  interruptOption: () => interruptOption2,
  interruptors: () => interruptors2,
  isCause: () => isCause2,
  isDie: () => isDie2,
  isDieType: () => isDieType2,
  isEmpty: () => isEmpty6,
  isEmptyType: () => isEmptyType2,
  isExceededCapacityException: () => isExceededCapacityException2,
  isFailType: () => isFailType2,
  isFailure: () => isFailure4,
  isIllegalArgumentException: () => isIllegalArgumentException2,
  isInterruptType: () => isInterruptType2,
  isInterrupted: () => isInterrupted3,
  isInterruptedException: () => isInterruptedException2,
  isInterruptedOnly: () => isInterruptedOnly2,
  isNoSuchElementException: () => isNoSuchElementException2,
  isParallelType: () => isParallelType2,
  isRuntimeException: () => isRuntimeException2,
  isSequentialType: () => isSequentialType2,
  isTimeoutException: () => isTimeoutException2,
  isUnknownException: () => isUnknownException2,
  keepDefects: () => keepDefects2,
  linearize: () => linearize2,
  map: () => map18,
  match: () => match11,
  originalError: () => originalError,
  parallel: () => parallel4,
  pretty: () => pretty3,
  prettyErrors: () => prettyErrors2,
  reduce: () => reduce11,
  reduceWithContext: () => reduceWithContext3,
  sequential: () => sequential4,
  size: () => size10,
  squash: () => squash,
  squashWith: () => squashWith,
  stripFailures: () => stripFailures2,
  stripSomeDefects: () => stripSomeDefects2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CauseTypeId2 = CauseTypeId;
var RuntimeExceptionTypeId2 = RuntimeExceptionTypeId;
var InterruptedExceptionTypeId2 = InterruptedExceptionTypeId;
var IllegalArgumentExceptionTypeId2 = IllegalArgumentExceptionTypeId;
var NoSuchElementExceptionTypeId2 = NoSuchElementExceptionTypeId;
var InvalidPubSubCapacityExceptionTypeId2 = InvalidPubSubCapacityExceptionTypeId;
var ExceededCapacityExceptionTypeId2 = ExceededCapacityExceptionTypeId;
var TimeoutExceptionTypeId2 = TimeoutExceptionTypeId;
var UnknownExceptionTypeId2 = UnknownExceptionTypeId;
var YieldableError2 = YieldableError;
var empty27 = empty8;
var fail5 = fail;
var die4 = die;
var interrupt4 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isEmptyType2 = isEmptyType;
var isFailType2 = isFailType;
var isDieType2 = isDieType;
var isInterruptType2 = isInterruptType;
var isSequentialType2 = isSequentialType;
var isParallelType2 = isParallelType;
var size10 = size5;
var isEmpty6 = isEmpty3;
var isFailure4 = isFailure;
var isDie2 = isDie;
var isInterrupted3 = isInterrupted;
var isInterruptedOnly2 = isInterruptedOnly;
var failures2 = failures;
var defects2 = defects;
var interruptors2 = interruptors;
var failureOption2 = failureOption;
var failureOrCause2 = failureOrCause;
var flipCauseOption2 = flipCauseOption;
var dieOption2 = dieOption;
var interruptOption2 = interruptOption;
var keepDefects2 = keepDefects;
var linearize2 = linearize;
var stripFailures2 = stripFailures;
var stripSomeDefects2 = stripSomeDefects;
var as6 = as2;
var map18 = map10;
var flatMap13 = flatMap8;
var andThen6 = andThen3;
var flatten8 = flatten4;
var contains5 = contains4;
var squash = causeSquash;
var squashWith = causeSquashWith;
var find2 = find;
var filter11 = filter8;
var match11 = match4;
var reduce11 = reduce6;
var reduceWithContext3 = reduceWithContext;
var InterruptedException2 = InterruptedException;
var isInterruptedException2 = isInterruptedException;
var IllegalArgumentException2 = IllegalArgumentException;
var isIllegalArgumentException2 = isIllegalArgumentException;
var NoSuchElementException2 = NoSuchElementException;
var isNoSuchElementException2 = isNoSuchElementException;
var RuntimeException2 = RuntimeException;
var isRuntimeException2 = isRuntimeException;
var TimeoutException2 = TimeoutException;
var isTimeoutException2 = isTimeoutException;
var UnknownException2 = UnknownException;
var isUnknownException2 = isUnknownException;
var ExceededCapacityException2 = ExceededCapacityException;
var isExceededCapacityException2 = isExceededCapacityException;
var pretty3 = pretty;
var prettyErrors2 = prettyErrors;
var originalError = originalInstance;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ScheduleDecision.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule/decision.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ScheduleIntervals.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule/intervals.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ScheduleInterval.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule/interval.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty28 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make36 = /* @__PURE__ */ __name((startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty28;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
}, "make");
var lessThan4 = /* @__PURE__ */ dual(2, (self2, that) => min4(self2, that) === self2);
var min4 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.endMillis <= that.startMillis) return self2;
  if (that.endMillis <= self2.startMillis) return that;
  if (self2.startMillis < that.startMillis) return self2;
  if (that.startMillis < self2.startMillis) return that;
  if (self2.endMillis <= that.endMillis) return self2;
  return that;
});
var isEmpty7 = /* @__PURE__ */ __name((self2) => {
  return self2.startMillis >= self2.endMillis;
}, "isEmpty");
var intersect = /* @__PURE__ */ dual(2, (self2, that) => {
  const start3 = Math.max(self2.startMillis, that.startMillis);
  const end6 = Math.min(self2.endMillis, that.endMillis);
  return make36(start3, end6);
});
var size11 = /* @__PURE__ */ __name((self2) => {
  return millis(self2.endMillis - self2.startMillis);
}, "size");
var after = /* @__PURE__ */ __name((startMilliseconds) => {
  return make36(startMilliseconds, Number.POSITIVE_INFINITY);
}, "after");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ScheduleInterval.js
var make37 = make36;
var empty29 = empty28;
var lessThan5 = lessThan4;
var isEmpty8 = isEmpty7;
var intersect2 = intersect;
var size12 = size11;
var after2 = after;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make38 = /* @__PURE__ */ __name((intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
}, "make");
var union8 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (!isNonEmpty(that.intervals)) {
    return self2;
  }
  if (!isNonEmpty(self2.intervals)) {
    return that;
  }
  if (headNonEmpty2(self2.intervals).startMillis < headNonEmpty2(that.intervals).startMillis) {
    return unionLoop(tailNonEmpty2(self2.intervals), that.intervals, headNonEmpty2(self2.intervals), empty4());
  }
  return unionLoop(self2.intervals, tailNonEmpty2(that.intervals), headNonEmpty2(that.intervals), empty4());
});
var unionLoop = /* @__PURE__ */ __name((_self, _that, _interval, _acc) => {
  let self2 = _self;
  let that = _that;
  let interval = _interval;
  let acc = _acc;
  while (isNonEmpty(self2) || isNonEmpty(that)) {
    if (!isNonEmpty(self2) && isNonEmpty(that)) {
      if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
        self2 = empty4();
      } else {
        interval = make37(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
        self2 = empty4();
      }
    } else if (isNonEmpty(self2) && isEmpty(that)) {
      if (interval.endMillis < headNonEmpty2(self2).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(self2);
        that = empty4();
        self2 = tailNonEmpty2(self2);
      } else {
        interval = make37(interval.startMillis, headNonEmpty2(self2).endMillis);
        that = empty4();
        self2 = tailNonEmpty2(self2);
      }
    } else if (isNonEmpty(self2) && isNonEmpty(that)) {
      if (headNonEmpty2(self2).startMillis < headNonEmpty2(that).startMillis) {
        if (interval.endMillis < headNonEmpty2(self2).startMillis) {
          acc = pipe(acc, prepend2(interval));
          interval = headNonEmpty2(self2);
          self2 = tailNonEmpty2(self2);
        } else {
          interval = make37(interval.startMillis, headNonEmpty2(self2).endMillis);
          self2 = tailNonEmpty2(self2);
        }
      } else if (interval.endMillis < headNonEmpty2(that).startMillis) {
        acc = pipe(acc, prepend2(interval));
        interval = headNonEmpty2(that);
        that = tailNonEmpty2(that);
      } else {
        interval = make37(interval.startMillis, headNonEmpty2(that).endMillis);
        that = tailNonEmpty2(that);
      }
    } else {
      throw new Error(getBugErrorMessage("Intervals.unionLoop"));
    }
  }
  return make38(pipe(acc, prepend2(interval), reverse2));
}, "unionLoop");
var intersect3 = /* @__PURE__ */ dual(2, (self2, that) => intersectLoop(self2.intervals, that.intervals, empty4()));
var intersectLoop = /* @__PURE__ */ __name((_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty(left3) && isNonEmpty(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty8(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan5(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make38(reverse2(acc));
}, "intersectLoop");
var start = /* @__PURE__ */ __name((self2) => {
  return pipe(self2.intervals, head3, getOrElse2(() => empty29)).startMillis;
}, "start");
var end = /* @__PURE__ */ __name((self2) => {
  return pipe(self2.intervals, head3, getOrElse2(() => empty29)).endMillis;
}, "end");
var lessThan6 = /* @__PURE__ */ dual(2, (self2, that) => start(self2) < start(that));
var isNonEmpty3 = /* @__PURE__ */ __name((self2) => {
  return isNonEmpty(self2.intervals);
}, "isNonEmpty");
var max5 = /* @__PURE__ */ dual(2, (self2, that) => lessThan6(self2, that) ? that : self2);

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ScheduleIntervals.js
var make39 = make38;
var union9 = union8;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan7 = lessThan6;
var isNonEmpty4 = isNonEmpty3;
var max6 = max5;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = /* @__PURE__ */ __name((intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
}, "_continue");
var continueWith = /* @__PURE__ */ __name((interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make39(of2(interval))
  };
}, "continueWith");
var done5 = {
  _tag: OP_DONE2
};
var isContinue = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_CONTINUE;
}, "isContinue");
var isDone3 = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_DONE2;
}, "isDone");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done6 = done5;
var isContinue2 = isContinue;
var isDone4 = isDone3;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Scope.js
var Scope_exports = {};
__export(Scope_exports, {
  CloseableScopeTypeId: () => CloseableScopeTypeId2,
  Scope: () => Scope,
  ScopeTypeId: () => ScopeTypeId2,
  addFinalizer: () => addFinalizer2,
  addFinalizerExit: () => addFinalizerExit,
  close: () => close,
  extend: () => extend3,
  fork: () => fork2,
  make: () => make40,
  use: () => use
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ScopeTypeId2 = ScopeTypeId;
var CloseableScopeTypeId2 = CloseableScopeTypeId;
var Scope = scopeTag;
var addFinalizer2 = scopeAddFinalizer;
var addFinalizerExit = scopeAddFinalizerExit;
var close = scopeClose;
var extend3 = scopeExtend;
var fork2 = scopeFork;
var use = scopeUse;
var make40 = scopeMake;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/effect/circular.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Semaphore = class {
  static {
    __name(this, "Semaphore");
  }
  permits;
  waiters = /* @__PURE__ */ new Set();
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = /* @__PURE__ */ __name((n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = /* @__PURE__ */ __name(() => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      }, "observer");
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  }), "take");
  updateTakenUnsafe(fiber, f) {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  }
  updateTaken(f) {
    return withFiberRuntime((fiber) => this.updateTakenUnsafe(fiber, f));
  }
  resize = /* @__PURE__ */ __name((permits) => asVoid2(withFiberRuntime((fiber) => {
    this.permits = permits;
    if (this.free < 0) {
      return void_3;
    }
    return this.updateTakenUnsafe(fiber, (taken) => taken);
  })), "resize");
  release = /* @__PURE__ */ __name((n) => this.updateTaken((taken) => taken - n), "release");
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = /* @__PURE__ */ __name((n) => (self2) => uninterruptibleMask((restore) => flatMap10(restore(this.take(n)), (permits) => ensuring(restore(self2), this.release(permits)))), "withPermits");
  withPermitsIfAvailable = /* @__PURE__ */ __name((n) => (self2) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self2)), this.release(n));
  })), "withPermitsIfAvailable");
};
var unsafeMakeSemaphore = /* @__PURE__ */ __name((permits) => new Semaphore(permits), "unsafeMakeSemaphore");
var makeSemaphore = /* @__PURE__ */ __name((permits) => sync(() => unsafeMakeSemaphore(permits)), "makeSemaphore");
var Latch = class extends Class2 {
  static {
    __name(this, "Latch");
  }
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_3;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_3;
  }
  flushWaiters = /* @__PURE__ */ __name(() => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0; i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  }, "flushWaiters");
  open = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_3;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen) return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_3;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_3);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index2 = this.waiters.indexOf(resume2);
      if (index2 !== -1) {
        this.waiters.splice(index2, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync(() => {
    this.isOpen = false;
  });
  whenOpen = /* @__PURE__ */ __name((self2) => {
    return zipRight2(this.await, self2);
  }, "whenOpen");
};
var unsafeMakeLatch = /* @__PURE__ */ __name((open) => new Latch(open ?? false), "unsafeMakeLatch");
var makeLatch = /* @__PURE__ */ __name((open) => sync(() => unsafeMakeLatch(open)), "makeLatch");
var awaitAllChildren = /* @__PURE__ */ __name((self2) => ensuringChildren(self2, fiberAwaitAll), "awaitAllChildren");
var cached2 = /* @__PURE__ */ dual(2, (self2, timeToLive) => map12(cachedInvalidateWithTTL(self2, timeToLive), (tuple5) => tuple5[0]));
var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self2, timeToLive) => {
  const duration4 = decode(timeToLive);
  return flatMap10(context2(), (env3) => map12(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self2, duration4, cache), env3), invalidateCache(cache)]));
});
var computeCachedValue = /* @__PURE__ */ __name((self2, timeToLive, start3) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap2((deferred) => intoDeferred(self2, deferred)), map12((deferred) => some3([start3 + timeToLiveMillis, deferred])));
}, "computeCachedValue");
var getCachedValue = /* @__PURE__ */ __name((self2, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock3) => clock3.currentTimeMillis), flatMap10((time4) => updateSomeAndGetEffectSynchronized(cache, (option9) => {
  switch (option9._tag) {
    case "None": {
      return some3(computeCachedValue(self2, timeToLive, time4));
    }
    case "Some": {
      const [end6] = option9.value;
      return end6 - time4 <= 0 ? some3(computeCachedValue(self2, timeToLive, time4)) : none2();
    }
  }
})), flatMap10((option9) => isNone2(option9) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option9.value[1]))))), "getCachedValue");
var invalidateCache = /* @__PURE__ */ __name((cache) => set4(cache, none2()), "invalidateCache");
var ensuringChild = /* @__PURE__ */ dual(2, (self2, f) => ensuringChildren(self2, (children3) => f(fiberAll(children3))));
var ensuringChildren = /* @__PURE__ */ dual(2, (self2, children3) => flatMap10(track, (supervisor) => pipe(supervised(self2, supervisor), ensuring(flatMap10(supervisor.value, children3)))));
var forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options4) => options4?.discard ? forEachSequentialDiscard(effects, fork) : map12(forEachSequential(effects, fork), fiberAll));
var forkIn = /* @__PURE__ */ dual(2, (self2, scope5) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope5;
  const fiber = unsafeFork2(self2, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer3 = /* @__PURE__ */ __name(() => fiberIdWith((fiberId5) => equals(fiberId5, fiber.id()) ? void_3 : asVoid2(interruptFiber(fiber))), "finalizer");
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer3);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed") return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = /* @__PURE__ */ __name((self2) => scopeWith((scope5) => forkIn(self2, scope5)), "forkScoped");
var fromFiber = /* @__PURE__ */ __name((fiber) => join3(fiber), "fromFiber");
var fromFiberEffect = /* @__PURE__ */ __name((fiber) => suspend(() => flatMap10(fiber, join3)), "fromFiberEffect");
var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");
var Key = class {
  static {
    __name(this, "Key");
  }
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [symbol2](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
};
var cachedFunction = /* @__PURE__ */ __name((f, eq) => {
  return pipe(sync(() => empty23()), flatMap10(makeSynchronized), map12((ref2) => (a) => pipe(ref2.modifyEffect((map38) => {
    const result = pipe(map38, get13(new Key(a, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap2((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map12((deferred) => [deferred, pipe(map38, set6(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map38]);
  }), flatMap10(deferredAwait), flatMap10(([patch12, b]) => pipe(patchFiberRefs(patch12), as3(b))))));
}, "cachedFunction");
var raceFirst = /* @__PURE__ */ dual(2, (self2, that) => pipe(exit2(self2), race(exit2(that)), (effect4) => flatten6(effect4)));
var supervised = /* @__PURE__ */ dual(2, (self2, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self2);
});
var timeout = /* @__PURE__ */ dual(2, (self2, duration4) => timeoutFail(self2, {
  onTimeout: /* @__PURE__ */ __name(() => timeoutExceptionFromDuration(duration4), "onTimeout"),
  duration: duration4
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self2, {
  duration: duration4,
  onTimeout
}) => flatten6(timeoutTo(self2, {
  onTimeout: /* @__PURE__ */ __name(() => failSync(onTimeout), "onTimeout"),
  onSuccess: succeed,
  duration: duration4
})));
var timeoutFailCause = /* @__PURE__ */ dual(2, (self2, {
  duration: duration4,
  onTimeout
}) => flatten6(timeoutTo(self2, {
  onTimeout: /* @__PURE__ */ __name(() => failCauseSync(onTimeout), "onTimeout"),
  onSuccess: succeed,
  duration: duration4
})));
var timeoutOption = /* @__PURE__ */ dual(2, (self2, duration4) => timeoutTo(self2, {
  duration: duration4,
  onSuccess: some3,
  onTimeout: none2
}));
var timeoutTo = /* @__PURE__ */ dual(2, (self2, {
  duration: duration4,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self2), interruptible2(sleep3(duration4)), {
  onSelfWin: /* @__PURE__ */ __name((winner, loser) => flatMap10(winner.await, (exit5) => {
    if (exit5._tag === "Success") {
      return flatMap10(winner.inheritAll, () => as3(interruptAsFiber(loser, parentFiberId), onSuccess(exit5.value)));
    } else {
      return flatMap10(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit5.cause));
    }
  }), "onSelfWin"),
  onOtherWin: /* @__PURE__ */ __name((winner, loser) => flatMap10(winner.await, (exit5) => {
    if (exit5._tag === "Success") {
      return flatMap10(winner.inheritAll, () => as3(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap10(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit5.cause));
    }
  }), "onOtherWin"),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var SynchronizedImpl = class extends Class2 {
  static {
    __name(this, "SynchronizedImpl");
  }
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId12] = TypeId12;
  constructor(ref2, withLock) {
    super();
    this.ref = ref2;
    this.withLock = withLock;
    this.get = get11(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap10(get11(this.ref), f), flatMap10(([b, a]) => as3(set4(this.ref, a), b))));
  }
};
var makeSynchronized = /* @__PURE__ */ __name((value6) => sync(() => unsafeMakeSynchronized(value6)), "makeSynchronized");
var unsafeMakeSynchronized = /* @__PURE__ */ __name((value6) => {
  const ref2 = unsafeMake5(value6);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref2, sem.withPermits(1));
}, "unsafeMakeSynchronized");
var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value6) => {
  const result = pf(value6);
  switch (result._tag) {
    case "None": {
      return succeed([value6, value6]);
    }
    case "Some": {
      return map12(result.value, (a) => [a, a]);
    }
  }
}));
var zipFiber = /* @__PURE__ */ dual(2, (self2, that) => zipWithFiber(self2, that, (a, b) => [a, b]));
var zipLeftFiber = /* @__PURE__ */ dual(2, (self2, that) => zipWithFiber(self2, that, (a, _) => a));
var zipRightFiber = /* @__PURE__ */ dual(2, (self2, that) => zipWithFiber(self2, that, (_, b) => b));
var zipWithFiber = /* @__PURE__ */ dual(3, (self2, that, f) => ({
  ...CommitPrototype2,
  commit() {
    return join3(this);
  },
  [FiberTypeId]: fiberVariance2,
  id: /* @__PURE__ */ __name(() => pipe(self2.id(), getOrElse6(that.id())), "id"),
  await: pipe(self2.await, flatten6, zipWithOptions(flatten6(that.await), f, {
    concurrent: true
  }), exit2),
  children: self2.children,
  inheritAll: zipRight2(that.inheritAll, self2.inheritAll),
  poll: zipWith5(self2.poll, that.poll, (optionA, optionB) => pipe(optionA, flatMap2((exitA) => pipe(optionB, map2((exitB) => zipWith6(exitA, exitB, {
    onSuccess: f,
    onFailure: parallel
  })))))),
  interruptAsFork: /* @__PURE__ */ __name((id4) => zipRight2(self2.interruptAsFork(id4), that.interruptAsFork(id4)), "interruptAsFork"),
  pipe() {
    return pipeArguments(this, arguments);
  }
}));
var bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, f, options4) => flatMap10(self2, (a) => all6(f(a), options4).pipe(map12((record4) => Object.assign({}, a, record4)))));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/managedRuntime/circular.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/layer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_EXTEND_SCOPE = "ExtendScope";
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_MERGE_ALL = "MergeAll";
var OP_ZIP_WITH2 = "ZipWith";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/runtime.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Fiber.js
var Fiber_exports = {};
__export(Fiber_exports, {
  FiberTypeId: () => FiberTypeId2,
  Order: () => Order5,
  RuntimeFiberTypeId: () => RuntimeFiberTypeId2,
  all: () => all7,
  await: () => _await2,
  awaitAll: () => awaitAll,
  children: () => children2,
  done: () => done7,
  dump: () => dump2,
  dumpAll: () => dumpAll2,
  fail: () => fail6,
  failCause: () => failCause5,
  fromEffect: () => fromEffect3,
  getCurrentFiber: () => getCurrentFiber2,
  id: () => id2,
  inheritAll: () => inheritAll2,
  interrupt: () => interrupt5,
  interruptAll: () => interruptAll2,
  interruptAllAs: () => interruptAllAs2,
  interruptAs: () => interruptAs,
  interruptAsFork: () => interruptAsFork2,
  interruptFork: () => interruptFork,
  interrupted: () => interrupted2,
  isFiber: () => isFiber2,
  isRuntimeFiber: () => isRuntimeFiber2,
  join: () => join4,
  joinAll: () => joinAll,
  map: () => map19,
  mapEffect: () => mapEffect3,
  mapFiber: () => mapFiber2,
  match: () => match12,
  never: () => never3,
  orElse: () => orElse5,
  orElseEither: () => orElseEither4,
  poll: () => poll2,
  pretty: () => pretty4,
  roots: () => roots2,
  scoped: () => scoped,
  status: () => status2,
  succeed: () => succeed6,
  unsafeRoots: () => unsafeRoots2,
  void: () => void_7,
  zip: () => zip7,
  zipLeft: () => zipLeft5,
  zipRight: () => zipRight5,
  zipWith: () => zipWith7
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FiberTypeId2 = FiberTypeId;
var RuntimeFiberTypeId2 = RuntimeFiberTypeId;
var Order5 = Order4;
var isFiber2 = isFiber;
var isRuntimeFiber2 = isRuntimeFiber;
var id2 = id;
var _await2 = _await;
var awaitAll = fiberAwaitAll;
var children2 = children;
var all7 = fiberAll;
var done7 = done4;
var dump2 = dump;
var dumpAll2 = dumpAll;
var fail6 = fail4;
var failCause5 = failCause4;
var fromEffect3 = fromEffect;
var getCurrentFiber2 = getCurrentFiber;
var inheritAll2 = inheritAll;
var interrupt5 = interruptFiber;
var interrupted2 = interrupted;
var interruptAs = interruptAsFiber;
var interruptAsFork2 = interruptAsFork;
var interruptAll2 = interruptAll;
var interruptAllAs2 = interruptAllAs;
var interruptFork = fiberInterruptFork;
var join4 = join3;
var joinAll = fiberJoinAll;
var map19 = map16;
var mapEffect3 = mapEffect2;
var mapFiber2 = mapFiber;
var match12 = match10;
var never3 = never2;
var orElse5 = orElse4;
var orElseEither4 = orElseEither2;
var poll2 = poll;
var pretty4 = pretty2;
var roots2 = roots;
var unsafeRoots2 = unsafeRoots;
var scoped = fiberScoped;
var status2 = status;
var succeed6 = succeed4;
var void_7 = void_6;
var zip7 = zipFiber;
var zipLeft5 = zipLeftFiber;
var zipRight5 = zipRightFiber;
var zipWith7 = zipWithFiber;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/runtime.js
var makeDual = /* @__PURE__ */ __name((f) => function() {
  if (arguments.length === 1) {
    const runtime8 = arguments[0];
    return (effect4, ...args2) => f(runtime8, effect4, ...args2);
  }
  return f.apply(this, arguments);
}, "makeDual");
var unsafeFork3 = /* @__PURE__ */ makeDual((runtime8, self2, options4) => {
  const fiberId5 = unsafeMake3();
  const fiberRefUpdates = [[currentContext, [[fiberId5, runtime8.context]]]];
  if (options4?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId5, options4.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime8.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId5
  });
  if (options4?.updateRefs) {
    fiberRefs3 = options4.updateRefs(fiberRefs3, fiberId5);
  }
  const fiberRuntime = new FiberRuntime(fiberId5, fiberRefs3, runtime8.runtimeFlags);
  let effect4 = self2;
  if (options4?.scope) {
    effect4 = flatMap10(fork2(options4.scope, sequential2), (closeableScope) => zipRight2(scopeAddFinalizer(closeableScope, fiberIdWith((id4) => equals(id4, fiberRuntime.id()) ? void_3 : interruptAsFiber(fiberRuntime, id4))), onExit(self2, (exit5) => close(closeableScope, exit5))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime8.context, effect4, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit5) => supervisor.onEnd(exit5, fiberRuntime));
  }
  globalScope.add(runtime8.runtimeFlags, fiberRuntime);
  if (options4?.immediate === false) {
    fiberRuntime.resume(effect4);
  } else {
    fiberRuntime.start(effect4);
  }
  return fiberRuntime;
});
var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime8, effect4, options4 = {}) => {
  const fiberRuntime = unsafeFork3(runtime8, effect4, options4);
  if (options4.onExit) {
    fiberRuntime.addObserver((exit5) => {
      options4.onExit(exit5);
    });
  }
  return (id4, cancelOptions) => unsafeRunCallback(runtime8)(pipe(fiberRuntime, interruptAs(id4 ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit5) => cancelOptions.onExit(flatten7(exit5)) : void 0
  });
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime8, effect4) => {
  const result = unsafeRunSyncExit(runtime8)(effect4);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});
var AsyncFiberExceptionImpl = class extends Error {
  static {
    __name(this, "AsyncFiberExceptionImpl");
  }
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
};
var asyncFiberException = /* @__PURE__ */ __name((fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error5 = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error5;
}, "asyncFiberException");
var isAsyncFiberException = /* @__PURE__ */ __name((u) => isTagged(u, "AsyncFiberException") && "fiber" in u, "isAsyncFiberException");
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
var FiberFailureImpl = class extends Error {
  static {
    __name(this, "FiberFailureImpl");
  }
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause3) {
    const head13 = prettyErrors(cause3)[0];
    super(head13?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause3;
    this.name = head13 ? `(FiberFailure) ${head13.name}` : "FiberFailure";
    if (head13?.stack) {
      this.stack = head13.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var fiberFailure = /* @__PURE__ */ __name((cause3) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error5 = new FiberFailureImpl(cause3);
  Error.stackTraceLimit = limit;
  return error5;
}, "fiberFailure");
var isFiberFailure = /* @__PURE__ */ __name((u) => hasProperty(u, FiberFailureId), "isFiberFailure");
var fastPath = /* @__PURE__ */ __name((effect4) => {
  const op = effect4;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(new NoSuchElementException());
    }
  }
}, "fastPath");
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime8, effect4) => {
  const op = fastPath(effect4);
  if (op) {
    return op;
  }
  const scheduler2 = new SyncScheduler();
  const fiberRuntime = unsafeFork3(runtime8)(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime8, effect4, options4) => unsafeRunPromiseExit(runtime8, effect4, options4).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime8, effect4, options4) => new Promise((resolve3) => {
  const op = fastPath(effect4);
  if (op) {
    resolve3(op);
  }
  const fiber = unsafeFork3(runtime8)(effect4);
  fiber.addObserver((exit5) => {
    resolve3(exit5);
  });
  if (options4?.signal !== void 0) {
    if (options4.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options4.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));
var RuntimeImpl = class {
  static {
    __name(this, "RuntimeImpl");
  }
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context17, runtimeFlags2, fiberRefs3) {
    this.context = context17;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make41 = /* @__PURE__ */ __name((options4) => new RuntimeImpl(options4.context, options4.runtimeFlags, options4.fiberRefs), "make");
var runtime3 = /* @__PURE__ */ __name(() => withFiberRuntime((state2, status3) => succeed(new RuntimeImpl(state2.getFiberRef(currentContext), status3.runtimeFlags, state2.getFiberRefs()))), "runtime");
var defaultRuntimeFlags = /* @__PURE__ */ make19(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make41({
  context: /* @__PURE__ */ empty10(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty21()
});
var updateRuntimeFlags2 = /* @__PURE__ */ dual(2, (self2, f) => make41({
  context: self2.context,
  runtimeFlags: f(self2.runtimeFlags),
  fiberRefs: self2.fiberRefs
}));
var disableRuntimeFlag = /* @__PURE__ */ dual(2, (self2, flag) => updateRuntimeFlags2(self2, disable2(flag)));
var enableRuntimeFlag = /* @__PURE__ */ dual(2, (self2, flag) => updateRuntimeFlags2(self2, enable2(flag)));
var updateContext2 = /* @__PURE__ */ dual(2, (self2, f) => make41({
  context: f(self2.context),
  runtimeFlags: self2.runtimeFlags,
  fiberRefs: self2.fiberRefs
}));
var provideService2 = /* @__PURE__ */ dual(3, (self2, tag8, service3) => updateContext2(self2, add4(tag8, service3)));
var updateFiberRefs2 = /* @__PURE__ */ dual(2, (self2, f) => make41({
  context: self2.context,
  runtimeFlags: self2.runtimeFlags,
  fiberRefs: f(self2.fiberRefs)
}));
var setFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, value6) => updateFiberRefs2(self2, updateAs2({
  fiberId: none4,
  fiberRef,
  value: value6
})));
var deleteFiberRef = /* @__PURE__ */ dual(2, (self2, fiberRef) => updateFiberRefs2(self2, delete_2(fiberRef)));
var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = /* @__PURE__ */ unsafeFork3(defaultRuntime);
var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
var asyncEffect = /* @__PURE__ */ __name((register) => suspend(() => {
  let cleanup = void 0;
  return flatMap10(deferredMake(), (deferred) => flatMap10(runtime3(), (runtime8) => uninterruptibleMask((restore) => zipRight2(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime8)(intoDeferred(cb, deferred))), {
    onFailure: /* @__PURE__ */ __name((cause3) => deferredFailCause(deferred, cause3), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((cleanup_) => {
      cleanup = cleanup_;
      return void_3;
    }, "onSuccess")
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_3))))));
}), "asyncEffect");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/synchronizedRef.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getAndUpdateEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect((value6) => map12(f(value6), (result) => [value6, result])));
var getAndUpdateSomeEffect = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value6) => {
  const result = pf(value6);
  switch (result._tag) {
    case "None": {
      return succeed([value6, value6]);
    }
    case "Some": {
      return map12(result.value, (newValue) => [value6, newValue]);
    }
  }
}));
var modifyEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect(f));
var modifySomeEffect = /* @__PURE__ */ dual(3, (self2, fallback, pf) => self2.modifyEffect((value6) => pipe(pf(value6), getOrElse2(() => succeed([fallback, value6])))));
var updateEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect((value6) => map12(f(value6), (result) => [void 0, result])));
var updateAndGetEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect((value6) => map12(f(value6), (result) => [result, result])));
var updateSomeEffect = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value6) => {
  const result = pf(value6);
  switch (result._tag) {
    case "None": {
      return succeed([void 0, value6]);
    }
    case "Some": {
      return map12(result.value, (a) => [void 0, a]);
    }
  }
}));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/layer.js
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  /* c8 ignore next */
  _RIn: /* @__PURE__ */ __name((_) => _, "_RIn"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _ROut: /* @__PURE__ */ __name((_) => _, "_ROut")
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: /* @__PURE__ */ __name(() => unsafeMakeMemoMap(), "defaultValue")
});
var isLayer = /* @__PURE__ */ __name((u) => hasProperty(u, LayerTypeId), "isLayer");
var isFresh = /* @__PURE__ */ __name((self2) => {
  return self2._op_layer === OP_FRESH;
}, "isFresh");
var MemoMapImpl = class {
  static {
    __name(this, "MemoMapImpl");
  }
  ref;
  [MemoMapTypeId];
  constructor(ref2) {
    this.ref = ref2;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  /**
   * Checks the memo map to see if a layer exists. If it is, immediately
   * returns it. Otherwise, obtains the layer, stores it in the memo map,
   * and adds a finalizer to the `Scope`.
   */
  getOrElseMemoize(layer14, scope5) {
    return pipe(modifyEffect(this.ref, (map38) => {
      const inMap = map38.get(layer14);
      if (inMap !== void 0) {
        const [acquire, release2] = inMap;
        const cached4 = pipe(acquire, flatMap10(([patch12, b]) => pipe(patchFiberRefs(patch12), as3(b))), onExit(exitMatch({
          onFailure: /* @__PURE__ */ __name(() => void_3, "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => scopeAddFinalizerExit(scope5, release2), "onSuccess")
        })));
        return succeed([cached4, map38]);
      }
      return pipe(make25(0), flatMap10((observers) => pipe(deferredMake(), flatMap10((deferred) => pipe(make25(() => void_3), map12((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap10((innerScope) => pipe(restore(flatMap10(makeBuilder(layer14, innerScope, true), (f) => diffFiberRefs(f(this)))), exit2, flatMap10((exit5) => {
          switch (exit5._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit5.effect_instruction_i0), zipRight2(scopeClose(innerScope, exit5)), zipRight2(failCause(exit5.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set4(finalizerRef, (exit6) => pipe(scopeClose(innerScope, exit6), whenEffect(modify5(observers, (n) => [n === 1, n - 1])), asVoid2)), zipRight2(update2(observers, (n) => n + 1)), zipRight2(scopeAddFinalizerExit(scope5, (exit6) => pipe(sync(() => map38.delete(layer14)), zipRight2(get11(finalizerRef)), flatMap10((finalizer3) => finalizer3(exit6))))), zipRight2(deferredSucceed(deferred, exit5.effect_instruction_i0)), as3(exit5.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: /* @__PURE__ */ __name(() => void_3, "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => update2(observers, (n) => n + 1), "onSuccess")
        }))), (exit5) => pipe(get11(finalizerRef), flatMap10((finalizer3) => finalizer3(exit5)))];
        return [resource, isFresh(layer14) ? map38 : map38.set(layer14, memoized)];
      }))))));
    }), flatten6);
  }
};
var makeMemoMap = /* @__PURE__ */ suspend(() => map12(makeSynchronized(/* @__PURE__ */ new Map()), (ref2) => new MemoMapImpl(ref2)));
var unsafeMakeMemoMap = /* @__PURE__ */ __name(() => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map())), "unsafeMakeMemoMap");
var build = /* @__PURE__ */ __name((self2) => scopeWith((scope5) => buildWithScope(self2, scope5)), "build");
var buildWithScope = /* @__PURE__ */ dual(2, (self2, scope5) => flatMap10(makeMemoMap, (memoMap) => buildWithMemoMap(self2, memoMap, scope5)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self2, memoMap, scope5) => flatMap10(makeBuilder(self2, scope5), (run10) => provideService(run10(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = /* @__PURE__ */ __name((self2, scope5, inMemoMap = false) => {
  const op = self2;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope5)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope6) => memoMap.getOrElseMemoize(op.layer, scope6)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope5), matchCauseEffect({
        onFailure: /* @__PURE__ */ __name((cause3) => memoMap.getOrElseMemoize(op.failureK(cause3), scope5), "onFailure"),
        onSuccess: /* @__PURE__ */ __name((value6) => memoMap.getOrElseMemoize(op.successK(value6), scope5), "onSuccess")
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope5)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope5));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), flatMap10((env3) => pipe(memoMap.getOrElseMemoize(op.second, scope5), provideContext(env3)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope5)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope5));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope5));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope5), zipWith5(memoMap.getOrElseMemoize(op.second, scope5), op.zipK)));
    }
    case "ZipWith": {
      return gen3(function* () {
        const parallelScope = yield* scopeFork(scope5, parallel2);
        const firstScope = yield* scopeFork(parallelScope, sequential2);
        const secondScope = yield* scopeFork(parallelScope, sequential2);
        return (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, firstScope), zipWithOptions(memoMap.getOrElseMemoize(op.second, secondScope), op.zipK, {
          concurrent: true
        }));
      });
    }
    case "MergeAll": {
      const layers = op.layers;
      return map12(scopeFork(scope5, parallel2), (parallelScope) => (memoMap) => {
        const contexts = new Array(layers.length);
        return map12(forEachConcurrentDiscard(layers, fnUntraced(function* (layer14, i) {
          const scope6 = yield* scopeFork(parallelScope, sequential2);
          const context17 = yield* memoMap.getOrElseMemoize(layer14, scope6);
          contexts[i] = context17;
        }), false, false), () => mergeAll2(...contexts));
      });
    }
  }
}, "makeBuilder");
var catchAll2 = /* @__PURE__ */ dual(2, (self2, onFailure) => match13(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause2 = /* @__PURE__ */ dual(2, (self2, onFailure) => matchCause3(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var die5 = /* @__PURE__ */ __name((defect) => failCause6(die4(defect)), "die");
var dieSync2 = /* @__PURE__ */ __name((evaluate3) => failCauseSync2(() => die4(evaluate3())), "dieSync");
var discard = /* @__PURE__ */ __name((self2) => map20(self2, () => empty10()), "discard");
var context3 = /* @__PURE__ */ __name(() => fromEffectContext(context2()), "context");
var extendScope = /* @__PURE__ */ __name((self2) => {
  const extendScope3 = Object.create(proto3);
  extendScope3._op_layer = OP_EXTEND_SCOPE;
  extendScope3.layer = self2;
  return extendScope3;
}, "extendScope");
var fail7 = /* @__PURE__ */ __name((error5) => failCause6(fail5(error5)), "fail");
var failSync2 = /* @__PURE__ */ __name((evaluate3) => failCauseSync2(() => fail5(evaluate3())), "failSync");
var failCause6 = /* @__PURE__ */ __name((cause3) => fromEffectContext(failCause(cause3)), "failCause");
var failCauseSync2 = /* @__PURE__ */ __name((evaluate3) => fromEffectContext(failCauseSync(evaluate3)), "failCauseSync");
var flatMap14 = /* @__PURE__ */ dual(2, (self2, f) => match13(self2, {
  onFailure: fail7,
  onSuccess: f
}));
var flatten9 = /* @__PURE__ */ dual(2, (self2, tag8) => flatMap14(self2, get6(tag8)));
var fresh = /* @__PURE__ */ __name((self2) => {
  const fresh3 = Object.create(proto3);
  fresh3._op_layer = OP_FRESH;
  fresh3.layer = self2;
  return fresh3;
}, "fresh");
var fromEffect4 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag8 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return fromEffectContext(map12(effect4, (service3) => make11(tag8, service3)));
});
var fromEffectDiscard = /* @__PURE__ */ __name((effect4) => fromEffectContext(map12(effect4, () => empty10())), "fromEffectDiscard");
function fromEffectContext(effect4) {
  const fromEffect10 = Object.create(proto3);
  fromEffect10._op_layer = OP_FROM_EFFECT;
  fromEffect10.effect = effect4;
  return fromEffect10;
}
__name(fromEffectContext, "fromEffectContext");
var fiberRefLocally2 = /* @__PURE__ */ dual(3, (self2, ref2, value6) => locallyEffect(self2, fiberRefLocally(ref2, value6)));
var locallyEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const locally4 = Object.create(proto3);
  locally4._op_layer = "Locally";
  locally4.self = self2;
  locally4.f = f;
  return locally4;
});
var fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self2, ref2, value6) => locallyEffect(self2, fiberRefLocallyWith(ref2, value6)));
var fiberRefLocallyScoped2 = /* @__PURE__ */ __name((self2, value6) => scopedDiscard(fiberRefLocallyScoped(self2, value6)), "fiberRefLocallyScoped");
var fiberRefLocallyScopedWith2 = /* @__PURE__ */ __name((self2, value6) => scopedDiscard(fiberRefLocallyScopedWith(self2, value6)), "fiberRefLocallyScopedWith");
var fromFunction = /* @__PURE__ */ __name((tagA, tagB, f) => fromEffectContext(map12(tagA, (a) => make11(tagB, f(a)))), "fromFunction");
var launch = /* @__PURE__ */ __name((self2) => scopedEffect(zipRight2(scopeWith((scope5) => pipe(self2, buildWithScope(scope5))), never)), "launch");
var mock = /* @__PURE__ */ __name(function() {
  if (arguments.length === 1) {
    return (service3) => mockImpl(arguments[0], service3);
  }
  return mockImpl(arguments[0], arguments[1]);
}, "mock");
var mockImpl = /* @__PURE__ */ __name((tag8, service3) => succeed7(tag8, new Proxy({
  ...service3
}, {
  get(target3, prop, _receiver) {
    if (prop in target3) {
      return target3[prop];
    }
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error5 = new Error(`${tag8.key}: Unimplemented method "${prop.toString()}"`);
    Error.stackTraceLimit = prevLimit;
    error5.name = "UnimplementedError";
    return makeUnimplemented(error5);
  },
  has: constTrue
})), "mockImpl");
var makeUnimplemented = /* @__PURE__ */ __name((error5) => {
  const dead = die2(error5);
  function unimplemented() {
    return dead;
  }
  __name(unimplemented, "unimplemented");
  Object.assign(unimplemented, dead);
  Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead));
  return unimplemented;
}, "makeUnimplemented");
var map20 = /* @__PURE__ */ dual(2, (self2, f) => flatMap14(self2, (context17) => succeedContext(f(context17))));
var mapError3 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (error5) => failSync2(() => f(error5))));
var matchCause3 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  const fold2 = Object.create(proto3);
  fold2._op_layer = OP_FOLD;
  fold2.layer = self2;
  fold2.failureK = onFailure;
  fold2.successK = onSuccess;
  return fold2;
});
var match13 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCause3(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => {
    const failureOrCause3 = failureOrCause2(cause3);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause6(failureOrCause3.right);
      }
    }
  }, "onFailure"),
  onSuccess
}));
var memoize2 = /* @__PURE__ */ __name((self2) => scopeWith((scope5) => map12(memoize(buildWithScope(self2, scope5)), fromEffectContext)), "memoize");
var merge6 = /* @__PURE__ */ dual(2, (self2, that) => zipWith8(self2, that, (a, b) => merge3(a, b)));
var mergeAll4 = /* @__PURE__ */ __name((...layers) => {
  const mergeAll12 = Object.create(proto3);
  mergeAll12._op_layer = OP_MERGE_ALL;
  mergeAll12.layers = layers;
  return mergeAll12;
}, "mergeAll");
var orDie2 = /* @__PURE__ */ __name((self2) => catchAll2(self2, (defect) => die5(defect)), "orDie");
var orElse6 = /* @__PURE__ */ dual(2, (self2, that) => catchAll2(self2, that));
var passthrough = /* @__PURE__ */ __name((self2) => merge6(context3(), self2), "passthrough");
var project = /* @__PURE__ */ dual(4, (self2, tagA, tagB, f) => map20(self2, (context17) => make11(tagB, f(unsafeGet5(context17, tagA)))));
var retry = /* @__PURE__ */ dual(2, (self2, schedule4) => suspend3(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed7(stateTag, {
    state: schedule4.initial
  }), flatMap14((env3) => retryLoop(self2, schedule4, stateTag, pipe(env3, get6(stateTag)).state)));
}));
var retryLoop = /* @__PURE__ */ __name((self2, schedule4, stateTag, state2) => {
  return pipe(self2, catchAll2((error5) => pipe(retryUpdate(schedule4, stateTag, error5, state2), flatMap14((env3) => fresh(retryLoop(self2, schedule4, stateTag, pipe(env3, get6(stateTag)).state))))));
}, "retryLoop");
var retryUpdate = /* @__PURE__ */ __name((schedule4, stateTag, error5, state2) => {
  return fromEffect4(stateTag, pipe(currentTimeMillis2, flatMap10((now2) => pipe(schedule4.step(now2, error5, state2), flatMap10(([state3, _, decision]) => isDone4(decision) ? fail2(error5) : pipe(sleep2(millis(start2(decision.intervals) - now2)), as3({
    state: state3
  })))))));
}, "retryUpdate");
var scoped2 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag8 = tagFirst ? a : b;
  const effect4 = tagFirst ? b : a;
  return scopedContext(map12(effect4, (service3) => make11(tag8, service3)));
});
var scopedDiscard = /* @__PURE__ */ __name((effect4) => scopedContext(pipe(effect4, as3(empty10()))), "scopedDiscard");
var scopedContext = /* @__PURE__ */ __name((effect4) => {
  const scoped9 = Object.create(proto3);
  scoped9._op_layer = OP_SCOPED;
  scoped9.effect = effect4;
  return scoped9;
}, "scopedContext");
var scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map12(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope5, exit5) => scope5.close(exit5)), (scope5) => make11(Scope, scope5)));
var service = /* @__PURE__ */ __name((tag8) => fromEffect4(tag8, tag8), "service");
var succeed7 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag8 = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make11(tag8, resource)));
});
var succeedContext = /* @__PURE__ */ __name((context17) => {
  return fromEffectContext(succeed(context17));
}, "succeedContext");
var empty31 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty10());
var suspend3 = /* @__PURE__ */ __name((evaluate3) => {
  const suspend16 = Object.create(proto3);
  suspend16._op_layer = OP_SUSPEND;
  suspend16.evaluate = evaluate3;
  return suspend16;
}, "suspend");
var sync4 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag8 = tagFirst ? a : b;
  const evaluate3 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make11(tag8, evaluate3())));
});
var syncContext = /* @__PURE__ */ __name((evaluate3) => {
  return fromEffectContext(sync(evaluate3));
}, "syncContext");
var tap3 = /* @__PURE__ */ dual(2, (self2, f) => flatMap14(self2, (context17) => fromEffectContext(as3(f(context17), context17))));
var tapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (e) => fromEffectContext(flatMap10(f(e), () => fail2(e)))));
var tapErrorCause2 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause2(self2, (cause3) => fromEffectContext(flatMap10(f(cause3), () => failCause(cause3)))));
var toRuntime = /* @__PURE__ */ __name((self2) => pipe(scopeWith((scope5) => buildWithScope(self2, scope5)), flatMap10((context17) => pipe(runtime3(), provideContext(context17)))), "toRuntime");
var toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self2, memoMap) => flatMap10(scopeWith((scope5) => buildWithMemoMap(self2, memoMap, scope5)), (context17) => pipe(runtime3(), provideContext(context17))));
var provide = /* @__PURE__ */ dual(2, (self2, that) => suspend3(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context3(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll4(...that) : that
    },
    zipK: {
      value: /* @__PURE__ */ __name((a, b) => pipe(a, merge3(b)), "value")
    }
  });
  provideTo.second = self2;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self2) => {
  const zipWith19 = Object.create(proto3);
  zipWith19._op_layer = OP_PROVIDE_MERGE;
  zipWith19.first = self2;
  zipWith19.second = provide(that, self2);
  zipWith19.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith19;
});
var zipWith8 = /* @__PURE__ */ dual(3, (self2, that, f) => suspend3(() => {
  const zipWith19 = Object.create(proto3);
  zipWith19._op_layer = OP_ZIP_WITH2;
  zipWith19.first = self2;
  zipWith19.second = that;
  zipWith19.zipK = f;
  return zipWith19;
}));
var unwrapEffect = /* @__PURE__ */ __name((self2) => {
  const tag8 = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap14(fromEffect4(tag8, self2), (context17) => get6(context17, tag8));
}, "unwrapEffect");
var unwrapScoped = /* @__PURE__ */ __name((self2) => {
  const tag8 = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap14(scoped2(tag8, self2), (context17) => get6(context17, tag8));
}, "unwrapScoped");
var annotateLogs2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set3(acc, key, value6), annotations3));
});
var annotateSpans2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set3(args2[1], args2[2]) : (annotations3) => Object.entries(args2[1]).reduce((acc, [key, value6]) => set3(acc, key, value6), annotations3));
});
var withSpan2 = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options4 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return unwrapScoped(map12(options4?.onEnd ? tap2(makeSpanScoped(name, options4), (span4) => addFinalizer((exit5) => options4.onEnd(span4, exit5))) : makeSpanScoped(name, options4), (span4) => withParentSpan2(self2, span4)));
  }
  return (self2) => unwrapScoped(map12(options4?.onEnd ? tap2(makeSpanScoped(name, options4), (span4) => addFinalizer((exit5) => options4.onEnd(span4, exit5))) : makeSpanScoped(name, options4), (span4) => withParentSpan2(self2, span4)));
}, "withSpan");
var withParentSpan2 = /* @__PURE__ */ dual(2, (self2, span4) => provide(self2, succeedContext(make11(spanTag, span4))));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self2, layer14) => scopedWith((scope5) => flatMap10(buildWithScope(layer14, scope5), (context17) => provideSomeContext(self2, context17))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self2, rt) => {
  const patchRefs = diff6(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff4(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch7(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch4(patchFlags)(oldFlags);
    const rollbackRefs = diff6(newRefs, oldRefs);
    const rollbackFlags = diff4(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self2), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch7(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch4(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_3;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self2, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self2, mergeAll4(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self2, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self2, source);
  } else if (TypeId15 in source) {
    return flatMap10(source.runtimeEffect, (rt) => provideSomeRuntime(self2, rt));
  } else {
    return provideSomeRuntime(self2, source);
  }
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/console.js
var console2 = /* @__PURE__ */ map12(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get6(consoleTag));
var consoleWith = /* @__PURE__ */ __name((f) => fiberRefGetWith(currentServices, (services) => f(get6(services, consoleTag))), "consoleWith");
var withConsole = /* @__PURE__ */ dual(2, (effect4, value6) => fiberRefLocallyWith(effect4, currentServices, add4(consoleTag, value6)));
var withConsoleScoped = /* @__PURE__ */ __name((console4) => fiberRefLocallyScopedWith(currentServices, add4(consoleTag, console4)), "withConsoleScoped");
var log4 = /* @__PURE__ */ __name((...args2) => consoleWith((_) => _.log(...args2)), "log");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/executionPlan.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Cron.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Data.js
var Data_exports = {};
__export(Data_exports, {
  Class: () => Class4,
  Error: () => Error3,
  Structural: () => Structural2,
  TaggedClass: () => TaggedClass,
  TaggedError: () => TaggedError,
  array: () => array4,
  case: () => _case,
  struct: () => struct3,
  tagged: () => tagged2,
  taggedEnum: () => taggedEnum,
  tuple: () => tuple3,
  unsafeArray: () => unsafeArray,
  unsafeStruct: () => unsafeStruct
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var struct3 = struct2;
var unsafeStruct = /* @__PURE__ */ __name((as16) => Object.setPrototypeOf(as16, StructuralPrototype), "unsafeStruct");
var tuple3 = /* @__PURE__ */ __name((...as16) => unsafeArray(as16), "tuple");
var array4 = /* @__PURE__ */ __name((as16) => unsafeArray(as16.slice(0)), "array");
var unsafeArray = /* @__PURE__ */ __name((as16) => Object.setPrototypeOf(as16, ArrayProto), "unsafeArray");
var _case = /* @__PURE__ */ __name(() => (args2) => args2 === void 0 ? Object.create(StructuralPrototype) : struct3(args2), "_case");
var tagged2 = /* @__PURE__ */ __name((tag8) => (args2) => {
  const value6 = args2 === void 0 ? Object.create(StructuralPrototype) : struct3(args2);
  value6._tag = tag8;
  return value6;
}, "tagged");
var Class4 = Structural;
var TaggedClass = /* @__PURE__ */ __name((tag8) => {
  class Base4 extends Class4 {
    static {
      __name(this, "Base");
    }
    _tag = tag8;
  }
  return Base4;
}, "TaggedClass");
var Structural2 = Structural;
var taggedEnum = /* @__PURE__ */ __name(() => new Proxy({}, {
  get(_target, tag8, _receiver) {
    if (tag8 === "$is") {
      return isTagged;
    } else if (tag8 === "$match") {
      return taggedMatch;
    }
    return tagged2(tag8);
  }
}), "taggedEnum");
function taggedMatch() {
  if (arguments.length === 1) {
    const cases2 = arguments[0];
    return function(value7) {
      return cases2[value7._tag](value7);
    };
  }
  const value6 = arguments[0];
  const cases = arguments[1];
  return cases[value6._tag](value6);
}
__name(taggedMatch, "taggedMatch");
var Error3 = /* @__PURE__ */ (function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      static {
        __name(this, "BaseEffectError");
      }
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : void 0);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
})();
var TaggedError = /* @__PURE__ */ __name((tag8) => {
  const O = {
    BaseEffectError: class extends Error3 {
      static {
        __name(this, "BaseEffectError");
      }
      _tag = tag8;
    }
  };
  O.BaseEffectError.prototype.name = tag8;
  return O.BaseEffectError;
}, "TaggedError");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/dateTime.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/DateTime");
var TimeZoneTypeId = /* @__PURE__ */ Symbol.for("effect/DateTime/TimeZone");
var Proto2 = {
  [TypeId16]: TypeId16,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
var ProtoUtc = {
  ...Proto2,
  _tag: "Utc",
  [symbol]() {
    return cached(this, number2(this.epochMillis));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
var ProtoZoned = {
  ...Proto2,
  _tag: "Zoned",
  [symbol]() {
    return pipe(number2(this.epochMillis), combine(hash(this.zone)), cached(this));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
var ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [symbol]() {
    return cached(this, string2(`Named:${this.id}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
var ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [symbol]() {
    return cached(this, string2(`Offset:${this.offset}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
var makeZonedProto = /* @__PURE__ */ __name((epochMillis, zone, partsUtc) => {
  const self2 = Object.create(ProtoZoned);
  self2.epochMillis = epochMillis;
  self2.zone = zone;
  Object.defineProperty(self2, "partsUtc", {
    value: partsUtc,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self2, "adjustedEpochMillis", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  Object.defineProperty(self2, "partsAdjusted", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self2;
}, "makeZonedProto");
var isDateTime = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId16), "isDateTime");
var isDateTimeArgs = /* @__PURE__ */ __name((args2) => isDateTime(args2[0]), "isDateTimeArgs");
var isTimeZone = /* @__PURE__ */ __name((u) => hasProperty(u, TimeZoneTypeId), "isTimeZone");
var isTimeZoneOffset = /* @__PURE__ */ __name((u) => isTimeZone(u) && u._tag === "Offset", "isTimeZoneOffset");
var isTimeZoneNamed = /* @__PURE__ */ __name((u) => isTimeZone(u) && u._tag === "Named", "isTimeZoneNamed");
var isUtc = /* @__PURE__ */ __name((self2) => self2._tag === "Utc", "isUtc");
var isZoned = /* @__PURE__ */ __name((self2) => self2._tag === "Zoned", "isZoned");
var Equivalence2 = /* @__PURE__ */ make((a, b) => a.epochMillis === b.epochMillis);
var makeUtc = /* @__PURE__ */ __name((epochMillis) => {
  const self2 = Object.create(ProtoUtc);
  self2.epochMillis = epochMillis;
  Object.defineProperty(self2, "partsUtc", {
    value: void 0,
    enumerable: false,
    writable: true
  });
  return self2;
}, "makeUtc");
var unsafeFromDate = /* @__PURE__ */ __name((date4) => {
  const epochMillis = date4.getTime();
  if (Number.isNaN(epochMillis)) {
    throw new IllegalArgumentException2("Invalid date");
  }
  return makeUtc(epochMillis);
}, "unsafeFromDate");
var unsafeMake9 = /* @__PURE__ */ __name((input) => {
  if (isDateTime(input)) {
    return input;
  } else if (input instanceof Date) {
    return unsafeFromDate(input);
  } else if (typeof input === "object") {
    const date4 = /* @__PURE__ */ new Date(0);
    setPartsDate(date4, input);
    return unsafeFromDate(date4);
  } else if (typeof input === "string" && !hasZone(input)) {
    return unsafeFromDate(/* @__PURE__ */ new Date(input + "Z"));
  }
  return unsafeFromDate(new Date(input));
}, "unsafeMake");
var hasZone = /* @__PURE__ */ __name((input) => /Z|[+-]\d{2}$|[+-]\d{2}:?\d{2}$|\]$/.test(input), "hasZone");
var minEpochMillis = -864e13 + 12 * 60 * 60 * 1e3;
var maxEpochMillis = 864e13 - 14 * 60 * 60 * 1e3;
var unsafeMakeZoned = /* @__PURE__ */ __name((input, options4) => {
  if (options4?.timeZone === void 0 && isDateTime(input) && isZoned(input)) {
    return input;
  }
  const self2 = unsafeMake9(input);
  if (self2.epochMillis < minEpochMillis || self2.epochMillis > maxEpochMillis) {
    throw new RangeError(`Epoch millis out of range: ${self2.epochMillis}`);
  }
  let zone;
  if (options4?.timeZone === void 0) {
    const offset = new Date(self2.epochMillis).getTimezoneOffset() * -60 * 1e3;
    zone = zoneMakeOffset(offset);
  } else if (isTimeZone(options4?.timeZone)) {
    zone = options4.timeZone;
  } else if (typeof options4?.timeZone === "number") {
    zone = zoneMakeOffset(options4.timeZone);
  } else {
    const parsedZone = zoneFromString(options4.timeZone);
    if (isNone2(parsedZone)) {
      throw new IllegalArgumentException2(`Invalid time zone: ${options4.timeZone}`);
    }
    zone = parsedZone.value;
  }
  if (options4?.adjustForTimeZone !== true) {
    return makeZonedProto(self2.epochMillis, zone, self2.partsUtc);
  }
  return makeZonedFromAdjusted(self2.epochMillis, zone, options4?.disambiguation ?? "compatible");
}, "unsafeMakeZoned");
var makeZoned = /* @__PURE__ */ liftThrowable(unsafeMakeZoned);
var zonedStringRegex = /^(.{17,35})\[(.+)\]$/;
var makeZonedFromString = /* @__PURE__ */ __name((input) => {
  const match24 = zonedStringRegex.exec(input);
  if (match24 === null) {
    const offset = parseOffset(input);
    return offset !== null ? makeZoned(input, {
      timeZone: offset
    }) : none2();
  }
  const [, isoString, timeZone] = match24;
  return makeZoned(isoString, {
    timeZone
  });
}, "makeZonedFromString");
var validZoneCache = /* @__PURE__ */ globalValue("effect/DateTime/validZoneCache", () => /* @__PURE__ */ new Map());
var formatOptions = {
  day: "numeric",
  month: "numeric",
  year: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric",
  timeZoneName: "longOffset",
  fractionalSecondDigits: 3,
  hourCycle: "h23"
};
var zoneMakeIntl = /* @__PURE__ */ __name((format8) => {
  const zoneId = format8.resolvedOptions().timeZone;
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  const zone = Object.create(ProtoTimeZoneNamed);
  zone.id = zoneId;
  zone.format = format8;
  validZoneCache.set(zoneId, zone);
  return zone;
}, "zoneMakeIntl");
var zoneUnsafeMakeNamed = /* @__PURE__ */ __name((zoneId) => {
  if (validZoneCache.has(zoneId)) {
    return validZoneCache.get(zoneId);
  }
  try {
    return zoneMakeIntl(new Intl.DateTimeFormat("en-US", {
      ...formatOptions,
      timeZone: zoneId
    }));
  } catch {
    throw new IllegalArgumentException2(`Invalid time zone: ${zoneId}`);
  }
}, "zoneUnsafeMakeNamed");
var zoneMakeOffset = /* @__PURE__ */ __name((offset) => {
  const zone = Object.create(ProtoTimeZoneOffset);
  zone.offset = offset;
  return zone;
}, "zoneMakeOffset");
var zoneMakeNamed = /* @__PURE__ */ liftThrowable(zoneUnsafeMakeNamed);
var offsetZoneRegex = /^(?:GMT|[+-])/;
var zoneFromString = /* @__PURE__ */ __name((zone) => {
  if (offsetZoneRegex.test(zone)) {
    const offset = parseOffset(zone);
    return offset === null ? none2() : some3(zoneMakeOffset(offset));
  }
  return zoneMakeNamed(zone);
}, "zoneFromString");
var zoneToString = /* @__PURE__ */ __name((self2) => {
  if (self2._tag === "Offset") {
    return offsetToString(self2.offset);
  }
  return self2.id;
}, "zoneToString");
var toDateUtc = /* @__PURE__ */ __name((self2) => new Date(self2.epochMillis), "toDateUtc");
var toDate = /* @__PURE__ */ __name((self2) => {
  if (self2._tag === "Utc") {
    return new Date(self2.epochMillis);
  } else if (self2.zone._tag === "Offset") {
    return new Date(self2.epochMillis + self2.zone.offset);
  } else if (self2.adjustedEpochMillis !== void 0) {
    return new Date(self2.adjustedEpochMillis);
  }
  const parts2 = self2.zone.format.formatToParts(self2.epochMillis).filter((_) => _.type !== "literal");
  const date4 = /* @__PURE__ */ new Date(0);
  date4.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
  date4.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
  self2.adjustedEpochMillis = date4.getTime();
  return date4;
}, "toDate");
var zonedOffset = /* @__PURE__ */ __name((self2) => {
  const date4 = toDate(self2);
  return date4.getTime() - toEpochMillis(self2);
}, "zonedOffset");
var offsetToString = /* @__PURE__ */ __name((offset) => {
  const abs2 = Math.abs(offset);
  let hours2 = Math.floor(abs2 / (60 * 60 * 1e3));
  let minutes2 = Math.round(abs2 % (60 * 60 * 1e3) / (60 * 1e3));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
}, "offsetToString");
var zonedOffsetIso = /* @__PURE__ */ __name((self2) => offsetToString(zonedOffset(self2)), "zonedOffsetIso");
var toEpochMillis = /* @__PURE__ */ __name((self2) => self2.epochMillis, "toEpochMillis");
var dateToParts = /* @__PURE__ */ __name((date4) => ({
  millis: date4.getUTCMilliseconds(),
  seconds: date4.getUTCSeconds(),
  minutes: date4.getUTCMinutes(),
  hours: date4.getUTCHours(),
  day: date4.getUTCDate(),
  weekDay: date4.getUTCDay(),
  month: date4.getUTCMonth() + 1,
  year: date4.getUTCFullYear()
}), "dateToParts");
var toParts = /* @__PURE__ */ __name((self2) => {
  if (self2._tag === "Utc") {
    return toPartsUtc(self2);
  } else if (self2.partsAdjusted !== void 0) {
    return self2.partsAdjusted;
  }
  self2.partsAdjusted = withDate(self2, dateToParts);
  return self2.partsAdjusted;
}, "toParts");
var toPartsUtc = /* @__PURE__ */ __name((self2) => {
  if (self2.partsUtc !== void 0) {
    return self2.partsUtc;
  }
  self2.partsUtc = withDateUtc(self2, dateToParts);
  return self2.partsUtc;
}, "toPartsUtc");
var setPartsDate = /* @__PURE__ */ __name((date4, parts2) => {
  if (parts2.year !== void 0) {
    date4.setUTCFullYear(parts2.year);
  }
  if (parts2.month !== void 0) {
    date4.setUTCMonth(parts2.month - 1);
  }
  if (parts2.day !== void 0) {
    date4.setUTCDate(parts2.day);
  }
  if (parts2.weekDay !== void 0) {
    const diff9 = parts2.weekDay - date4.getUTCDay();
    date4.setUTCDate(date4.getUTCDate() + diff9);
  }
  if (parts2.hours !== void 0) {
    date4.setUTCHours(parts2.hours);
  }
  if (parts2.minutes !== void 0) {
    date4.setUTCMinutes(parts2.minutes);
  }
  if (parts2.seconds !== void 0) {
    date4.setUTCSeconds(parts2.seconds);
  }
  if (parts2.millis !== void 0) {
    date4.setUTCMilliseconds(parts2.millis);
  }
}, "setPartsDate");
var constDayMillis = 24 * 60 * 60 * 1e3;
var makeZonedFromAdjusted = /* @__PURE__ */ __name((adjustedMillis, zone, disambiguation) => {
  if (zone._tag === "Offset") {
    return makeZonedProto(adjustedMillis - zone.offset, zone);
  }
  const beforeOffset = calculateNamedOffset(adjustedMillis - constDayMillis, adjustedMillis, zone);
  const afterOffset = calculateNamedOffset(adjustedMillis + constDayMillis, adjustedMillis, zone);
  if (beforeOffset === afterOffset) {
    return makeZonedProto(adjustedMillis - beforeOffset, zone);
  }
  const isForwards = beforeOffset < afterOffset;
  const transitionMillis = beforeOffset - afterOffset;
  if (isForwards) {
    const currentAfterOffset = calculateNamedOffset(adjustedMillis - afterOffset, adjustedMillis, zone);
    if (currentAfterOffset === afterOffset) {
      return makeZonedProto(adjustedMillis - afterOffset, zone);
    }
    const before2 = makeZonedProto(adjustedMillis - beforeOffset, zone);
    const beforeAdjustedMillis = toDate(before2).getTime();
    if (adjustedMillis !== beforeAdjustedMillis) {
      switch (disambiguation) {
        case "reject": {
          const formatted = new Date(adjustedMillis).toISOString();
          throw new RangeError(`Gap time: ${formatted} does not exist in time zone ${zone.id}`);
        }
        case "earlier":
          return makeZonedProto(adjustedMillis - afterOffset, zone);
        case "compatible":
        case "later":
          return before2;
      }
    }
    return before2;
  }
  const currentBeforeOffset = calculateNamedOffset(adjustedMillis - beforeOffset, adjustedMillis, zone);
  if (currentBeforeOffset === beforeOffset) {
    if (disambiguation === "earlier" || disambiguation === "compatible") {
      return makeZonedProto(adjustedMillis - beforeOffset, zone);
    }
    const laterOffset = calculateNamedOffset(adjustedMillis - beforeOffset + transitionMillis, adjustedMillis + transitionMillis, zone);
    if (laterOffset === beforeOffset) {
      return makeZonedProto(adjustedMillis - beforeOffset, zone);
    }
    if (disambiguation === "reject") {
      const formatted = new Date(adjustedMillis).toISOString();
      throw new RangeError(`Ambiguous time: ${formatted} occurs twice in time zone ${zone.id}`);
    }
  }
  return makeZonedProto(adjustedMillis - afterOffset, zone);
}, "makeZonedFromAdjusted");
var offsetRegex = /([+-])(\d{2}):(\d{2})$/;
var parseOffset = /* @__PURE__ */ __name((offset) => {
  const match24 = offsetRegex.exec(offset);
  if (match24 === null) {
    return null;
  }
  const [, sign2, hours2, minutes2] = match24;
  return (sign2 === "+" ? 1 : -1) * (Number(hours2) * 60 + Number(minutes2)) * 60 * 1e3;
}, "parseOffset");
var calculateNamedOffset = /* @__PURE__ */ __name((utcMillis, adjustedMillis, zone) => {
  const offset = zone.format.formatToParts(utcMillis).find((_) => _.type === "timeZoneName")?.value ?? "";
  if (offset === "GMT") {
    return 0;
  }
  const result = parseOffset(offset);
  if (result === null) {
    return zonedOffset(makeZonedProto(adjustedMillis, zone));
  }
  return result;
}, "calculateNamedOffset");
var mutate5 = /* @__PURE__ */ dual(isDateTimeArgs, (self2, f, options4) => {
  if (self2._tag === "Utc") {
    const date4 = toDateUtc(self2);
    f(date4);
    return makeUtc(date4.getTime());
  }
  const adjustedDate = toDate(self2);
  const newAdjustedDate = new Date(adjustedDate.getTime());
  f(newAdjustedDate);
  return makeZonedFromAdjusted(newAdjustedDate.getTime(), self2.zone, options4?.disambiguation ?? "compatible");
});
var withDate = /* @__PURE__ */ dual(2, (self2, f) => f(toDate(self2)));
var withDateUtc = /* @__PURE__ */ dual(2, (self2, f) => f(toDateUtc(self2)));
var formatIso2 = /* @__PURE__ */ __name((self2) => toDateUtc(self2).toISOString(), "formatIso");
var formatIsoOffset = /* @__PURE__ */ __name((self2) => {
  const date4 = toDate(self2);
  return self2._tag === "Utc" ? date4.toISOString() : `${date4.toISOString().slice(0, -1)}${zonedOffsetIso(self2)}`;
}, "formatIsoOffset");
var formatIsoZoned = /* @__PURE__ */ __name((self2) => self2.zone._tag === "Offset" ? formatIsoOffset(self2) : `${formatIsoOffset(self2)}[${self2.zone.id}]`, "formatIsoZoned");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/String.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Equivalence3 = string;
var toUpperCase = /* @__PURE__ */ __name((self2) => self2.toUpperCase(), "toUpperCase");
var toLowerCase = /* @__PURE__ */ __name((self2) => self2.toLowerCase(), "toLowerCase");
var capitalize = /* @__PURE__ */ __name((self2) => {
  if (self2.length === 0) return self2;
  return toUpperCase(self2[0]) + self2.slice(1);
}, "capitalize");
var uncapitalize = /* @__PURE__ */ __name((self2) => {
  if (self2.length === 0) return self2;
  return toLowerCase(self2[0]) + self2.slice(1);
}, "uncapitalize");
var isNonEmpty5 = /* @__PURE__ */ __name((self2) => self2.length > 0, "isNonEmpty");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Cron.js
var TypeId17 = /* @__PURE__ */ Symbol.for("effect/Cron");
var CronProto = {
  [TypeId17]: TypeId17,
  [symbol2](that) {
    return isCron(that) && equals3(this, that);
  },
  [symbol]() {
    return pipe(hash(this.tz), combine(array2(fromIterable2(this.seconds))), combine(array2(fromIterable2(this.minutes))), combine(array2(fromIterable2(this.hours))), combine(array2(fromIterable2(this.days))), combine(array2(fromIterable2(this.months))), combine(array2(fromIterable2(this.weekdays))), cached(this));
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      tz: this.tz,
      seconds: fromIterable2(this.seconds),
      minutes: fromIterable2(this.minutes),
      hours: fromIterable2(this.hours),
      days: fromIterable2(this.days),
      months: fromIterable2(this.months),
      weekdays: fromIterable2(this.weekdays)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCron = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId17), "isCron");
var make42 = /* @__PURE__ */ __name((values6) => {
  const o = Object.create(CronProto);
  o.seconds = new Set(sort(values6.seconds ?? [0], Order2));
  o.minutes = new Set(sort(values6.minutes, Order2));
  o.hours = new Set(sort(values6.hours, Order2));
  o.days = new Set(sort(values6.days, Order2));
  o.months = new Set(sort(values6.months, Order2));
  o.weekdays = new Set(sort(values6.weekdays, Order2));
  o.tz = fromNullable2(values6.tz);
  const seconds2 = Array.from(o.seconds);
  const minutes2 = Array.from(o.minutes);
  const hours2 = Array.from(o.hours);
  const days2 = Array.from(o.days);
  const months = Array.from(o.months);
  const weekdays = Array.from(o.weekdays);
  o.first = {
    second: seconds2[0] ?? 0,
    minute: minutes2[0] ?? 0,
    hour: hours2[0] ?? 0,
    day: days2[0] ?? 1,
    month: (months[0] ?? 1) - 1,
    weekday: weekdays[0] ?? 0
  };
  o.next = {
    second: nextLookupTable(seconds2, 60),
    minute: nextLookupTable(minutes2, 60),
    hour: nextLookupTable(hours2, 24),
    day: nextLookupTable(days2, 32),
    month: nextLookupTable(months, 13),
    weekday: nextLookupTable(weekdays, 7)
  };
  return o;
}, "make");
var nextLookupTable = /* @__PURE__ */ __name((values6, size22) => {
  const result = new Array(size22).fill(void 0);
  if (values6.length === 0) {
    return result;
  }
  let current2 = void 0;
  let index2 = values6.length - 1;
  for (let i = size22 - 1; i >= 0; i--) {
    while (index2 >= 0 && values6[index2] >= i) {
      current2 = values6[index2--];
    }
    result[i] = current2;
  }
  return result;
}, "nextLookupTable");
var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Cron/errors/ParseError");
var ParseError = class extends (/* @__PURE__ */ TaggedError("CronParseError")) {
  static {
    __name(this, "ParseError");
  }
  /**
   * @since 2.0.0
   */
  [ParseErrorTypeId] = ParseErrorTypeId;
};
var parse2 = /* @__PURE__ */ __name((cron3, tz) => {
  const segments = cron3.split(" ").filter(isNonEmpty5);
  if (segments.length !== 5 && segments.length !== 6) {
    return left2(new ParseError({
      message: `Invalid number of segments in cron expression`,
      input: cron3
    }));
  }
  if (segments.length === 5) {
    segments.unshift("0");
  }
  const [seconds2, minutes2, hours2, days2, months, weekdays] = segments;
  const zone = tz === void 0 || isTimeZone(tz) ? right2(tz) : fromOption2(zoneFromString(tz), () => new ParseError({
    message: `Invalid time zone in cron expression`,
    input: tz
  }));
  return all2({
    tz: zone,
    seconds: parseSegment(seconds2, secondOptions),
    minutes: parseSegment(minutes2, minuteOptions),
    hours: parseSegment(hours2, hourOptions),
    days: parseSegment(days2, dayOptions),
    months: parseSegment(months, monthOptions),
    weekdays: parseSegment(weekdays, weekdayOptions)
  }).pipe(map(make42));
}, "parse");
var match14 = /* @__PURE__ */ __name((cron3, date4) => {
  const parts2 = unsafeMakeZoned(date4, {
    timeZone: getOrUndefined2(cron3.tz)
  }).pipe(toParts);
  if (cron3.seconds.size !== 0 && !cron3.seconds.has(parts2.seconds)) {
    return false;
  }
  if (cron3.minutes.size !== 0 && !cron3.minutes.has(parts2.minutes)) {
    return false;
  }
  if (cron3.hours.size !== 0 && !cron3.hours.has(parts2.hours)) {
    return false;
  }
  if (cron3.months.size !== 0 && !cron3.months.has(parts2.month)) {
    return false;
  }
  if (cron3.days.size === 0 && cron3.weekdays.size === 0) {
    return true;
  }
  if (cron3.weekdays.size === 0) {
    return cron3.days.has(parts2.day);
  }
  if (cron3.days.size === 0) {
    return cron3.weekdays.has(parts2.weekDay);
  }
  return cron3.days.has(parts2.day) || cron3.weekdays.has(parts2.weekDay);
}, "match");
var daysInMonth = /* @__PURE__ */ __name((date4) => new Date(Date.UTC(date4.getUTCFullYear(), date4.getUTCMonth() + 1, 0)).getUTCDate(), "daysInMonth");
var next2 = /* @__PURE__ */ __name((cron3, startFrom) => {
  const tz = getOrUndefined2(cron3.tz);
  const zoned = unsafeMakeZoned(startFrom ?? /* @__PURE__ */ new Date(), {
    timeZone: tz
  });
  const utc = tz !== void 0 && isTimeZoneNamed(tz) && tz.id === "UTC";
  const adjustDst = utc ? constVoid : (current2) => {
    const adjusted = unsafeMakeZoned(current2, {
      timeZone: zoned.zone,
      adjustForTimeZone: true
    }).pipe(toDate);
    const drift = current2.getTime() - adjusted.getTime();
    if (drift > 0) {
      current2.setTime(current2.getTime() + drift);
    }
  };
  const result = mutate5(zoned, (current2) => {
    current2.setUTCSeconds(current2.getUTCSeconds() + 1, 0);
    for (let i = 0; i < 1e4; i++) {
      if (cron3.seconds.size !== 0) {
        const currentSecond = current2.getUTCSeconds();
        const nextSecond2 = cron3.next.second[currentSecond];
        if (nextSecond2 === void 0) {
          current2.setUTCMinutes(current2.getUTCMinutes() + 1, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextSecond2 > currentSecond) {
          current2.setUTCSeconds(nextSecond2);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.minutes.size !== 0) {
        const currentMinute = current2.getUTCMinutes();
        const nextMinute2 = cron3.next.minute[currentMinute];
        if (nextMinute2 === void 0) {
          current2.setUTCHours(current2.getUTCHours() + 1, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextMinute2 > currentMinute) {
          current2.setUTCMinutes(nextMinute2, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.hours.size !== 0) {
        const currentHour = current2.getUTCHours();
        const nextHour2 = cron3.next.hour[currentHour];
        if (nextHour2 === void 0) {
          current2.setUTCDate(current2.getUTCDate() + 1);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextHour2 > currentHour) {
          current2.setUTCHours(nextHour2, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.weekdays.size !== 0 || cron3.days.size !== 0) {
        let a = Infinity;
        let b = Infinity;
        if (cron3.weekdays.size !== 0) {
          const currentWeekday = current2.getUTCDay();
          const nextWeekday = cron3.next.weekday[currentWeekday];
          a = nextWeekday === void 0 ? 7 - currentWeekday + cron3.first.weekday : nextWeekday - currentWeekday;
        }
        if (cron3.days.size !== 0 && a !== 0) {
          const currentDay = current2.getUTCDate();
          const nextDay2 = cron3.next.day[currentDay];
          b = nextDay2 === void 0 ? daysInMonth(current2) - currentDay + cron3.first.day : nextDay2 - currentDay;
        }
        const addDays = Math.min(a, b);
        if (addDays !== 0) {
          current2.setUTCDate(current2.getUTCDate() + addDays);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      if (cron3.months.size !== 0) {
        const currentMonth = current2.getUTCMonth() + 1;
        const nextMonth = cron3.next.month[currentMonth];
        if (nextMonth === void 0) {
          current2.setUTCFullYear(current2.getUTCFullYear() + 1);
          current2.setUTCMonth(cron3.first.month, cron3.first.day);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
        if (nextMonth > currentMonth) {
          current2.setUTCMonth(nextMonth - 1, cron3.first.day);
          current2.setUTCHours(cron3.first.hour, cron3.first.minute, cron3.first.second);
          adjustDst(current2);
          continue;
        }
      }
      return;
    }
    throw new Error("Unable to find next cron date");
  });
  return toDateUtc(result);
}, "next");
var Equivalence4 = /* @__PURE__ */ make((self2, that) => restrictionsEquals(self2.seconds, that.seconds) && restrictionsEquals(self2.minutes, that.minutes) && restrictionsEquals(self2.hours, that.hours) && restrictionsEquals(self2.days, that.days) && restrictionsEquals(self2.months, that.months) && restrictionsEquals(self2.weekdays, that.weekdays));
var restrictionsArrayEquals = /* @__PURE__ */ array(number);
var restrictionsEquals = /* @__PURE__ */ __name((self2, that) => restrictionsArrayEquals(fromIterable2(self2), fromIterable2(that)), "restrictionsEquals");
var equals3 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence4(self2, that));
var secondOptions = {
  min: 0,
  max: 59
};
var minuteOptions = {
  min: 0,
  max: 59
};
var hourOptions = {
  min: 0,
  max: 23
};
var dayOptions = {
  min: 1,
  max: 31
};
var monthOptions = {
  min: 1,
  max: 12,
  aliases: {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12
  }
};
var weekdayOptions = {
  min: 0,
  max: 6,
  aliases: {
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
  }
};
var parseSegment = /* @__PURE__ */ __name((input, options4) => {
  const capacity9 = options4.max - options4.min + 1;
  const values6 = /* @__PURE__ */ new Set();
  const fields = input.split(",");
  for (const field of fields) {
    const [raw3, step4] = splitStep(field);
    if (raw3 === "*" && step4 === void 0) {
      return right2(/* @__PURE__ */ new Set());
    }
    if (step4 !== void 0) {
      if (!Number.isInteger(step4)) {
        return left2(new ParseError({
          message: `Expected step value to be a positive integer`,
          input
        }));
      }
      if (step4 < 1) {
        return left2(new ParseError({
          message: `Expected step value to be greater than 0`,
          input
        }));
      }
      if (step4 > options4.max) {
        return left2(new ParseError({
          message: `Expected step value to be less than ${options4.max}`,
          input
        }));
      }
    }
    if (raw3 === "*") {
      for (let i = options4.min; i <= options4.max; i += step4 ?? 1) {
        values6.add(i);
      }
    } else {
      const [left3, right3] = splitRange(raw3, options4.aliases);
      if (!Number.isInteger(left3)) {
        return left2(new ParseError({
          message: `Expected a positive integer`,
          input
        }));
      }
      if (left3 < options4.min || left3 > options4.max) {
        return left2(new ParseError({
          message: `Expected a value between ${options4.min} and ${options4.max}`,
          input
        }));
      }
      if (right3 === void 0) {
        values6.add(left3);
      } else {
        if (!Number.isInteger(right3)) {
          return left2(new ParseError({
            message: `Expected a positive integer`,
            input
          }));
        }
        if (right3 < options4.min || right3 > options4.max) {
          return left2(new ParseError({
            message: `Expected a value between ${options4.min} and ${options4.max}`,
            input
          }));
        }
        if (left3 > right3) {
          return left2(new ParseError({
            message: `Invalid value range`,
            input
          }));
        }
        for (let i = left3; i <= right3; i += step4 ?? 1) {
          values6.add(i);
        }
      }
    }
    if (values6.size >= capacity9) {
      return right2(/* @__PURE__ */ new Set());
    }
  }
  return right2(values6);
}, "parseSegment");
var splitStep = /* @__PURE__ */ __name((input) => {
  const seperator = input.indexOf("/");
  if (seperator !== -1) {
    return [input.slice(0, seperator), Number(input.slice(seperator + 1))];
  }
  return [input, void 0];
}, "splitStep");
var splitRange = /* @__PURE__ */ __name((input, aliases) => {
  const seperator = input.indexOf("-");
  if (seperator !== -1) {
    return [aliasOrValue(input.slice(0, seperator), aliases), aliasOrValue(input.slice(seperator + 1), aliases)];
  }
  return [aliasOrValue(input, aliases), void 0];
}, "splitRange");
function aliasOrValue(field, aliases) {
  return aliases?.[field.toLocaleLowerCase()] ?? Number(field);
}
__name(aliasOrValue, "aliasOrValue");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Random.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var next3 = next;
var fixed2 = fixed;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = /* @__PURE__ */ __name((u) => hasProperty(u, ScheduleTypeId), "isSchedule");
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: void 0,
  output: void 0,
  elapsed: zero,
  elapsedSincePrevious: zero,
  recurrence: 0
};
var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: /* @__PURE__ */ __name(() => defaultIterationMetadata, "defaultValue")
});
var scheduleVariance = {
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var scheduleDriverVariance = {
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var ScheduleImpl = class {
  static {
    __name(this, "ScheduleImpl");
  }
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step4) {
    this.initial = initial;
    this.step = step4;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var updateInfo = /* @__PURE__ */ __name((iterationMetaRef, now2, input, output) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now: now2,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: zero,
  elapsedSincePrevious: zero,
  start: now2
} : {
  now: now2,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now2 - prev.start),
  elapsedSincePrevious: millis(now2 - prev.now),
  start: prev.start
}), "updateInfo");
var ScheduleDriverImpl = class {
  static {
    __name(this, "ScheduleDriverImpl");
  }
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule4, ref2) {
    this.schedule = schedule4;
    this.ref = ref2;
  }
  get state() {
    return map12(get11(this.ref), (tuple5) => tuple5[1]);
  }
  get last() {
    return flatMap10(get11(this.ref), ([element2, _]) => {
      switch (element2._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException());
        }
        case "Some": {
          return succeed(element2.value);
        }
      }
    });
  }
  iterationMeta = /* @__PURE__ */ unsafeMake5(defaultIterationMetadata);
  get reset() {
    return set4(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft2(set4(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map12(get11(this.ref), (tuple5) => tuple5[1]), flatMap10((state2) => pipe(currentTimeMillis2, flatMap10((now2) => pipe(suspend(() => this.schedule.step(now2, input, state2)), flatMap10(([state3, out, decision]) => {
      const setState = set4(this.ref, [some3(out), state3]);
      if (isDone4(decision)) {
        return setState.pipe(zipRight2(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now2;
      if (millis2 <= 0) {
        return setState.pipe(zipRight2(updateInfo(this.iterationMeta, now2, input, out)), as3(out));
      }
      const duration4 = millis(millis2);
      return pipe(setState, zipRight2(updateInfo(this.iterationMeta, now2, input, out)), zipRight2(sleep3(duration4)), as3(out));
    }))))));
  }
};
var makeWithState = /* @__PURE__ */ __name((initial, step4) => new ScheduleImpl(initial, step4), "makeWithState");
var addDelay = /* @__PURE__ */ dual(2, (self2, f) => addDelayEffect(self2, (out) => sync(() => f(out))));
var addDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (out, duration4) => map12(f(out), (delay3) => sum(duration4, decode(delay3)))));
var andThen7 = /* @__PURE__ */ dual(2, (self2, that) => map21(andThenEither(self2, that), merge));
var andThenEither = /* @__PURE__ */ dual(2, (self2, that) => makeWithState([self2.initial, that.initial, true], (now2, input, state2) => state2[2] ? flatMap10(self2.step(now2, input, state2[0]), ([lState, out, decision]) => {
  if (isDone4(decision)) {
    return map12(that.step(now2, input, state2[1]), ([rState, out2, decision2]) => [[lState, rState, false], right2(out2), decision2]);
  }
  return succeed([[lState, state2[1], true], left2(out), decision]);
}) : map12(that.step(now2, input, state2[1]), ([rState, out, decision]) => [[state2[0], rState, false], right2(out), decision])));
var as7 = /* @__PURE__ */ dual(2, (self2, out) => map21(self2, () => out));
var asVoid4 = /* @__PURE__ */ __name((self2) => map21(self2, constVoid), "asVoid");
var bothInOut = /* @__PURE__ */ dual(2, (self2, that) => makeWithState([self2.initial, that.initial], (now2, [in1, in2], state2) => zipWith5(self2.step(now2, in1, state2[0]), that.step(now2, in2, state2[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const interval = pipe(lDecision.intervals, union9(rDecision.intervals));
    return [[lState, rState], [out, out2], _continue2(interval)];
  }
  return [[lState, rState], [out, out2], done6];
})));
var check = /* @__PURE__ */ dual(2, (self2, test3) => checkEffect(self2, (input, out) => sync(() => test3(input, out))));
var checkEffect = /* @__PURE__ */ dual(2, (self2, test3) => makeWithState(self2.initial, (now2, input, state2) => flatMap10(self2.step(now2, input, state2), ([state3, out, decision]) => {
  if (isDone4(decision)) {
    return succeed([state3, out, done6]);
  }
  return map12(test3(input, out), (cont) => cont ? [state3, out, decision] : [state3, out, done6]);
})));
var collectAllInputs = /* @__PURE__ */ __name(() => collectAllOutputs(identity2()), "collectAllInputs");
var collectAllOutputs = /* @__PURE__ */ __name((self2) => reduce12(self2, empty4(), (outs, out) => pipe(outs, append2(out))), "collectAllOutputs");
var collectUntil = /* @__PURE__ */ __name((f) => collectAllOutputs(recurUntil(f)), "collectUntil");
var collectUntilEffect = /* @__PURE__ */ __name((f) => collectAllOutputs(recurUntilEffect(f)), "collectUntilEffect");
var collectWhile = /* @__PURE__ */ __name((f) => collectAllOutputs(recurWhile(f)), "collectWhile");
var collectWhileEffect = /* @__PURE__ */ __name((f) => collectAllOutputs(recurWhileEffect(f)), "collectWhileEffect");
var compose2 = /* @__PURE__ */ dual(2, (self2, that) => makeWithState([self2.initial, that.initial], (now2, input, state2) => flatMap10(self2.step(now2, input, state2[0]), ([lState, out, lDecision]) => map12(that.step(now2, out, state2[1]), ([rState, out2, rDecision]) => isDone4(lDecision) ? [[lState, rState], out2, done6] : isDone4(rDecision) ? [[lState, rState], out2, done6] : [[lState, rState], out2, _continue2(pipe(lDecision.intervals, max6(rDecision.intervals)))]))));
var mapInput5 = /* @__PURE__ */ dual(2, (self2, f) => mapInputEffect(self2, (input2) => sync(() => f(input2))));
var mapInputContext2 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state2) => mapInputContext(self2.step(now2, input, state2), f)));
var mapInputEffect = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input2, state2) => flatMap10(f(input2), (input) => self2.step(now2, input, state2))));
var cron = /* @__PURE__ */ __name((expression, tz) => {
  const parsed = isCron(expression) ? right2(expression) : parse2(expression, tz);
  return makeWithState([true, [Number.MIN_SAFE_INTEGER, 0, 0]], (now2, _, [initial, previous2]) => {
    if (now2 < previous2[0]) {
      return succeed([[false, previous2], [previous2[1], previous2[2]], continueWith2(make37(previous2[1], previous2[2]))]);
    }
    if (isLeft2(parsed)) {
      return die2(parsed.left);
    }
    const cron3 = parsed.right;
    const date4 = new Date(now2);
    let next4;
    if (initial && match14(cron3, date4)) {
      next4 = now2;
    }
    next4 = next2(cron3, date4).getTime();
    const start3 = beginningOfSecond(next4);
    const end6 = endOfSecond(next4);
    return succeed([[false, [next4, start3, end6]], [start3, end6], continueWith2(make37(start3, end6))]);
  });
}, "cron");
var dayOfMonth = /* @__PURE__ */ __name((day) => {
  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now2, _, state2) => {
    if (!Number.isInteger(day) || day < 1 || 31 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));
    }
    const n = state2[1];
    const initial = n === 0;
    const day0 = nextDayOfMonth(now2, day, initial);
    const start3 = beginningOfDay(day0);
    const end6 = endOfDay(day0);
    const interval = make37(start3, end6);
    return succeed([[end6, n + 1], n, continueWith2(interval)]);
  });
}, "dayOfMonth");
var dayOfWeek = /* @__PURE__ */ __name((day) => {
  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now2, _, state2) => {
    if (!Number.isInteger(day) || day < 1 || 7 < day) {
      return dieSync(() => new IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));
    }
    const n = state2[1];
    const initial = n === 0;
    const day0 = nextDay(now2, day, initial);
    const start3 = beginningOfDay(day0);
    const end6 = endOfDay(day0);
    const interval = make37(start3, end6);
    return succeed([[end6, n + 1], n, continueWith2(interval)]);
  });
}, "dayOfWeek");
var delayed = /* @__PURE__ */ dual(2, (self2, f) => delayedEffect(self2, (duration4) => sync(() => f(duration4))));
var delayedEffect = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (_, delay3) => f(delay3)));
var delayedSchedule = /* @__PURE__ */ __name((schedule4) => addDelay(schedule4, (x) => x), "delayedSchedule");
var delays = /* @__PURE__ */ __name((self2) => makeWithState(self2.initial, (now2, input, state2) => pipe(self2.step(now2, input, state2), flatMap10(([state3, _, decision]) => {
  if (isDone4(decision)) {
    return succeed([state3, zero, decision]);
  }
  return succeed([state3, millis(start2(decision.intervals) - now2), decision]);
}))), "delays");
var mapBoth4 = /* @__PURE__ */ dual(2, (self2, {
  onInput,
  onOutput
}) => map21(mapInput5(self2, onInput), onOutput));
var mapBothEffect = /* @__PURE__ */ dual(2, (self2, {
  onInput,
  onOutput
}) => mapEffect4(mapInputEffect(self2, onInput), onOutput));
var driver = /* @__PURE__ */ __name((self2) => pipe(make25([none2(), self2.initial]), map12((ref2) => new ScheduleDriverImpl(self2, ref2))), "driver");
var duration = /* @__PURE__ */ __name((durationInput) => {
  const duration4 = decode(durationInput);
  const durationMillis = toMillis(duration4);
  return makeWithState(true, (now2, _, state2) => succeed(state2 ? [false, duration4, continueWith2(after2(now2 + durationMillis))] : [false, zero, done6]));
}, "duration");
var either3 = /* @__PURE__ */ dual(2, (self2, that) => union10(self2, that));
var eitherWith = /* @__PURE__ */ dual(3, (self2, that, f) => unionWith2(self2, that, f));
var ensuring2 = /* @__PURE__ */ dual(2, (self2, finalizer3) => makeWithState(self2.initial, (now2, input, state2) => flatMap10(self2.step(now2, input, state2), ([state3, out, decision]) => isDone4(decision) ? as3(finalizer3, [state3, out, decision]) : succeed([state3, out, decision]))));
var exponential2 = /* @__PURE__ */ __name((baseInput, factor = 2) => {
  const base = decode(baseInput);
  return delayedSchedule(map21(forever2, (i) => times(base, Math.pow(factor, i))));
}, "exponential");
var fibonacci = /* @__PURE__ */ __name((oneInput) => {
  const one = decode(oneInput);
  return delayedSchedule(pipe(unfold2([one, one], ([a, b]) => [b, sum(a, b)]), map21((out) => out[0])));
}, "fibonacci");
var fixed3 = /* @__PURE__ */ __name((intervalInput) => {
  const interval = decode(intervalInput);
  const intervalMillis = toMillis(interval);
  return makeWithState([none2(), 0], (now2, _, [option9, n]) => sync(() => {
    switch (option9._tag) {
      case "None": {
        return [[some3([now2, now2 + intervalMillis]), n + 1], n, continueWith2(after2(now2 + intervalMillis))];
      }
      case "Some": {
        const [startMillis, lastRun] = option9.value;
        const runningBehind = now2 > lastRun + intervalMillis;
        const boundary = equals(interval, zero) ? interval : millis(intervalMillis - (now2 - startMillis) % intervalMillis);
        const sleepTime = equals(boundary, zero) ? interval : boundary;
        const nextRun = runningBehind ? now2 : now2 + toMillis(sleepTime);
        return [[some3([startMillis, nextRun]), n + 1], n, continueWith2(after2(nextRun))];
      }
    }
  }));
}, "fixed");
var fromDelay = /* @__PURE__ */ __name((delay3) => duration(delay3), "fromDelay");
var fromDelays = /* @__PURE__ */ __name((delay3, ...delays3) => makeWithState([[delay3, ...delays3].map((_) => decode(_)), true], (now2, _, [durations, cont]) => sync(() => {
  if (cont) {
    const x = durations[0];
    const interval = after2(now2 + toMillis(x));
    if (durations.length >= 2) {
      return [[durations.slice(1), true], x, continueWith2(interval)];
    }
    const y = durations.slice(1);
    return [[[x, ...y], false], x, continueWith2(interval)];
  }
  return [[durations, false], zero, done6];
})), "fromDelays");
var fromFunction2 = /* @__PURE__ */ __name((f) => map21(identity2(), f), "fromFunction");
var hourOfDay = /* @__PURE__ */ __name((hour) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now2, _, state2) => {
  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));
  }
  const n = state2[1];
  const initial = n === 0;
  const hour0 = nextHour(now2, hour, initial);
  const start3 = beginningOfHour(hour0);
  const end6 = endOfHour(hour0);
  const interval = make37(start3, end6);
  return succeed([[end6, n + 1], n, continueWith2(interval)]);
}), "hourOfDay");
var identity2 = /* @__PURE__ */ __name(() => makeWithState(void 0, (now2, input, state2) => succeed([state2, input, continueWith2(after2(now2))])), "identity");
var intersect5 = /* @__PURE__ */ dual(2, (self2, that) => intersectWith(self2, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now2, input, state2) => pipe(zipWith5(self2.step(now2, input, state2[0]), that.step(now2, input, state2[1]), (a, b) => [a, b]), flatMap10(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self2, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done6]);
}))));
var intersectWithLoop = /* @__PURE__ */ __name((self2, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty4(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan7(rInterval))) {
    return flatMap10(self2.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone4(decision)) {
        return succeed([[lState2, rState], [out3, out2], done6]);
      }
      return intersectWithLoop(self2, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap10(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone4(decision)) {
      return succeed([[lState, rState2], [out, out22], done6]);
    }
    return intersectWithLoop(self2, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
}, "intersectWithLoop");
var jittered = /* @__PURE__ */ __name((self2) => jitteredWith(self2, {
  min: 0.8,
  max: 1.2
}), "jittered");
var jitteredWith = /* @__PURE__ */ dual(2, (self2, options4) => {
  const {
    max: max9,
    min: min6
  } = Object.assign({
    min: 0.8,
    max: 1.2
  }, options4);
  return delayedEffect(self2, (duration4) => map12(next3, (random4) => {
    const d = toMillis(duration4);
    const jittered3 = d * min6 * (1 - random4) + d * max9 * random4;
    return millis(jittered3);
  }));
});
var linear = /* @__PURE__ */ __name((baseInput) => {
  const base = decode(baseInput);
  return delayedSchedule(map21(forever2, (i) => times(base, i + 1)));
}, "linear");
var map21 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect4(self2, (out) => sync(() => f(out))));
var mapEffect4 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state2) => flatMap10(self2.step(now2, input, state2), ([state3, out, decision]) => map12(f(out), (out2) => [state3, out2, decision]))));
var minuteOfHour = /* @__PURE__ */ __name((minute) => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now2, _, state2) => {
  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));
  }
  const n = state2[1];
  const initial = n === 0;
  const minute0 = nextMinute(now2, minute, initial);
  const start3 = beginningOfMinute(minute0);
  const end6 = endOfMinute(minute0);
  const interval = make37(start3, end6);
  return succeed([[end6, n + 1], n, continueWith2(interval)]);
}), "minuteOfHour");
var modifyDelay = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (out, duration4) => sync(() => f(out, duration4))));
var modifyDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state2) => flatMap10(self2.step(now2, input, state2), ([state3, out, decision]) => {
  if (isDone4(decision)) {
    return succeed([state3, out, decision]);
  }
  const intervals = decision.intervals;
  const delay3 = size12(make37(now2, start2(intervals)));
  return map12(f(out, delay3), (durationInput) => {
    const duration4 = decode(durationInput);
    const oldStart = start2(intervals);
    const newStart = now2 + toMillis(duration4);
    const delta = newStart - oldStart;
    const newEnd = Math.max(0, end2(intervals) + delta);
    const newInterval = make37(newStart, newEnd);
    return [state3, out, continueWith2(newInterval)];
  });
})));
var onDecision = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state2) => flatMap10(self2.step(now2, input, state2), ([state3, out, decision]) => as3(f(out, decision), [state3, out, decision]))));
var passthrough2 = /* @__PURE__ */ __name((self2) => makeWithState(self2.initial, (now2, input, state2) => pipe(self2.step(now2, input, state2), map12(([state3, _, decision]) => [state3, input, decision]))), "passthrough");
var provideContext3 = /* @__PURE__ */ dual(2, (self2, context17) => makeWithState(self2.initial, (now2, input, state2) => provideContext(self2.step(now2, input, state2), context17)));
var provideService3 = /* @__PURE__ */ dual(3, (self2, tag8, service3) => makeWithState(self2.initial, (now2, input, state2) => contextWithEffect((env3) => provideContext(
  // @ts-expect-error
  self2.step(now2, input, state2),
  add4(env3, tag8, service3)
))));
var recurUntil = /* @__PURE__ */ __name((f) => untilInput(identity2(), f), "recurUntil");
var recurUntilEffect = /* @__PURE__ */ __name((f) => untilInputEffect(identity2(), f), "recurUntilEffect");
var recurUntilOption = /* @__PURE__ */ __name((pf) => untilOutput(map21(identity2(), pf), isSome2), "recurUntilOption");
var recurUpTo = /* @__PURE__ */ __name((durationInput) => {
  const duration4 = decode(durationInput);
  return whileOutput(elapsed, (elapsed3) => lessThan2(elapsed3, duration4));
}, "recurUpTo");
var recurWhile = /* @__PURE__ */ __name((f) => whileInput(identity2(), f), "recurWhile");
var recurWhileEffect = /* @__PURE__ */ __name((f) => whileInputEffect(identity2(), f), "recurWhileEffect");
var recurs = /* @__PURE__ */ __name((n) => whileOutput(forever2, (out) => out < n), "recurs");
var reduce12 = /* @__PURE__ */ dual(3, (self2, zero3, f) => reduceEffect2(self2, zero3, (z, out) => sync(() => f(z, out))));
var reduceEffect2 = /* @__PURE__ */ dual(3, (self2, zero3, f) => makeWithState([self2.initial, zero3], (now2, input, [s, z]) => flatMap10(self2.step(now2, input, s), ([s2, out, decision]) => isDone4(decision) ? succeed([[s2, z], z, decision]) : map12(f(z, out), (z2) => [[s2, z2], z, decision]))));
var repetitions = /* @__PURE__ */ __name((self2) => reduce12(self2, 0, (n, _) => n + 1), "repetitions");
var resetAfter = /* @__PURE__ */ dual(2, (self2, durationInput) => {
  const duration4 = decode(durationInput);
  return pipe(self2, intersect5(elapsed), resetWhen(([, time4]) => greaterThanOrEqualTo2(time4, duration4)), map21((out) => out[0]));
});
var resetWhen = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state2) => flatMap10(self2.step(now2, input, state2), ([state3, out, decision]) => f(out) ? self2.step(now2, input, self2.initial) : succeed([state3, out, decision]))));
var run = /* @__PURE__ */ dual(3, (self2, now2, input) => pipe(runLoop(self2, now2, fromIterable3(input), self2.initial, empty4()), map12((list) => reverse2(list))));
var runLoop = /* @__PURE__ */ __name((self2, now2, inputs, state2, acc) => {
  if (!isNonEmpty(inputs)) {
    return succeed(acc);
  }
  const input = headNonEmpty2(inputs);
  const nextInputs = tailNonEmpty2(inputs);
  return flatMap10(self2.step(now2, input, state2), ([state3, out, decision]) => {
    if (isDone4(decision)) {
      return sync(() => pipe(acc, prepend2(out)));
    }
    return runLoop(self2, start2(decision.intervals), nextInputs, state3, prepend2(acc, out));
  });
}, "runLoop");
var secondOfMinute = /* @__PURE__ */ __name((second) => makeWithState([Number.NEGATIVE_INFINITY, 0], (now2, _, state2) => {
  if (!Number.isInteger(second) || second < 0 || 59 < second) {
    return dieSync(() => new IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));
  }
  const n = state2[1];
  const initial = n === 0;
  const second0 = nextSecond(now2, second, initial);
  const start3 = beginningOfSecond(second0);
  const end6 = endOfSecond(second0);
  const interval = make37(start3, end6);
  return succeed([[end6, n + 1], n, continueWith2(interval)]);
}), "secondOfMinute");
var spaced = /* @__PURE__ */ __name((duration4) => addDelay(forever2, () => duration4), "spaced");
var succeed8 = /* @__PURE__ */ __name((value6) => map21(forever2, () => value6), "succeed");
var sync5 = /* @__PURE__ */ __name((evaluate3) => map21(forever2, evaluate3), "sync");
var tapInput = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state2) => zipRight2(f(input), self2.step(now2, input, state2))));
var tapOutput = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now2, input, state2) => tap2(self2.step(now2, input, state2), ([, out]) => f(out))));
var unfold2 = /* @__PURE__ */ __name((initial, f) => makeWithState(initial, (now2, _, state2) => sync(() => [f(state2), state2, continueWith2(after2(now2))])), "unfold");
var union10 = /* @__PURE__ */ dual(2, (self2, that) => unionWith2(self2, that, union9));
var unionWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now2, input, state2) => zipWith5(self2.step(now2, input, state2[0]), that.step(now2, input, state2[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {
  if (isDone4(lDecision) && isDone4(rDecision)) {
    return [[lState, rState], [l, r], done6];
  }
  if (isDone4(lDecision) && isContinue2(rDecision)) {
    return [[lState, rState], [l, r], _continue2(rDecision.intervals)];
  }
  if (isContinue2(lDecision) && isDone4(rDecision)) {
    return [[lState, rState], [l, r], _continue2(lDecision.intervals)];
  }
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    const combined = f(lDecision.intervals, rDecision.intervals);
    return [[lState, rState], [l, r], _continue2(combined)];
  }
  throw new Error("BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/effect/issues");
})));
var untilInput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (input, _) => !f(input)));
var untilInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => negate(f(input))));
var untilOutput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (_, out) => !f(out)));
var untilOutputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (_, out) => negate(f(out))));
var upTo = /* @__PURE__ */ dual(2, (self2, duration4) => zipLeft6(self2, recurUpTo(duration4)));
var whileInput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (input, _) => f(input)));
var whileInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (_, out) => f(out)));
var whileOutputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (_, out) => f(out)));
var windowed = /* @__PURE__ */ __name((intervalInput) => {
  const interval = decode(intervalInput);
  const millis2 = toMillis(interval);
  return makeWithState([none2(), 0], (now2, _, [option9, n]) => {
    switch (option9._tag) {
      case "None": {
        return succeed([[some3(now2), n + 1], n, continueWith2(after2(now2 + millis2))]);
      }
      case "Some": {
        return succeed([[some3(option9.value), n + 1], n, continueWith2(after2(now2 + (millis2 - (now2 - option9.value) % millis2)))]);
      }
    }
  });
}, "windowed");
var zipLeft6 = /* @__PURE__ */ dual(2, (self2, that) => map21(intersect5(self2, that), (out) => out[0]));
var zipRight6 = /* @__PURE__ */ dual(2, (self2, that) => map21(intersect5(self2, that), (out) => out[1]));
var zipWith9 = /* @__PURE__ */ dual(3, (self2, that, f) => map21(intersect5(self2, that), ([out, out2]) => f(out, out2)));
var beginningOfSecond = /* @__PURE__ */ __name((now2) => {
  const date4 = new Date(now2);
  return new Date(date4.getFullYear(), date4.getMonth(), date4.getDate(), date4.getHours(), date4.getMinutes(), date4.getSeconds(), 0).getTime();
}, "beginningOfSecond");
var endOfSecond = /* @__PURE__ */ __name((now2) => {
  const date4 = new Date(beginningOfSecond(now2));
  return date4.setSeconds(date4.getSeconds() + 1);
}, "endOfSecond");
var nextSecond = /* @__PURE__ */ __name((now2, second, initial) => {
  const date4 = new Date(now2);
  if (date4.getSeconds() === second && initial) {
    return now2;
  }
  if (date4.getSeconds() < second) {
    return date4.setSeconds(second);
  }
  const newDate = new Date(date4.setSeconds(second));
  return newDate.setTime(newDate.getTime() + 1e3 * 60);
}, "nextSecond");
var beginningOfMinute = /* @__PURE__ */ __name((now2) => {
  const date4 = new Date(now2);
  return new Date(date4.getFullYear(), date4.getMonth(), date4.getDate(), date4.getHours(), date4.getMinutes(), 0, 0).getTime();
}, "beginningOfMinute");
var endOfMinute = /* @__PURE__ */ __name((now2) => {
  const date4 = new Date(beginningOfMinute(now2));
  return date4.setMinutes(date4.getMinutes() + 1);
}, "endOfMinute");
var nextMinute = /* @__PURE__ */ __name((now2, minute, initial) => {
  const date4 = new Date(now2);
  if (date4.getMinutes() === minute && initial) {
    return now2;
  }
  if (date4.getMinutes() < minute) {
    return date4.setMinutes(minute);
  }
  const newDate = new Date(date4.setMinutes(minute));
  return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60);
}, "nextMinute");
var beginningOfHour = /* @__PURE__ */ __name((now2) => {
  const date4 = new Date(now2);
  return new Date(date4.getFullYear(), date4.getMonth(), date4.getDate(), date4.getHours(), 0, 0, 0).getTime();
}, "beginningOfHour");
var endOfHour = /* @__PURE__ */ __name((now2) => {
  const date4 = new Date(beginningOfHour(now2));
  return date4.setHours(date4.getHours() + 1);
}, "endOfHour");
var nextHour = /* @__PURE__ */ __name((now2, hour, initial) => {
  const date4 = new Date(now2);
  if (date4.getHours() === hour && initial) {
    return now2;
  }
  if (date4.getHours() < hour) {
    return date4.setHours(hour);
  }
  const newDate = new Date(date4.setHours(hour));
  return newDate.setTime(newDate.getTime() + 1e3 * 60 * 60 * 24);
}, "nextHour");
var beginningOfDay = /* @__PURE__ */ __name((now2) => {
  const date4 = new Date(now2);
  return new Date(date4.getFullYear(), date4.getMonth(), date4.getDate(), 0, 0, 0, 0).getTime();
}, "beginningOfDay");
var endOfDay = /* @__PURE__ */ __name((now2) => {
  const date4 = new Date(beginningOfDay(now2));
  return date4.setDate(date4.getDate() + 1);
}, "endOfDay");
var nextDay = /* @__PURE__ */ __name((now2, dayOfWeek3, initial) => {
  const date4 = new Date(now2);
  if (date4.getDay() === dayOfWeek3 && initial) {
    return now2;
  }
  const nextDayOfWeek = (7 + dayOfWeek3 - date4.getDay()) % 7;
  return date4.setDate(date4.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));
}, "nextDay");
var nextDayOfMonth = /* @__PURE__ */ __name((now2, day, initial) => {
  const date4 = new Date(now2);
  if (date4.getDate() === day && initial) {
    return now2;
  }
  if (date4.getDate() < day) {
    return date4.setDate(day);
  }
  return findNextMonth(now2, day, 1);
}, "nextDayOfMonth");
var findNextMonth = /* @__PURE__ */ __name((now2, day, months) => {
  const d = new Date(now2);
  const tmp1 = new Date(d.setDate(day));
  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));
  if (tmp2.getDate() === day) {
    const d2 = new Date(now2);
    const tmp3 = new Date(d2.setDate(day));
    return tmp3.setMonth(tmp3.getMonth() + months);
  }
  return findNextMonth(now2, day, months + 1);
}, "findNextMonth");
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
var ScheduleDefect = class {
  static {
    __name(this, "ScheduleDefect");
  }
  error;
  [ScheduleDefectTypeId];
  constructor(error5) {
    this.error = error5;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
};
var isScheduleDefect = /* @__PURE__ */ __name((u) => hasProperty(u, ScheduleDefectTypeId), "isScheduleDefect");
var scheduleDefectWrap = /* @__PURE__ */ __name((self2) => catchAll(self2, (e) => die2(new ScheduleDefect(e))), "scheduleDefectWrap");
var scheduleDefectRefailCause = /* @__PURE__ */ __name((cause3) => match2(find(cause3, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some3(_.defect) : none2()), {
  onNone: /* @__PURE__ */ __name(() => cause3, "onNone"),
  onSome: /* @__PURE__ */ __name((error5) => fail(error5.error), "onSome")
}), "scheduleDefectRefailCause");
var scheduleDefectRefail = /* @__PURE__ */ __name((effect4) => catchAllCause(effect4, (cause3) => failCause(scheduleDefectRefailCause(cause3))), "scheduleDefectRefail");
var repeat_Effect = /* @__PURE__ */ dual(2, (self2, schedule4) => repeatOrElse_Effect(self2, schedule4, (e, _) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self2, options4) => {
  if (isSchedule(options4)) {
    return repeat_Effect(self2, options4);
  }
  const base = options4.schedule ?? passthrough2(forever2);
  const withWhile = options4.while ? whileInputEffect(base, (a) => {
    const applied = options4.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options4.until ? untilInputEffect(withWhile, (a) => {
    const applied = options4.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options4.times ? intersect5(withUntil, recurs(options4.times)).pipe(map21((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self2, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self2, schedule4, orElse19) => flatMap10(driver(schedule4), (driver3) => matchEffect(self2, {
  onFailure: /* @__PURE__ */ __name((error5) => orElse19(error5, none2()), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((value6) => repeatOrElseEffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver3.iterationMeta)), driver3, (error5, option9) => provideServiceEffect(orElse19(error5, option9), CurrentIterationMetadata, get11(driver3.iterationMeta)), value6), "onSuccess")
})));
var repeatOrElseEffectLoop = /* @__PURE__ */ __name((self2, driver3, orElse19, value6) => matchEffect(driver3.next(value6), {
  onFailure: /* @__PURE__ */ __name(() => orDie(driver3.last), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((b) => matchEffect(self2, {
    onFailure: /* @__PURE__ */ __name((error5) => orElse19(error5, some3(b)), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((value7) => repeatOrElseEffectLoop(self2, driver3, orElse19, value7), "onSuccess")
  }), "onSuccess")
}), "repeatOrElseEffectLoop");
var retry_Effect = /* @__PURE__ */ dual(2, (self2, policy2) => retryOrElse_Effect(self2, policy2, (e, _) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self2, options4) => {
  if (isSchedule(options4)) {
    return retry_Effect(self2, options4);
  }
  return scheduleDefectRefail(retry_Effect(self2, fromRetryOptions(options4)));
});
var fromRetryOptions = /* @__PURE__ */ __name((options4) => {
  const base = options4.schedule ?? forever2;
  const withWhile = options4.while ? whileInputEffect(base, (e) => {
    const applied = options4.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options4.until ? untilInputEffect(withWhile, (e) => {
    const applied = options4.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options4.times ? intersect5(withUntil, recurs(options4.times)) : withUntil;
}, "fromRetryOptions");
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self2, policy2, orElse19) => flatMap10(driver(policy2), (driver3) => retryOrElse_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver3.iterationMeta)), driver3, (e, out) => provideServiceEffect(orElse19(e, out), CurrentIterationMetadata, get11(driver3.iterationMeta)))));
var retryOrElse_EffectLoop = /* @__PURE__ */ __name((self2, driver3, orElse19) => {
  return catchAll(self2, (e) => matchEffect(driver3.next(e), {
    onFailure: /* @__PURE__ */ __name(() => pipe(driver3.last, orDie, flatMap10((out) => orElse19(e, out))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => retryOrElse_EffectLoop(self2, driver3, orElse19), "onSuccess")
  }));
}, "retryOrElse_EffectLoop");
var schedule_Effect = /* @__PURE__ */ dual(2, (self2, schedule4) => scheduleFrom_Effect(self2, void 0, schedule4));
var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self2, initial, schedule4) => flatMap10(driver(schedule4), (driver3) => scheduleFrom_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver3.iterationMeta)), initial, driver3)));
var scheduleFrom_EffectLoop = /* @__PURE__ */ __name((self2, initial, driver3) => matchEffect(driver3.next(initial), {
  onFailure: /* @__PURE__ */ __name(() => orDie(driver3.last), "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => flatMap10(self2, (a) => scheduleFrom_EffectLoop(self2, a, driver3)), "onSuccess")
}), "scheduleFrom_EffectLoop");
var count3 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
var elapsed = /* @__PURE__ */ makeWithState(/* @__PURE__ */ none2(), (now2, _, state2) => {
  switch (state2._tag) {
    case "None": {
      return succeed([some3(now2), zero, continueWith2(after2(now2))]);
    }
    case "Some": {
      return succeed([some3(state2.value), millis(now2 - state2.value), continueWith2(after2(now2))]);
    }
  }
});
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
var once3 = /* @__PURE__ */ asVoid4(/* @__PURE__ */ recurs(1));
var stop = /* @__PURE__ */ asVoid4(/* @__PURE__ */ recurs(0));
var scheduleForked = /* @__PURE__ */ dual(2, (self2, schedule4) => forkScoped(schedule_Effect(self2, schedule4)));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/executionPlan.js
var withExecutionPlan = /* @__PURE__ */ dual(2, (effect4, plan) => suspend(() => {
  let i = 0;
  let result;
  return flatMap10(whileLoop({
    while: /* @__PURE__ */ __name(() => i < plan.steps.length && (result === void 0 || isLeft2(result)), "while"),
    body: /* @__PURE__ */ __name(() => {
      const step4 = plan.steps[i];
      let nextEffect = effect_provide(effect4, step4.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted) return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step4, false)));
      } else {
        const schedule4 = scheduleFromStep(step4, true);
        nextEffect = schedule4 ? scheduleDefectRefail(retry_Effect(nextEffect, schedule4)) : nextEffect;
      }
      return either2(nextEffect);
    }, "body"),
    step: /* @__PURE__ */ __name((either12) => {
      result = either12;
      i++;
    }, "step")
  }), () => result);
}));
var scheduleFromStep = /* @__PURE__ */ __name((step4, first2) => {
  if (!first2) {
    return fromRetryOptions({
      schedule: step4.schedule ? step4.schedule : step4.attempts ? void 0 : once3,
      times: step4.attempts,
      while: step4.while
    });
  } else if (step4.attempts === 1 || !(step4.schedule || step4.attempts)) {
    return void 0;
  }
  return fromRetryOptions({
    schedule: step4.schedule,
    while: step4.while,
    times: step4.attempts ? step4.attempts - 1 : void 0
  });
}, "scheduleFromStep");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/query.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/cache.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Deferred.js
var Deferred_exports = {};
__export(Deferred_exports, {
  DeferredTypeId: () => DeferredTypeId2,
  await: () => _await3,
  complete: () => complete2,
  completeWith: () => completeWith,
  die: () => die6,
  dieSync: () => dieSync3,
  done: () => done8,
  fail: () => fail8,
  failCause: () => failCause7,
  failCauseSync: () => failCauseSync3,
  failSync: () => failSync3,
  interrupt: () => interrupt6,
  interruptWith: () => interruptWith2,
  isDone: () => isDone5,
  make: () => make43,
  makeAs: () => makeAs,
  poll: () => poll3,
  succeed: () => succeed9,
  sync: () => sync6,
  unsafeDone: () => unsafeDone,
  unsafeMake: () => unsafeMake10
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DeferredTypeId2 = DeferredTypeId;
var make43 = deferredMake;
var makeAs = deferredMakeAs;
var _await3 = deferredAwait;
var complete2 = deferredComplete;
var completeWith = deferredCompleteWith;
var done8 = deferredDone;
var fail8 = deferredFail;
var failSync3 = deferredFailSync;
var failCause7 = deferredFailCause;
var failCauseSync3 = deferredFailCauseSync;
var die6 = deferredDie;
var dieSync3 = deferredDieSync;
var interrupt6 = deferredInterrupt;
var interruptWith2 = deferredInterruptWith;
var isDone5 = deferredIsDone;
var poll3 = deferredPoll;
var succeed9 = deferredSucceed;
var sync6 = deferredSync;
var unsafeMake10 = deferredUnsafeMake;
var unsafeDone = deferredUnsafeDone;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/MutableQueue.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/MutableList.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId18 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId18]: TypeId18,
  [Symbol.iterator]() {
    let done12 = false;
    let head13 = this.head;
    return {
      next() {
        if (done12) {
          return this.return();
        }
        if (head13 == null) {
          done12 = true;
          return this.return();
        }
        const value6 = head13.value;
        head13 = head13.next;
        return {
          done: done12,
          value: value6
        };
      },
      return(value6) {
        if (!done12) {
          done12 = true;
        }
        return {
          done: true,
          value: value6
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = /* @__PURE__ */ __name((value6) => ({
  value: value6,
  removed: false,
  prev: void 0,
  next: void 0
}), "makeNode");
var empty32 = /* @__PURE__ */ __name(() => {
  const list = Object.create(MutableListProto);
  list.head = void 0;
  list.tail = void 0;
  list._length = 0;
  return list;
}, "empty");
var isEmpty9 = /* @__PURE__ */ __name((self2) => length2(self2) === 0, "isEmpty");
var length2 = /* @__PURE__ */ __name((self2) => self2._length, "length");
var append3 = /* @__PURE__ */ dual(2, (self2, value6) => {
  const node = makeNode(value6);
  if (self2.head === void 0) {
    self2.head = node;
  }
  if (self2.tail === void 0) {
    self2.tail = node;
  } else {
    self2.tail.next = node;
    node.prev = self2.tail;
    self2.tail = node;
  }
  ;
  self2._length += 1;
  return self2;
});
var shift = /* @__PURE__ */ __name((self2) => {
  const head13 = self2.head;
  if (head13 !== void 0) {
    remove9(self2, head13);
    return head13.value;
  }
  return void 0;
}, "shift");
var remove9 = /* @__PURE__ */ __name((self2, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== void 0 && node.next !== void 0) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== void 0) {
    self2.tail = node.prev;
    node.prev.next = void 0;
  } else if (node.next !== void 0) {
    self2.head = node.next;
    node.next.prev = void 0;
  } else {
    self2.tail = void 0;
    self2.head = void 0;
  }
  if (self2._length > 0) {
    ;
    self2._length -= 1;
  }
}, "remove");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/MutableQueue.js
var TypeId19 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId19]: TypeId19,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make44 = /* @__PURE__ */ __name((capacity9) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty32();
  queue.capacity = capacity9;
  return queue;
}, "make");
var bounded = /* @__PURE__ */ __name((capacity9) => make44(capacity9), "bounded");
var unbounded = /* @__PURE__ */ __name(() => make44(void 0), "unbounded");
var length3 = /* @__PURE__ */ __name((self2) => length2(self2.queue), "length");
var isEmpty10 = /* @__PURE__ */ __name((self2) => isEmpty9(self2.queue), "isEmpty");
var capacity = /* @__PURE__ */ __name((self2) => self2.capacity === void 0 ? Infinity : self2.capacity, "capacity");
var offer = /* @__PURE__ */ dual(2, (self2, value6) => {
  const queueLength = length2(self2.queue);
  if (self2.capacity !== void 0 && queueLength === self2.capacity) {
    return false;
  }
  append3(value6)(self2.queue);
  return true;
});
var offerAll = /* @__PURE__ */ dual(2, (self2, values6) => {
  const iterator = values6[Symbol.iterator]();
  let next4;
  let remainder2 = empty4();
  let offering = true;
  while (offering && (next4 = iterator.next()) && !next4.done) {
    offering = offer(next4.value)(self2);
  }
  while (next4 != null && !next4.done) {
    remainder2 = prepend2(next4.value)(remainder2);
    next4 = iterator.next();
  }
  return reverse2(remainder2);
});
var poll4 = /* @__PURE__ */ dual(2, (self2, def) => {
  if (isEmpty9(self2.queue)) {
    return def;
  }
  return shift(self2.queue);
});
var pollUpTo = /* @__PURE__ */ dual(2, (self2, n) => {
  let result = empty4();
  let count7 = 0;
  while (count7 < n) {
    const element2 = poll4(EmptyMutableQueue)(self2);
    if (element2 === EmptyMutableQueue) {
      break;
    }
    result = prepend2(element2)(result);
    count7 += 1;
  }
  return reverse2(result);
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/cache.js
var complete3 = /* @__PURE__ */ __name((key, exit5, entryStats, timeToLiveMillis) => struct2({
  _tag: "Complete",
  key,
  exit: exit5,
  entryStats,
  timeToLiveMillis
}), "complete");
var pending2 = /* @__PURE__ */ __name((key, deferred) => struct2({
  _tag: "Pending",
  key,
  deferred
}), "pending");
var refreshing = /* @__PURE__ */ __name((deferred, complete4) => struct2({
  _tag: "Refreshing",
  deferred,
  complete: complete4
}), "refreshing");
var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");
var MapKeyImpl = class {
  static {
    __name(this, "MapKeyImpl");
  }
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = void 0;
  next = void 0;
  constructor(current2) {
    this.current = current2;
  }
  [symbol]() {
    return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
  }
  [symbol2](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
};
var makeMapKey = /* @__PURE__ */ __name((current2) => new MapKeyImpl(current2), "makeMapKey");
var isMapKey = /* @__PURE__ */ __name((u) => hasProperty(u, MapKeyTypeId), "isMapKey");
var KeySetImpl = class {
  static {
    __name(this, "KeySetImpl");
  }
  head = void 0;
  tail = void 0;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === void 0) {
        this.head = key;
        this.tail = key;
      } else {
        const previous2 = key.previous;
        const next4 = key.next;
        if (next4 !== void 0) {
          key.next = void 0;
          if (previous2 !== void 0) {
            previous2.next = next4;
            next4.previous = previous2;
          } else {
            this.head = next4;
            this.head.previous = void 0;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== void 0) {
      const next4 = key.next;
      if (next4 !== void 0) {
        key.next = void 0;
        this.head = next4;
        this.head.previous = void 0;
      } else {
        this.head = void 0;
        this.tail = void 0;
      }
    }
    return key;
  }
};
var makeKeySet = /* @__PURE__ */ __name(() => new KeySetImpl(), "makeKeySet");
var makeCacheState = /* @__PURE__ */ __name((map38, keys6, accesses, updating, hits, misses) => ({
  map: map38,
  keys: keys6,
  accesses,
  updating,
  hits,
  misses
}), "makeCacheState");
var initialCacheState = /* @__PURE__ */ __name(() => makeCacheState(empty23(), makeKeySet(), unbounded(), make13(false), 0, 0), "initialCacheState");
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
var cacheVariance = {
  /* c8 ignore next */
  _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
  /* c8 ignore next */
  _Error: /* @__PURE__ */ __name((_) => _, "_Error"),
  /* c8 ignore next */
  _Value: /* @__PURE__ */ __name((_) => _, "_Value")
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  /* c8 ignore next */
  _Key: /* @__PURE__ */ __name((_) => _, "_Key"),
  /* c8 ignore next */
  _Error: /* @__PURE__ */ __name((_) => _, "_Error"),
  /* c8 ignore next */
  _Value: /* @__PURE__ */ __name((_) => _, "_Value")
};
var makeCacheStats = /* @__PURE__ */ __name((options4) => options4, "makeCacheStats");
var makeEntryStats = /* @__PURE__ */ __name((loadedMillis) => ({
  loadedMillis
}), "makeEntryStats");
var CacheImpl = class {
  static {
    __name(this, "CacheImpl");
  }
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance;
  cacheState;
  constructor(capacity9, context17, fiberId5, lookup, timeToLive) {
    this.capacity = capacity9;
    this.context = context17;
    this.fiberId = fiberId5;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map12(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size7(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get13(this.cacheState.map, key), {
      onNone: /* @__PURE__ */ __name(() => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      }, "onNone"),
      onSome: /* @__PURE__ */ __name((value6) => this.resolveMapValue(value6), "onSome")
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get13(this.cacheState.map, key), {
      onNone: /* @__PURE__ */ __name(() => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      }, "onNone"),
      onSome: /* @__PURE__ */ __name((value6) => this.resolveMapValue(value6, true), "onSome")
    }));
  }
  contains(key) {
    return sync(() => has6(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option9 = get13(this.cacheState.map, key);
      if (isSome2(option9)) {
        switch (option9.value._tag) {
          case "Complete": {
            const loaded = option9.value.entryStats.loadedMillis;
            return some3(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option9.value.complete.entryStats.loadedMillis;
            return some3(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = void 0;
      let deferred = void 0;
      let value6 = getOrUndefined2(get13(this.cacheState.map, k));
      if (value6 === void 0) {
        deferred = unsafeMake10(this.fiberId);
        mapKey = makeMapKey(k);
        if (has6(this.cacheState.map, k)) {
          value6 = getOrUndefined2(get13(this.cacheState.map, k));
        } else {
          set6(this.cacheState.map, k, pending2(mapKey, deferred));
        }
      }
      if (value6 === void 0) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map12(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap10(this.resolveMapValue(value6), match2({
          onNone: /* @__PURE__ */ __name(() => this.getEither(key), "onNone"),
          onSome: /* @__PURE__ */ __name((value7) => succeed(left2(value7)), "onSome")
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove7(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when9) {
    return sync(() => {
      const value6 = get13(this.cacheState.map, key);
      if (isSome2(value6) && value6.value._tag === "Complete") {
        if (value6.value.exit._tag === "Success") {
          if (when9(value6.value.exit.value)) {
            remove7(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty23();
    });
  }
  refresh(key) {
    return clockWith3((clock3) => suspend(() => {
      const k = key;
      const deferred = unsafeMake10(this.fiberId);
      let value6 = getOrUndefined2(get13(this.cacheState.map, k));
      if (value6 === void 0) {
        if (has6(this.cacheState.map, k)) {
          value6 = getOrUndefined2(get13(this.cacheState.map, k));
        } else {
          set6(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
        }
      }
      if (value6 === void 0) {
        return asVoid2(this.lookupValueOf(key, deferred));
      } else {
        switch (value6._tag) {
          case "Complete": {
            if (this.hasExpired(clock3, value6.timeToLiveMillis)) {
              const found = getOrUndefined2(get13(this.cacheState.map, k));
              if (equals(found, value6)) {
                remove7(this.cacheState.map, k);
              }
              return asVoid2(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current2 = getOrUndefined2(get13(this.cacheState.map, k));
              if (equals(current2, value6)) {
                const mapValue = refreshing(deferred, value6);
                set6(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid2);
          }
          case "Pending": {
            return _await3(value6.deferred);
          }
          case "Refreshing": {
            return _await3(value6.deferred);
          }
        }
      }
    }));
  }
  set(key, value6) {
    return clockWith3((clock3) => sync(() => {
      const now2 = clock3.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed3(value6);
      const mapValue = complete3(makeMapKey(k), lookupResult, makeEntryStats(now2), now2 + toMillis(decode(this.timeToLive(lookupResult))));
      set6(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size7(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values6 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values6.push(entry[1].exit.value);
        }
      }
      return values6;
    });
  }
  get entries() {
    return sync(() => {
      const values6 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values6.push([entry[0], entry[1].exit.value]);
        }
      }
      return values6;
    });
  }
  get keys() {
    return sync(() => {
      const keys6 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys6.push(entry[0]);
        }
      }
      return keys6;
    });
  }
  resolveMapValue(value6, ignorePending = false) {
    return clockWith3((clock3) => {
      switch (value6._tag) {
        case "Complete": {
          this.trackAccess(value6.key);
          if (this.hasExpired(clock3, value6.timeToLiveMillis)) {
            remove7(this.cacheState.map, value6.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map12(value6.exit, some3);
        }
        case "Pending": {
          this.trackAccess(value6.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map12(_await3(value6.deferred), some3);
        }
        case "Refreshing": {
          this.trackAccess(value6.complete.key);
          this.trackHit();
          if (this.hasExpired(clock3, value6.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map12(_await3(value6.deferred), some3);
          }
          return map12(value6.complete.exit, some3);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop5 = true;
      while (loop5) {
        const key2 = poll4(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop5 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size22 = size7(this.cacheState.map);
      loop5 = size22 > this.capacity;
      while (loop5) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== void 0) {
          if (has6(this.cacheState.map, key2.current)) {
            remove7(this.cacheState.map, key2.current);
            size22 = size22 - 1;
            loop5 = size22 > this.capacity;
          }
        } else {
          loop5 = false;
        }
      }
      set2(this.cacheState.updating, false);
    }
  }
  hasExpired(clock3, timeToLiveMillis) {
    return clock3.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock3) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit2, flatMap10((exit5) => {
        const now2 = clock3.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now2);
        const value6 = complete3(makeMapKey(key), exit5, stats, now2 + toMillis(decode(this.timeToLive(exit5))));
        set6(this.cacheState.map, key, value6);
        return zipRight2(done8(deferred, exit5), exit5);
      }), onInterrupt(() => zipRight2(interrupt6(deferred), sync(() => {
        remove7(this.cacheState.map, key);
      }))));
    }));
  }
};
var unsafeMakeWith = /* @__PURE__ */ __name((capacity9, lookup, timeToLive) => new CacheImpl(capacity9, empty10(), none3, lookup, (exit5) => decode(timeToLive(exit5))), "unsafeMakeWith");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/query.js
var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map12(deferredMake(), (handle) => ({
  listeners: new Listeners(),
  handle
})), () => seconds(60))));
var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = /* @__PURE__ */ __name((request2, dataSource) => flatMap10(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id4) => {
  const proxy = new Proxy(request2, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached4 = fiberRefGetWith(currentCache, (cache) => flatMap10(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap10(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached4);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap10(exit2(blocked(empty18, restore(deferredAwait(orNew.left.handle)))), (exit5) => {
              orNew.left.listeners.decrement();
              return exit5;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap10(exit2(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id4,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached4;
    }
    const listeners2 = new Listeners();
    listeners2.increment();
    return flatMap10(deferredMake(), (ref2) => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref2,
      listeners: listeners2,
      ownerId: id4,
      state: {
        completed: false
      }
    })), deferredAwait(ref2)), sync(() => listeners2.decrement())));
  });
})), "fromRequest");
var cacheRequest = /* @__PURE__ */ __name((request2, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap10(cache.getEither(request2), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_3;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_3;
  });
}, "cacheRequest");
var withRequestCaching = /* @__PURE__ */ dual(2, (self2, strategy) => fiberRefLocally(self2, currentCacheEnabled, strategy));
var withRequestCache = /* @__PURE__ */ dual(
  2,
  // @ts-expect-error
  (self2, cache) => fiberRefLocally(self2, currentCache, cache)
);

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Request.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isRequest2 = isRequest;
var Class5 = Class3;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Effect.js
var EffectTypeId4 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once4 = once2;
var all8 = all6;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile4 = dropWhile3;
var takeUntil2 = takeUntil;
var takeWhile4 = takeWhile3;
var every10 = every8;
var exists4 = exists3;
var filter12 = filter10;
var filterMap7 = filterMap6;
var findFirst8 = findFirst6;
var forEach11 = forEach10;
var head5 = head4;
var mergeAll5 = mergeAll3;
var partition6 = partition5;
var reduce13 = reduce9;
var reduceWhile2 = reduceWhile;
var reduceRight4 = reduceRight3;
var reduceEffect3 = reduceEffect;
var replicate3 = replicate2;
var replicateEffect2 = replicateEffect;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async2 = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail10 = fail2;
var failSync4 = failSync;
var failCause9 = failCause;
var failCauseSync4 = failCauseSync;
var die7 = die2;
var dieMessage2 = dieMessage;
var dieSync4 = dieSync;
var gen4 = gen3;
var never4 = never;
var none9 = none6;
var promise2 = promise;
var succeed11 = succeed;
var succeedNone2 = succeedNone;
var succeedSome2 = succeedSome;
var suspend4 = suspend;
var sync7 = sync;
var _void = void_3;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll3 = catchAll;
var catchAllCause3 = catchAllCause;
var catchAllDefect2 = catchAllDefect;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore2 = ignore;
var ignoreLogged2 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox2 = sandbox;
var retry2 = retry_combined;
var withExecutionPlan2 = withExecutionPlan;
var retryOrElse = retryOrElse_Effect;
var try_3 = try_2;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise2 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect3 = disconnect2;
var interrupt7 = interrupt2;
var interruptWith3 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt2 = onInterrupt;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate5 = liftPredicate4;
var as8 = as3;
var asSome2 = asSome;
var asSomeError2 = asSomeError;
var asVoid5 = asVoid2;
var flip3 = flip2;
var flipWith2 = flipWith;
var map22 = map12;
var mapAccum4 = mapAccum3;
var mapBoth5 = mapBoth2;
var mapError4 = mapError;
var mapErrorCause3 = mapErrorCause;
var merge7 = merge5;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer3 = addFinalizer;
var ensuring3 = ensuring;
var onError2 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope3 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped3 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork3 = fork;
var forkDaemon2 = forkDaemon;
var forkAll2 = forkAll;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency2 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay2 = delay;
var sleep4 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout2 = timeout;
var timeoutOption2 = timeoutOption;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context4 = context2;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext3 = mapInputContext;
var provide2 = effect_provide;
var provideService4 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption2 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService2 = updateService;
var Do5 = Do4;
var bind6 = bind5;
var bindAll2 = bindAll;
var bindTo6 = bindTo5;
var let_6 = let_5;
var option2 = option;
var either4 = either2;
var exit4 = exit2;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail2 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when2 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap15 = flatMap10;
var andThen8 = andThen5;
var flatten10 = flatten6;
var race2 = race;
var raceAll2 = raceAll;
var raceFirst2 = raceFirst;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap4 = tap2;
var tapBoth2 = tapBoth;
var tapDefect2 = tapDefect;
var tapError3 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause3 = tapErrorCause;
var forever3 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop3 = whileLoop;
var getFiberRefs = fiberRefs2;
var inheritFiberRefs2 = inheritFiberRefs;
var locally2 = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs3 = updateFiberRefs;
var isFailure5 = isFailure2;
var isSuccess3 = isSuccess;
var match15 = match8;
var matchCause4 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect3 = matchEffect;
var log5 = log3;
var logWithLevel2 = /* @__PURE__ */ __name((level, ...message) => logWithLevel(level)(...message), "logWithLevel");
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs3 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie3 = orDie;
var orDieWith2 = orDieWith;
var orElse7 = orElse3;
var orElseFail2 = orElseFail;
var orElseSucceed2 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random3 = random2;
var randomWith2 = randomWith;
var withRandom2 = withRandom;
var withRandomFixed = /* @__PURE__ */ dual(2, (effect4, values6) => withRandom2(effect4, fixed2(values6)));
var withRandomScoped2 = withRandomScoped;
var runtime4 = runtime3;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise = unsafeRunPromiseEffect;
var runPromiseExit = unsafeRunPromiseExitEffect;
var runSync = unsafeRunSyncEffect;
var runSyncExit = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip8 = zipOptions;
var zipLeft7 = zipLeftOptions;
var zipRight7 = zipRightOptions;
var zipWith10 = zipWithOptions;
var ap3 = /* @__PURE__ */ dual(2, (self2, that) => zipWith10(self2, that, (f, a) => f(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans3 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan3 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan3 = withParentSpan;
var fromNullable5 = fromNullable4;
var optionFromOptional2 = optionFromOptional;
var transposeOption2 = /* @__PURE__ */ __name((self2) => {
  return isNone(self2) ? succeedNone2 : map22(self2.value, some2);
}, "transposeOption");
var transposeMapOption2 = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? succeedNone2 : map22(f(self2.value), some2));
var makeTagProxy = /* @__PURE__ */ __name((TagClass) => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(TagClass, {
    get(target3, prop, receiver) {
      if (prop in target3) {
        return Reflect.get(target3, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn2 = /* @__PURE__ */ __name((...args2) => andThen5(target3, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen5(target3, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen5(target3, (s2) => s2[prop]));
        return s[prop];
      }), "fn");
      const cn = andThen5(target3, (s) => s[prop]);
      Object.assign(fn2, cn);
      const apply = fn2.apply;
      const bind11 = fn2.bind;
      const call = fn2.call;
      const proto14 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
      proto14.apply = apply;
      proto14.bind = bind11;
      proto14.call = call;
      Object.setPrototypeOf(fn2, proto14);
      cache.set(prop, fn2);
      return fn2;
    }
  });
}, "makeTagProxy");
var Tag3 = /* @__PURE__ */ __name((id4) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error();
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  __name(TagClass, "TagClass");
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id4;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen5(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
}, "Tag");
var Service = /* @__PURE__ */ __name(function() {
  return function() {
    const [id4, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = /* @__PURE__ */ __name(function(service3) {
      if (patchState === "unchecked") {
        const proto14 = Object.getPrototypeOf(service3);
        if (proto14 === Object.prototype || proto14 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto14);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service3);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service3, Object.getPrototypeOf(this));
        return service3;
      }
    }, "TagClass");
    TagClass.prototype._tag = id4;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service3) => new this(service3);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen5(this, body);
      }
    });
    TagClass.key = id4;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return fromEffect4(TagClass, map22(maker.effect.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= fromEffect4(TagClass, map22(maker.effect, (_) => new this(_)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return scoped2(TagClass, map22(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= scoped2(TagClass, map22(maker.scoped, (_) => new this(_)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync4(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed7(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
}, "Service");
var fn = /* @__PURE__ */ __name(function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error();
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args2,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options4 = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error();
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body,
        args: args2,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options4,
        errorDef,
        errorCall
      });
    }
  }[name]);
}, "fn");
function defineLength(length5, fn2) {
  return Object.defineProperty(fn2, "length", {
    value: length5,
    configurable: true
  });
}
__name(defineLength, "defineLength");
function fnApply(options4) {
  let effect4;
  let fnError = void 0;
  if (isGeneratorFunction(options4.body)) {
    effect4 = fromIterator(() => options4.body.apply(options4.self, options4.args));
  } else {
    try {
      effect4 = options4.body.apply(options4.self, options4.args);
    } catch (error5) {
      fnError = error5;
      effect4 = die7(error5);
    }
  }
  if (options4.pipeables.length > 0) {
    try {
      for (const x of options4.pipeables) {
        effect4 = x(effect4, ...options4.args);
      }
    } catch (error5) {
      effect4 = fnError ? failCause9(sequential(die(fnError), die(error5))) : die7(error5);
    }
  }
  let cache = false;
  const captureStackTrace = /* @__PURE__ */ __name(() => {
    if (cache !== false) {
      return cache;
    }
    if (options4.errorCall.stack) {
      const stackDef = options4.errorDef.stack.trim().split("\n");
      const stackCall = options4.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}
${endStackCall}`;
      return cache;
    }
  }, "captureStackTrace");
  const opts = options4.spanOptions && "captureStackTrace" in options4.spanOptions ? options4.spanOptions : {
    captureStackTrace,
    ...options4.spanOptions
  };
  return withSpan3(effect4, options4.spanName, opts);
}
__name(fnApply, "fnApply");
var fnUntraced2 = fnUntraced;
var ensureSuccessType = /* @__PURE__ */ __name(() => (effect4) => effect4, "ensureSuccessType");
var ensureErrorType = /* @__PURE__ */ __name(() => (effect4) => effect4, "ensureErrorType");
var ensureRequirementsType = /* @__PURE__ */ __name(() => (effect4) => effect4, "ensureRequirementsType");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Redacted.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/redacted.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
var RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
var proto4 = {
  [RedactedTypeId]: {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol]() {
    return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol2](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = /* @__PURE__ */ __name((u) => hasProperty(u, RedactedTypeId), "isRedacted");
var make45 = /* @__PURE__ */ __name((value6) => {
  const redacted2 = Object.create(proto4);
  redactedRegistry.set(redacted2, value6);
  return redacted2;
}, "make");
var value = /* @__PURE__ */ __name((self2) => {
  if (redactedRegistry.has(self2)) {
    return redactedRegistry.get(self2);
  } else {
    throw new Error("Unable to get redacted value");
  }
}, "value");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Redacted.js
var isRedacted2 = isRedacted;
var make46 = make45;
var value2 = value;
var getEquivalence8 = /* @__PURE__ */ __name((isEquivalent) => make((x, y) => isEquivalent(value2(x), value2(y))), "getEquivalence");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Headers.js
var Headers_exports = {};
__export(Headers_exports, {
  HeadersTypeId: () => HeadersTypeId,
  currentRedactedNames: () => currentRedactedNames,
  empty: () => empty34,
  fromInput: () => fromInput,
  get: () => get15,
  has: () => has10,
  isHeaders: () => isHeaders,
  merge: () => merge9,
  redact: () => redact2,
  remove: () => remove10,
  schema: () => schema,
  schemaFromSelf: () => schemaFromSelf,
  set: () => set9,
  setAll: () => setAll3,
  unsafeFromRecord: () => unsafeFromRecord
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberRef.js
var FiberRef_exports = {};
__export(FiberRef_exports, {
  FiberRefTypeId: () => FiberRefTypeId2,
  currentConcurrency: () => currentConcurrency2,
  currentContext: () => currentContext2,
  currentLogAnnotations: () => currentLogAnnotations2,
  currentLogLevel: () => currentLogLevel2,
  currentLogSpan: () => currentLogSpan2,
  currentLoggers: () => currentLoggers2,
  currentMaxOpsBeforeYield: () => currentMaxOpsBeforeYield2,
  currentMetricLabels: () => currentMetricLabels2,
  currentMinimumLogLevel: () => currentMinimumLogLevel2,
  currentRequestBatchingEnabled: () => currentRequestBatchingEnabled,
  currentRequestCache: () => currentRequestCache,
  currentRequestCacheEnabled: () => currentRequestCacheEnabled,
  currentRuntimeFlags: () => currentRuntimeFlags2,
  currentScheduler: () => currentScheduler2,
  currentSchedulingPriority: () => currentSchedulingPriority2,
  currentSupervisor: () => currentSupervisor2,
  currentTracerEnabled: () => currentTracerEnabled2,
  currentTracerSpanAnnotations: () => currentTracerSpanAnnotations2,
  currentTracerSpanLinks: () => currentTracerSpanLinks2,
  currentTracerTimingEnabled: () => currentTracerTimingEnabled2,
  delete: () => _delete,
  get: () => get14,
  getAndSet: () => getAndSet3,
  getAndUpdate: () => getAndUpdate3,
  getAndUpdateSome: () => getAndUpdateSome3,
  getWith: () => getWith,
  interruptedCause: () => interruptedCause,
  make: () => make47,
  makeContext: () => makeContext2,
  makeRuntimeFlags: () => makeRuntimeFlags,
  makeWith: () => makeWith,
  modify: () => modify7,
  modifySome: () => modifySome3,
  reset: () => reset,
  set: () => set7,
  unhandledErrorLogLevel: () => unhandledErrorLogLevel,
  unsafeMake: () => unsafeMake11,
  unsafeMakeContext: () => unsafeMakeContext,
  unsafeMakeHashSet: () => unsafeMakeHashSet,
  unsafeMakePatch: () => unsafeMakePatch,
  unsafeMakeSupervisor: () => unsafeMakeSupervisor,
  update: () => update5,
  updateAndGet: () => updateAndGet3,
  updateSome: () => updateSome3,
  updateSomeAndGet: () => updateSomeAndGet3,
  versionMismatchErrorLogLevel: () => versionMismatchErrorLogLevel
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FiberRefTypeId2 = FiberRefTypeId;
var make47 = fiberRefMake;
var makeWith = fiberRefMakeWith;
var makeContext2 = fiberRefMakeContext;
var makeRuntimeFlags = fiberRefMakeRuntimeFlags;
var unsafeMake11 = fiberRefUnsafeMake;
var unsafeMakeHashSet = fiberRefUnsafeMakeHashSet;
var unsafeMakeContext = fiberRefUnsafeMakeContext;
var unsafeMakeSupervisor = fiberRefUnsafeMakeSupervisor;
var unsafeMakePatch = fiberRefUnsafeMakePatch;
var get14 = fiberRefGet;
var getAndSet3 = fiberRefGetAndSet;
var getAndUpdate3 = fiberRefGetAndUpdate;
var getAndUpdateSome3 = fiberRefGetAndUpdateSome;
var getWith = fiberRefGetWith;
var set7 = fiberRefSet;
var _delete = fiberRefDelete;
var reset = fiberRefReset;
var modify7 = fiberRefModify;
var modifySome3 = fiberRefModifySome;
var update5 = fiberRefUpdate;
var updateSome3 = fiberRefUpdateSome;
var updateAndGet3 = fiberRefUpdateAndGet;
var updateSomeAndGet3 = fiberRefUpdateSomeAndGet;
var currentConcurrency2 = currentConcurrency;
var currentRequestBatchingEnabled = currentRequestBatching;
var currentRequestCache = currentCache;
var currentRequestCacheEnabled = currentCacheEnabled;
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentMaxOpsBeforeYield2 = currentMaxOpsBeforeYield;
var unhandledErrorLogLevel = currentUnhandledErrorLogLevel;
var versionMismatchErrorLogLevel = currentVersionMismatchErrorLogLevel;
var currentLogAnnotations2 = currentLogAnnotations;
var currentLoggers2 = currentLoggers;
var currentLogLevel2 = currentLogLevel;
var currentMinimumLogLevel2 = currentMinimumLogLevel;
var currentLogSpan2 = currentLogSpan;
var currentRuntimeFlags2 = currentRuntimeFlags;
var currentScheduler2 = currentScheduler;
var currentSupervisor2 = currentSupervisor;
var currentMetricLabels2 = currentMetricLabels;
var currentTracerEnabled2 = currentTracerEnabled;
var currentTracerTimingEnabled2 = currentTracerTimingEnabled;
var currentTracerSpanAnnotations2 = currentTracerSpanAnnotations;
var currentTracerSpanLinks2 = currentTracerSpanLinks;
var interruptedCause = currentInterruptedCause;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Schema.js
var Schema_exports = {};
__export(Schema_exports, {
  Any: () => Any,
  Array: () => Array$,
  ArrayEnsure: () => ArrayEnsure,
  ArrayFormatterIssue: () => ArrayFormatterIssue,
  BetweenBigDecimalSchemaId: () => BetweenBigDecimalSchemaId,
  BetweenBigIntSchemaId: () => BetweenBigIntSchemaId,
  BetweenDateSchemaId: () => BetweenDateSchemaId,
  BetweenDurationSchemaId: () => BetweenDurationSchemaId,
  BetweenSchemaId: () => BetweenSchemaId2,
  BigDecimal: () => BigDecimal,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigInt: () => BigInt$,
  BigIntFromNumber: () => BigIntFromNumber,
  BigIntFromSelf: () => BigIntFromSelf,
  Boolean: () => Boolean$,
  BooleanFromString: () => BooleanFromString,
  BooleanFromUnknown: () => BooleanFromUnknown,
  BrandSchemaId: () => BrandSchemaId,
  Capitalize: () => Capitalize,
  Capitalized: () => Capitalized,
  CapitalizedSchemaId: () => CapitalizedSchemaId,
  Cause: () => Cause,
  CauseFromSelf: () => CauseFromSelf,
  Char: () => Char,
  Chunk: () => Chunk,
  ChunkFromSelf: () => ChunkFromSelf,
  Class: () => Class6,
  Config: () => Config,
  Data: () => Data,
  DataFromSelf: () => DataFromSelf,
  Date: () => Date$,
  DateFromNumber: () => DateFromNumber,
  DateFromSelf: () => DateFromSelf,
  DateFromSelfSchemaId: () => DateFromSelfSchemaId2,
  DateFromString: () => DateFromString,
  DateTimeUtc: () => DateTimeUtc,
  DateTimeUtcFromDate: () => DateTimeUtcFromDate,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf,
  DateTimeZoned: () => DateTimeZoned,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf,
  Defect: () => Defect,
  Duration: () => Duration,
  DurationFromMillis: () => DurationFromMillis,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromSelf: () => DurationFromSelf,
  Either: () => Either,
  EitherFromSelf: () => EitherFromSelf,
  EitherFromUnion: () => EitherFromUnion,
  EndsWithSchemaId: () => EndsWithSchemaId,
  Enums: () => Enums2,
  Exit: () => Exit,
  ExitFromSelf: () => ExitFromSelf,
  FiberId: () => FiberId,
  FiberIdFromSelf: () => FiberIdFromSelf,
  Finite: () => Finite,
  FiniteSchemaId: () => FiniteSchemaId2,
  FromPropertySignature: () => FromPropertySignature,
  GreaterThanBigDecimalSchemaId: () => GreaterThanBigDecimalSchemaId,
  GreaterThanBigIntSchemaId: () => GreaterThanBigIntSchemaId,
  GreaterThanDateSchemaId: () => GreaterThanDateSchemaId,
  GreaterThanDurationSchemaId: () => GreaterThanDurationSchemaId,
  GreaterThanOrEqualToBigDecimalSchemaId: () => GreaterThanOrEqualToBigDecimalSchemaId,
  GreaterThanOrEqualToBigIntSchemaId: () => GreaterThanOrEqualToBigIntSchemaId2,
  GreaterThanOrEqualToDateSchemaId: () => GreaterThanOrEqualToDateSchemaId,
  GreaterThanOrEqualToDurationSchemaId: () => GreaterThanOrEqualToDurationSchemaId,
  GreaterThanOrEqualToSchemaId: () => GreaterThanOrEqualToSchemaId2,
  GreaterThanSchemaId: () => GreaterThanSchemaId2,
  HashMap: () => HashMap,
  HashMapFromSelf: () => HashMapFromSelf,
  HashSet: () => HashSet,
  HashSetFromSelf: () => HashSetFromSelf,
  IncludesSchemaId: () => IncludesSchemaId,
  InstanceOfSchemaId: () => InstanceOfSchemaId,
  Int: () => Int,
  IntSchemaId: () => IntSchemaId2,
  ItemsCountSchemaId: () => ItemsCountSchemaId2,
  JsonNumber: () => JsonNumber,
  JsonNumberSchemaId: () => JsonNumberSchemaId2,
  LengthSchemaId: () => LengthSchemaId2,
  LessThanBigDecimalSchemaId: () => LessThanBigDecimalSchemaId,
  LessThanBigIntSchemaId: () => LessThanBigIntSchemaId2,
  LessThanDateSchemaId: () => LessThanDateSchemaId,
  LessThanDurationSchemaId: () => LessThanDurationSchemaId,
  LessThanOrEqualToBigDecimalSchemaId: () => LessThanOrEqualToBigDecimalSchemaId,
  LessThanOrEqualToBigIntSchemaId: () => LessThanOrEqualToBigIntSchemaId2,
  LessThanOrEqualToDateSchemaId: () => LessThanOrEqualToDateSchemaId,
  LessThanOrEqualToDurationSchemaId: () => LessThanOrEqualToDurationSchemaId,
  LessThanOrEqualToSchemaId: () => LessThanOrEqualToSchemaId2,
  LessThanSchemaId: () => LessThanSchemaId2,
  List: () => List,
  ListFromSelf: () => ListFromSelf,
  Literal: () => Literal2,
  Lowercase: () => Lowercase,
  Lowercased: () => Lowercased,
  LowercasedSchemaId: () => LowercasedSchemaId,
  Map: () => map27,
  MapFromRecord: () => MapFromRecord,
  MapFromSelf: () => MapFromSelf,
  MaxItemsSchemaId: () => MaxItemsSchemaId2,
  MaxLengthSchemaId: () => MaxLengthSchemaId2,
  MinItemsSchemaId: () => MinItemsSchemaId2,
  MinLengthSchemaId: () => MinLengthSchemaId2,
  MultipleOfSchemaId: () => MultipleOfSchemaId,
  Negative: () => Negative,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  NegativeBigDecimalSchemaId: () => NegativeBigDecimalSchemaId,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  Never: () => Never,
  NonEmptyArray: () => NonEmptyArray,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyString: () => NonEmptyString,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString,
  NonNaN: () => NonNaN,
  NonNaNSchemaId: () => NonNaNSchemaId2,
  NonNegative: () => NonNegative,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegativeBigDecimalSchemaId: () => NonNegativeBigDecimalSchemaId,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeInt: () => NonNegativeInt,
  NonPositive: () => NonPositive,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositiveBigDecimalSchemaId: () => NonPositiveBigDecimalSchemaId,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  Not: () => Not,
  Null: () => Null,
  NullOr: () => NullOr,
  NullishOr: () => NullishOr,
  Number: () => Number$,
  NumberFromString: () => NumberFromString,
  Object: () => Object$,
  Option: () => Option,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString,
  OptionFromNullOr: () => OptionFromNullOr,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  PatternSchemaId: () => PatternSchemaId,
  Positive: () => Positive,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  PositiveBigDecimalSchemaId: () => PositiveBigDecimalSchemaId,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PropertyKey: () => PropertyKey$,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PropertySignatureTransformation: () => PropertySignatureTransformation2,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  ReadonlyMap: () => ReadonlyMap,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  Record: () => Record,
  Redacted: () => Redacted,
  RedactedFromSelf: () => RedactedFromSelf,
  RefineSchemaId: () => RefineSchemaId,
  Set: () => set8,
  SetFromSelf: () => SetFromSelf,
  SortedSet: () => SortedSet,
  SortedSetFromSelf: () => SortedSetFromSelf,
  StartsWithSchemaId: () => StartsWithSchemaId,
  String: () => String$,
  StringFromBase64: () => StringFromBase64,
  StringFromBase64Url: () => StringFromBase64Url,
  StringFromHex: () => StringFromHex,
  StringFromUriComponent: () => StringFromUriComponent,
  Struct: () => Struct,
  Symbol: () => Symbol$,
  SymbolFromSelf: () => SymbolFromSelf,
  TaggedClass: () => TaggedClass3,
  TaggedError: () => TaggedError2,
  TaggedRequest: () => TaggedRequest,
  TaggedStruct: () => TaggedStruct,
  TemplateLiteral: () => TemplateLiteral2,
  TemplateLiteralParser: () => TemplateLiteralParser,
  TimeZone: () => TimeZone,
  TimeZoneFromSelf: () => TimeZoneFromSelf,
  TimeZoneNamed: () => TimeZoneNamed,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf,
  TimeZoneOffset: () => TimeZoneOffset,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf,
  ToPropertySignature: () => ToPropertySignature,
  Trim: () => Trim,
  Trimmed: () => Trimmed,
  TrimmedSchemaId: () => TrimmedSchemaId,
  Tuple: () => Tuple,
  TypeId: () => TypeId21,
  ULID: () => ULID,
  ULIDSchemaId: () => ULIDSchemaId,
  URL: () => URL$,
  URLFromSelf: () => URLFromSelf,
  UUID: () => UUID,
  UUIDSchemaId: () => UUIDSchemaId,
  Uint8: () => Uint8,
  Uint8Array: () => Uint8Array$,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase64,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uncapitalize: () => Uncapitalize,
  Uncapitalized: () => Uncapitalized,
  UncapitalizedSchemaId: () => UncapitalizedSchemaId,
  Undefined: () => Undefined,
  UndefinedOr: () => UndefinedOr,
  Union: () => Union2,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Unknown: () => Unknown,
  Uppercase: () => Uppercase,
  Uppercased: () => Uppercased,
  UppercasedSchemaId: () => UppercasedSchemaId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  ValidDateSchemaId: () => ValidDateSchemaId,
  Void: () => Void,
  annotations: () => annotations2,
  asSchema: () => asSchema,
  asSerializable: () => asSerializable,
  asSerializableWithResult: () => asSerializableWithResult,
  asWithResult: () => asWithResult,
  asserts: () => asserts,
  attachPropertySignature: () => attachPropertySignature,
  between: () => between5,
  betweenBigDecimal: () => betweenBigDecimal,
  betweenBigInt: () => betweenBigInt,
  betweenDate: () => betweenDate,
  betweenDuration: () => betweenDuration,
  brand: () => brand,
  capitalized: () => capitalized,
  clamp: () => clamp8,
  clampBigDecimal: () => clampBigDecimal,
  clampBigInt: () => clampBigInt,
  clampDuration: () => clampDuration,
  compose: () => compose4,
  declare: () => declare,
  decode: () => decode6,
  decodeEither: () => decodeEither2,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise2,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown3,
  decodeUnknownEither: () => decodeUnknownEither2,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise2,
  decodeUnknownSync: () => decodeUnknownSync,
  deserialize: () => deserialize,
  deserializeExit: () => deserializeExit,
  deserializeFailure: () => deserializeFailure,
  deserializeSuccess: () => deserializeSuccess,
  element: () => element,
  encode: () => encode5,
  encodeEither: () => encodeEither2,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise2,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown2,
  encodeUnknownEither: () => encodeUnknownEither2,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise2,
  encodeUnknownSync: () => encodeUnknownSync,
  encodedBoundSchema: () => encodedBoundSchema,
  encodedSchema: () => encodedSchema,
  endsWith: () => endsWith,
  equivalence: () => equivalence2,
  exitSchema: () => exitSchema,
  extend: () => extend4,
  failureSchema: () => failureSchema,
  filter: () => filter13,
  filterEffect: () => filterEffect,
  finite: () => finite,
  format: () => format6,
  fromBrand: () => fromBrand,
  fromKey: () => fromKey,
  getClassTag: () => getClassTag,
  getNumberIndexedAccess: () => getNumberIndexedAccess2,
  greaterThan: () => greaterThan6,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanDate: () => greaterThanDate,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo5,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  head: () => head6,
  headNonEmpty: () => headNonEmpty3,
  headOrElse: () => headOrElse,
  includes: () => includes,
  instanceOf: () => instanceOf,
  int: () => int,
  is: () => is,
  isPropertySignature: () => isPropertySignature,
  isSchema: () => isSchema,
  itemsCount: () => itemsCount,
  keyof: () => keyof2,
  length: () => length4,
  lessThan: () => lessThan10,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThanBigInt: () => lessThanBigInt,
  lessThanDate: () => lessThanDate,
  lessThanDuration: () => lessThanDuration,
  lessThanOrEqualTo: () => lessThanOrEqualTo5,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lowercased: () => lowercased,
  make: () => make50,
  makePropertySignature: () => makePropertySignature,
  maxItems: () => maxItems,
  maxLength: () => maxLength,
  minItems: () => minItems,
  minLength: () => minLength,
  multipleOf: () => multipleOf,
  mutable: () => mutable2,
  negative: () => negative,
  negativeBigDecimal: () => negativeBigDecimal,
  negativeBigInt: () => negativeBigInt,
  nonEmptyString: () => nonEmptyString2,
  nonNaN: () => nonNaN,
  nonNegative: () => nonNegative,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonPositive: () => nonPositive,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositiveBigInt: () => nonPositiveBigInt,
  omit: () => omit5,
  optional: () => optional,
  optionalElement: () => optionalElement,
  optionalToOptional: () => optionalToOptional,
  optionalToRequired: () => optionalToRequired,
  optionalWith: () => optionalWith,
  parseJson: () => parseJson,
  parseNumber: () => parseNumber,
  partial: () => partial2,
  partialWith: () => partialWith,
  pattern: () => pattern,
  pick: () => pick5,
  pickLiteral: () => pickLiteral,
  pluck: () => pluck,
  positive: () => positive,
  positiveBigDecimal: () => positiveBigDecimal,
  positiveBigInt: () => positiveBigInt,
  propertySignature: () => propertySignature,
  rename: () => rename2,
  required: () => required2,
  requiredToOptional: () => requiredToOptional,
  serializableSchema: () => serializableSchema,
  serialize: () => serialize,
  serializeExit: () => serializeExit,
  serializeFailure: () => serializeFailure,
  serializeSuccess: () => serializeSuccess,
  split: () => split3,
  standardSchemaV1: () => standardSchemaV1,
  startsWith: () => startsWith,
  successSchema: () => successSchema,
  suspend: () => suspend7,
  symbolSerializable: () => symbolSerializable,
  symbolWithResult: () => symbolWithResult,
  tag: () => tag,
  transform: () => transform2,
  transformLiteral: () => transformLiteral,
  transformLiterals: () => transformLiterals,
  transformOrFail: () => transformOrFail,
  trimmed: () => trimmed,
  typeSchema: () => typeSchema,
  uncapitalized: () => uncapitalized,
  uppercased: () => uppercased,
  validDate: () => validDate,
  validate: () => validate5,
  validateEither: () => validateEither2,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise2,
  validateSync: () => validateSync,
  withConstructorDefault: () => withConstructorDefault,
  withDecodingDefault: () => withDecodingDefault,
  withDefaults: () => withDefaults
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/BigDecimal.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var FINITE_INT_REGEX = /^[+-]?\d+$/;
var TypeId20 = /* @__PURE__ */ Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId20]: TypeId20,
  [symbol]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine(number2(normalized.scale)), cached(this));
  },
  [symbol2](that) {
    return isBigDecimal(that) && equals4(this, that);
  },
  toString() {
    return `BigDecimal(${format4(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId20), "isBigDecimal");
var make48 = /* @__PURE__ */ __name((value6, scale2) => {
  const o = Object.create(BigDecimalProto);
  o.value = value6;
  o.scale = scale2;
  return o;
}, "make");
var unsafeMakeNormalized = /* @__PURE__ */ __name((value6, scale2) => {
  if (value6 !== bigint04 && value6 % bigint10 === bigint04) {
    throw new RangeError("Value must be normalized");
  }
  const o = make48(value6, scale2);
  o.normalized = o;
  return o;
}, "unsafeMakeNormalized");
var bigint04 = /* @__PURE__ */ BigInt(0);
var bigint10 = /* @__PURE__ */ BigInt(10);
var zero2 = /* @__PURE__ */ unsafeMakeNormalized(bigint04, 0);
var normalize = /* @__PURE__ */ __name((self2) => {
  if (self2.normalized === void 0) {
    if (self2.value === bigint04) {
      self2.normalized = zero2;
    } else {
      const digits = `${self2.value}`;
      let trail = 0;
      for (let i = digits.length - 1; i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self2.normalized = self2;
      }
      const value6 = BigInt(digits.substring(0, digits.length - trail));
      const scale2 = self2.scale - trail;
      self2.normalized = unsafeMakeNormalized(value6, scale2);
    }
  }
  return self2.normalized;
}, "normalize");
var scale = /* @__PURE__ */ dual(2, (self2, scale2) => {
  if (scale2 > self2.scale) {
    return make48(self2.value * bigint10 ** BigInt(scale2 - self2.scale), scale2);
  }
  if (scale2 < self2.scale) {
    return make48(self2.value / bigint10 ** BigInt(self2.scale - scale2), scale2);
  }
  return self2;
});
var Order6 = /* @__PURE__ */ make2((self2, that) => {
  const scmp = number3(sign(self2), sign(that));
  if (scmp !== 0) {
    return scmp;
  }
  if (self2.scale > that.scale) {
    return bigint2(self2.value, scale(that, self2.scale).value);
  }
  if (self2.scale < that.scale) {
    return bigint2(scale(self2, that.scale).value, that.value);
  }
  return bigint2(self2.value, that.value);
});
var lessThan8 = /* @__PURE__ */ lessThan(Order6);
var lessThanOrEqualTo3 = /* @__PURE__ */ lessThanOrEqualTo(Order6);
var greaterThan4 = /* @__PURE__ */ greaterThan(Order6);
var greaterThanOrEqualTo3 = /* @__PURE__ */ greaterThanOrEqualTo(Order6);
var between3 = /* @__PURE__ */ between(Order6);
var clamp5 = /* @__PURE__ */ clamp(Order6);
var sign = /* @__PURE__ */ __name((n) => n.value === bigint04 ? 0 : n.value < bigint04 ? -1 : 1, "sign");
var abs = /* @__PURE__ */ __name((n) => n.value < bigint04 ? make48(-n.value, n.scale) : n, "abs");
var Equivalence5 = /* @__PURE__ */ make((self2, that) => {
  if (self2.scale > that.scale) {
    return scale(that, self2.scale).value === self2.value;
  }
  if (self2.scale < that.scale) {
    return scale(self2, that.scale).value === that.value;
  }
  return self2.value === that.value;
});
var equals4 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence5(self2, that));
var unsafeFromNumber = /* @__PURE__ */ __name((n) => getOrThrowWith2(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`)), "unsafeFromNumber");
var safeFromNumber = /* @__PURE__ */ __name((n) => {
  if (!Number.isFinite(n)) {
    return none2();
  }
  const string7 = `${n}`;
  if (string7.includes("e")) {
    return fromString(string7);
  }
  const [lead, trail = ""] = string7.split(".");
  return some3(make48(BigInt(`${lead}${trail}`), trail.length));
}, "safeFromNumber");
var fromString = /* @__PURE__ */ __name((s) => {
  if (s === "") {
    return some3(zero2);
  }
  let base;
  let exp;
  const seperator = s.search(/[eE]/);
  if (seperator !== -1) {
    const trail = s.slice(seperator + 1);
    base = s.slice(0, seperator);
    exp = Number(trail);
    if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {
      return none2();
    }
  } else {
    base = s;
    exp = 0;
  }
  let digits;
  let offset;
  const dot = base.search(/\./);
  if (dot !== -1) {
    const lead = base.slice(0, dot);
    const trail = base.slice(dot + 1);
    digits = `${lead}${trail}`;
    offset = trail.length;
  } else {
    digits = base;
    offset = 0;
  }
  if (!FINITE_INT_REGEX.test(digits)) {
    return none2();
  }
  const scale2 = offset - exp;
  if (!Number.isSafeInteger(scale2)) {
    return none2();
  }
  return some3(make48(BigInt(digits), scale2));
}, "fromString");
var format4 = /* @__PURE__ */ __name((n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative2 = normalized.value < bigint04;
  const absolute = negative2 ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before2;
  let after3;
  if (normalized.scale >= absolute.length) {
    before2 = "0";
    after3 = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location2 = absolute.length - normalized.scale;
    if (location2 > absolute.length) {
      const zeros = location2 - absolute.length;
      before2 = `${absolute}${"0".repeat(zeros)}`;
      after3 = "";
    } else {
      after3 = absolute.slice(location2);
      before2 = absolute.slice(0, location2);
    }
  }
  const complete4 = after3 === "" ? before2 : `${before2}.${after3}`;
  return negative2 ? `-${complete4}` : complete4;
}, "format");
var toExponential = /* @__PURE__ */ __name((n) => {
  if (isZero2(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head13 = digits.slice(0, 1);
  const tail3 = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head13}`;
  if (tail3 !== "") {
    output += `.${tail3}`;
  }
  const exp = tail3.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
}, "toExponential");
var unsafeToNumber = /* @__PURE__ */ __name((n) => Number(format4(n)), "unsafeToNumber");
var isZero2 = /* @__PURE__ */ __name((n) => n.value === bigint04, "isZero");
var isNegative = /* @__PURE__ */ __name((n) => n.value < bigint04, "isNegative");
var isPositive = /* @__PURE__ */ __name((n) => n.value > bigint04, "isPositive");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/BigInt.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Order7 = bigint2;
var clamp6 = /* @__PURE__ */ clamp(Order7);
var toNumber = /* @__PURE__ */ __name((b) => {
  if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) {
    return none2();
  }
  return some3(Number(b));
}, "toNumber");
var fromString2 = /* @__PURE__ */ __name((s) => {
  try {
    return s.trim() === "" ? none2() : some3(BigInt(s));
  } catch {
    return none2();
  }
}, "fromString");
var fromNumber = /* @__PURE__ */ __name((n) => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
    return none2();
  }
  try {
    return some3(BigInt(n));
  } catch {
    return none2();
  }
}, "fromNumber");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Config.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/config.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ConfigError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var InvalidData2 = InvalidData;
var isMissingDataOnly2 = isMissingDataOnly;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
var configVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var proto5 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config2(this);
  }
};
var map23 = /* @__PURE__ */ dual(2, (self2, f) => mapOrFail(self2, (a) => right2(f(a))));
var mapOrFail = /* @__PURE__ */ dual(2, (self2, f) => {
  const mapOrFail3 = Object.create(proto5);
  mapOrFail3._tag = OP_MAP_OR_FAIL;
  mapOrFail3.original = self2;
  mapOrFail3.mapOrFail = f;
  return mapOrFail3;
});
var nested2 = /* @__PURE__ */ dual(2, (self2, name) => {
  const nested3 = Object.create(proto5);
  nested3._tag = OP_NESTED;
  nested3.name = name;
  nested3.config = self2;
  return nested3;
});
var orElseIf = /* @__PURE__ */ dual(2, (self2, options4) => {
  const fallback = Object.create(proto5);
  fallback._tag = OP_FALLBACK;
  fallback.first = self2;
  fallback.second = suspend5(options4.orElse);
  fallback.condition = options4.if;
  return fallback;
});
var primitive = /* @__PURE__ */ __name((description, parse5) => {
  const primitive2 = Object.create(proto5);
  primitive2._tag = OP_PRIMITIVE;
  primitive2.description = description;
  primitive2.parse = parse5;
  return primitive2;
}, "primitive");
var string3 = /* @__PURE__ */ __name((name) => {
  const config3 = primitive("a text property", right2);
  return name === void 0 ? config3 : nested2(config3, name);
}, "string");
var succeed12 = /* @__PURE__ */ __name((value6) => {
  const constant3 = Object.create(proto5);
  constant3._tag = OP_CONSTANT;
  constant3.value = value6;
  constant3.parse = () => right2(value6);
  return constant3;
}, "succeed");
var suspend5 = /* @__PURE__ */ __name((config3) => {
  const lazy = Object.create(proto5);
  lazy._tag = OP_LAZY;
  lazy.config = config3;
  return lazy;
}, "suspend");
var withDefault = /* @__PURE__ */ dual(2, (self2, def) => orElseIf(self2, {
  orElse: /* @__PURE__ */ __name(() => succeed12(def), "orElse"),
  if: isMissingDataOnly2
}));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Config.js
var map24 = map23;
var mapOrFail2 = mapOrFail;
var string4 = string3;
var withDefault2 = withDefault;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/DateTime.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Layer.js
var Layer_exports = {};
__export(Layer_exports, {
  CurrentMemoMap: () => CurrentMemoMap2,
  LayerTypeId: () => LayerTypeId2,
  MemoMapTypeId: () => MemoMapTypeId2,
  annotateLogs: () => annotateLogs4,
  annotateSpans: () => annotateSpans4,
  build: () => build2,
  buildWithMemoMap: () => buildWithMemoMap2,
  buildWithScope: () => buildWithScope2,
  catchAll: () => catchAll4,
  catchAllCause: () => catchAllCause4,
  context: () => context5,
  die: () => die8,
  dieSync: () => dieSync5,
  discard: () => discard2,
  effect: () => effect,
  effectContext: () => effectContext,
  effectDiscard: () => effectDiscard,
  empty: () => empty33,
  extendScope: () => extendScope2,
  fail: () => fail12,
  failCause: () => failCause10,
  failCauseSync: () => failCauseSync5,
  failSync: () => failSync5,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  flatMap: () => flatMap16,
  flatten: () => flatten11,
  fresh: () => fresh2,
  function: () => fromFunction3,
  isFresh: () => isFresh2,
  isLayer: () => isLayer2,
  launch: () => launch2,
  locally: () => locally3,
  locallyEffect: () => locallyEffect2,
  locallyScoped: () => locallyScoped2,
  locallyWith: () => locallyWith2,
  makeMemoMap: () => makeMemoMap2,
  map: () => map25,
  mapError: () => mapError5,
  match: () => match16,
  matchCause: () => matchCause5,
  memoize: () => memoize3,
  merge: () => merge8,
  mergeAll: () => mergeAll6,
  mock: () => mock2,
  orDie: () => orDie4,
  orElse: () => orElse9,
  parentSpan: () => parentSpan2,
  passthrough: () => passthrough3,
  project: () => project2,
  provide: () => provide3,
  provideMerge: () => provideMerge2,
  retry: () => retry3,
  scope: () => scope4,
  scoped: () => scoped4,
  scopedContext: () => scopedContext2,
  scopedDiscard: () => scopedDiscard2,
  service: () => service2,
  setClock: () => setClock,
  setConfigProvider: () => setConfigProvider2,
  setRandom: () => setRandom,
  setRequestBatching: () => setRequestBatching,
  setRequestCache: () => setRequestCache,
  setRequestCaching: () => setRequestCaching,
  setScheduler: () => setScheduler,
  setTracer: () => setTracer2,
  setTracerEnabled: () => setTracerEnabled,
  setTracerTiming: () => setTracerTiming,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  setVersionMismatchErrorLogLevel: () => setVersionMismatchErrorLogLevel,
  span: () => span3,
  succeed: () => succeed13,
  succeedContext: () => succeedContext2,
  suspend: () => suspend6,
  sync: () => sync9,
  syncContext: () => syncContext2,
  tap: () => tap5,
  tapError: () => tapError4,
  tapErrorCause: () => tapErrorCause4,
  toRuntime: () => toRuntime2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  unwrapEffect: () => unwrapEffect2,
  unwrapScoped: () => unwrapScoped2,
  updateService: () => updateService3,
  withParentSpan: () => withParentSpan4,
  withSpan: () => withSpan4,
  zipWith: () => zipWith12
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/layer/circular.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var minimumLogLevel = /* @__PURE__ */ __name((level) => scopedDiscard(fiberRefLocallyScoped(currentMinimumLogLevel, level)), "minimumLogLevel");
var withMinimumLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(currentMinimumLogLevel, level)(self2));
var addLogger = /* @__PURE__ */ __name((logger3) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, add2(logger3))), "addLogger");
var addLoggerEffect = /* @__PURE__ */ __name((effect4) => unwrapEffect(map12(effect4, addLogger)), "addLoggerEffect");
var addLoggerScoped = /* @__PURE__ */ __name((effect4) => unwrapScoped(map12(effect4, addLogger)), "addLoggerScoped");
var removeLogger = /* @__PURE__ */ __name((logger3) => scopedDiscard(fiberRefLocallyScopedWith(currentLoggers, remove5(logger3))), "removeLogger");
var replaceLogger = /* @__PURE__ */ dual(2, (self2, that) => flatMap14(removeLogger(self2), () => addLogger(that)));
var replaceLoggerEffect = /* @__PURE__ */ dual(2, (self2, that) => flatMap14(removeLogger(self2), () => addLoggerEffect(that)));
var replaceLoggerScoped = /* @__PURE__ */ dual(2, (self2, that) => flatMap14(removeLogger(self2), () => addLoggerScoped(that)));
var setConfigProvider = /* @__PURE__ */ __name((configProvider) => scopedDiscard(withConfigProviderScoped(configProvider)), "setConfigProvider");
var parentSpan = /* @__PURE__ */ __name((span4) => succeedContext(make11(spanTag, span4)), "parentSpan");
var span2 = /* @__PURE__ */ __name((name, options4) => {
  options4 = addSpanStackTrace(options4);
  return scoped2(spanTag, options4?.onEnd ? tap2(makeSpanScoped(name, options4), (span4) => addFinalizer((exit5) => options4.onEnd(span4, exit5))) : makeSpanScoped(name, options4));
}, "span");
var setTracer = /* @__PURE__ */ __name((tracer4) => scopedDiscard(withTracerScoped(tracer4)), "setTracer");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Layer.js
var LayerTypeId2 = LayerTypeId;
var MemoMapTypeId2 = MemoMapTypeId;
var CurrentMemoMap2 = CurrentMemoMap;
var isLayer2 = isLayer;
var isFresh2 = isFresh;
var annotateLogs4 = annotateLogs2;
var annotateSpans4 = annotateSpans2;
var build2 = build;
var buildWithScope2 = buildWithScope;
var catchAll4 = catchAll2;
var catchAllCause4 = catchAllCause2;
var context5 = context3;
var die8 = die5;
var dieSync5 = dieSync2;
var discard2 = discard;
var effect = fromEffect4;
var effectDiscard = fromEffectDiscard;
var effectContext = fromEffectContext;
var empty33 = empty31;
var extendScope2 = extendScope;
var fail12 = fail7;
var failSync5 = failSync2;
var failCause10 = failCause6;
var failCauseSync5 = failCauseSync2;
var flatMap16 = flatMap14;
var flatten11 = flatten9;
var fresh2 = fresh;
var mock2 = mock;
var fromFunction3 = fromFunction;
var launch2 = launch;
var map25 = map20;
var mapError5 = mapError3;
var match16 = match13;
var matchCause5 = matchCause3;
var memoize3 = memoize2;
var merge8 = merge6;
var mergeAll6 = mergeAll4;
var orDie4 = orDie2;
var orElse9 = orElse6;
var passthrough3 = passthrough;
var project2 = project;
var locallyEffect2 = locallyEffect;
var locally3 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
var retry3 = retry;
var scope4 = scope2;
var scoped4 = scoped2;
var scopedDiscard2 = scopedDiscard;
var scopedContext2 = scopedContext;
var service2 = service;
var succeed13 = succeed7;
var succeedContext2 = succeedContext;
var suspend6 = suspend3;
var sync9 = sync4;
var syncContext2 = syncContext;
var tap5 = tap3;
var tapError4 = tapError2;
var tapErrorCause4 = tapErrorCause2;
var toRuntime2 = toRuntime;
var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
var provide3 = provide;
var provideMerge2 = provideMerge;
var zipWith12 = zipWith8;
var unwrapEffect2 = unwrapEffect;
var unwrapScoped2 = unwrapScoped;
var setClock = /* @__PURE__ */ __name((clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add4(clockTag, clock3))), "setClock");
var setConfigProvider2 = setConfigProvider;
var parentSpan2 = parentSpan;
var setRandom = /* @__PURE__ */ __name((random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add4(randomTag, random4))), "setRandom");
var setRequestBatching = /* @__PURE__ */ __name((requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching)), "setRequestBatching");
var setRequestCaching = /* @__PURE__ */ __name((requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching)), "setRequestCaching");
var setRequestCache = /* @__PURE__ */ __name((cache) => scopedDiscard2(isEffect(cache) ? flatMap10(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache)), "setRequestCache");
var setScheduler = /* @__PURE__ */ __name((scheduler2) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler2)), "setScheduler");
var span3 = span2;
var setTracer2 = setTracer;
var setTracerEnabled = /* @__PURE__ */ __name((enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2)), "setTracerEnabled");
var setTracerTiming = /* @__PURE__ */ __name((enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2)), "setTracerTiming");
var setUnhandledErrorLogLevel = /* @__PURE__ */ __name((level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level)), "setUnhandledErrorLogLevel");
var setVersionMismatchErrorLogLevel = /* @__PURE__ */ __name((level) => scopedDiscard2(fiberRefLocallyScoped(currentVersionMismatchErrorLogLevel, level)), "setVersionMismatchErrorLogLevel");
var withSpan4 = withSpan2;
var withParentSpan4 = withParentSpan2;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;
var updateService3 = /* @__PURE__ */ dual(3, (layer14, tag8, f) => provide3(layer14, map25(context5(), (c) => add4(c, tag8, f(unsafeGet5(c, tag8))))));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/DateTime.js
var isDateTime2 = isDateTime;
var isTimeZoneOffset2 = isTimeZoneOffset;
var isTimeZoneNamed2 = isTimeZoneNamed;
var isUtc2 = isUtc;
var isZoned2 = isZoned;
var Equivalence6 = Equivalence2;
var unsafeFromDate2 = unsafeFromDate;
var unsafeMake12 = unsafeMake9;
var unsafeMakeZoned2 = unsafeMakeZoned;
var makeZonedFromString2 = makeZonedFromString;
var zoneUnsafeMakeNamed2 = zoneUnsafeMakeNamed;
var zoneMakeOffset2 = zoneMakeOffset;
var zoneFromString2 = zoneFromString;
var zoneToString2 = zoneToString;
var toDateUtc2 = toDateUtc;
var toEpochMillis2 = toEpochMillis;
var formatIso3 = formatIso2;
var formatIsoZoned2 = formatIsoZoned;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Encoding.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/encoding/base64.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/encoding/common.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DecodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Decode");
var DecodeException = /* @__PURE__ */ __name((input, message) => {
  const out = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
}, "DecodeException");
var EncodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Encode");
var EncodeException = /* @__PURE__ */ __name((input, message) => {
  const out = {
    _tag: "EncodeException",
    [EncodeExceptionTypeId]: EncodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
}, "EncodeException");
var encoder = /* @__PURE__ */ new TextEncoder();
var decoder = /* @__PURE__ */ new TextDecoder();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/encoding/base64.js
var encode = /* @__PURE__ */ __name((bytes) => {
  const length5 = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < length5; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 63];
  }
  if (i === length5 + 1) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length5) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}, "encode");
var decode2 = /* @__PURE__ */ __name((str) => {
  const stripped = stripCrlf(str);
  const length5 = stripped.length;
  if (length5 % 4 !== 0) {
    return left2(DecodeException(stripped, `Length must be a multiple of 4, but is ${length5}`));
  }
  const index2 = stripped.indexOf("=");
  if (index2 !== -1 && (index2 < length5 - 2 || index2 === length5 - 2 && stripped[length5 - 1] !== "=")) {
    return left2(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
  }
  try {
    const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
    const result = new Uint8Array(3 * (length5 / 4) - missingOctets);
    for (let i = 0, j = 0; i < length5; i += 4, j += 3) {
      const buffer4 = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
      result[j] = buffer4 >> 16;
      result[j + 1] = buffer4 >> 8 & 255;
      result[j + 2] = buffer4 & 255;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
  }
}, "decode");
var stripCrlf = /* @__PURE__ */ __name((str) => str.replace(/[\n\r]/g, ""), "stripCrlf");
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code;
}
__name(getBase64Code, "getBase64Code");
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/encoding/base64Url.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var encode2 = /* @__PURE__ */ __name((data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_"), "encode");
var decode3 = /* @__PURE__ */ __name((str) => {
  const stripped = stripCrlf(str);
  const length5 = stripped.length;
  if (length5 % 4 === 1) {
    return left2(DecodeException(stripped, `Length should be a multiple of 4, but is ${length5}`));
  }
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {
    return left2(DecodeException(stripped, "Invalid input"));
  }
  let sanitized = length5 % 4 === 2 ? `${stripped}==` : length5 % 4 === 3 ? `${stripped}=` : stripped;
  sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
  return decode2(sanitized);
}, "decode");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/encoding/hex.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var encode3 = /* @__PURE__ */ __name((bytes) => {
  let result = "";
  for (let i = 0; i < bytes.length; ++i) {
    result += bytesToHex[bytes[i]];
  }
  return result;
}, "encode");
var decode4 = /* @__PURE__ */ __name((str) => {
  const bytes = new TextEncoder().encode(str);
  if (bytes.length % 2 !== 0) {
    return left2(DecodeException(str, `Length must be a multiple of 2, but is ${bytes.length}`));
  }
  try {
    const length5 = bytes.length / 2;
    const result = new Uint8Array(length5);
    for (let i = 0; i < length5; i++) {
      const a = fromHexChar(bytes[i * 2]);
      const b = fromHexChar(bytes[i * 2 + 1]);
      result[i] = a << 4 | b;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
  }
}, "decode");
var bytesToHex = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var fromHexChar = /* @__PURE__ */ __name((byte) => {
  if (48 <= byte && byte <= 57) {
    return byte - 48;
  }
  if (97 <= byte && byte <= 102) {
    return byte - 97 + 10;
  }
  if (65 <= byte && byte <= 70) {
    return byte - 65 + 10;
  }
  throw new TypeError("Invalid input");
}, "fromHexChar");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Encoding.js
var encodeBase64 = /* @__PURE__ */ __name((input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input), "encodeBase64");
var decodeBase64 = /* @__PURE__ */ __name((str) => decode2(str), "decodeBase64");
var decodeBase64String = /* @__PURE__ */ __name((str) => map(decodeBase64(str), (_) => decoder.decode(_)), "decodeBase64String");
var encodeBase64Url = /* @__PURE__ */ __name((input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input), "encodeBase64Url");
var decodeBase64Url = /* @__PURE__ */ __name((str) => decode3(str), "decodeBase64Url");
var decodeBase64UrlString = /* @__PURE__ */ __name((str) => map(decodeBase64Url(str), (_) => decoder.decode(_)), "decodeBase64UrlString");
var encodeHex = /* @__PURE__ */ __name((input) => typeof input === "string" ? encode3(encoder.encode(input)) : encode3(input), "encodeHex");
var decodeHex = /* @__PURE__ */ __name((str) => decode4(str), "decodeHex");
var decodeHexString = /* @__PURE__ */ __name((str) => map(decodeHex(str), (_) => decoder.decode(_)), "decodeHexString");
var encodeUriComponent = /* @__PURE__ */ __name((str) => try_({
  try: /* @__PURE__ */ __name(() => encodeURIComponent(str), "try"),
  catch: /* @__PURE__ */ __name((e) => EncodeException2(str, e instanceof Error ? e.message : "Invalid input"), "catch")
}), "encodeUriComponent");
var decodeUriComponent = /* @__PURE__ */ __name((str) => try_({
  try: /* @__PURE__ */ __name(() => decodeURIComponent(str), "try"),
  catch: /* @__PURE__ */ __name((e) => DecodeException2(str, e instanceof Error ? e.message : "Invalid input"), "catch")
}), "decodeUriComponent");
var DecodeException2 = DecodeException;
var EncodeException2 = EncodeException;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/fast-check-default.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/precondition/Pre.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/precondition/PreconditionFailure.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PreconditionFailure = class _PreconditionFailure extends Error {
  static {
    __name(this, "PreconditionFailure");
  }
  constructor(interruptExecution = false) {
    super();
    this.interruptExecution = interruptExecution;
    this.footprint = _PreconditionFailure.SharedFootPrint;
  }
  static isFailure(err) {
    return err != null && err.footprint === _PreconditionFailure.SharedFootPrint;
  }
};
PreconditionFailure.SharedFootPrint = Symbol.for("fast-check/PreconditionFailure");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/AsyncProperty.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/Stream.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/StreamHelpers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Nil = class {
  static {
    __name(this, "Nil");
  }
  [Symbol.iterator]() {
    return this;
  }
  next(value6) {
    return { value: value6, done: true };
  }
};
Nil.nil = new Nil();
function nilHelper() {
  return Nil.nil;
}
__name(nilHelper, "nilHelper");
function* mapHelper(g, f) {
  for (const v of g) {
    yield f(v);
  }
}
__name(mapHelper, "mapHelper");
function* flatMapHelper(g, f) {
  for (const v of g) {
    yield* f(v);
  }
}
__name(flatMapHelper, "flatMapHelper");
function* filterHelper(g, f) {
  for (const v of g) {
    if (f(v)) {
      yield v;
    }
  }
}
__name(filterHelper, "filterHelper");
function* takeNHelper(g, n) {
  for (let i = 0; i < n; ++i) {
    const cur = g.next();
    if (cur.done) {
      break;
    }
    yield cur.value;
  }
}
__name(takeNHelper, "takeNHelper");
function* takeWhileHelper(g, f) {
  let cur = g.next();
  while (!cur.done && f(cur.value)) {
    yield cur.value;
    cur = g.next();
  }
}
__name(takeWhileHelper, "takeWhileHelper");
function* joinHelper(g, others) {
  for (let cur = g.next(); !cur.done; cur = g.next()) {
    yield cur.value;
  }
  for (const s of others) {
    for (let cur = s.next(); !cur.done; cur = s.next()) {
      yield cur.value;
    }
  }
}
__name(joinHelper, "joinHelper");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/Stream.js
var safeSymbolIterator = Symbol.iterator;
var Stream = class _Stream {
  static {
    __name(this, "Stream");
  }
  static nil() {
    return new _Stream(nilHelper());
  }
  static of(...elements) {
    return new _Stream(elements[safeSymbolIterator]());
  }
  constructor(g) {
    this.g = g;
  }
  next() {
    return this.g.next();
  }
  [Symbol.iterator]() {
    return this.g;
  }
  map(f) {
    return new _Stream(mapHelper(this.g, f));
  }
  flatMap(f) {
    return new _Stream(flatMapHelper(this.g, f));
  }
  dropWhile(f) {
    let foundEligible = false;
    function* helper(v) {
      if (foundEligible || !f(v)) {
        foundEligible = true;
        yield v;
      }
    }
    __name(helper, "helper");
    return this.flatMap(helper);
  }
  drop(n) {
    if (n <= 0) {
      return this;
    }
    let idx = 0;
    function helper() {
      return idx++ < n;
    }
    __name(helper, "helper");
    return this.dropWhile(helper);
  }
  takeWhile(f) {
    return new _Stream(takeWhileHelper(this.g, f));
  }
  take(n) {
    return new _Stream(takeNHelper(this.g, n));
  }
  filter(f) {
    return new _Stream(filterHelper(this.g, f));
  }
  every(f) {
    for (const v of this.g) {
      if (!f(v)) {
        return false;
      }
    }
    return true;
  }
  has(f) {
    for (const v of this.g) {
      if (f(v)) {
        return [true, v];
      }
    }
    return [false, null];
  }
  join(...others) {
    return new _Stream(joinHelper(this.g, others));
  }
  getNthOrLast(nth) {
    let remaining = nth;
    let last5 = null;
    for (const v of this.g) {
      if (remaining-- === 0)
        return v;
      last5 = v;
    }
    return last5;
  }
};
function stream(g) {
  return new Stream(g);
}
__name(stream, "stream");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/symbols.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var cloneMethod = Symbol.for("fast-check/cloneMethod");
function hasCloneMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && cloneMethod in instance && typeof instance[cloneMethod] === "function";
}
__name(hasCloneMethod, "hasCloneMethod");
function cloneIfNeeded(instance) {
  return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;
}
__name(cloneIfNeeded, "cloneIfNeeded");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeObjectDefineProperty = Object.defineProperty;
var Value = class {
  static {
    __name(this, "Value");
  }
  constructor(value_, context17, customGetValue = void 0) {
    this.value_ = value_;
    this.context = context17;
    this.hasToBeCloned = customGetValue !== void 0 || hasCloneMethod(value_);
    this.readOnce = false;
    if (this.hasToBeCloned) {
      safeObjectDefineProperty(this, "value", { get: customGetValue !== void 0 ? customGetValue : this.getValue });
    } else {
      this.value = value_;
    }
  }
  getValue() {
    if (this.hasToBeCloned) {
      if (!this.readOnce) {
        this.readOnce = true;
        return this.value_;
      }
      return this.value_[cloneMethod]();
    }
    return this.value_;
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
var safeObjectAssign = Object.assign;
var Arbitrary = class {
  static {
    __name(this, "Arbitrary");
  }
  filter(refinement) {
    return new FilterArbitrary(this, refinement);
  }
  map(mapper, unmapper) {
    return new MapArbitrary(this, mapper, unmapper);
  }
  chain(chainer) {
    return new ChainArbitrary(this, chainer);
  }
  noShrink() {
    return new NoShrinkArbitrary(this);
  }
  noBias() {
    return new NoBiasArbitrary(this);
  }
};
var ChainArbitrary = class extends Arbitrary {
  static {
    __name(this, "ChainArbitrary");
  }
  constructor(arb, chainer) {
    super();
    this.arb = arb;
    this.chainer = chainer;
  }
  generate(mrng, biasFactor) {
    const clonedMrng = mrng.clone();
    const src3 = this.arb.generate(mrng, biasFactor);
    return this.valueChainer(src3, mrng, clonedMrng, biasFactor);
  }
  canShrinkWithoutContext(value6) {
    return false;
  }
  shrink(value6, context17) {
    if (this.isSafeContext(context17)) {
      return (!context17.stoppedForOriginal ? this.arb.shrink(context17.originalValue, context17.originalContext).map((v) => this.valueChainer(v, context17.clonedMrng.clone(), context17.clonedMrng, context17.originalBias)) : Stream.nil()).join(context17.chainedArbitrary.shrink(value6, context17.chainedContext).map((dst) => {
        const newContext = safeObjectAssign(safeObjectAssign({}, context17), {
          chainedContext: dst.context,
          stoppedForOriginal: true
        });
        return new Value(dst.value_, newContext);
      }));
    }
    return Stream.nil();
  }
  valueChainer(v, generateMrng, clonedMrng, biasFactor) {
    const chainedArbitrary = this.chainer(v.value_);
    const dst = chainedArbitrary.generate(generateMrng, biasFactor);
    const context17 = {
      originalBias: biasFactor,
      originalValue: v.value_,
      originalContext: v.context,
      stoppedForOriginal: false,
      chainedArbitrary,
      chainedContext: dst.context,
      clonedMrng
    };
    return new Value(dst.value_, context17);
  }
  isSafeContext(context17) {
    return context17 != null && typeof context17 === "object" && "originalBias" in context17 && "originalValue" in context17 && "originalContext" in context17 && "stoppedForOriginal" in context17 && "chainedArbitrary" in context17 && "chainedContext" in context17 && "clonedMrng" in context17;
  }
};
var MapArbitrary = class extends Arbitrary {
  static {
    __name(this, "MapArbitrary");
  }
  constructor(arb, mapper, unmapper) {
    super();
    this.arb = arb;
    this.mapper = mapper;
    this.unmapper = unmapper;
    this.bindValueMapper = (v) => this.valueMapper(v);
  }
  generate(mrng, biasFactor) {
    const g = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(g);
  }
  canShrinkWithoutContext(value6) {
    if (this.unmapper !== void 0) {
      try {
        const unmapped = this.unmapper(value6);
        return this.arb.canShrinkWithoutContext(unmapped);
      } catch (_err) {
        return false;
      }
    }
    return false;
  }
  shrink(value6, context17) {
    if (this.isSafeContext(context17)) {
      return this.arb.shrink(context17.originalValue, context17.originalContext).map(this.bindValueMapper);
    }
    if (this.unmapper !== void 0) {
      const unmapped = this.unmapper(value6);
      return this.arb.shrink(unmapped, void 0).map(this.bindValueMapper);
    }
    return Stream.nil();
  }
  mapperWithCloneIfNeeded(v) {
    const sourceValue = v.value;
    const mappedValue = this.mapper(sourceValue);
    if (v.hasToBeCloned && (typeof mappedValue === "object" && mappedValue !== null || typeof mappedValue === "function") && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) {
      Object.defineProperty(mappedValue, cloneMethod, { get: /* @__PURE__ */ __name(() => () => this.mapperWithCloneIfNeeded(v)[0], "get") });
    }
    return [mappedValue, sourceValue];
  }
  valueMapper(v) {
    const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
    const context17 = { originalValue: sourceValue, originalContext: v.context };
    return new Value(mappedValue, context17);
  }
  isSafeContext(context17) {
    return context17 != null && typeof context17 === "object" && "originalValue" in context17 && "originalContext" in context17;
  }
};
var FilterArbitrary = class extends Arbitrary {
  static {
    __name(this, "FilterArbitrary");
  }
  constructor(arb, refinement) {
    super();
    this.arb = arb;
    this.refinement = refinement;
    this.bindRefinementOnValue = (v) => this.refinementOnValue(v);
  }
  generate(mrng, biasFactor) {
    while (true) {
      const g = this.arb.generate(mrng, biasFactor);
      if (this.refinementOnValue(g)) {
        return g;
      }
    }
  }
  canShrinkWithoutContext(value6) {
    return this.arb.canShrinkWithoutContext(value6) && this.refinement(value6);
  }
  shrink(value6, context17) {
    return this.arb.shrink(value6, context17).filter(this.bindRefinementOnValue);
  }
  refinementOnValue(v) {
    return this.refinement(v.value);
  }
};
var NoShrinkArbitrary = class extends Arbitrary {
  static {
    __name(this, "NoShrinkArbitrary");
  }
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    return this.arb.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value6) {
    return this.arb.canShrinkWithoutContext(value6);
  }
  shrink(_value, _context) {
    return Stream.nil();
  }
  noShrink() {
    return this;
  }
};
var NoBiasArbitrary = class extends Arbitrary {
  static {
    __name(this, "NoBiasArbitrary");
  }
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, _biasFactor) {
    return this.arb.generate(mrng, void 0);
  }
  canShrinkWithoutContext(value6) {
    return this.arb.canShrinkWithoutContext(value6);
  }
  shrink(value6, context17) {
    return this.arb.shrink(value6, context17);
  }
  noBias() {
    return this;
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/tuple.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/TupleArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/globals.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/apply.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var untouchedApply = Function.prototype.apply;
var ApplySymbol = Symbol("apply");
function safeExtractApply(f) {
  try {
    return f.apply;
  } catch (err) {
    return void 0;
  }
}
__name(safeExtractApply, "safeExtractApply");
function safeApplyHacky(f, instance, args2) {
  const ff = f;
  ff[ApplySymbol] = untouchedApply;
  const out = ff[ApplySymbol](instance, args2);
  delete ff[ApplySymbol];
  return out;
}
__name(safeApplyHacky, "safeApplyHacky");
function safeApply(f, instance, args2) {
  if (safeExtractApply(f) === untouchedApply) {
    return f.apply(instance, args2);
  }
  return safeApplyHacky(f, instance, args2);
}
__name(safeApply, "safeApply");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/globals.js
var SArray = typeof Array !== "undefined" ? Array : void 0;
var SError = typeof Error !== "undefined" ? Error : void 0;
var SString = typeof String !== "undefined" ? String : void 0;
var SencodeURIComponent = typeof encodeURIComponent !== "undefined" ? encodeURIComponent : void 0;
var SSymbol = Symbol;
var untouchedForEach = Array.prototype.forEach;
var untouchedIndexOf = Array.prototype.indexOf;
var untouchedJoin = Array.prototype.join;
var untouchedMap = Array.prototype.map;
var untouchedFilter = Array.prototype.filter;
var untouchedPush = Array.prototype.push;
var untouchedPop = Array.prototype.pop;
var untouchedSplice = Array.prototype.splice;
var untouchedSlice = Array.prototype.slice;
var untouchedSort = Array.prototype.sort;
var untouchedEvery = Array.prototype.every;
function extractIndexOf(instance) {
  try {
    return instance.indexOf;
  } catch (err) {
    return void 0;
  }
}
__name(extractIndexOf, "extractIndexOf");
function extractJoin(instance) {
  try {
    return instance.join;
  } catch (err) {
    return void 0;
  }
}
__name(extractJoin, "extractJoin");
function extractMap(instance) {
  try {
    return instance.map;
  } catch (err) {
    return void 0;
  }
}
__name(extractMap, "extractMap");
function extractFilter(instance) {
  try {
    return instance.filter;
  } catch (err) {
    return void 0;
  }
}
__name(extractFilter, "extractFilter");
function extractPush(instance) {
  try {
    return instance.push;
  } catch (err) {
    return void 0;
  }
}
__name(extractPush, "extractPush");
function extractSlice(instance) {
  try {
    return instance.slice;
  } catch (err) {
    return void 0;
  }
}
__name(extractSlice, "extractSlice");
function safeIndexOf(instance, ...args2) {
  if (extractIndexOf(instance) === untouchedIndexOf) {
    return instance.indexOf(...args2);
  }
  return safeApply(untouchedIndexOf, instance, args2);
}
__name(safeIndexOf, "safeIndexOf");
function safeJoin(instance, ...args2) {
  if (extractJoin(instance) === untouchedJoin) {
    return instance.join(...args2);
  }
  return safeApply(untouchedJoin, instance, args2);
}
__name(safeJoin, "safeJoin");
function safeMap(instance, fn2) {
  if (extractMap(instance) === untouchedMap) {
    return instance.map(fn2);
  }
  return safeApply(untouchedMap, instance, [fn2]);
}
__name(safeMap, "safeMap");
function safeFilter(instance, predicate) {
  if (extractFilter(instance) === untouchedFilter) {
    return instance.filter(predicate);
  }
  return safeApply(untouchedFilter, instance, [predicate]);
}
__name(safeFilter, "safeFilter");
function safePush(instance, ...args2) {
  if (extractPush(instance) === untouchedPush) {
    return instance.push(...args2);
  }
  return safeApply(untouchedPush, instance, args2);
}
__name(safePush, "safePush");
function safeSlice(instance, ...args2) {
  if (extractSlice(instance) === untouchedSlice) {
    return instance.slice(...args2);
  }
  return safeApply(untouchedSlice, instance, args2);
}
__name(safeSlice, "safeSlice");
var untouchedGetTime = Date.prototype.getTime;
var untouchedToISOString = Date.prototype.toISOString;
function extractGetTime(instance) {
  try {
    return instance.getTime;
  } catch (err) {
    return void 0;
  }
}
__name(extractGetTime, "extractGetTime");
function extractToISOString(instance) {
  try {
    return instance.toISOString;
  } catch (err) {
    return void 0;
  }
}
__name(extractToISOString, "extractToISOString");
function safeGetTime(instance) {
  if (extractGetTime(instance) === untouchedGetTime) {
    return instance.getTime();
  }
  return safeApply(untouchedGetTime, instance, []);
}
__name(safeGetTime, "safeGetTime");
function safeToISOString(instance) {
  if (extractToISOString(instance) === untouchedToISOString) {
    return instance.toISOString();
  }
  return safeApply(untouchedToISOString, instance, []);
}
__name(safeToISOString, "safeToISOString");
var untouchedAdd = Set.prototype.add;
var untouchedHas = Set.prototype.has;
var untouchedSet = WeakMap.prototype.set;
var untouchedGet = WeakMap.prototype.get;
var untouchedMapSet = Map.prototype.set;
var untouchedMapGet = Map.prototype.get;
function extractMapSet(instance) {
  try {
    return instance.set;
  } catch (err) {
    return void 0;
  }
}
__name(extractMapSet, "extractMapSet");
function extractMapGet(instance) {
  try {
    return instance.get;
  } catch (err) {
    return void 0;
  }
}
__name(extractMapGet, "extractMapGet");
function safeMapSet(instance, key, value6) {
  if (extractMapSet(instance) === untouchedMapSet) {
    return instance.set(key, value6);
  }
  return safeApply(untouchedMapSet, instance, [key, value6]);
}
__name(safeMapSet, "safeMapSet");
function safeMapGet(instance, key) {
  if (extractMapGet(instance) === untouchedMapGet) {
    return instance.get(key);
  }
  return safeApply(untouchedMapGet, instance, [key]);
}
__name(safeMapGet, "safeMapGet");
var untouchedSplit = String.prototype.split;
var untouchedStartsWith = String.prototype.startsWith;
var untouchedEndsWith = String.prototype.endsWith;
var untouchedSubstring = String.prototype.substring;
var untouchedToLowerCase = String.prototype.toLowerCase;
var untouchedToUpperCase = String.prototype.toUpperCase;
var untouchedPadStart = String.prototype.padStart;
var untouchedCharCodeAt = String.prototype.charCodeAt;
var untouchedNormalize = String.prototype.normalize;
var untouchedReplace = String.prototype.replace;
function extractSplit(instance) {
  try {
    return instance.split;
  } catch (err) {
    return void 0;
  }
}
__name(extractSplit, "extractSplit");
function extractCharCodeAt(instance) {
  try {
    return instance.charCodeAt;
  } catch (err) {
    return void 0;
  }
}
__name(extractCharCodeAt, "extractCharCodeAt");
function safeSplit(instance, ...args2) {
  if (extractSplit(instance) === untouchedSplit) {
    return instance.split(...args2);
  }
  return safeApply(untouchedSplit, instance, args2);
}
__name(safeSplit, "safeSplit");
function safeCharCodeAt(instance, index2) {
  if (extractCharCodeAt(instance) === untouchedCharCodeAt) {
    return instance.charCodeAt(index2);
  }
  return safeApply(untouchedCharCodeAt, instance, [index2]);
}
__name(safeCharCodeAt, "safeCharCodeAt");
var untouchedNumberToString = Number.prototype.toString;
function extractNumberToString(instance) {
  try {
    return instance.toString;
  } catch (err) {
    return void 0;
  }
}
__name(extractNumberToString, "extractNumberToString");
function safeNumberToString(instance, ...args2) {
  if (extractNumberToString(instance) === untouchedNumberToString) {
    return instance.toString(...args2);
  }
  return safeApply(untouchedNumberToString, instance, args2);
}
__name(safeNumberToString, "safeNumberToString");
var untouchedToString = Object.prototype.toString;
function safeToString2(instance) {
  return safeApply(untouchedToString, instance, []);
}
__name(safeToString2, "safeToString");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var LazyIterableIterator = class {
  static {
    __name(this, "LazyIterableIterator");
  }
  constructor(producer) {
    this.producer = producer;
  }
  [Symbol.iterator]() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it;
  }
  next() {
    if (this.it === void 0) {
      this.it = this.producer();
    }
    return this.it.next();
  }
};
function makeLazy(producer) {
  return new LazyIterableIterator(producer);
}
__name(makeLazy, "makeLazy");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/IRawProperty.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeMathLog = Math.log;
function runIdToFrequency(runId) {
  return 2 + ~~(safeMathLog(runId + 1) * 0.4342944819032518);
}
__name(runIdToFrequency, "runIdToFrequency");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var globalParameters = {};
function readConfigureGlobal() {
  return globalParameters;
}
__name(readConfigureGlobal, "readConfigureGlobal");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/NoUndefinedAsContext.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UndefinedContextPlaceholder = Symbol("UndefinedContextPlaceholder");
function noUndefinedAsContext(value6) {
  if (value6.context !== void 0) {
    return value6;
  }
  if (value6.hasToBeCloned) {
    return new Value(value6.value_, UndefinedContextPlaceholder, () => value6.value);
  }
  return new Value(value6.value_, UndefinedContextPlaceholder);
}
__name(noUndefinedAsContext, "noUndefinedAsContext");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/AsyncProperty.generic.js
var AsyncProperty = class _AsyncProperty {
  static {
    __name(this, "AsyncProperty");
  }
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0 && beforeEach !== void 0) {
      throw SError(`Global "asyncBeforeEach" and "beforeEach" parameters can't be set at the same time when running async properties`);
    }
    if (asyncAfterEach !== void 0 && afterEach !== void 0) {
      throw SError(`Global "asyncAfterEach" and "afterEach" parameters can't be set at the same time when running async properties`);
    }
    this.beforeEachHook = asyncBeforeEach || beforeEach || _AsyncProperty.dummyHook;
    this.afterEachHook = asyncAfterEach || afterEach || _AsyncProperty.dummyHook;
  }
  isAsync() {
    return true;
  }
  generate(mrng, runId) {
    const value6 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value6);
  }
  shrink(value6) {
    if (value6.context === void 0 && !this.arb.canShrinkWithoutContext(value6.value_)) {
      return Stream.nil();
    }
    const safeContext = value6.context !== UndefinedContextPlaceholder ? value6.context : void 0;
    return this.arb.shrink(value6.value_, safeContext).map(noUndefinedAsContext);
  }
  async runBeforeEach() {
    await this.beforeEachHook();
  }
  async runAfterEach() {
    await this.afterEachHook();
  }
  async run(v, dontRunHook) {
    if (!dontRunHook) {
      await this.beforeEachHook();
    }
    try {
      const output = await this.predicate(v);
      return output == null || output === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err) {
      if (PreconditionFailure.isFailure(err))
        return err;
      if (err instanceof SError && err.stack) {
        return { error: err, errorMessage: err.stack };
      }
      return { error: err, errorMessage: SString(err) };
    } finally {
      if (!dontRunHook) {
        await this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
AsyncProperty.dummyHook = () => {
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/AlwaysShrinkableArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/Property.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/Property.generic.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Property = class _Property {
  static {
    __name(this, "Property");
  }
  constructor(arb, predicate) {
    this.arb = arb;
    this.predicate = predicate;
    const { beforeEach = _Property.dummyHook, afterEach = _Property.dummyHook, asyncBeforeEach, asyncAfterEach } = readConfigureGlobal() || {};
    if (asyncBeforeEach !== void 0) {
      throw SError(`"asyncBeforeEach" can't be set when running synchronous properties`);
    }
    if (asyncAfterEach !== void 0) {
      throw SError(`"asyncAfterEach" can't be set when running synchronous properties`);
    }
    this.beforeEachHook = beforeEach;
    this.afterEachHook = afterEach;
  }
  isAsync() {
    return false;
  }
  generate(mrng, runId) {
    const value6 = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : void 0);
    return noUndefinedAsContext(value6);
  }
  shrink(value6) {
    if (value6.context === void 0 && !this.arb.canShrinkWithoutContext(value6.value_)) {
      return Stream.nil();
    }
    const safeContext = value6.context !== UndefinedContextPlaceholder ? value6.context : void 0;
    return this.arb.shrink(value6.value_, safeContext).map(noUndefinedAsContext);
  }
  runBeforeEach() {
    this.beforeEachHook();
  }
  runAfterEach() {
    this.afterEachHook();
  }
  run(v, dontRunHook) {
    if (!dontRunHook) {
      this.beforeEachHook();
    }
    try {
      const output = this.predicate(v);
      return output == null || output === true ? null : {
        error: new SError("Property failed by returning false"),
        errorMessage: "Error: Property failed by returning false"
      };
    } catch (err) {
      if (PreconditionFailure.isFailure(err))
        return err;
      if (err instanceof SError && err.stack) {
        return { error: err, errorMessage: err.stack };
      }
      return { error: err, errorMessage: SString(err) };
    } finally {
      if (!dontRunHook) {
        this.afterEachHook();
      }
    }
  }
  beforeEach(hookFunction) {
    const previousBeforeEachHook = this.beforeEachHook;
    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
    return this;
  }
  afterEach(hookFunction) {
    const previousAfterEachHook = this.afterEachHook;
    this.afterEachHook = () => hookFunction(previousAfterEachHook);
    return this;
  }
};
Property.dummyHook = () => {
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/Runner.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand-default.js
var pure_rand_default_exports = {};
__export(pure_rand_default_exports, {
  __commitHash: () => __commitHash,
  __type: () => __type,
  __version: () => __version,
  congruential32: () => congruential32,
  generateN: () => generateN,
  mersenne: () => MersenneTwister_default,
  skipN: () => skipN,
  uniformArrayIntDistribution: () => uniformArrayIntDistribution,
  uniformBigIntDistribution: () => uniformBigIntDistribution,
  uniformIntDistribution: () => uniformIntDistribution,
  unsafeGenerateN: () => unsafeGenerateN,
  unsafeSkipN: () => unsafeSkipN,
  unsafeUniformArrayIntDistribution: () => unsafeUniformArrayIntDistribution,
  unsafeUniformBigIntDistribution: () => unsafeUniformBigIntDistribution,
  unsafeUniformIntDistribution: () => unsafeUniformIntDistribution,
  xoroshiro128plus: () => xoroshiro128plus,
  xorshift128plus: () => xorshift128plus
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/RandomGenerator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function unsafeGenerateN(rng, num) {
  var out = [];
  for (var idx = 0; idx != num; ++idx) {
    out.push(rng.unsafeNext());
  }
  return out;
}
__name(unsafeGenerateN, "unsafeGenerateN");
function generateN(rng, num) {
  var nextRng = rng.clone();
  var out = unsafeGenerateN(nextRng, num);
  return [out, nextRng];
}
__name(generateN, "generateN");
function unsafeSkipN(rng, num) {
  for (var idx = 0; idx != num; ++idx) {
    rng.unsafeNext();
  }
}
__name(unsafeSkipN, "unsafeSkipN");
function skipN(rng, num) {
  var nextRng = rng.clone();
  unsafeSkipN(nextRng, num);
  return nextRng;
}
__name(skipN, "skipN");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/LinearCongruential.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MULTIPLIER = 214013;
var INCREMENT = 2531011;
var MASK2 = 4294967295;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = /* @__PURE__ */ __name(function(seed) {
  return seed * MULTIPLIER + INCREMENT & MASK2;
}, "computeNextSeed");
var computeValueFromNextSeed = /* @__PURE__ */ __name(function(nextseed) {
  return (nextseed & MASK_2) >> 16;
}, "computeValueFromNextSeed");
var LinearCongruential32 = (function() {
  function LinearCongruential322(seed) {
    this.seed = seed;
  }
  __name(LinearCongruential322, "LinearCongruential32");
  LinearCongruential322.prototype.clone = function() {
    return new LinearCongruential322(this.seed);
  };
  LinearCongruential322.prototype.next = function() {
    var nextRng = new LinearCongruential322(this.seed);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  LinearCongruential322.prototype.unsafeNext = function() {
    var s1 = computeNextSeed(this.seed);
    var v1 = computeValueFromNextSeed(s1);
    var s2 = computeNextSeed(s1);
    var v2 = computeValueFromNextSeed(s2);
    this.seed = computeNextSeed(s2);
    var v3 = computeValueFromNextSeed(this.seed);
    var vnext = v3 + (v2 + (v1 << 15) << 15);
    return vnext | 0;
  };
  LinearCongruential322.prototype.getState = function() {
    return [this.seed];
  };
  return LinearCongruential322;
})();
function fromState(state2) {
  var valid = state2.length === 1;
  if (!valid) {
    throw new Error("The state must have been produced by a congruential32 RandomGenerator");
  }
  return new LinearCongruential32(state2[0]);
}
__name(fromState, "fromState");
var congruential32 = Object.assign(function(seed) {
  return new LinearCongruential32(seed);
}, { fromState });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/MersenneTwister.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error5) {
    e = { error: error5 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack4) {
  if (pack4 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var MersenneTwister = (function() {
  function MersenneTwister2(states, index2) {
    this.states = states;
    this.index = index2;
  }
  __name(MersenneTwister2, "MersenneTwister");
  MersenneTwister2.twist = function(prev) {
    var mt = prev.slice();
    for (var idx = 0; idx !== MersenneTwister2.N - MersenneTwister2.M; ++idx) {
      var y_1 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt[idx] = mt[idx + MersenneTwister2.M] ^ y_1 >>> 1 ^ -(y_1 & 1) & MersenneTwister2.A;
    }
    for (var idx = MersenneTwister2.N - MersenneTwister2.M; idx !== MersenneTwister2.N - 1; ++idx) {
      var y_2 = (mt[idx] & MersenneTwister2.MASK_UPPER) + (mt[idx + 1] & MersenneTwister2.MASK_LOWER);
      mt[idx] = mt[idx + MersenneTwister2.M - MersenneTwister2.N] ^ y_2 >>> 1 ^ -(y_2 & 1) & MersenneTwister2.A;
    }
    var y = (mt[MersenneTwister2.N - 1] & MersenneTwister2.MASK_UPPER) + (mt[0] & MersenneTwister2.MASK_LOWER);
    mt[MersenneTwister2.N - 1] = mt[MersenneTwister2.M - 1] ^ y >>> 1 ^ -(y & 1) & MersenneTwister2.A;
    return mt;
  };
  MersenneTwister2.seeded = function(seed) {
    var out = Array(MersenneTwister2.N);
    out[0] = seed;
    for (var idx = 1; idx !== MersenneTwister2.N; ++idx) {
      var xored = out[idx - 1] ^ out[idx - 1] >>> 30;
      out[idx] = Math.imul(MersenneTwister2.F, xored) + idx | 0;
    }
    return out;
  };
  MersenneTwister2.from = function(seed) {
    return new MersenneTwister2(MersenneTwister2.twist(MersenneTwister2.seeded(seed)), 0);
  };
  MersenneTwister2.prototype.clone = function() {
    return new MersenneTwister2(this.states, this.index);
  };
  MersenneTwister2.prototype.next = function() {
    var nextRng = new MersenneTwister2(this.states, this.index);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  MersenneTwister2.prototype.unsafeNext = function() {
    var y = this.states[this.index];
    y ^= this.states[this.index] >>> MersenneTwister2.U;
    y ^= y << MersenneTwister2.S & MersenneTwister2.B;
    y ^= y << MersenneTwister2.T & MersenneTwister2.C;
    y ^= y >>> MersenneTwister2.L;
    if (++this.index >= MersenneTwister2.N) {
      this.states = MersenneTwister2.twist(this.states);
      this.index = 0;
    }
    return y;
  };
  MersenneTwister2.prototype.getState = function() {
    return __spreadArray([this.index], __read(this.states), false);
  };
  MersenneTwister2.fromState = function(state2) {
    var valid = state2.length === MersenneTwister2.N + 1 && state2[0] >= 0 && state2[0] < MersenneTwister2.N;
    if (!valid) {
      throw new Error("The state must have been produced by a mersenne RandomGenerator");
    }
    return new MersenneTwister2(state2.slice(1), state2[0]);
  };
  MersenneTwister2.N = 624;
  MersenneTwister2.M = 397;
  MersenneTwister2.R = 31;
  MersenneTwister2.A = 2567483615;
  MersenneTwister2.F = 1812433253;
  MersenneTwister2.U = 11;
  MersenneTwister2.S = 7;
  MersenneTwister2.B = 2636928640;
  MersenneTwister2.T = 15;
  MersenneTwister2.C = 4022730752;
  MersenneTwister2.L = 18;
  MersenneTwister2.MASK_LOWER = Math.pow(2, MersenneTwister2.R) - 1;
  MersenneTwister2.MASK_UPPER = Math.pow(2, MersenneTwister2.R);
  return MersenneTwister2;
})();
function fromState2(state2) {
  return MersenneTwister.fromState(state2);
}
__name(fromState2, "fromState");
var MersenneTwister_default = Object.assign(function(seed) {
  return MersenneTwister.from(seed);
}, { fromState: fromState2 });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/XorShift.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var XorShift128Plus = (function() {
  function XorShift128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  __name(XorShift128Plus2, "XorShift128Plus");
  XorShift128Plus2.prototype.clone = function() {
    return new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XorShift128Plus2.prototype.next = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XorShift128Plus2.prototype.unsafeNext = function() {
    var a0 = this.s00 ^ this.s00 << 23;
    var a1 = this.s01 ^ (this.s01 << 23 | this.s00 >>> 9);
    var b0 = a0 ^ this.s10 ^ (a0 >>> 18 | a1 << 14) ^ (this.s10 >>> 5 | this.s11 << 27);
    var b1 = a1 ^ this.s11 ^ a1 >>> 18 ^ this.s11 >>> 5;
    var out = this.s00 + this.s10 | 0;
    this.s01 = this.s11;
    this.s00 = this.s10;
    this.s11 = b1;
    this.s10 = b0;
    return out;
  };
  XorShift128Plus2.prototype.jump = function() {
    var nextRng = new XorShift128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XorShift128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [1667051007, 2321340297, 1548169110, 304075285];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XorShift128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XorShift128Plus2;
})();
function fromState3(state2) {
  var valid = state2.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xorshift128plus RandomGenerator");
  }
  return new XorShift128Plus(state2[0], state2[1], state2[2], state2[3]);
}
__name(fromState3, "fromState");
var xorshift128plus = Object.assign(function(seed) {
  return new XorShift128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState3 });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/generator/XoroShiro.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var XoroShiro128Plus = (function() {
  function XoroShiro128Plus2(s01, s00, s11, s10) {
    this.s01 = s01;
    this.s00 = s00;
    this.s11 = s11;
    this.s10 = s10;
  }
  __name(XoroShiro128Plus2, "XoroShiro128Plus");
  XoroShiro128Plus2.prototype.clone = function() {
    return new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
  };
  XoroShiro128Plus2.prototype.next = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    var out = nextRng.unsafeNext();
    return [out, nextRng];
  };
  XoroShiro128Plus2.prototype.unsafeNext = function() {
    var out = this.s00 + this.s10 | 0;
    var a0 = this.s10 ^ this.s00;
    var a1 = this.s11 ^ this.s01;
    var s00 = this.s00;
    var s01 = this.s01;
    this.s00 = s00 << 24 ^ s01 >>> 8 ^ a0 ^ a0 << 16;
    this.s01 = s01 << 24 ^ s00 >>> 8 ^ a1 ^ (a1 << 16 | a0 >>> 16);
    this.s10 = a1 << 5 ^ a0 >>> 27;
    this.s11 = a0 << 5 ^ a1 >>> 27;
    return out;
  };
  XoroShiro128Plus2.prototype.jump = function() {
    var nextRng = new XoroShiro128Plus2(this.s01, this.s00, this.s11, this.s10);
    nextRng.unsafeJump();
    return nextRng;
  };
  XoroShiro128Plus2.prototype.unsafeJump = function() {
    var ns01 = 0;
    var ns00 = 0;
    var ns11 = 0;
    var ns10 = 0;
    var jump = [3639956645, 3750757012, 1261568508, 386426335];
    for (var i = 0; i !== 4; ++i) {
      for (var mask = 1; mask; mask <<= 1) {
        if (jump[i] & mask) {
          ns01 ^= this.s01;
          ns00 ^= this.s00;
          ns11 ^= this.s11;
          ns10 ^= this.s10;
        }
        this.unsafeNext();
      }
    }
    this.s01 = ns01;
    this.s00 = ns00;
    this.s11 = ns11;
    this.s10 = ns10;
  };
  XoroShiro128Plus2.prototype.getState = function() {
    return [this.s01, this.s00, this.s11, this.s10];
  };
  return XoroShiro128Plus2;
})();
function fromState4(state2) {
  var valid = state2.length === 4;
  if (!valid) {
    throw new Error("The state must have been produced by a xoroshiro128plus RandomGenerator");
  }
  return new XoroShiro128Plus(state2[0], state2[1], state2[2], state2[3]);
}
__name(fromState4, "fromState");
var xoroshiro128plus = Object.assign(function(seed) {
  return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
}, { fromState: fromState4 });

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/ArrayInt.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function addArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var data = [];
  var reminder = 0;
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA + vB + reminder;
    data.push(current2 >>> 0);
    reminder = ~~(current2 / 4294967296);
  }
  if (reminder !== 0) {
    data.push(reminder);
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
__name(addArrayIntToNew, "addArrayIntToNew");
function addOneToPositiveArrayInt(arrayInt) {
  arrayInt.sign = 1;
  var data = arrayInt.data;
  for (var index2 = data.length - 1; index2 >= 0; --index2) {
    if (data[index2] === 4294967295) {
      data[index2] = 0;
    } else {
      data[index2] += 1;
      return arrayInt;
    }
  }
  data.unshift(1);
  return arrayInt;
}
__name(addOneToPositiveArrayInt, "addOneToPositiveArrayInt");
function isStrictlySmaller(dataA, dataB) {
  var maxLength2 = Math.max(dataA.length, dataB.length);
  for (var index2 = 0; index2 < maxLength2; ++index2) {
    var indexA = index2 + dataA.length - maxLength2;
    var indexB = index2 + dataB.length - maxLength2;
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    if (vA < vB)
      return true;
    if (vA > vB)
      return false;
  }
  return false;
}
__name(isStrictlySmaller, "isStrictlySmaller");
function substractArrayIntToNew(arrayIntA, arrayIntB) {
  if (arrayIntA.sign !== arrayIntB.sign) {
    return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
  }
  var dataA = arrayIntA.data;
  var dataB = arrayIntB.data;
  if (isStrictlySmaller(dataA, dataB)) {
    var out = substractArrayIntToNew(arrayIntB, arrayIntA);
    out.sign = -out.sign;
    return out;
  }
  var data = [];
  var reminder = 0;
  for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
    var vA = indexA >= 0 ? dataA[indexA] : 0;
    var vB = indexB >= 0 ? dataB[indexB] : 0;
    var current2 = vA - vB - reminder;
    data.push(current2 >>> 0);
    reminder = current2 < 0 ? 1 : 0;
  }
  return { sign: arrayIntA.sign, data: data.reverse() };
}
__name(substractArrayIntToNew, "substractArrayIntToNew");
function trimArrayIntInplace(arrayInt) {
  var data = arrayInt.data;
  var firstNonZero = 0;
  for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) {
  }
  if (firstNonZero === data.length) {
    arrayInt.sign = 1;
    arrayInt.data = [0];
    return arrayInt;
  }
  data.splice(0, firstNonZero);
  return arrayInt;
}
__name(trimArrayIntInplace, "trimArrayIntInplace");
function fromNumberToArrayInt64(out, n) {
  if (n < 0) {
    var posN = -n;
    out.sign = -1;
    out.data[0] = ~~(posN / 4294967296);
    out.data[1] = posN >>> 0;
  } else {
    out.sign = 1;
    out.data[0] = ~~(n / 4294967296);
    out.data[1] = n >>> 0;
  }
  return out;
}
__name(fromNumberToArrayInt64, "fromNumberToArrayInt64");
function substractArrayInt64(out, arrayIntA, arrayIntB) {
  var lowA = arrayIntA.data[1];
  var highA = arrayIntA.data[0];
  var signA = arrayIntA.sign;
  var lowB = arrayIntB.data[1];
  var highB = arrayIntB.data[0];
  var signB = arrayIntB.sign;
  out.sign = 1;
  if (signA === 1 && signB === -1) {
    var low_1 = lowA + lowB;
    var high = highA + highB + (low_1 > 4294967295 ? 1 : 0);
    out.data[0] = high >>> 0;
    out.data[1] = low_1 >>> 0;
    return out;
  }
  var lowFirst = lowA;
  var highFirst = highA;
  var lowSecond = lowB;
  var highSecond = highB;
  if (signA === -1) {
    lowFirst = lowB;
    highFirst = highB;
    lowSecond = lowA;
    highSecond = highA;
  }
  var reminderLow = 0;
  var low = lowFirst - lowSecond;
  if (low < 0) {
    reminderLow = 1;
    low = low >>> 0;
  }
  out.data[0] = highFirst - highSecond - reminderLow;
  out.data[1] = low;
  return out;
}
__name(substractArrayInt64, "substractArrayInt64");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformIntDistributionInternal.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
  var MaxAllowed = rangeSize > 2 ? ~~(4294967296 / rangeSize) * rangeSize : 4294967296;
  var deltaV = rng.unsafeNext() + 2147483648;
  while (deltaV >= MaxAllowed) {
    deltaV = rng.unsafeNext() + 2147483648;
  }
  return deltaV % rangeSize;
}
__name(unsafeUniformIntDistributionInternal, "unsafeUniformIntDistributionInternal");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/internals/UnsafeUniformArrayIntDistributionInternal.js
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
  var rangeLength = rangeSize.length;
  while (true) {
    for (var index2 = 0; index2 !== rangeLength; ++index2) {
      var indexRangeSize = index2 === 0 ? rangeSize[0] + 1 : 4294967296;
      var g = unsafeUniformIntDistributionInternal(indexRangeSize, rng);
      out[index2] = g;
    }
    for (var index2 = 0; index2 !== rangeLength; ++index2) {
      var current2 = out[index2];
      var currentInRange = rangeSize[index2];
      if (current2 < currentInRange) {
        return out;
      } else if (current2 > currentInRange) {
        break;
      }
    }
  }
}
__name(unsafeUniformArrayIntDistributionInternal, "unsafeUniformArrayIntDistributionInternal");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformArrayIntDistribution.js
function unsafeUniformArrayIntDistribution(from, to, rng) {
  var rangeSize = trimArrayIntInplace(addOneToPositiveArrayInt(substractArrayIntToNew(to, from)));
  var emptyArrayIntData = rangeSize.data.slice(0);
  var g = unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);
  return trimArrayIntInplace(addArrayIntToNew({ sign: 1, data: g }, from));
}
__name(unsafeUniformArrayIntDistribution, "unsafeUniformArrayIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformArrayIntDistribution.js
function uniformArrayIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformArrayIntDistribution(from, to, nextRng2), nextRng2];
  };
}
__name(uniformArrayIntDistribution, "uniformArrayIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformBigIntDistribution.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SBigInt = typeof BigInt !== "undefined" ? BigInt : void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
  var diff9 = to - from + SBigInt(1);
  var MinRng = SBigInt(-2147483648);
  var NumValues = SBigInt(4294967296);
  var FinalNumValues = NumValues;
  var NumIterations = 1;
  while (FinalNumValues < diff9) {
    FinalNumValues *= NumValues;
    ++NumIterations;
  }
  var MaxAcceptedRandom = FinalNumValues - FinalNumValues % diff9;
  while (true) {
    var value6 = SBigInt(0);
    for (var num = 0; num !== NumIterations; ++num) {
      var out = rng.unsafeNext();
      value6 = NumValues * value6 + (SBigInt(out) - MinRng);
    }
    if (value6 < MaxAcceptedRandom) {
      var inDiff = value6 % diff9;
      return inDiff + from;
    }
  }
}
__name(unsafeUniformBigIntDistribution, "unsafeUniformBigIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformBigIntDistribution.js
function uniformBigIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformBigIntDistribution(from, to, nextRng2), nextRng2];
  };
}
__name(uniformBigIntDistribution, "uniformBigIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UnsafeUniformIntDistribution.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeNumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
  var rangeSizeArrayIntValue = rangeSize <= safeNumberMaxSafeInteger ? fromNumberToArrayInt64(sharedC, rangeSize) : substractArrayInt64(sharedC, fromNumberToArrayInt64(sharedA, to), fromNumberToArrayInt64(sharedB, from));
  if (rangeSizeArrayIntValue.data[1] === 4294967295) {
    rangeSizeArrayIntValue.data[0] += 1;
    rangeSizeArrayIntValue.data[1] = 0;
  } else {
    rangeSizeArrayIntValue.data[1] += 1;
  }
  unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
  return sharedData[0] * 4294967296 + sharedData[1] + from;
}
__name(uniformLargeIntInternal, "uniformLargeIntInternal");
function unsafeUniformIntDistribution(from, to, rng) {
  var rangeSize = to - from;
  if (rangeSize <= 4294967295) {
    var g = unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
    return g + from;
  }
  return uniformLargeIntInternal(from, to, rangeSize, rng);
}
__name(unsafeUniformIntDistribution, "unsafeUniformIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/distribution/UniformIntDistribution.js
function uniformIntDistribution(from, to, rng) {
  if (rng != null) {
    var nextRng = rng.clone();
    return [unsafeUniformIntDistribution(from, to, nextRng), nextRng];
  }
  return function(rng2) {
    var nextRng2 = rng2.clone();
    return [unsafeUniformIntDistribution(from, to, nextRng2), nextRng2];
  };
}
__name(uniformIntDistribution, "uniformIntDistribution");

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand-default.js
var __type = "module";
var __version = "6.1.0";
var __commitHash = "a413dd2b721516be2ef29adffb515c5ae67bfbad";

// node_modules/.pnpm/pure-rand@6.1.0/node_modules/pure-rand/lib/esm/pure-rand.js
var pure_rand_default = pure_rand_default_exports;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/VerbosityLevel.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var VerbosityLevel;
(function(VerbosityLevel2) {
  VerbosityLevel2[VerbosityLevel2["None"] = 0] = "None";
  VerbosityLevel2[VerbosityLevel2["Verbose"] = 1] = "Verbose";
  VerbosityLevel2[VerbosityLevel2["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel || (VerbosityLevel = {}));

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/configuration/QualifiedParameters.js
var safeDateNow = Date.now;
var safeMathMin = Math.min;
var safeMathRandom = Math.random;
var QualifiedParameters = class _QualifiedParameters {
  static {
    __name(this, "QualifiedParameters");
  }
  constructor(op) {
    const p = op || {};
    this.seed = _QualifiedParameters.readSeed(p);
    this.randomType = _QualifiedParameters.readRandomType(p);
    this.numRuns = _QualifiedParameters.readNumRuns(p);
    this.verbose = _QualifiedParameters.readVerbose(p);
    this.maxSkipsPerRun = _QualifiedParameters.readOrDefault(p, "maxSkipsPerRun", 100);
    this.timeout = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "timeout", null));
    this.skipAllAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "skipAllAfterTimeLimit", null));
    this.interruptAfterTimeLimit = _QualifiedParameters.safeTimeout(_QualifiedParameters.readOrDefault(p, "interruptAfterTimeLimit", null));
    this.markInterruptAsFailure = _QualifiedParameters.readBoolean(p, "markInterruptAsFailure");
    this.skipEqualValues = _QualifiedParameters.readBoolean(p, "skipEqualValues");
    this.ignoreEqualValues = _QualifiedParameters.readBoolean(p, "ignoreEqualValues");
    this.logger = _QualifiedParameters.readOrDefault(p, "logger", (v) => {
      console.log(v);
    });
    this.path = _QualifiedParameters.readOrDefault(p, "path", "");
    this.unbiased = _QualifiedParameters.readBoolean(p, "unbiased");
    this.examples = _QualifiedParameters.readOrDefault(p, "examples", []);
    this.endOnFailure = _QualifiedParameters.readBoolean(p, "endOnFailure");
    this.reporter = _QualifiedParameters.readOrDefault(p, "reporter", null);
    this.asyncReporter = _QualifiedParameters.readOrDefault(p, "asyncReporter", null);
    this.errorWithCause = _QualifiedParameters.readBoolean(p, "errorWithCause");
  }
  toParameters() {
    const orUndefined2 = /* @__PURE__ */ __name((value6) => value6 !== null ? value6 : void 0, "orUndefined");
    const parameters = {
      seed: this.seed,
      randomType: this.randomType,
      numRuns: this.numRuns,
      maxSkipsPerRun: this.maxSkipsPerRun,
      timeout: orUndefined2(this.timeout),
      skipAllAfterTimeLimit: orUndefined2(this.skipAllAfterTimeLimit),
      interruptAfterTimeLimit: orUndefined2(this.interruptAfterTimeLimit),
      markInterruptAsFailure: this.markInterruptAsFailure,
      skipEqualValues: this.skipEqualValues,
      ignoreEqualValues: this.ignoreEqualValues,
      path: this.path,
      logger: this.logger,
      unbiased: this.unbiased,
      verbose: this.verbose,
      examples: this.examples,
      endOnFailure: this.endOnFailure,
      reporter: orUndefined2(this.reporter),
      asyncReporter: orUndefined2(this.asyncReporter),
      errorWithCause: this.errorWithCause
    };
    return parameters;
  }
  static read(op) {
    return new _QualifiedParameters(op);
  }
};
QualifiedParameters.createQualifiedRandomGenerator = (random4) => {
  return (seed) => {
    const rng = random4(seed);
    if (rng.unsafeJump === void 0) {
      rng.unsafeJump = () => unsafeSkipN(rng, 42);
    }
    return rng;
  };
};
QualifiedParameters.readSeed = (p) => {
  if (p.seed == null)
    return safeDateNow() ^ safeMathRandom() * 4294967296;
  const seed32 = p.seed | 0;
  if (p.seed === seed32)
    return seed32;
  const gap = p.seed - seed32;
  return seed32 ^ gap * 4294967296;
};
QualifiedParameters.readRandomType = (p) => {
  if (p.randomType == null)
    return pure_rand_default.xorshift128plus;
  if (typeof p.randomType === "string") {
    switch (p.randomType) {
      case "mersenne":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.mersenne);
      case "congruential":
      case "congruential32":
        return QualifiedParameters.createQualifiedRandomGenerator(pure_rand_default.congruential32);
      case "xorshift128plus":
        return pure_rand_default.xorshift128plus;
      case "xoroshiro128plus":
        return pure_rand_default.xoroshiro128plus;
      default:
        throw new Error(`Invalid random specified: '${p.randomType}'`);
    }
  }
  const mrng = p.randomType(0);
  if ("min" in mrng && mrng.min !== -2147483648) {
    throw new Error(`Invalid random number generator: min must equal -0x80000000, got ${String(mrng.min)}`);
  }
  if ("max" in mrng && mrng.max !== 2147483647) {
    throw new Error(`Invalid random number generator: max must equal 0x7fffffff, got ${String(mrng.max)}`);
  }
  if ("unsafeJump" in mrng) {
    return p.randomType;
  }
  return QualifiedParameters.createQualifiedRandomGenerator(p.randomType);
};
QualifiedParameters.readNumRuns = (p) => {
  const defaultValue = 100;
  if (p.numRuns != null)
    return p.numRuns;
  if (p.num_runs != null)
    return p.num_runs;
  return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
  if (p.verbose == null)
    return VerbosityLevel.None;
  if (typeof p.verbose === "boolean") {
    return p.verbose === true ? VerbosityLevel.Verbose : VerbosityLevel.None;
  }
  if (p.verbose <= VerbosityLevel.None) {
    return VerbosityLevel.None;
  }
  if (p.verbose >= VerbosityLevel.VeryVerbose) {
    return VerbosityLevel.VeryVerbose;
  }
  return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
  const value6 = p[key];
  return value6 != null ? value6 : defaultValue;
};
QualifiedParameters.safeTimeout = (value6) => {
  if (value6 === null) {
    return null;
  }
  return safeMathMin(value6, 2147483647);
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/SkipAfterProperty.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/TimeoutProperty.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/UnbiasedProperty.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/property/IgnoreEqualValuesProperty.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/stringify.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeArrayFrom = Array.from;
var safeBufferIsBuffer = typeof Buffer !== "undefined" ? Buffer.isBuffer : void 0;
var safeJsonStringify = JSON.stringify;
var safeNumberIsNaN = Number.isNaN;
var safeObjectKeys = Object.keys;
var safeObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;
var safeObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var safeObjectGetPrototypeOf = Object.getPrototypeOf;
var safeNegativeInfinity = Number.NEGATIVE_INFINITY;
var safePositiveInfinity = Number.POSITIVE_INFINITY;
var toStringMethod = Symbol.for("fast-check/toStringMethod");
function hasToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && toStringMethod in instance && typeof instance[toStringMethod] === "function";
}
__name(hasToStringMethod, "hasToStringMethod");
var asyncToStringMethod = Symbol.for("fast-check/asyncToStringMethod");
function hasAsyncToStringMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === "function";
}
__name(hasAsyncToStringMethod, "hasAsyncToStringMethod");
var findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
  if (s.description !== void 0)
    return s.description;
  const m = findSymbolNameRegex.exec(SString(s));
  return m && m[1].length ? m[1] : null;
}
__name(getSymbolDescription, "getSymbolDescription");
function stringifyNumber(numValue) {
  switch (numValue) {
    case 0:
      return 1 / numValue === safeNegativeInfinity ? "-0" : "0";
    case safeNegativeInfinity:
      return "Number.NEGATIVE_INFINITY";
    case safePositiveInfinity:
      return "Number.POSITIVE_INFINITY";
    default:
      return numValue === numValue ? SString(numValue) : "Number.NaN";
  }
}
__name(stringifyNumber, "stringifyNumber");
function isSparseArray(arr) {
  let previousNumberedIndex = -1;
  for (const index2 in arr) {
    const numberedIndex = Number(index2);
    if (numberedIndex !== previousNumberedIndex + 1)
      return true;
    previousNumberedIndex = numberedIndex;
  }
  return previousNumberedIndex + 1 !== arr.length;
}
__name(isSparseArray, "isSparseArray");
function stringifyInternal(value6, previousValues, getAsyncContent) {
  const currentValues = [...previousValues, value6];
  if (typeof value6 === "object") {
    if (safeIndexOf(previousValues, value6) !== -1) {
      return "[cyclic]";
    }
  }
  if (hasAsyncToStringMethod(value6)) {
    const content = getAsyncContent(value6);
    if (content.state === "fulfilled") {
      return content.value;
    }
  }
  if (hasToStringMethod(value6)) {
    try {
      return value6[toStringMethod]();
    } catch (err) {
    }
  }
  switch (safeToString2(value6)) {
    case "[object Array]": {
      const arr = value6;
      if (arr.length >= 50 && isSparseArray(arr)) {
        const assignments = [];
        for (const index2 in arr) {
          if (!safeNumberIsNaN(Number(index2)))
            safePush(assignments, `${index2}:${stringifyInternal(arr[index2], currentValues, getAsyncContent)}`);
        }
        return assignments.length !== 0 ? `Object.assign(Array(${arr.length}),{${safeJoin(assignments, ",")}})` : `Array(${arr.length})`;
      }
      const stringifiedArray = safeJoin(safeMap(arr, (v) => stringifyInternal(v, currentValues, getAsyncContent)), ",");
      return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
    }
    case "[object BigInt]":
      return `${value6}n`;
    case "[object Boolean]": {
      const unboxedToString = value6 == true ? "true" : "false";
      return typeof value6 === "boolean" ? unboxedToString : `new Boolean(${unboxedToString})`;
    }
    case "[object Date]": {
      const d = value6;
      return safeNumberIsNaN(safeGetTime(d)) ? `new Date(NaN)` : `new Date(${safeJsonStringify(safeToISOString(d))})`;
    }
    case "[object Map]":
      return `new Map(${stringifyInternal(Array.from(value6), currentValues, getAsyncContent)})`;
    case "[object Null]":
      return `null`;
    case "[object Number]":
      return typeof value6 === "number" ? stringifyNumber(value6) : `new Number(${stringifyNumber(Number(value6))})`;
    case "[object Object]": {
      try {
        const toStringAccessor = value6.toString;
        if (typeof toStringAccessor === "function" && toStringAccessor !== Object.prototype.toString) {
          return value6.toString();
        }
      } catch (err) {
        return "[object Object]";
      }
      const mapper = /* @__PURE__ */ __name((k) => `${k === "__proto__" ? '["__proto__"]' : typeof k === "symbol" ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]` : safeJsonStringify(k)}:${stringifyInternal(value6[k], currentValues, getAsyncContent)}`, "mapper");
      const stringifiedProperties = [
        ...safeMap(safeObjectKeys(value6), mapper),
        ...safeMap(safeFilter(safeObjectGetOwnPropertySymbols(value6), (s) => {
          const descriptor3 = safeObjectGetOwnPropertyDescriptor(value6, s);
          return descriptor3 && descriptor3.enumerable;
        }), mapper)
      ];
      const rawRepr = "{" + safeJoin(stringifiedProperties, ",") + "}";
      if (safeObjectGetPrototypeOf(value6) === null) {
        return rawRepr === "{}" ? "Object.create(null)" : `Object.assign(Object.create(null),${rawRepr})`;
      }
      return rawRepr;
    }
    case "[object Set]":
      return `new Set(${stringifyInternal(Array.from(value6), currentValues, getAsyncContent)})`;
    case "[object String]":
      return typeof value6 === "string" ? safeJsonStringify(value6) : `new String(${safeJsonStringify(value6)})`;
    case "[object Symbol]": {
      const s = value6;
      if (SSymbol.keyFor(s) !== void 0) {
        return `Symbol.for(${safeJsonStringify(SSymbol.keyFor(s))})`;
      }
      const desc = getSymbolDescription(s);
      if (desc === null) {
        return "Symbol()";
      }
      const knownSymbol = desc.startsWith("Symbol.") && SSymbol[desc.substring(7)];
      return s === knownSymbol ? desc : `Symbol(${safeJsonStringify(desc)})`;
    }
    case "[object Promise]": {
      const promiseContent = getAsyncContent(value6);
      switch (promiseContent.state) {
        case "fulfilled":
          return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "rejected":
          return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
        case "pending":
          return `new Promise(() => {/*pending*/})`;
        case "unknown":
        default:
          return `new Promise(() => {/*unknown*/})`;
      }
    }
    case "[object Error]":
      if (value6 instanceof Error) {
        return `new Error(${stringifyInternal(value6.message, currentValues, getAsyncContent)})`;
      }
      break;
    case "[object Undefined]":
      return `undefined`;
    case "[object Int8Array]":
    case "[object Uint8Array]":
    case "[object Uint8ClampedArray]":
    case "[object Int16Array]":
    case "[object Uint16Array]":
    case "[object Int32Array]":
    case "[object Uint32Array]":
    case "[object Float32Array]":
    case "[object Float64Array]":
    case "[object BigInt64Array]":
    case "[object BigUint64Array]": {
      if (typeof safeBufferIsBuffer === "function" && safeBufferIsBuffer(value6)) {
        return `Buffer.from(${stringifyInternal(safeArrayFrom(value6.values()), currentValues, getAsyncContent)})`;
      }
      const valuePrototype = safeObjectGetPrototypeOf(value6);
      const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
      if (typeof className === "string") {
        const typedArray = value6;
        const valuesFromTypedArr = typedArray.values();
        return `${className}.from(${stringifyInternal(safeArrayFrom(valuesFromTypedArr), currentValues, getAsyncContent)})`;
      }
      break;
    }
  }
  try {
    return value6.toString();
  } catch (_a) {
    return safeToString2(value6);
  }
}
__name(stringifyInternal, "stringifyInternal");
function stringify(value6) {
  return stringifyInternal(value6, [], () => ({ state: "unknown", value: void 0 }));
}
__name(stringify, "stringify");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/DecorateProperty.js
var safeDateNow2 = Date.now;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/RunnerIterator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/ExecutionStatus.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ExecutionStatus;
(function(ExecutionStatus2) {
  ExecutionStatus2[ExecutionStatus2["Success"] = 0] = "Success";
  ExecutionStatus2[ExecutionStatus2["Skipped"] = -1] = "Skipped";
  ExecutionStatus2[ExecutionStatus2["Failure"] = 1] = "Failure";
})(ExecutionStatus || (ExecutionStatus = {}));

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/reporter/RunExecution.js
var RunExecution = class _RunExecution {
  static {
    __name(this, "RunExecution");
  }
  constructor(verbosity, interruptedAsFailure) {
    this.verbosity = verbosity;
    this.interruptedAsFailure = interruptedAsFailure;
    this.isSuccess = () => this.pathToFailure == null;
    this.firstFailure = () => this.pathToFailure ? +safeSplit(this.pathToFailure, ":")[0] : -1;
    this.numShrinks = () => this.pathToFailure ? safeSplit(this.pathToFailure, ":").length - 1 : 0;
    this.rootExecutionTrees = [];
    this.currentLevelExecutionTrees = this.rootExecutionTrees;
    this.failure = null;
    this.numSkips = 0;
    this.numSuccesses = 0;
    this.interrupted = false;
  }
  appendExecutionTree(status3, value6) {
    const currentTree = { status: status3, value: value6, children: [] };
    this.currentLevelExecutionTrees.push(currentTree);
    return currentTree;
  }
  fail(value6, id4, failure) {
    if (this.verbosity >= VerbosityLevel.Verbose) {
      const currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value6);
      this.currentLevelExecutionTrees = currentTree.children;
    }
    if (this.pathToFailure == null)
      this.pathToFailure = `${id4}`;
    else
      this.pathToFailure += `:${id4}`;
    this.value = value6;
    this.failure = failure;
  }
  skip(value6) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Skipped, value6);
    }
    if (this.pathToFailure == null) {
      ++this.numSkips;
    }
  }
  success(value6) {
    if (this.verbosity >= VerbosityLevel.VeryVerbose) {
      this.appendExecutionTree(ExecutionStatus.Success, value6);
    }
    if (this.pathToFailure == null) {
      ++this.numSuccesses;
    }
  }
  interrupt() {
    this.interrupted = true;
  }
  extractFailures() {
    if (this.isSuccess()) {
      return [];
    }
    const failures3 = [];
    let cursor = this.rootExecutionTrees;
    while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {
      const failureTree = cursor[cursor.length - 1];
      failures3.push(failureTree.value);
      cursor = failureTree.children;
    }
    return failures3;
  }
  toRunDetails(seed, basePath, maxSkips, qParams) {
    if (!this.isSuccess()) {
      return {
        failed: true,
        interrupted: this.interrupted,
        numRuns: this.firstFailure() + 1 - this.numSkips,
        numSkips: this.numSkips,
        numShrinks: this.numShrinks(),
        seed,
        counterexample: this.value,
        counterexamplePath: _RunExecution.mergePaths(basePath, this.pathToFailure),
        error: this.failure.errorMessage,
        errorInstance: this.failure.error,
        failures: this.extractFailures(),
        executionSummary: this.rootExecutionTrees,
        verbose: this.verbosity,
        runConfiguration: qParams.toParameters()
      };
    }
    const considerInterruptedAsFailure = this.interruptedAsFailure || this.numSuccesses === 0;
    const failed = this.numSkips > maxSkips || this.interrupted && considerInterruptedAsFailure;
    const out = {
      failed,
      interrupted: this.interrupted,
      numRuns: this.numSuccesses,
      numSkips: this.numSkips,
      numShrinks: 0,
      seed,
      counterexample: null,
      counterexamplePath: null,
      error: null,
      errorInstance: null,
      failures: [],
      executionSummary: this.rootExecutionTrees,
      verbose: this.verbosity,
      runConfiguration: qParams.toParameters()
    };
    return out;
  }
};
RunExecution.mergePaths = (offsetPath, path) => {
  if (offsetPath.length === 0)
    return path;
  const offsetItems = offsetPath.split(":");
  const remainingItems = path.split(":");
  const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
  return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(":");
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/SourceValuesIterator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/Tosser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/random/generator/Random.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Random = class _Random {
  static {
    __name(this, "Random");
  }
  constructor(sourceRng) {
    this.internalRng = sourceRng.clone();
  }
  clone() {
    return new _Random(this.internalRng);
  }
  next(bits) {
    return unsafeUniformIntDistribution(0, (1 << bits) - 1, this.internalRng);
  }
  nextBoolean() {
    return unsafeUniformIntDistribution(0, 1, this.internalRng) == 1;
  }
  nextInt(min6, max9) {
    return unsafeUniformIntDistribution(min6 == null ? _Random.MIN_INT : min6, max9 == null ? _Random.MAX_INT : max9, this.internalRng);
  }
  nextBigInt(min6, max9) {
    return unsafeUniformBigIntDistribution(min6, max9, this.internalRng);
  }
  nextArrayInt(min6, max9) {
    return unsafeUniformArrayIntDistribution(min6, max9, this.internalRng);
  }
  nextDouble() {
    const a = this.next(26);
    const b = this.next(27);
    return (a * _Random.DBL_FACTOR + b) * _Random.DBL_DIVISOR;
  }
  getState() {
    if ("getState" in this.internalRng && typeof this.internalRng.getState === "function") {
      return this.internalRng.getState();
    }
    return void 0;
  }
};
Random.MIN_INT = 2147483648 | 0;
Random.MAX_INT = 2147483647 | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/utils/PathWalker.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/utils/RunDetailsFormatter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/runner/Sampler.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/gen.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/GeneratorArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/GeneratorValueBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StableArbitraryGeneratorCache.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/integer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeMathFloor = Math.floor;
var safeMathLog2 = Math.log;
function integerLogLike(v) {
  return safeMathFloor(safeMathLog2(v) / safeMathLog2(2));
}
__name(integerLogLike, "integerLogLike");
function biasNumericRange(min6, max9, logLike) {
  if (min6 === max9) {
    return [{ min: min6, max: max9 }];
  }
  if (min6 < 0 && max9 > 0) {
    const logMin = logLike(-min6);
    const logMax = logLike(max9);
    return [
      { min: -logMin, max: logMax },
      { min: max9 - logMax, max: max9 },
      { min: min6, max: min6 + logMin }
    ];
  }
  const logGap = logLike(max9 - min6);
  const arbCloseToMin = { min: min6, max: min6 + logGap };
  const arbCloseToMax = { min: max9 - logGap, max: max9 };
  return min6 < 0 ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
}
__name(biasNumericRange, "biasNumericRange");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeMathCeil = Math.ceil;
var safeMathFloor2 = Math.floor;
function halvePosInteger(n) {
  return safeMathFloor2(n / 2);
}
__name(halvePosInteger, "halvePosInteger");
function halveNegInteger(n) {
  return safeMathCeil(n / 2);
}
__name(halveNegInteger, "halveNegInteger");
function shrinkInteger(current2, target3, tryTargetAsap) {
  const realGap = current2 - target3;
  function* shrinkDecr() {
    let previous2 = tryTargetAsap ? void 0 : target3;
    const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
    for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
      const next4 = toremove === realGap ? target3 : current2 - toremove;
      yield new Value(next4, previous2);
      previous2 = next4;
    }
  }
  __name(shrinkDecr, "shrinkDecr");
  function* shrinkIncr() {
    let previous2 = tryTargetAsap ? void 0 : target3;
    const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
    for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
      const next4 = toremove === realGap ? target3 : current2 - toremove;
      yield new Value(next4, previous2);
      previous2 = next4;
    }
  }
  __name(shrinkIncr, "shrinkIncr");
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}
__name(shrinkInteger, "shrinkInteger");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
var safeMathSign = Math.sign;
var safeNumberIsInteger = Number.isInteger;
var safeObjectIs = Object.is;
var IntegerArbitrary = class _IntegerArbitrary extends Arbitrary {
  static {
    __name(this, "IntegerArbitrary");
  }
  constructor(min6, max9) {
    super();
    this.min = min6;
    this.max = max9;
  }
  generate(mrng, biasFactor) {
    const range5 = this.computeGenerateRange(mrng, biasFactor);
    return new Value(mrng.nextInt(range5.min, range5.max), void 0);
  }
  canShrinkWithoutContext(value6) {
    return typeof value6 === "number" && safeNumberIsInteger(value6) && !safeObjectIs(value6, -0) && this.min <= value6 && value6 <= this.max;
  }
  shrink(current2, context17) {
    if (!_IntegerArbitrary.isValidContext(current2, context17)) {
      const target3 = this.defaultTarget();
      return shrinkInteger(current2, target3, true);
    }
    if (this.isLastChanceTry(current2, context17)) {
      return Stream.of(new Value(context17, void 0));
    }
    return shrinkInteger(current2, context17, false);
  }
  defaultTarget() {
    if (this.min <= 0 && this.max >= 0) {
      return 0;
    }
    return this.min < 0 ? this.max : this.min;
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === void 0 || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = biasNumericRange(this.min, this.max, integerLogLike);
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id4 = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id4 < 0 ? ranges[0] : ranges[id4 + 1];
  }
  isLastChanceTry(current2, context17) {
    if (current2 > 0)
      return current2 === context17 + 1 && current2 > this.min;
    if (current2 < 0)
      return current2 === context17 - 1 && current2 < this.max;
    return false;
  }
  static isValidContext(current2, context17) {
    if (context17 === void 0) {
      return false;
    }
    if (typeof context17 !== "number") {
      throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
    }
    if (context17 !== 0 && safeMathSign(current2) !== safeMathSign(context17)) {
      throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
    }
    return true;
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/integer.js
var safeNumberIsInteger2 = Number.isInteger;
function buildCompleteIntegerConstraints(constraints) {
  const min6 = constraints.min !== void 0 ? constraints.min : -2147483648;
  const max9 = constraints.max !== void 0 ? constraints.max : 2147483647;
  return { min: min6, max: max9 };
}
__name(buildCompleteIntegerConstraints, "buildCompleteIntegerConstraints");
function integer2(constraints = {}) {
  const fullConstraints = buildCompleteIntegerConstraints(constraints);
  if (fullConstraints.min > fullConstraints.max) {
    throw new Error("fc.integer maximum value should be equal or greater than the minimum one");
  }
  if (!safeNumberIsInteger2(fullConstraints.min)) {
    throw new Error("fc.integer minimum value should be an integer");
  }
  if (!safeNumberIsInteger2(fullConstraints.max)) {
    throw new Error("fc.integer maximum value should be an integer");
  }
  return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}
__name(integer2, "integer");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var depthContextCache = /* @__PURE__ */ new Map();
function getDepthContextFor(contextMeta) {
  if (contextMeta === void 0) {
    return { depth: 0 };
  }
  if (typeof contextMeta !== "string") {
    return contextMeta;
  }
  const cachedContext = safeMapGet(depthContextCache, contextMeta);
  if (cachedContext !== void 0) {
    return cachedContext;
  }
  const context17 = { depth: 0 };
  safeMapSet(depthContextCache, contextMeta, context17);
  return context17;
}
__name(getDepthContextFor, "getDepthContextFor");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NoopSlicedGenerator = class {
  static {
    __name(this, "NoopSlicedGenerator");
  }
  constructor(arb, mrng, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.biasFactor = biasFactor;
  }
  attemptExact() {
    return;
  }
  next() {
    return this.arb.generate(this.mrng, this.biasFactor);
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeMathMin2 = Math.min;
var safeMathMax = Math.max;
var SlicedBasedGenerator = class {
  static {
    __name(this, "SlicedBasedGenerator");
  }
  constructor(arb, mrng, slices, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.slices = slices;
    this.biasFactor = biasFactor;
    this.activeSliceIndex = 0;
    this.nextIndexInSlice = 0;
    this.lastIndexInSlice = -1;
  }
  attemptExact(targetLength) {
    if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
      const eligibleIndices = [];
      for (let index2 = 0; index2 !== this.slices.length; ++index2) {
        const slice = this.slices[index2];
        if (slice.length === targetLength) {
          safePush(eligibleIndices, index2);
        }
      }
      if (eligibleIndices.length === 0) {
        return;
      }
      this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
      this.nextIndexInSlice = 0;
      this.lastIndexInSlice = targetLength - 1;
    }
  }
  next() {
    if (this.nextIndexInSlice <= this.lastIndexInSlice) {
      return new Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], void 0);
    }
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      return this.arb.generate(this.mrng, this.biasFactor);
    }
    this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
    const slice = this.slices[this.activeSliceIndex];
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      this.nextIndexInSlice = 1;
      this.lastIndexInSlice = slice.length - 1;
      return new Value(slice[0], void 0);
    }
    const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);
    const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);
    this.nextIndexInSlice = safeMathMin2(rangeBoundaryA, rangeBoundaryB);
    this.lastIndexInSlice = safeMathMax(rangeBoundaryA, rangeBoundaryB);
    return new Value(slice[this.nextIndexInSlice++], void 0);
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
  if (biasFactor === void 0 || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) {
    return new NoopSlicedGenerator(arb, mrng, biasFactor);
  }
  return new SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}
__name(buildSlicedGenerator, "buildSlicedGenerator");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
var safeMathFloor3 = Math.floor;
var safeMathLog3 = Math.log;
var safeMathMax2 = Math.max;
var safeArrayIsArray = Array.isArray;
function biasedMaxLength(minLength2, maxLength2) {
  if (minLength2 === maxLength2) {
    return minLength2;
  }
  return minLength2 + safeMathFloor3(safeMathLog3(maxLength2 - minLength2) / safeMathLog3(2));
}
__name(biasedMaxLength, "biasedMaxLength");
var ArrayArbitrary = class _ArrayArbitrary extends Arbitrary {
  static {
    __name(this, "ArrayArbitrary");
  }
  constructor(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, setBuilder, customSlices) {
    super();
    this.arb = arb;
    this.minLength = minLength2;
    this.maxGeneratedLength = maxGeneratedLength;
    this.maxLength = maxLength2;
    this.setBuilder = setBuilder;
    this.customSlices = customSlices;
    this.lengthArb = integer2({ min: minLength2, max: maxGeneratedLength });
    this.depthContext = getDepthContextFor(depthIdentifier);
  }
  preFilter(tab) {
    if (this.setBuilder === void 0) {
      return tab;
    }
    const s = this.setBuilder();
    for (let index2 = 0; index2 !== tab.length; ++index2) {
      s.tryAdd(tab[index2]);
    }
    return s.getData();
  }
  static makeItCloneable(vs, shrinkables) {
    vs[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0; idx !== shrinkables.length; ++idx) {
        safePush(cloned, shrinkables[idx].value);
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }
  generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    let numSkippedInRow = 0;
    const s = setBuilder();
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {
      const current2 = slicedGenerator.next();
      if (s.tryAdd(current2)) {
        numSkippedInRow = 0;
      } else {
        numSkippedInRow += 1;
      }
    }
    return s.getData();
  }
  safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  generateNItems(N, mrng, biasFactorItems) {
    const items = [];
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    slicedGenerator.attemptExact(N);
    for (let index2 = 0; index2 !== N; ++index2) {
      const current2 = slicedGenerator.next();
      safePush(items, current2);
    }
    return items;
  }
  safeGenerateNItems(N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItems(N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
    let cloneable = false;
    const vs = [];
    const itemsContexts = [];
    for (let idx = 0; idx !== items.length; ++idx) {
      const s = items[idx];
      cloneable = cloneable || s.hasToBeCloned;
      safePush(vs, s.value);
      safePush(itemsContexts, s.context);
    }
    if (cloneable) {
      _ArrayArbitrary.makeItCloneable(vs, items);
    }
    const context17 = {
      shrunkOnce,
      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== void 0 ? itemsRawLengthContext : void 0,
      itemsContexts,
      startIndex
    };
    return new Value(vs, context17);
  }
  generate(mrng, biasFactor) {
    const biasMeta = this.applyBias(mrng, biasFactor);
    const targetSize = biasMeta.size;
    const items = this.setBuilder !== void 0 ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
    return this.wrapper(items, false, void 0, 0);
  }
  applyBias(mrng, biasFactor) {
    if (biasFactor === void 0) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    if (mrng.nextInt(1, biasFactor) !== 1) {
      return { size: this.lengthArb.generate(mrng, void 0).value };
    }
    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, void 0).value, biasFactorItems: biasFactor };
    }
    const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
    const targetSizeValue = integer2({ min: this.minLength, max: maxBiasedLength }).generate(mrng, void 0);
    return { size: targetSizeValue.value, biasFactorItems: biasFactor };
  }
  canShrinkWithoutContext(value6) {
    if (!safeArrayIsArray(value6) || this.minLength > value6.length || value6.length > this.maxLength) {
      return false;
    }
    for (let index2 = 0; index2 !== value6.length; ++index2) {
      if (!(index2 in value6)) {
        return false;
      }
      if (!this.arb.canShrinkWithoutContext(value6[index2])) {
        return false;
      }
    }
    const filtered = this.preFilter(safeMap(value6, (item) => new Value(item, void 0)));
    return filtered.length === value6.length;
  }
  shrinkItemByItem(value6, safeContext, endIndex) {
    const shrinks = [];
    for (let index2 = safeContext.startIndex; index2 < endIndex; ++index2) {
      safePush(shrinks, makeLazy(() => this.arb.shrink(value6[index2], safeContext.itemsContexts[index2]).map((v) => {
        const beforeCurrent = safeMap(safeSlice(value6, 0, index2), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i]));
        const afterCurrent = safeMap(safeSlice(value6, index2 + 1), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i + index2 + 1]));
        return [
          [...beforeCurrent, v, ...afterCurrent],
          void 0,
          index2
        ];
      })));
    }
    return Stream.nil().join(...shrinks);
  }
  shrinkImpl(value6, context17) {
    if (value6.length === 0) {
      return Stream.nil();
    }
    const safeContext = context17 !== void 0 ? context17 : { shrunkOnce: false, lengthContext: void 0, itemsContexts: [], startIndex: 0 };
    return this.lengthArb.shrink(value6.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === void 0 && value6.length > this.minLength + 1 ? 1 : 0).map((lengthValue) => {
      const sliceStart = value6.length - lengthValue.value;
      return [
        safeMap(safeSlice(value6, sliceStart), (v, index2) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[index2 + sliceStart])),
        lengthValue.context,
        0
      ];
    }).join(makeLazy(() => value6.length > this.minLength ? this.shrinkItemByItem(value6, safeContext, 1) : this.shrinkItemByItem(value6, safeContext, value6.length))).join(value6.length > this.minLength ? makeLazy(() => {
      const subContext = {
        shrunkOnce: false,
        lengthContext: void 0,
        itemsContexts: safeSlice(safeContext.itemsContexts, 1),
        startIndex: 0
      };
      return this.shrinkImpl(safeSlice(value6, 1), subContext).filter((v) => this.minLength <= v[0].length + 1).map((v) => {
        return [[new Value(cloneIfNeeded(value6[0]), safeContext.itemsContexts[0]), ...v[0]], void 0, 0];
      });
    }) : Stream.nil());
  }
  shrink(value6, context17) {
    return this.shrinkImpl(value6, context17).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeMathFloor4 = Math.floor;
var safeMathMin3 = Math.min;
var MaxLengthUpperBound = 2147483647;
var orderedSize = ["xsmall", "small", "medium", "large", "xlarge"];
var orderedRelativeSize = ["-4", "-3", "-2", "-1", "=", "+1", "+2", "+3", "+4"];
var DefaultSize = "small";
function maxLengthFromMinLength(minLength2, size22) {
  switch (size22) {
    case "xsmall":
      return safeMathFloor4(1.1 * minLength2) + 1;
    case "small":
      return 2 * minLength2 + 10;
    case "medium":
      return 11 * minLength2 + 100;
    case "large":
      return 101 * minLength2 + 1e3;
    case "xlarge":
      return 1001 * minLength2 + 1e4;
    default:
      throw new Error(`Unable to compute lengths based on received size: ${size22}`);
  }
}
__name(maxLengthFromMinLength, "maxLengthFromMinLength");
function relativeSizeToSize(size22, defaultSize) {
  const sizeInRelative = safeIndexOf(orderedRelativeSize, size22);
  if (sizeInRelative === -1) {
    return size22;
  }
  const defaultSizeInSize = safeIndexOf(orderedSize, defaultSize);
  if (defaultSizeInSize === -1) {
    throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
  }
  const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
  return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
__name(relativeSizeToSize, "relativeSizeToSize");
function maxGeneratedLengthFromSizeForArbitrary(size22, minLength2, maxLength2, specifiedMaxLength) {
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = size22 !== void 0 ? size22 : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return maxLength2;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  return safeMathMin3(maxLengthFromMinLength(minLength2, finalSize), maxLength2);
}
__name(maxGeneratedLengthFromSizeForArbitrary, "maxGeneratedLengthFromSizeForArbitrary");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/array.js
function array6(arb, constraints = {}) {
  const size22 = constraints.size;
  const minLength2 = constraints.minLength || 0;
  const maxLengthOrUnset = constraints.maxLength;
  const depthIdentifier = constraints.depthIdentifier;
  const maxLength2 = maxLengthOrUnset !== void 0 ? maxLengthOrUnset : MaxLengthUpperBound;
  const specifiedMaxLength = maxLengthOrUnset !== void 0;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size22, minLength2, maxLength2, specifiedMaxLength);
  const customSlices = constraints.experimentalCustomSlices || [];
  return new ArrayArbitrary(arb, minLength2, maxGeneratedLength, maxLength2, depthIdentifier, void 0, customSlices);
}
__name(array6, "array");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigInt.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/BigIntArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkBigInt.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigIntN.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigUint.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigUintN.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/boolean.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/noBias.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/falsy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/constantFrom.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ConstantArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ascii.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToCharString.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
  if (typeof c !== "string") {
    throw new Error("Cannot unmap non-string");
  }
  if (c.length === 0 || c.length > 2) {
    throw new Error("Cannot unmap string with more or less than one character");
  }
  const c1 = safeCharCodeAt(c, 0);
  if (c.length === 1) {
    return c1;
  }
  const c2 = safeCharCodeAt(c, 1);
  if (c1 < 55296 || c1 > 56319 || c2 < 56320 || c2 > 57343) {
    throw new Error("Cannot unmap invalid surrogate pairs");
  }
  return c.codePointAt(0);
}
__name(indexToCharStringUnmapper, "indexToCharStringUnmapper");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterArbitraryBuilder.js
function buildCharacterArbitrary(min6, max9, mapToCode, unmapFromCode) {
  return integer2({ min: min6, max: max9 }).map((n) => indexToCharStringMapper(mapToCode(n)), (c) => unmapFromCode(indexToCharStringUnmapper(c)));
}
__name(buildCharacterArbitrary, "buildCharacterArbitrary");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToPrintableIndex.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function indexToPrintableIndexMapper(v) {
  if (v < 95)
    return v + 32;
  if (v <= 126)
    return v - 95;
  return v;
}
__name(indexToPrintableIndexMapper, "indexToPrintableIndexMapper");
function indexToPrintableIndexUnmapper(v) {
  if (v >= 32 && v <= 126)
    return v - 32;
  if (v >= 0 && v <= 31)
    return v + 95;
  return v;
}
__name(indexToPrintableIndexUnmapper, "indexToPrintableIndexUnmapper");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/base64.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/char.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function identity3(v) {
  return v;
}
__name(identity3, "identity");
function char() {
  return buildCharacterArbitrary(32, 126, identity3, identity3);
}
__name(char, "char");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/char16bits.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/fullUnicode.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var gapSize = 57343 + 1 - 55296;
function unicodeMapper(v) {
  if (v < 55296)
    return indexToPrintableIndexMapper(v);
  return v + gapSize;
}
__name(unicodeMapper, "unicodeMapper");
function unicodeUnmapper(v) {
  if (v < 55296)
    return indexToPrintableIndexUnmapper(v);
  if (v <= 57343)
    return -1;
  return v - gapSize;
}
__name(unicodeUnmapper, "unicodeUnmapper");
function fullUnicode() {
  return buildCharacterArbitrary(0, 1114111 - gapSize, unicodeMapper, unicodeUnmapper);
}
__name(fullUnicode, "fullUnicode");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/hexa.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/unicode.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var gapSize2 = 57343 + 1 - 55296;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/constant.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/context.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ContextImplem = class _ContextImplem {
  static {
    __name(this, "ContextImplem");
  }
  constructor() {
    this.receivedLogs = [];
  }
  log(data) {
    this.receivedLogs.push(data);
  }
  size() {
    return this.receivedLogs.length;
  }
  toString() {
    return JSON.stringify({ logs: this.receivedLogs });
  }
  [cloneMethod]() {
    return new _ContextImplem();
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/date.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/TimeToDate.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeNaN = Number.NaN;
var safeNumberIsNaN2 = Number.isNaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/date.js
var safeNumberIsNaN3 = Number.isNaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/clone.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/CloneArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/dictionary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uniqueArray.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/CustomEqualSet.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/StrictlyEqualSet.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeNumberIsNaN4 = Number.isNaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueSet.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SameValueZeroSet.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/KeyValuePairsToObject.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/emailAddress.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/oneof.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/FrequencyArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safePositiveInfinity2 = Number.POSITIVE_INFINITY;
var safeMaxSafeInteger = Number.MAX_SAFE_INTEGER;
var safeNumberIsInteger3 = Number.isInteger;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/mapToConstant.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/nat.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeNumberIsInteger4 = Number.isInteger;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/IndexToMappedConstant.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CharacterRangeArbitraryBuilder.js
var safeStringFromCharCode = String.fromCharCode;
function percentCharArbMapper(c) {
  const encoded = SencodeURIComponent(c);
  return c !== encoded ? encoded : `%${safeNumberToString(safeCharCodeAt(c, 0), 16)}`;
}
__name(percentCharArbMapper, "percentCharArbMapper");
function percentCharArbUnmapper(value6) {
  if (typeof value6 !== "string") {
    throw new Error("Unsupported");
  }
  const decoded = decodeURIComponent(value6);
  return decoded;
}
__name(percentCharArbUnmapper, "percentCharArbUnmapper");
var percentCharArb = fullUnicode().map(percentCharArbMapper, percentCharArbUnmapper);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/domain.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/option.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/string.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SlicesForStringBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PatternsToString.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeString.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/StringUnitArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/data/GraphemeRanges.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/GraphemeRangesHelpers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeStringFromCodePoint = String.fromCodePoint;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/InvalidSubdomainLabelFiIter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/AdapterArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var AdaptedValue = Symbol("adapted-value");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/double.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ArrayInt64.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayInt64Arbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleHelpers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeNegativeInfinity2 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity3 = Number.POSITIVE_INFINITY;
var safeEpsilon = Number.EPSILON;
var f64 = new Float64Array(1);
var u32 = new Uint32Array(f64.buffer, f64.byteOffset);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatingOnlyHelpers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeNumberIsInteger5 = Number.isInteger;
var safeNegativeInfinity3 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity4 = Number.POSITIVE_INFINITY;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DoubleOnlyHelpers.js
var safeNegativeInfinity4 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity5 = Number.POSITIVE_INFINITY;
var safeMaxValue = Number.MAX_VALUE;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/double.js
var safeNumberIsInteger6 = Number.isInteger;
var safeNumberIsNaN5 = Number.isNaN;
var safeNegativeInfinity5 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity6 = Number.POSITIVE_INFINITY;
var safeMaxValue2 = Number.MAX_VALUE;
var safeNaN2 = Number.NaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatHelpers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeNegativeInfinity6 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity7 = Number.POSITIVE_INFINITY;
var MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
var MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
var EPSILON_32 = 2 ** -23;
var f32 = new Float32Array(1);
var u322 = new Uint32Array(f32.buffer, f32.byteOffset);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/FloatOnlyHelpers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeNegativeInfinity7 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity8 = Number.POSITIVE_INFINITY;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float.js
var safeNumberIsInteger7 = Number.isInteger;
var safeNumberIsNaN6 = Number.isNaN;
var safeNegativeInfinity8 = Number.NEGATIVE_INFINITY;
var safePositiveInfinity9 = Number.POSITIVE_INFINITY;
var safeNaN3 = Number.NaN;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/compareBooleanFunc.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/CompareFunctionArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TextEscaper.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function escapeForTemplateString(originalText) {
  return originalText.replace(/([$`\\])/g, "\\$1").replace(/\r/g, "\\r");
}
__name(escapeForTemplateString, "escapeForTemplateString");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/utils/hash.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/noShrink.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/compareFunc.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/func.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/maxSafeInteger.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeMinSafeInteger = Number.MIN_SAFE_INTEGER;
var safeMaxSafeInteger2 = Number.MAX_SAFE_INTEGER;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/maxSafeNat.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeMaxSafeInteger3 = Number.MAX_SAFE_INTEGER;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ipV4.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NatToStringifiedNat.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var safeNumberParseInt = Number.parseInt;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ipV4Extended.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/StringifiedNatArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ipV6.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/hexaString.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CodePointsToString.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/EntitiesToIPv6.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/letrec.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/LazyArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/lorem.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/WordsToLorem.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/memo.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/mixedCase.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/MixedCaseArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ToggleFlags.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/object.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/AnyArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float32Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/float64Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/int16Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/TypedIntArrayArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/int32Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/int8Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint16Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint32Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint8Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uint8ClampedArray.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/sparseArray.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/RestrictedIntegerArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/WithShrinkFromOtherArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/sparseArray.js
var safeArrayIsArray2 = SArray.isArray;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToMap.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ArrayToSet.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/QualifiedObjectConstraints.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/fullUnicodeString.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/BoxedArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UnboxedToBoxed.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/json.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/jsonValue.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/JsonConstraintsBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/anything.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/unicodeJsonValue.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/unicodeString.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/unicodeJson.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/record.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/EnumerableKeysExtractor.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/ValuesAndSeparateKeysToObject.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PartialRecordArbitraryBuilder.js
var noKeyValue = Symbol("no-key");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/infiniteStream.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/StreamArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/asciiString.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/base64String.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/StringToBase64.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/string16bits.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/CharsToString.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/stringOf.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/subarray.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/SubarrayArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/IsSubarrayOf.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/shuffledSubarray.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ulid.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/UintToBase32String.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var encodeSymbolLookupTable = {
  10: "A",
  11: "B",
  12: "C",
  13: "D",
  14: "E",
  15: "F",
  16: "G",
  17: "H",
  18: "J",
  19: "K",
  20: "M",
  21: "N",
  22: "P",
  23: "Q",
  24: "R",
  25: "S",
  26: "T",
  27: "V",
  28: "W",
  29: "X",
  30: "Y",
  31: "Z"
};
function encodeSymbol(symbol6) {
  return symbol6 < 10 ? SString(symbol6) : encodeSymbolLookupTable[symbol6];
}
__name(encodeSymbol, "encodeSymbol");
function pad2(value6, paddingLength) {
  let extraPadding = "";
  while (value6.length + extraPadding.length < paddingLength) {
    extraPadding += "0";
  }
  return extraPadding + value6;
}
__name(pad2, "pad");
function smallUintToBase32StringMapper(num) {
  let base32Str = "";
  for (let remaining = num; remaining !== 0; ) {
    const next4 = remaining >> 5;
    const current2 = remaining - (next4 << 5);
    base32Str = encodeSymbol(current2) + base32Str;
    remaining = next4;
  }
  return base32Str;
}
__name(smallUintToBase32StringMapper, "smallUintToBase32StringMapper");
function uintToBase32StringMapper(num, paddingLength) {
  const head13 = ~~(num / 1073741824);
  const tail3 = num & 1073741823;
  return pad2(smallUintToBase32StringMapper(head13), paddingLength - 6) + pad2(smallUintToBase32StringMapper(tail3), 6);
}
__name(uintToBase32StringMapper, "uintToBase32StringMapper");
function paddedUintToBase32StringMapper(paddingLength) {
  return /* @__PURE__ */ __name(function padded(num) {
    return uintToBase32StringMapper(num, paddingLength);
  }, "padded");
}
__name(paddedUintToBase32StringMapper, "paddedUintToBase32StringMapper");

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/ulid.js
var padded10Mapper = paddedUintToBase32StringMapper(10);
var padded8Mapper = paddedUintToBase32StringMapper(8);

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uuid.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/PaddedNumberArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/NumberToPaddedEight.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PaddedEightsToUuid.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/VersionsApplierForUuid.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/uuidV.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webAuthority.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webFragments.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriQueryOrFragmentArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webPath.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/builders/UriPathArbitraryBuilder.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webSegment.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/SegmentsToPath.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webQueryParameters.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/webUrl.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/mappers/PartsToUrl.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/commands.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/CommandsArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/commands/CommandsIterable.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CommandsIterable = class _CommandsIterable {
  static {
    __name(this, "CommandsIterable");
  }
  constructor(commands2, metadataForReplay) {
    this.commands = commands2;
    this.metadataForReplay = metadataForReplay;
  }
  [Symbol.iterator]() {
    return this.commands[Symbol.iterator]();
  }
  [cloneMethod]() {
    return new _CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
  }
  toString() {
    const serializedCommands = this.commands.filter((c) => c.hasRan).map((c) => c.toString()).join(",");
    const metadata = this.metadataForReplay();
    return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/commands/CommandWrapper.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/ReplayPath.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/ModelRunner.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/check/model/commands/ScheduledCommand.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/scheduler.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSchedulerFor.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SchedulerImplem.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var defaultSchedulerAct = /* @__PURE__ */ __name((f) => f(), "defaultSchedulerAct");
var SchedulerImplem = class _SchedulerImplem {
  static {
    __name(this, "SchedulerImplem");
  }
  constructor(act, taskSelector) {
    this.act = act;
    this.taskSelector = taskSelector;
    this.lastTaskId = 0;
    this.sourceTaskSelector = taskSelector.clone();
    this.scheduledTasks = [];
    this.triggeredTasks = [];
    this.scheduledWatchers = [];
  }
  static buildLog(reportItem) {
    return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== void 0 ? ` with value ${escapeForTemplateString(reportItem.outputValue)}` : ""}`;
  }
  log(schedulingType, taskId, label, metadata, status3, data) {
    this.triggeredTasks.push({
      status: status3,
      schedulingType,
      taskId,
      label,
      metadata,
      outputValue: data !== void 0 ? stringify(data) : void 0
    });
  }
  scheduleInternal(schedulingType, label, task, metadata, customAct, thenTaskToBeAwaited) {
    let trigger = null;
    const taskId = ++this.lastTaskId;
    const scheduledPromise = new Promise((resolve3, reject3) => {
      trigger = /* @__PURE__ */ __name(() => {
        (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {
          this.log(schedulingType, taskId, label, metadata, "resolved", data);
          return resolve3(data);
        }, (err) => {
          this.log(schedulingType, taskId, label, metadata, "rejected", err);
          return reject3(err);
        });
      }, "trigger");
    });
    this.scheduledTasks.push({
      original: task,
      scheduled: scheduledPromise,
      trigger,
      schedulingType,
      taskId,
      label,
      metadata,
      customAct
    });
    if (this.scheduledWatchers.length !== 0) {
      this.scheduledWatchers[0]();
    }
    return scheduledPromise;
  }
  schedule(task, label, metadata, customAct) {
    return this.scheduleInternal("promise", label || "", task, metadata, customAct || defaultSchedulerAct);
  }
  scheduleFunction(asyncFunction, customAct) {
    return (...args2) => this.scheduleInternal("function", `${asyncFunction.name}(${args2.map(stringify).join(",")})`, asyncFunction(...args2), void 0, customAct || defaultSchedulerAct);
  }
  scheduleSequence(sequenceBuilders, customAct) {
    const status3 = { done: false, faulty: false };
    const dummyResolvedPromise = { then: /* @__PURE__ */ __name((f) => f(), "then") };
    let resolveSequenceTask = /* @__PURE__ */ __name(() => {
    }, "resolveSequenceTask");
    const sequenceTask = new Promise((resolve3) => resolveSequenceTask = resolve3);
    sequenceBuilders.reduce((previouslyScheduled, item) => {
      const [builder, label, metadata] = typeof item === "function" ? [item, item.name, void 0] : [item.builder, item.label, item.metadata];
      return previouslyScheduled.then(() => {
        const scheduled = this.scheduleInternal("sequence", label, dummyResolvedPromise, metadata, customAct || defaultSchedulerAct, () => builder());
        scheduled.catch(() => {
          status3.faulty = true;
          resolveSequenceTask();
        });
        return scheduled;
      });
    }, dummyResolvedPromise).then(() => {
      status3.done = true;
      resolveSequenceTask();
    }, () => {
    });
    return Object.assign(status3, {
      task: Promise.resolve(sequenceTask).then(() => {
        return { done: status3.done, faulty: status3.faulty };
      })
    });
  }
  count() {
    return this.scheduledTasks.length;
  }
  internalWaitOne() {
    if (this.scheduledTasks.length === 0) {
      throw new Error("No task scheduled");
    }
    const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
    const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
    return scheduledTask.customAct(async () => {
      scheduledTask.trigger();
      try {
        await scheduledTask.scheduled;
      } catch (_err) {
      }
    });
  }
  async waitOne(customAct) {
    const waitAct = customAct || defaultSchedulerAct;
    await this.act(() => waitAct(async () => await this.internalWaitOne()));
  }
  async waitAll(customAct) {
    while (this.scheduledTasks.length > 0) {
      await this.waitOne(customAct);
    }
  }
  async waitFor(unscheduledTask, customAct) {
    let taskResolved = false;
    let awaiterPromise = null;
    const awaiter = /* @__PURE__ */ __name(async () => {
      while (!taskResolved && this.scheduledTasks.length > 0) {
        await this.waitOne(customAct);
      }
      awaiterPromise = null;
    }, "awaiter");
    const handleNotified = /* @__PURE__ */ __name(() => {
      if (awaiterPromise !== null) {
        return;
      }
      awaiterPromise = Promise.resolve().then(awaiter);
    }, "handleNotified");
    const clearAndReplaceWatcher = /* @__PURE__ */ __name(() => {
      const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);
      if (handleNotifiedIndex !== -1) {
        this.scheduledWatchers.splice(handleNotifiedIndex, 1);
      }
      if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) {
        this.scheduledWatchers[0]();
      }
    }, "clearAndReplaceWatcher");
    const rewrappedTask = unscheduledTask.then((ret) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        return ret;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        return ret;
      });
    }, (err) => {
      taskResolved = true;
      if (awaiterPromise === null) {
        clearAndReplaceWatcher();
        throw err;
      }
      return awaiterPromise.then(() => {
        clearAndReplaceWatcher();
        throw err;
      });
    });
    if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) {
      handleNotified();
    }
    this.scheduledWatchers.push(handleNotified);
    return rewrappedTask;
  }
  report() {
    return [
      ...this.triggeredTasks,
      ...this.scheduledTasks.map((t) => ({
        status: "pending",
        schedulingType: t.schedulingType,
        taskId: t.taskId,
        label: t.label,
        metadata: t.metadata
      }))
    ];
  }
  toString() {
    return "schedulerFor()`\n" + this.report().map(_SchedulerImplem.buildLog).map((log8) => `-> ${log8}`).join("\n") + "`";
  }
  [cloneMethod]() {
    return new _SchedulerImplem(this.act, this.sourceTaskSelector);
  }
};

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/SchedulerArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigInt64Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/bigUint64Array.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/stringMatching.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/SanitizeRegexAst.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeRegex.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ReadRegex.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TokenizerBlockMode;
(function(TokenizerBlockMode2) {
  TokenizerBlockMode2[TokenizerBlockMode2["Full"] = 0] = "Full";
  TokenizerBlockMode2[TokenizerBlockMode2["Character"] = 1] = "Character";
})(TokenizerBlockMode || (TokenizerBlockMode = {}));

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/TokenizeRegex.js
var safeStringFromCodePoint2 = String.fromCodePoint;

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/stringMatching.js
var safeStringFromCodePoint3 = String.fromCodePoint;
var wordChars = [..."abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_"];
var digitChars = [..."0123456789"];
var spaceChars = [..." 	\r\n\v\f"];
var newLineChars = [..."\r\n"];
var terminatorChars = [...""];
var newLineAndTerminatorChars = [...newLineChars, ...terminatorChars];
var defaultChar = char();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/limitShrink.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/LimitedShrinkArbitrary.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/fast-check@3.23.2/node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ZipIterableIterators.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schema/errors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schema/util.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getKeysForIndexSignature = /* @__PURE__ */ __name((input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
}, "getKeysForIndexSignature");
var memoizeThunk = /* @__PURE__ */ __name((f) => {
  let done12 = false;
  let a;
  return () => {
    if (done12) {
      return a;
    }
    a = f();
    done12 = true;
    return a;
  };
}, "memoizeThunk");
var isNonEmpty6 = /* @__PURE__ */ __name((x) => Array.isArray(x), "isNonEmpty");
var isSingle = /* @__PURE__ */ __name((x) => !Array.isArray(x), "isSingle");
var formatPathKey = /* @__PURE__ */ __name((key) => `[${formatPropertyKey(key)}]`, "formatPathKey");
var formatPath = /* @__PURE__ */ __name((path) => isNonEmpty6(path) ? path.map(formatPathKey).join("") : formatPathKey(path), "formatPath");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = /* @__PURE__ */ __name((reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `
at path: ${formatPath(path)}`;
  }
  if (details !== void 0) {
    out += `
details: ${details}`;
  }
  if (ast) {
    out += `
schema (${ast._tag}): ${ast}`;
  }
  return out;
}, "getErrorMessage");
var getInvalidArgumentErrorMessage = /* @__PURE__ */ __name((details) => getErrorMessage("Invalid Argument", details), "getInvalidArgumentErrorMessage");
var getUnsupportedSchemaErrorMessage = /* @__PURE__ */ __name((details, path, ast) => getErrorMessage("Unsupported schema", details, path, ast), "getUnsupportedSchemaErrorMessage");
var getEquivalenceUnsupportedErrorMessage = /* @__PURE__ */ __name((ast, path) => getUnsupportedSchemaErrorMessage("Cannot build an Equivalence", path, ast), "getEquivalenceUnsupportedErrorMessage");
var getSchemaExtendErrorMessage = /* @__PURE__ */ __name((x, y, path) => getErrorMessage("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path), "getSchemaExtendErrorMessage");
var getSchemaUnsupportedLiteralSpanErrorMessage = /* @__PURE__ */ __name((ast) => getErrorMessage("Unsupported template literal span", void 0, void 0, ast), "getSchemaUnsupportedLiteralSpanErrorMessage");
var getASTUnsupportedSchemaErrorMessage = /* @__PURE__ */ __name((ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast), "getASTUnsupportedSchemaErrorMessage");
var getASTUnsupportedKeySchemaErrorMessage = /* @__PURE__ */ __name((ast) => getErrorMessage("Unsupported key schema", void 0, void 0, ast), "getASTUnsupportedKeySchemaErrorMessage");
var getASTUnsupportedLiteralErrorMessage = /* @__PURE__ */ __name((literal2) => getErrorMessage("Unsupported literal", `literal value: ${formatUnknown(literal2)}`), "getASTUnsupportedLiteralErrorMessage");
var getASTDuplicateIndexSignatureErrorMessage = /* @__PURE__ */ __name((type3) => getErrorMessage("Duplicate index signature", `${type3} index signature`), "getASTDuplicateIndexSignatureErrorMessage");
var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage = /* @__PURE__ */ __name((key) => getErrorMessage("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`), "getASTDuplicatePropertySignatureTransformationErrorMessage");
var getASTUnsupportedRenameSchemaErrorMessage = /* @__PURE__ */ __name((ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast), "getASTUnsupportedRenameSchemaErrorMessage");
var getASTDuplicatePropertySignatureErrorMessage = /* @__PURE__ */ __name((key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`), "getASTDuplicatePropertySignatureErrorMessage");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/schema/schemaId.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
var GreaterThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThan");
var GreaterThanOrEqualToSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
var LessThanSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThan");
var LessThanOrEqualToSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualTo");
var IntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");
var NonNaNSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/NonNaN");
var FiniteSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Finite");
var JsonNumberSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/JsonNumber");
var BetweenSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Between");
var GreaterThanBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigint");
var GreaterThanOrEqualToBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualToBigint");
var LessThanBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigint");
var LessThanOrEqualToBigIntSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanOrEqualToBigint");
var BetweenBigintSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigint");
var MinLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinLength");
var MaxLengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxLength");
var LengthSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Length");
var MinItemsSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MinItems");
var MaxItemsSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MaxItems");
var ItemsCountSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ItemsCount");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ParseResult.js
var ParseResult_exports = {};
__export(ParseResult_exports, {
  ArrayFormatter: () => ArrayFormatter,
  Composite: () => Composite2,
  Forbidden: () => Forbidden,
  Missing: () => Missing,
  ParseError: () => ParseError2,
  ParseErrorTypeId: () => ParseErrorTypeId2,
  Pointer: () => Pointer,
  Refinement: () => Refinement2,
  Transformation: () => Transformation2,
  TreeFormatter: () => TreeFormatter,
  Type: () => Type2,
  Unexpected: () => Unexpected,
  asserts: () => asserts,
  decode: () => decode5,
  decodeEither: () => decodeEither,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise,
  decodeSync: () => decodeSync,
  decodeUnknown: () => decodeUnknown2,
  decodeUnknownEither: () => decodeUnknownEither,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise,
  decodeUnknownSync: () => decodeUnknownSync,
  eitherOrUndefined: () => eitherOrUndefined,
  encode: () => encode4,
  encodeEither: () => encodeEither,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise,
  encodeSync: () => encodeSync,
  encodeUnknown: () => encodeUnknown,
  encodeUnknownEither: () => encodeUnknownEither,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise,
  encodeUnknownSync: () => encodeUnknownSync,
  fail: () => fail13,
  flatMap: () => flatMap17,
  fromOption: () => fromOption5,
  getFinalTransformation: () => getFinalTransformation,
  getLiterals: () => getLiterals,
  getOption: () => getOption3,
  getRefinementExpected: () => getRefinementExpected,
  getSearchTree: () => getSearchTree,
  is: () => is,
  isComposite: () => isComposite2,
  isParseError: () => isParseError,
  map: () => map26,
  mapBoth: () => mapBoth6,
  mapError: () => mapError6,
  mergeInternalOptions: () => mergeInternalOptions,
  orElse: () => orElse10,
  parseError: () => parseError,
  succeed: () => succeed14,
  try: () => _try,
  validate: () => validate4,
  validateEither: () => validateEither,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise,
  validateSync: () => validateSync
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/SchemaAST.js
var SchemaAST_exports = {};
__export(SchemaAST_exports, {
  AnyKeyword: () => AnyKeyword,
  ArbitraryAnnotationId: () => ArbitraryAnnotationId,
  AutoTitleAnnotationId: () => AutoTitleAnnotationId,
  BatchingAnnotationId: () => BatchingAnnotationId,
  BigIntKeyword: () => BigIntKeyword,
  BooleanKeyword: () => BooleanKeyword,
  BrandAnnotationId: () => BrandAnnotationId,
  ComposeTransformation: () => ComposeTransformation,
  ConcurrencyAnnotationId: () => ConcurrencyAnnotationId,
  Declaration: () => Declaration,
  DecodingFallbackAnnotationId: () => DecodingFallbackAnnotationId,
  DefaultAnnotationId: () => DefaultAnnotationId,
  DescriptionAnnotationId: () => DescriptionAnnotationId,
  DocumentationAnnotationId: () => DocumentationAnnotationId,
  Enums: () => Enums,
  EquivalenceAnnotationId: () => EquivalenceAnnotationId,
  ExamplesAnnotationId: () => ExamplesAnnotationId,
  FinalTransformation: () => FinalTransformation,
  IdentifierAnnotationId: () => IdentifierAnnotationId,
  IndexSignature: () => IndexSignature,
  JSONIdentifierAnnotationId: () => JSONIdentifierAnnotationId,
  JSONSchemaAnnotationId: () => JSONSchemaAnnotationId,
  Literal: () => Literal,
  MessageAnnotationId: () => MessageAnnotationId,
  MissingMessageAnnotationId: () => MissingMessageAnnotationId,
  NeverKeyword: () => NeverKeyword,
  NumberKeyword: () => NumberKeyword,
  ObjectKeyword: () => ObjectKeyword,
  OptionalType: () => OptionalType,
  ParseIssueTitleAnnotationId: () => ParseIssueTitleAnnotationId,
  ParseJsonSchemaId: () => ParseJsonSchemaId,
  ParseOptionsAnnotationId: () => ParseOptionsAnnotationId,
  PrettyAnnotationId: () => PrettyAnnotationId,
  PropertySignature: () => PropertySignature,
  PropertySignatureTransformation: () => PropertySignatureTransformation,
  Refinement: () => Refinement,
  SchemaIdAnnotationId: () => SchemaIdAnnotationId,
  StableFilterAnnotationId: () => StableFilterAnnotationId,
  StringKeyword: () => StringKeyword,
  SurrogateAnnotationId: () => SurrogateAnnotationId,
  Suspend: () => Suspend,
  SymbolKeyword: () => SymbolKeyword,
  TemplateLiteral: () => TemplateLiteral,
  TemplateLiteralSpan: () => TemplateLiteralSpan,
  TitleAnnotationId: () => TitleAnnotationId,
  Transformation: () => Transformation,
  TupleType: () => TupleType,
  Type: () => Type,
  TypeConstructorAnnotationId: () => TypeConstructorAnnotationId,
  TypeLiteral: () => TypeLiteral,
  TypeLiteralTransformation: () => TypeLiteralTransformation,
  UndefinedKeyword: () => UndefinedKeyword,
  Union: () => Union,
  UniqueSymbol: () => UniqueSymbol,
  UnknownKeyword: () => UnknownKeyword,
  VoidKeyword: () => VoidKeyword,
  annotations: () => annotations,
  anyKeyword: () => anyKeyword,
  bigIntKeyword: () => bigIntKeyword,
  booleanKeyword: () => booleanKeyword,
  compose: () => compose3,
  composeTransformation: () => composeTransformation,
  defaultParseOption: () => defaultParseOption,
  encodedAST: () => encodedAST,
  encodedBoundAST: () => encodedBoundAST,
  equals: () => equals5,
  flatten: () => flatten12,
  getAnnotation: () => getAnnotation,
  getAutoTitleAnnotation: () => getAutoTitleAnnotation,
  getBatchingAnnotation: () => getBatchingAnnotation,
  getBrandAnnotation: () => getBrandAnnotation,
  getCompiler: () => getCompiler,
  getConcurrencyAnnotation: () => getConcurrencyAnnotation,
  getDecodingFallbackAnnotation: () => getDecodingFallbackAnnotation,
  getDefaultAnnotation: () => getDefaultAnnotation,
  getDescriptionAnnotation: () => getDescriptionAnnotation,
  getDocumentationAnnotation: () => getDocumentationAnnotation,
  getEncodedParameter: () => getEncodedParameter,
  getExamplesAnnotation: () => getExamplesAnnotation,
  getIdentifierAnnotation: () => getIdentifierAnnotation,
  getJSONIdentifier: () => getJSONIdentifier,
  getJSONIdentifierAnnotation: () => getJSONIdentifierAnnotation,
  getJSONSchemaAnnotation: () => getJSONSchemaAnnotation,
  getMessageAnnotation: () => getMessageAnnotation,
  getMissingMessageAnnotation: () => getMissingMessageAnnotation,
  getNumberIndexedAccess: () => getNumberIndexedAccess,
  getParseIssueTitleAnnotation: () => getParseIssueTitleAnnotation,
  getParseOptionsAnnotation: () => getParseOptionsAnnotation,
  getPropertyKeyIndexedAccess: () => getPropertyKeyIndexedAccess,
  getPropertySignatures: () => getPropertySignatures,
  getSchemaIdAnnotation: () => getSchemaIdAnnotation,
  getSurrogateAnnotation: () => getSurrogateAnnotation,
  getTemplateLiteralCapturingRegExp: () => getTemplateLiteralCapturingRegExp,
  getTemplateLiteralRegExp: () => getTemplateLiteralRegExp,
  getTitleAnnotation: () => getTitleAnnotation,
  getTransformationFrom: () => getTransformationFrom,
  getTypeConstructorAnnotation: () => getTypeConstructorAnnotation,
  hasStableFilter: () => hasStableFilter,
  isAnyKeyword: () => isAnyKeyword,
  isBigIntKeyword: () => isBigIntKeyword,
  isBooleanKeyword: () => isBooleanKeyword,
  isComposeTransformation: () => isComposeTransformation,
  isDeclaration: () => isDeclaration,
  isEnums: () => isEnums,
  isFinalTransformation: () => isFinalTransformation,
  isLiteral: () => isLiteral,
  isMembers: () => isMembers,
  isNeverKeyword: () => isNeverKeyword,
  isNumberKeyword: () => isNumberKeyword,
  isObjectKeyword: () => isObjectKeyword,
  isParameter: () => isParameter,
  isRefinement: () => isRefinement,
  isStringKeyword: () => isStringKeyword,
  isSuspend: () => isSuspend,
  isSymbolKeyword: () => isSymbolKeyword,
  isTemplateLiteral: () => isTemplateLiteral,
  isTransformation: () => isTransformation,
  isTupleType: () => isTupleType,
  isTypeLiteral: () => isTypeLiteral,
  isTypeLiteralTransformation: () => isTypeLiteralTransformation,
  isUndefinedKeyword: () => isUndefinedKeyword,
  isUnion: () => isUnion,
  isUniqueSymbol: () => isUniqueSymbol,
  isUnknownKeyword: () => isUnknownKeyword,
  isVoidKeyword: () => isVoidKeyword,
  keyof: () => keyof,
  mapMembers: () => mapMembers,
  mutable: () => mutable,
  neverKeyword: () => neverKeyword,
  null: () => $null,
  numberKeyword: () => numberKeyword,
  objectKeyword: () => objectKeyword,
  omit: () => omit3,
  omitAnnotations: () => omitAnnotations,
  orUndefined: () => orUndefined,
  partial: () => partial,
  pick: () => pick3,
  pickAnnotations: () => pickAnnotations,
  pruneUndefined: () => pruneUndefined,
  record: () => record2,
  rename: () => rename,
  required: () => required,
  stringKeyword: () => stringKeyword,
  symbolKeyword: () => symbolKeyword,
  typeAST: () => typeAST,
  undefinedKeyword: () => undefinedKeyword,
  unify: () => unify,
  unknownKeyword: () => unknownKeyword,
  voidKeyword: () => voidKeyword
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeConstructorAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/TypeConstructor");
var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some3(annotated.annotations[key]) : none2());
var getTypeConstructorAnnotation = /* @__PURE__ */ getAnnotation(TypeConstructorAnnotationId);
var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
var getSchemaIdAnnotation = /* @__PURE__ */ getAnnotation(SchemaIdAnnotationId);
var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
var getExamplesAnnotation = /* @__PURE__ */ getAnnotation(ExamplesAnnotationId);
var getDefaultAnnotation = /* @__PURE__ */ getAnnotation(DefaultAnnotationId);
var getJSONSchemaAnnotation = /* @__PURE__ */ getAnnotation(JSONSchemaAnnotationId);
var getDocumentationAnnotation = /* @__PURE__ */ getAnnotation(DocumentationAnnotationId);
var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
var hasStableFilter = /* @__PURE__ */ __name((annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true), "hasStableFilter");
var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = /* @__PURE__ */ __name((annotated) => orElse2(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated)), "getJSONIdentifier");
var ParseJsonSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/ParseJson");
var Declaration = class {
  static {
    __name(this, "Declaration");
  }
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown4, encodeUnknown3, annotations3 = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown4;
    this.encodeUnknown = encodeUnknown3;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => "<declaration schema>");
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var createASTGuard = /* @__PURE__ */ __name((tag8) => (ast) => ast._tag === tag8, "createASTGuard");
var isDeclaration = /* @__PURE__ */ createASTGuard("Declaration");
var Literal = class {
  static {
    __name(this, "Literal");
  }
  literal;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Literal";
  constructor(literal2, annotations3 = {}) {
    this.literal = literal2;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatUnknown(this.literal));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
var $null = /* @__PURE__ */ new Literal(null);
var UniqueSymbol = class {
  static {
    __name(this, "UniqueSymbol");
  }
  symbol;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UniqueSymbol";
  constructor(symbol6, annotations3 = {}) {
    this.symbol = symbol6;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatUnknown(this.symbol));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isUniqueSymbol = /* @__PURE__ */ createASTGuard("UniqueSymbol");
var UndefinedKeyword = class {
  static {
    __name(this, "UndefinedKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UndefinedKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
var isUndefinedKeyword = /* @__PURE__ */ createASTGuard("UndefinedKeyword");
var VoidKeyword = class {
  static {
    __name(this, "VoidKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "VoidKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var voidKeyword = /* @__PURE__ */ new VoidKeyword({
  [TitleAnnotationId]: "void"
});
var isVoidKeyword = /* @__PURE__ */ createASTGuard("VoidKeyword");
var NeverKeyword = class {
  static {
    __name(this, "NeverKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NeverKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var neverKeyword = /* @__PURE__ */ new NeverKeyword({
  [TitleAnnotationId]: "never"
});
var isNeverKeyword = /* @__PURE__ */ createASTGuard("NeverKeyword");
var UnknownKeyword = class {
  static {
    __name(this, "UnknownKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "UnknownKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
var isUnknownKeyword = /* @__PURE__ */ createASTGuard("UnknownKeyword");
var AnyKeyword = class {
  static {
    __name(this, "AnyKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "AnyKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var anyKeyword = /* @__PURE__ */ new AnyKeyword({
  [TitleAnnotationId]: "any"
});
var isAnyKeyword = /* @__PURE__ */ createASTGuard("AnyKeyword");
var StringKeyword = class {
  static {
    __name(this, "StringKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "StringKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var stringKeyword = /* @__PURE__ */ new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
var NumberKeyword = class {
  static {
    __name(this, "NumberKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "NumberKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var numberKeyword = /* @__PURE__ */ new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
var isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");
var BooleanKeyword = class {
  static {
    __name(this, "BooleanKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BooleanKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
var isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");
var BigIntKeyword = class {
  static {
    __name(this, "BigIntKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "BigIntKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
var isBigIntKeyword = /* @__PURE__ */ createASTGuard("BigIntKeyword");
var SymbolKeyword = class {
  static {
    __name(this, "SymbolKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "SymbolKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
var ObjectKeyword = class {
  static {
    __name(this, "ObjectKeyword");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "ObjectKeyword";
  constructor(annotations3 = {}) {
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return formatKeyword(this);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
var isObjectKeyword = /* @__PURE__ */ createASTGuard("ObjectKeyword");
var Enums = class {
  static {
    __name(this, "Enums");
  }
  enums;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Enums";
  constructor(enums, annotations3 = {}) {
    this.enums = enums;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map(([_, value6]) => JSON.stringify(value6)).join(" | ")}>`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isEnums = /* @__PURE__ */ createASTGuard("Enums");
var isTemplateLiteralSpanType = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "Literal":
    case "NumberKeyword":
    case "StringKeyword":
    case "TemplateLiteral":
      return true;
    case "Union":
      return ast.types.every(isTemplateLiteralSpanType);
  }
  return false;
}, "isTemplateLiteralSpanType");
var templateLiteralSpanUnionTypeToString = /* @__PURE__ */ __name((type3) => {
  switch (type3._tag) {
    case "Literal":
      return JSON.stringify(String(type3.literal));
    case "StringKeyword":
      return "string";
    case "NumberKeyword":
      return "number";
    case "TemplateLiteral":
      return String(type3);
    case "Union":
      return type3.types.map(templateLiteralSpanUnionTypeToString).join(" | ");
  }
}, "templateLiteralSpanUnionTypeToString");
var templateLiteralSpanTypeToString = /* @__PURE__ */ __name((type3) => {
  switch (type3._tag) {
    case "Literal":
      return String(type3.literal);
    case "StringKeyword":
      return "${string}";
    case "NumberKeyword":
      return "${number}";
    case "TemplateLiteral":
      return "${" + String(type3) + "}";
    case "Union":
      return "${" + type3.types.map(templateLiteralSpanUnionTypeToString).join(" | ") + "}";
  }
}, "templateLiteralSpanTypeToString");
var TemplateLiteralSpan = class {
  static {
    __name(this, "TemplateLiteralSpan");
  }
  literal;
  /**
   * @since 3.10.0
   */
  type;
  constructor(type3, literal2) {
    this.literal = literal2;
    if (isTemplateLiteralSpanType(type3)) {
      this.type = type3;
    } else {
      throw new Error(getSchemaUnsupportedLiteralSpanErrorMessage(type3));
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return templateLiteralSpanTypeToString(this.type) + this.literal;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
};
var TemplateLiteral = class {
  static {
    __name(this, "TemplateLiteral");
  }
  head;
  spans;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TemplateLiteral";
  constructor(head13, spans, annotations3 = {}) {
    this.head = head13;
    this.spans = spans;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTemplateLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map((span4) => span4.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTemplateLiteral = /* @__PURE__ */ __name((ast) => "`" + ast.head + ast.spans.map(String).join("") + "`", "formatTemplateLiteral");
var isTemplateLiteral = /* @__PURE__ */ createASTGuard("TemplateLiteral");
var Type = class {
  static {
    __name(this, "Type");
  }
  type;
  annotations;
  constructor(type3, annotations3 = {}) {
    this.type = type3;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type);
  }
};
var OptionalType = class extends Type {
  static {
    __name(this, "OptionalType");
  }
  isOptional;
  constructor(type3, isOptional, annotations3 = {}) {
    super(type3, annotations3);
    this.isOptional = isOptional;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
};
var getRestASTs = /* @__PURE__ */ __name((rest) => rest.map((annotatedAST) => annotatedAST.type), "getRestASTs");
var TupleType = class {
  static {
    __name(this, "TupleType");
  }
  elements;
  rest;
  isReadonly;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations3 = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations3;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTuple(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatTuple = /* @__PURE__ */ __name((ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: /* @__PURE__ */ __name(() => `readonly [${formattedElements}]`, "onEmpty"),
    onNonEmpty: /* @__PURE__ */ __name((head13, tail3) => {
      const formattedHead = String(head13);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail3.length > 0) {
        const formattedTail = tail3.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }, "onNonEmpty")
  });
}, "formatTuple");
var isTupleType = /* @__PURE__ */ createASTGuard("TupleType");
var PropertySignature = class extends OptionalType {
  static {
    __name(this, "PropertySignature");
  }
  name;
  isReadonly;
  constructor(name, type3, isOptional, isReadonly, annotations3) {
    super(type3, isOptional, annotations3);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isParameter = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
}, "isParameter");
var IndexSignature = class {
  static {
    __name(this, "IndexSignature");
  }
  type;
  isReadonly;
  /**
   * @since 3.10.0
   */
  parameter;
  constructor(parameter, type3, isReadonly) {
    this.type = type3;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
};
var TypeLiteral = class {
  static {
    __name(this, "TypeLiteral");
  }
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteral";
  /**
   * @since 3.10.0
   */
  propertySignatures;
  /**
   * @since 3.10.0
   */
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations3 = {}) {
    this.annotations = annotations3;
    const keys6 = {};
    for (let i = 0; i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys6, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys6[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0; i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => formatTypeLiteral(this));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var formatIndexSignatures = /* @__PURE__ */ __name((iss) => iss.map(String).join("; "), "formatIndexSignatures");
var formatTypeLiteral = /* @__PURE__ */ __name((ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
}, "formatTypeLiteral");
var isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput3(Order2, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten12 = /* @__PURE__ */ __name((candidates) => flatMap3(candidates, (ast) => isUnion(ast) ? flatten12(ast.types) : [ast]), "flatten");
var unify = /* @__PURE__ */ __name((candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      // uniques
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type3 = typeof ast.literal;
        switch (type3) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type3];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          // null
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
}, "unify");
var Union = class _Union {
  static {
    __name(this, "Union");
  }
  types;
  annotations;
  static make = /* @__PURE__ */ __name((types, annotations3) => {
    return isMembers(types) ? new _Union(types, annotations3) : types.length === 1 ? types[0] : neverKeyword;
  }, "make");
  /** @internal */
  static unify = /* @__PURE__ */ __name((candidates, annotations3) => {
    return _Union.make(unify(flatten12(candidates)), annotations3);
  }, "unify");
  /**
   * @since 3.10.0
   */
  _tag = "Union";
  constructor(types, annotations3 = {}) {
    this.types = types;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => this.types.map(String).join(" | "));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var mapMembers = /* @__PURE__ */ __name((members, f) => members.map(f), "mapMembers");
var isMembers = /* @__PURE__ */ __name((as16) => as16.length > 1, "isMembers");
var isUnion = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
var Suspend = class {
  static {
    __name(this, "Suspend");
  }
  f;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Suspend";
  constructor(f, annotations3 = {}) {
    this.f = f;
    this.annotations = annotations3;
    this.f = memoizeThunk(f);
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getExpected(this).pipe(orElse2(() => flatMap2(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse2(() => "<suspended schema>"));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
};
var isSuspend = /* @__PURE__ */ createASTGuard("Suspend");
var Refinement = class {
  static {
    __name(this, "Refinement");
  }
  from;
  filter;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(from, filter18, annotations3 = {}) {
    this.from = from;
    this.filter = filter18;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse2(() => match2(getOrElseExpected(this), {
      onNone: /* @__PURE__ */ __name(() => `{ ${this.from} | filter }`, "onNone"),
      onSome: /* @__PURE__ */ __name((expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected, "onSome")
    })));
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
var defaultParseOption = {};
var Transformation = class {
  static {
    __name(this, "Transformation");
  }
  from;
  to;
  transformation;
  annotations;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(from, to, transformation, annotations3 = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations3;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return getOrElse2(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
};
var isTransformation = /* @__PURE__ */ createASTGuard("Transformation");
var FinalTransformation = class {
  static {
    __name(this, "FinalTransformation");
  }
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "FinalTransformation";
  constructor(decode9, encode8) {
    this.decode = decode9;
    this.encode = encode8;
  }
};
var createTransformationGuard = /* @__PURE__ */ __name((tag8) => (ast) => ast._tag === tag8, "createTransformationGuard");
var isFinalTransformation = /* @__PURE__ */ createTransformationGuard("FinalTransformation");
var ComposeTransformation = class {
  static {
    __name(this, "ComposeTransformation");
  }
  /**
   * @since 3.10.0
   */
  _tag = "ComposeTransformation";
};
var composeTransformation = /* @__PURE__ */ new ComposeTransformation();
var isComposeTransformation = /* @__PURE__ */ createTransformationGuard("ComposeTransformation");
var PropertySignatureTransformation = class {
  static {
    __name(this, "PropertySignatureTransformation");
  }
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode9, encode8) {
    this.from = from;
    this.to = to;
    this.decode = decode9;
    this.encode = encode8;
  }
};
var isRenamingPropertySignatureTransformation = /* @__PURE__ */ __name((t) => t.decode === identity && t.encode === identity, "isRenamingPropertySignatureTransformation");
var TypeLiteralTransformation = class {
  static {
    __name(this, "TypeLiteralTransformation");
  }
  propertySignatureTransformations;
  /**
   * @since 3.10.0
   */
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
      }
      toKeys[to] = true;
    }
  }
};
var isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
var annotations = /* @__PURE__ */ __name((ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const base = {
    ...ast.annotations
  };
  delete base[IdentifierAnnotationId];
  const value6 = {
    ...base,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value6[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value6;
  return Object.create(Object.getPrototypeOf(ast), d);
}, "annotations");
var keyof = /* @__PURE__ */ __name((ast) => Union.unify(_keyof(ast)), "keyof");
var STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = /* @__PURE__ */ __name((type3, capture2) => {
  switch (type3._tag) {
    case "Literal":
      return escape(String(type3.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type3, capture2, false);
    case "Union":
      return type3.types.map((type4) => getTemplateLiteralSpanTypePattern(type4, capture2)).join("|");
  }
}, "getTemplateLiteralSpanTypePattern");
var handleTemplateLiteralSpanTypeParens = /* @__PURE__ */ __name((type3, s, capture2, top) => {
  if (isUnion(type3)) {
    if (capture2 && !top) {
      return `(?:${s})`;
    }
  } else if (!capture2 || !top) {
    return s;
  }
  return `(${s})`;
}, "handleTemplateLiteralSpanTypeParens");
var getTemplateLiteralPattern = /* @__PURE__ */ __name((ast, capture2, top) => {
  let pattern2 = ``;
  if (ast.head !== "") {
    const head13 = escape(ast.head);
    pattern2 += capture2 && top ? `(${head13})` : head13;
  }
  for (const span4 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span4.type, capture2);
    pattern2 += handleTemplateLiteralSpanTypeParens(span4.type, spanPattern, capture2, top);
    if (span4.literal !== "") {
      const literal2 = escape(span4.literal);
      pattern2 += capture2 && top ? `(${literal2})` : literal2;
    }
  }
  return pattern2;
}, "getTemplateLiteralPattern");
var getTemplateLiteralRegExp = /* @__PURE__ */ __name((ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}$`), "getTemplateLiteralRegExp");
var getTemplateLiteralCapturingRegExp = /* @__PURE__ */ __name((ast) => new RegExp(`^${getTemplateLiteralPattern(ast, true, true)}$`), "getTemplateLiteralCapturingRegExp");
var getPropertySignatures = /* @__PURE__ */ __name((ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertySignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.slice();
    case "Suspend":
      return getPropertySignatures(ast.f());
    case "Refinement":
      return getPropertySignatures(ast.from);
  }
  return getPropertyKeys(ast).map((name) => getPropertyKeyIndexedAccess(ast, name));
}, "getPropertySignatures");
var getIndexSignatures = /* @__PURE__ */ __name((ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getIndexSignatures(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.indexSignatures.slice();
    case "Suspend":
      return getIndexSignatures(ast.f());
    case "Refinement":
      return getIndexSignatures(ast.from);
  }
  return [];
}, "getIndexSignatures");
var getNumberIndexedAccess = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "TupleType": {
      let hasOptional = false;
      let out = [];
      for (const e of ast.elements) {
        if (e.isOptional) {
          hasOptional = true;
        }
        out.push(e.type);
      }
      if (hasOptional) {
        out.push(undefinedKeyword);
      }
      out = out.concat(getRestASTs(ast.rest));
      return Union.make(out);
    }
    case "Refinement":
      return getNumberIndexedAccess(ast.from);
    case "Union":
      return Union.make(ast.types.map(getNumberIndexedAccess));
    case "Suspend":
      return getNumberIndexedAccess(ast.f());
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
}, "getNumberIndexedAccess");
var getTypeLiteralPropertySignature = /* @__PURE__ */ __name((ast, name) => {
  const ops = findFirst2(ast.propertySignatures, (ps) => ps.name === name);
  if (isSome2(ops)) {
    return ops.value;
  }
  if (isString(name)) {
    let out = void 0;
    for (const is4 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is4.parameter);
      switch (encodedParameter._tag) {
        case "TemplateLiteral": {
          const regex = getTemplateLiteralRegExp(encodedParameter);
          if (regex.test(name)) {
            return new PropertySignature(name, is4.type, false, true);
          }
          break;
        }
        case "StringKeyword": {
          if (out === void 0) {
            out = new PropertySignature(name, is4.type, false, true);
          }
        }
      }
    }
    if (out) {
      return out;
    }
  } else if (isSymbol(name)) {
    for (const is4 of ast.indexSignatures) {
      const encodedParameter = getEncodedParameter(is4.parameter);
      if (isSymbolKeyword(encodedParameter)) {
        return new PropertySignature(name, is4.type, false, true);
      }
    }
  }
}, "getTypeLiteralPropertySignature");
var getPropertyKeyIndexedAccess = /* @__PURE__ */ __name((ast, name) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeyIndexedAccess(annotation.value, name);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const ps = getTypeLiteralPropertySignature(ast, name);
      if (ps) {
        return ps;
      }
      break;
    }
    case "Union":
      return new PropertySignature(name, Union.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess(ast2, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess(ast.f(), name);
    case "Refinement":
      return getPropertyKeyIndexedAccess(ast.from, name);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
}, "getPropertyKeyIndexedAccess");
var getPropertyKeys = /* @__PURE__ */ __name((ast) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return getPropertyKeys(annotation.value);
  }
  switch (ast._tag) {
    case "TypeLiteral":
      return ast.propertySignatures.map((ps) => ps.name);
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection(out, getPropertyKeys(ast2)), getPropertyKeys(ast.types[0]));
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Refinement":
      return getPropertyKeys(ast.from);
    case "Transformation":
      return getPropertyKeys(ast.to);
  }
  return [];
}, "getPropertyKeys");
var record2 = /* @__PURE__ */ __name((key, value6) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go3 = /* @__PURE__ */ __name((key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature(key2, value6, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature(key2.literal, value6, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_, name] of key2.enums) {
          propertySignatures.push(new PropertySignature(name, value6, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature(key2.symbol, value6, false, true));
        break;
      case "Union":
        key2.types.forEach(go3);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
    }
  }, "go");
  go3(key);
  return {
    propertySignatures,
    indexSignatures
  };
}, "record");
var pick3 = /* @__PURE__ */ __name((ast, keys6) => {
  const annotation = getSurrogateAnnotation(ast);
  if (isSome2(annotation)) {
    return pick3(annotation.value, keys6);
  }
  switch (ast._tag) {
    case "TypeLiteral": {
      const pss = [];
      const names = {};
      for (const ps of ast.propertySignatures) {
        names[ps.name] = null;
        if (keys6.includes(ps.name)) {
          pss.push(ps);
        }
      }
      for (const key of keys6) {
        if (!(key in names)) {
          const ps = getTypeLiteralPropertySignature(ast, key);
          if (ps) {
            pss.push(ps);
          }
        }
      }
      return new TypeLiteral(pss, []);
    }
    case "Union":
      return new TypeLiteral(keys6.map((name) => getPropertyKeyIndexedAccess(ast, name)), []);
    case "Suspend":
      return pick3(ast.f(), keys6);
    case "Refinement":
      return pick3(ast.from, keys6);
    case "Transformation": {
      switch (ast.transformation._tag) {
        case "ComposeTransformation":
          return new Transformation(pick3(ast.from, keys6), pick3(ast.to, keys6), composeTransformation);
        case "TypeLiteralTransformation": {
          const ts = [];
          const fromKeys = [];
          for (const k of keys6) {
            const t = ast.transformation.propertySignatureTransformations.find((t2) => t2.to === k);
            if (t) {
              ts.push(t);
              fromKeys.push(t.from);
            } else {
              fromKeys.push(k);
            }
          }
          return isNonEmptyReadonlyArray(ts) ? new Transformation(pick3(ast.from, fromKeys), pick3(ast.to, keys6), new TypeLiteralTransformation(ts)) : pick3(ast.from, fromKeys);
        }
      }
    }
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
}, "pick");
var omit3 = /* @__PURE__ */ __name((ast, keys6) => {
  let indexSignatures = getIndexSignatures(ast);
  if (indexSignatures.length > 0) {
    if (indexSignatures.some((is4) => isStringKeyword(getEncodedParameter(is4.parameter)))) {
      indexSignatures = indexSignatures.filter((is4) => !isTemplateLiteral(getEncodedParameter(is4.parameter)));
    }
    return new TypeLiteral([], indexSignatures);
  }
  return pick3(ast, getPropertyKeys(ast).filter((name) => !keys6.includes(name)));
}, "omit");
var orUndefined = /* @__PURE__ */ __name((ast) => Union.make([ast, undefinedKeyword]), "orUndefined");
var partial = /* @__PURE__ */ __name((ast, options4) => {
  const exact = options4?.exact === true;
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(exact ? e.type : orUndefined(e.type), true)), match3(ast.rest, {
        onEmpty: /* @__PURE__ */ __name(() => ast.rest, "onEmpty"),
        onNonEmpty: /* @__PURE__ */ __name((rest) => [new Type(Union.make([...getRestASTs(rest), undefinedKeyword]))], "onNonEmpty")
      }), ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((ps) => new PropertySignature(ps.name, exact ? ps.type : orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is4) => new IndexSignature(is4.parameter, orUndefined(is4.type), is4.isReadonly)));
    case "Union":
      return Union.make(ast.types.map((member) => partial(member, options4)));
    case "Suspend":
      return new Suspend(() => partial(ast.f(), options4));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(partial(ast.from, options4), partial(ast.to, options4), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
}, "partial");
var required = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "TupleType":
      return new TupleType(ast.elements.map((e) => new OptionalType(e.type, false)), ast.rest, ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral(ast.propertySignatures.map((f) => new PropertySignature(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return Union.make(ast.types.map((member) => required(member)));
    case "Suspend":
      return new Suspend(() => required(ast.f()));
    case "Declaration":
    case "Refinement":
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation(required(ast.from), required(ast.to), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
    }
  }
  return ast;
}, "required");
var mutable = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => is4.isReadonly === false ? is4 : new IndexSignature(is4.parameter, is4.type, false));
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, mutable);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => mutable(ast.f()), ast.annotations);
    case "Refinement": {
      const from = mutable(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const from = mutable(ast.from);
      const to = mutable(ast.to);
      return from === ast.from && to === ast.to ? ast : new Transformation(from, to, ast.transformation, ast.annotations);
    }
  }
  return ast;
}, "mutable");
var getCompiler = /* @__PURE__ */ __name((match24) => {
  const compile = /* @__PURE__ */ __name((ast, path) => match24[ast._tag](ast, compile, path), "compile");
  return compile;
}, "getCompiler");
var pickAnnotations = /* @__PURE__ */ __name((annotationIds) => (annotated) => {
  let out = void 0;
  for (const id4 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id4)) {
      if (out === void 0) {
        out = {};
      }
      out[id4] = annotated.annotations[id4];
    }
  }
  return out;
}, "pickAnnotations");
var omitAnnotations = /* @__PURE__ */ __name((annotationIds) => (annotated) => {
  const out = {
    ...annotated.annotations
  };
  for (const id4 of annotationIds) {
    delete out[id4];
  }
  return out;
}, "omitAnnotations");
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type3 = typeAST(e.type);
        return type3 === e.type ? e : new OptionalType(type3, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type3) => new Type(type3)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type3 = typeAST(p.type);
        return type3 === p.type ? p : new PropertySignature(p.name, type3, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => {
        const type3 = typeAST(is4.type);
        return type3 === is4.type ? is4 : new IndexSignature(is4.parameter, type3, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== void 0 ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
}, "typeAST");
function changeMap(as16, f) {
  let changed = false;
  const out = allocate(as16.length);
  for (let i = 0; i < as16.length; i++) {
    const a = as16[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as16;
}
__name(changeMap, "changeMap");
var getTransformationFrom = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
}, "getTransformationFrom");
var encodedAST_ = /* @__PURE__ */ __name((ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type3 = encodedAST_(e.type, isBound);
        return type3 === e.type ? e : new OptionalType(type3, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type3 = encodedAST_(ps.type, isBound);
        return type3 === ps.type ? ps : new PropertySignature(ps.name, type3, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is4) => {
        const type3 = encodedAST_(is4.type, isBound);
        return type3 === is4.type ? is4 : new IndexSignature(is4.parameter, type3, is4.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types);
    }
    case "Suspend": {
      let borrowedAnnotations = void 0;
      const identifier2 = getJSONIdentifier(ast);
      if (isSome2(identifier2)) {
        const suffix = isBound ? "Bound" : "";
        borrowedAnnotations = {
          [JSONIdentifierAnnotationId]: `${identifier2.value}Encoded${suffix}`
        };
      }
      return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
    }
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) return ast;
        if (getTransformationFrom(ast.from) === void 0 && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
        return from;
      } else {
        return from;
      }
    }
    case "Transformation":
      return encodedAST_(ast.from, isBound);
  }
  return ast;
}, "encodedAST_");
var encodedAST = /* @__PURE__ */ __name((ast) => encodedAST_(ast, false), "encodedAST");
var encodedBoundAST = /* @__PURE__ */ __name((ast) => encodedAST_(ast, true), "encodedBoundAST");
var toJSONAnnotations = /* @__PURE__ */ __name((annotations3) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations3)) {
    out[String(k)] = annotations3[k];
  }
  return out;
}, "toJSONAnnotations");
var getEncodedParameter = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
}, "getEncodedParameter");
var equals5 = /* @__PURE__ */ __name((self2, that) => {
  switch (self2._tag) {
    case "Literal":
      return isLiteral(that) && that.literal === self2.literal;
    case "UniqueSymbol":
      return isUniqueSymbol(that) && that.symbol === self2.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self2._tag;
    case "TemplateLiteral":
      return isTemplateLiteral(that) && that.head === self2.head && equalsTemplateLiteralSpan(that.spans, self2.spans);
    case "Enums":
      return isEnums(that) && equalsEnums(that.enums, self2.enums);
    case "Union":
      return isUnion(that) && equalsUnion(self2.types, that.types);
    case "Refinement":
    case "TupleType":
    case "TypeLiteral":
    case "Suspend":
    case "Transformation":
    case "Declaration":
      return self2 === that;
  }
}, "equals");
var equalsTemplateLiteralSpan = /* @__PURE__ */ getEquivalence4((self2, that) => {
  return self2.literal === that.literal && equals5(self2.type, that.type);
});
var equalsEnums = /* @__PURE__ */ getEquivalence4((self2, that) => that[0] === self2[0] && that[1] === self2[1]);
var equalsUnion = /* @__PURE__ */ getEquivalence4(equals5);
var intersection5 = /* @__PURE__ */ intersectionWith(equals5);
var _keyof = /* @__PURE__ */ __name((ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return _keyof(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((p) => isSymbol(p.name) ? new UniqueSymbol(p.name) : new Literal(p.name)).concat(ast.indexSignatures.map((is4) => getEncodedParameter(is4.parameter)));
    case "Suspend":
      return _keyof(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection5(out, _keyof(ast2)), _keyof(ast.types[0]));
    case "Transformation":
      return _keyof(ast.to);
  }
  throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
}, "_keyof");
var compose3 = /* @__PURE__ */ __name((ab, cd) => new Transformation(ab, cd, composeTransformation), "compose");
var rename = /* @__PURE__ */ __name((ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      const propertySignatureTransformations = [];
      for (const key of Reflect.ownKeys(mapping)) {
        const name = mapping[key];
        if (name !== void 0) {
          propertySignatureTransformations.push(new PropertySignatureTransformation(key, name, identity, identity));
        }
      }
      if (propertySignatureTransformations.length === 0) {
        return ast;
      }
      return new Transformation(ast, new TypeLiteral(ast.propertySignatures.map((ps) => {
        const name = mapping[ps.name];
        return new PropertySignature(name === void 0 ? ps.name : name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
      }), ast.indexSignatures), new TypeLiteralTransformation(propertySignatureTransformations));
    }
    case "Union":
      return Union.make(ast.types.map((ast2) => rename(ast2, mapping)));
    case "Suspend":
      return new Suspend(() => rename(ast.f(), mapping));
    case "Transformation":
      return compose3(ast, rename(typeAST(ast), mapping));
  }
  throw new Error(getASTUnsupportedRenameSchemaErrorMessage(ast));
}, "rename");
var formatKeyword = /* @__PURE__ */ __name((ast) => getOrElse2(getExpected(ast), () => ast._tag), "formatKeyword");
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: /* @__PURE__ */ __name(() => "", "onNone"),
    onSome: /* @__PURE__ */ __name((brands) => brands.map((brand2) => ` & Brand<${formatUnknown(brand2)}>`).join(""), "onSome")
  });
}
__name(getBrands, "getBrands");
var getOrElseExpected = /* @__PURE__ */ __name((ast) => getTitleAnnotation(ast).pipe(orElse2(() => getDescriptionAnnotation(ast)), orElse2(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast))), "getOrElseExpected");
var getExpected = /* @__PURE__ */ __name((ast) => orElse2(getIdentifierAnnotation(ast), () => getOrElseExpected(ast)), "getExpected");
var pruneUndefined = /* @__PURE__ */ __name((ast, self2, onTransformation) => {
  switch (ast._tag) {
    case "UndefinedKeyword":
      return neverKeyword;
    case "Union": {
      const types = [];
      let hasUndefined2 = false;
      for (const type3 of ast.types) {
        const pruned = self2(type3);
        if (pruned) {
          hasUndefined2 = true;
          if (!isNeverKeyword(pruned)) {
            types.push(pruned);
          }
        } else {
          types.push(type3);
        }
      }
      if (hasUndefined2) {
        return Union.make(types);
      }
      break;
    }
    case "Suspend":
      return self2(ast.f());
    case "Transformation":
      return onTransformation(ast);
  }
}, "pruneUndefined");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/ParseResult.js
var Pointer = class {
  static {
    __name(this, "Pointer");
  }
  path;
  actual;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
};
var Unexpected = class {
  static {
    __name(this, "Unexpected");
  }
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
};
var Missing = class {
  static {
    __name(this, "Missing");
  }
  ast;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Missing";
  /**
   * @since 3.10.0
   */
  actual = void 0;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
};
var Composite2 = class {
  static {
    __name(this, "Composite");
  }
  ast;
  actual;
  issues;
  output;
  /**
   * @since 3.10.0
   */
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
};
var Refinement2 = class {
  static {
    __name(this, "Refinement");
  }
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Transformation2 = class {
  static {
    __name(this, "Transformation");
  }
  ast;
  actual;
  kind;
  issue;
  /**
   * @since 3.10.0
   */
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
};
var Type2 = class {
  static {
    __name(this, "Type");
  }
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var Forbidden = class {
  static {
    __name(this, "Forbidden");
  }
  ast;
  actual;
  message;
  /**
   * @since 3.10.0
   */
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
};
var ParseErrorTypeId2 = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
var isParseError = /* @__PURE__ */ __name((u) => hasProperty(u, ParseErrorTypeId2), "isParseError");
var ParseError2 = class extends (/* @__PURE__ */ TaggedError("ParseError")) {
  static {
    __name(this, "ParseError");
  }
  /**
   * @since 3.10.0
   */
  [ParseErrorTypeId2] = ParseErrorTypeId2;
  get message() {
    return this.toString();
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  /**
   * @since 3.10.0
   */
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  /**
   * @since 3.10.0
   */
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var parseError = /* @__PURE__ */ __name((issue) => new ParseError2({
  issue
}), "parseError");
var succeed14 = right2;
var fail13 = left2;
var _try = try_;
var fromOption5 = fromOption2;
var isEither3 = isEither2;
var flatMap17 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? match(self2, {
    onLeft: left2,
    onRight: f
  }) : flatMap15(self2, f);
});
var map26 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? map(self2, f) : map22(self2, f);
});
var mapError6 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? mapLeft(self2, f) : mapError4(self2, f);
});
var eitherOrUndefined = /* @__PURE__ */ __name((self2) => {
  if (isEither3(self2)) {
    return self2;
  }
}, "eitherOrUndefined");
var mapBoth6 = /* @__PURE__ */ dual(2, (self2, options4) => {
  return isEither3(self2) ? mapBoth(self2, {
    onLeft: options4.onFailure,
    onRight: options4.onSuccess
  }) : mapBoth5(self2, options4);
});
var orElse10 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither3(self2) ? match(self2, {
    onLeft: f,
    onRight: right2
  }) : catchAll3(self2, f);
});
var mergeInternalOptions = /* @__PURE__ */ __name((options4, overrideOptions) => {
  if (overrideOptions === void 0 || isNumber(overrideOptions)) {
    return options4;
  }
  if (options4 === void 0) {
    return overrideOptions;
  }
  return {
    ...options4,
    ...overrideOptions
  };
}, "mergeInternalOptions");
var getEither = /* @__PURE__ */ __name((ast, isDecoding, options4) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options4, overrideOptions));
}, "getEither");
var getSync = /* @__PURE__ */ __name((ast, isDecoding, options4) => {
  const parser = getEither(ast, isDecoding, options4);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
}, "getSync");
var getOption3 = /* @__PURE__ */ __name((ast, isDecoding, options4) => {
  const parser = getEither(ast, isDecoding, options4);
  return (input, overrideOptions) => getRight3(parser(input, overrideOptions));
}, "getOption");
var getEffect = /* @__PURE__ */ __name((ast, isDecoding, options4) => {
  const parser = goMemo(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions(options4, overrideOptions),
    isEffectAllowed: true
  });
}, "getEffect");
var decodeUnknownSync = /* @__PURE__ */ __name((schema4, options4) => getSync(schema4.ast, true, options4), "decodeUnknownSync");
var decodeUnknownOption = /* @__PURE__ */ __name((schema4, options4) => getOption3(schema4.ast, true, options4), "decodeUnknownOption");
var decodeUnknownEither = /* @__PURE__ */ __name((schema4, options4) => getEither(schema4.ast, true, options4), "decodeUnknownEither");
var decodeUnknownPromise = /* @__PURE__ */ __name((schema4, options4) => {
  const parser = decodeUnknown2(schema4, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "decodeUnknownPromise");
var decodeUnknown2 = /* @__PURE__ */ __name((schema4, options4) => getEffect(schema4.ast, true, options4), "decodeUnknown");
var encodeUnknownSync = /* @__PURE__ */ __name((schema4, options4) => getSync(schema4.ast, false, options4), "encodeUnknownSync");
var encodeUnknownOption = /* @__PURE__ */ __name((schema4, options4) => getOption3(schema4.ast, false, options4), "encodeUnknownOption");
var encodeUnknownEither = /* @__PURE__ */ __name((schema4, options4) => getEither(schema4.ast, false, options4), "encodeUnknownEither");
var encodeUnknownPromise = /* @__PURE__ */ __name((schema4, options4) => {
  const parser = encodeUnknown(schema4, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "encodeUnknownPromise");
var encodeUnknown = /* @__PURE__ */ __name((schema4, options4) => getEffect(schema4.ast, false, options4), "encodeUnknown");
var decodeSync = decodeUnknownSync;
var decodeOption = decodeUnknownOption;
var decodeEither = decodeUnknownEither;
var decodePromise = decodeUnknownPromise;
var decode5 = decodeUnknown2;
var validateSync = /* @__PURE__ */ __name((schema4, options4) => getSync(typeAST(schema4.ast), true, options4), "validateSync");
var validateOption = /* @__PURE__ */ __name((schema4, options4) => getOption3(typeAST(schema4.ast), true, options4), "validateOption");
var validateEither = /* @__PURE__ */ __name((schema4, options4) => getEither(typeAST(schema4.ast), true, options4), "validateEither");
var validatePromise = /* @__PURE__ */ __name((schema4, options4) => {
  const parser = validate4(schema4, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "validatePromise");
var validate4 = /* @__PURE__ */ __name((schema4, options4) => getEffect(typeAST(schema4.ast), true, options4), "validate");
var is = /* @__PURE__ */ __name((schema4, options4) => {
  const parser = goMemo(typeAST(schema4.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions(options4, overrideOptions)
  }));
}, "is");
var asserts = /* @__PURE__ */ __name((schema4, options4) => {
  const parser = goMemo(typeAST(schema4.ast), true);
  return (u, overrideOptions) => {
    const result = parser(u, {
      exact: true,
      ...mergeInternalOptions(options4, overrideOptions)
    });
    if (isLeft2(result)) {
      throw parseError(result.left);
    }
  };
}, "asserts");
var encodeSync = encodeUnknownSync;
var encodeOption = encodeUnknownOption;
var encodeEither = encodeUnknownEither;
var encodePromise = encodeUnknownPromise;
var encode4 = encodeUnknown;
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
var goMemo = /* @__PURE__ */ __name((ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo2 = memoMap.get(ast);
  if (memo2) {
    return memo2;
  }
  const raw3 = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options4) => raw3(i, mergeInternalOptions(options4, parseOptionsAnnotation.value)) : raw3;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options4) => handleForbidden(orElse10(parserWithOptions(i, options4), decodingFallbackAnnotation.value), ast, i, options4) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
}, "goMemo");
var getConcurrency = /* @__PURE__ */ __name((ast) => getOrUndefined2(getConcurrencyAnnotation(ast)), "getConcurrency");
var getBatching = /* @__PURE__ */ __name((ast) => getOrUndefined2(getBatchingAnnotation(ast)), "getBatching");
var go = /* @__PURE__ */ __name((ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options4) => {
          options4 = options4 ?? defaultParseOption;
          const allErrors = options4?.errors === "all";
          const result = flatMap17(orElse10(from(i, options4), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options4, ast), {
                onNone: /* @__PURE__ */ __name(() => left2(issue), "onNone"),
                onSome: /* @__PURE__ */ __name((ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)])), "onSome")
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options4, ast), {
            onNone: /* @__PURE__ */ __name(() => right2(a), "onNone"),
            onSome: /* @__PURE__ */ __name((ep) => left2(new Refinement2(ast, i, "Predicate", ep)), "onSome")
          }));
          return handleForbidden(result, ast, i, options4);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options4) => handleForbidden(flatMap17(from(i, options4), (a) => to(a, options4)), ast, i, options4);
      }
    }
    case "Transformation": {
      const transform5 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options4) => handleForbidden(flatMap17(mapError6(from(i, options4), (e) => new Transformation2(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap17(mapError6(transform5(a, options4 ?? defaultParseOption, ast, i), (e) => new Transformation2(ast, i, "Transformation", e)), (i2) => mapError6(to(i2, options4), (e) => new Transformation2(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options4);
    }
    case "Declaration": {
      const parse5 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options4) => handleForbidden(parse5(i, options4 ?? defaultParseOption, ast), ast, i, options4);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value6]) => value6 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options4) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options4?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len; i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = void 0;
        for (; i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options4);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index2 = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap15(either4(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index2, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head13, ...tail3] = rest;
          for (; i < len - tail3.length; i++) {
            const te = head13(input[i], options4);
            if (isEither3(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index2 = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap15(either4(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index2, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0; j < tail3.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail3[j](input[i], options4);
              if (isEither3(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index2 = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap15(either4(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index2, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = /* @__PURE__ */ __name(({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2)), "computeResult");
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state2 = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap15(forEach11(cqueue, (f) => f(state2), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state2));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is4) => [goMemo(is4.parameter, isDecoding), goMemo(is4.type, isDecoding), is4.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is4) => is4.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options4) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options4?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options4?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options4?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = Reflect.ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options4);
            if (isEither3(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = void 0;
        const isExact = options4?.exact === true;
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options4);
          if (isEither3(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te.right;
          } else {
            const nk = stepKey++;
            const index2 = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap15(either4(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index2, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index2] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0; i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type3 = indexSignature[1];
          const keys6 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys6) {
            const keu = parameter(key, options4);
            if (isEither3(keu) && isRight2(keu)) {
              const vpr = type3(input[key], options4);
              if (isEither3(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index2 = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap15(either4(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index2, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = /* @__PURE__ */ __name(({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options4?.propertyOrder === "original") {
            const keys6 = inputKeys || Reflect.ownKeys(input);
            for (const name of expectedKeys) {
              if (keys6.indexOf(name) === -1) {
                keys6.push(name);
              }
            }
            const out = {};
            for (const key of keys6) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        }, "computeResult");
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state2 = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap15(forEach11(cqueue, (f) => f(state2), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state2));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys = Reflect.ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys.length;
      const astTypesLen = ast.types.length;
      const map38 = /* @__PURE__ */ new Map();
      for (let i = 0; i < astTypesLen; i++) {
        map38.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options4) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0; i < ownKeysLen; i++) {
              const name = ownKeys[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = void 0;
        for (let i = 0; i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map38.get(candidate)(input, options4);
          if (isEither3(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state2) => suspend4(() => {
              if ("finalResult" in state2) {
                return _void;
              } else {
                return flatMap15(either4(pr), (t) => {
                  if (isRight2(t)) {
                    state2.finalResult = t;
                  } else {
                    state2.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = /* @__PURE__ */ __name((es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : (
          // this should never happen
          left2(new Type2(ast, input))
        ), "computeResult");
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend4(() => {
            const state2 = {
              es: copy(es)
            };
            return flatMap15(forEach11(cqueue, (f) => f(state2), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state2) {
                return state2.finalResult;
              }
              return computeResult(state2.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get29 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
      return (a, options4) => get29()(a, options4);
    }
  }
}, "go");
var fromRefinement = /* @__PURE__ */ __name((ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u)), "fromRefinement");
var getLiterals = /* @__PURE__ */ __name((ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0; i < ast.propertySignatures.length; i++) {
        const propertySignature2 = ast.propertySignatures[i];
        const type3 = isDecoding ? encodedAST(propertySignature2.type) : typeAST(propertySignature2.type);
        if (isLiteral(type3) && !propertySignature2.isOptional) {
          out.push([propertySignature2.name, type3]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0; i < ast.elements.length; i++) {
        const element2 = ast.elements[i];
        const type3 = isDecoding ? encodedAST(element2.type) : typeAST(element2.type);
        if (isLiteral(type3) && !element2.isOptional) {
          out.push([i, type3]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
}, "getLiterals");
var getSearchTree = /* @__PURE__ */ __name((members, isDecoding) => {
  const keys6 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0; i < members.length; i++) {
    const member = members[i];
    const tags3 = getLiterals(member, isDecoding);
    if (tags3.length > 0) {
      candidates.push(member);
      for (let j = 0; j < tags3.length; j++) {
        const [key, literal2] = tags3[j];
        const hash5 = String(literal2.literal);
        keys6[key] = keys6[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys6[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash5)) {
          if (j < tags3.length - 1) {
            continue;
          }
          buckets[hash5].push(member);
          keys6[key].literals.push(literal2);
          keys6[key].candidates.push(member);
        } else {
          buckets[hash5] = [member];
          keys6[key].literals.push(literal2);
          keys6[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys6,
    otherwise,
    candidates
  };
}, "getSearchTree");
var dropRightRefinement = /* @__PURE__ */ __name((ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast, "dropRightRefinement");
var handleForbidden = /* @__PURE__ */ __name((effect4, ast, actual, options4) => {
  if (options4?.isEffectAllowed === true) {
    return effect4;
  }
  if (isEither3(effect4)) {
    return effect4;
  }
  const scheduler2 = new SyncScheduler();
  const fiber = runFork2(effect4, {
    scheduler: scheduler2
  });
  scheduler2.flush();
  const exit5 = fiber.unsafePoll();
  if (exit5) {
    if (isSuccess2(exit5)) {
      return right2(exit5.value);
    }
    const cause3 = exit5.cause;
    if (isFailType2(cause3)) {
      return left2(cause3.error);
    }
    return left2(new Forbidden(ast, actual, pretty3(cause3)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
}, "handleForbidden");
var compare = /* @__PURE__ */ __name(([a], [b]) => a > b ? 1 : a < b ? -1 : 0, "compare");
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
__name(sortByIndex, "sortByIndex");
var getFinalTransformation = /* @__PURE__ */ __name((transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = /* @__PURE__ */ __name((input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some3(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          }, "f");
          out = map26(out, f);
        }
        return out;
      };
  }
}, "getFinalTransformation");
var makeTree = /* @__PURE__ */ __name((value6, forest = []) => ({
  value: value6,
  forest
}), "makeTree");
var TreeFormatter = {
  formatIssue: /* @__PURE__ */ __name((issue) => map26(formatTree(issue), drawTree), "formatIssue"),
  formatIssueSync: /* @__PURE__ */ __name((issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither3(e) ? getOrThrow(e) : runSync(e);
  }, "formatIssueSync"),
  formatError: /* @__PURE__ */ __name((error5) => TreeFormatter.formatIssue(error5.issue), "formatError"),
  formatErrorSync: /* @__PURE__ */ __name((error5) => TreeFormatter.formatIssueSync(error5.issue), "formatErrorSync")
};
var drawTree = /* @__PURE__ */ __name((tree) => tree.value + draw("\n", tree.forest), "drawTree");
var draw = /* @__PURE__ */ __name((indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0; i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
}, "draw");
var formatTransformationKind = /* @__PURE__ */ __name((kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
}, "formatTransformationKind");
var formatRefinementKind = /* @__PURE__ */ __name((kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
}, "formatRefinementKind");
var getAnnotated = /* @__PURE__ */ __name((issue) => "ast" in issue ? some3(issue.ast) : none2(), "getAnnotated");
var Either_void = /* @__PURE__ */ right2(void 0);
var getCurrentMessage = /* @__PURE__ */ __name((issue) => getAnnotated(issue).pipe(flatMap2(getMessageAnnotation), match2({
  onNone: /* @__PURE__ */ __name(() => Either_void, "onNone"),
  onSome: /* @__PURE__ */ __name((messageAnnotation) => {
    const union12 = messageAnnotation(issue);
    if (isString(union12)) {
      return right2({
        message: union12,
        override: false
      });
    }
    if (isEffect2(union12)) {
      return map22(union12, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union12.message)) {
      return right2({
        message: union12.message,
        override: union12.override
      });
    }
    return map22(union12.message, (message) => ({
      message,
      override: union12.override
    }));
  }, "onSome")
})), "getCurrentMessage");
var createParseIssueGuard = /* @__PURE__ */ __name((tag8) => (issue) => issue._tag === tag8, "createParseIssueGuard");
var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation2 = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = /* @__PURE__ */ __name((issue) => flatMap17(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== void 0) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation2(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation2(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
}), "getMessage");
var getParseIssueTitleAnnotation2 = /* @__PURE__ */ __name((issue) => getAnnotated(issue).pipe(flatMap2(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined2), "getParseIssueTitleAnnotation");
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse2(() => getTitleAnnotation(ast)), orElse2(() => getAutoTitleAnnotation(ast)), orElse2(() => getIdentifierAnnotation(ast)), getOrElse2(() => `{ ${ast.from} | filter }`));
}
__name(getRefinementExpected, "getRefinementExpected");
function getDefaultTypeMessage(issue) {
  if (issue.message !== void 0) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}
__name(getDefaultTypeMessage, "getDefaultTypeMessage");
var formatTypeMessage = /* @__PURE__ */ __name((issue) => map26(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue)), "formatTypeMessage");
var getParseIssueTitle = /* @__PURE__ */ __name((issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast), "getParseIssueTitle");
var formatForbiddenMessage = /* @__PURE__ */ __name((issue) => issue.message ?? "is forbidden", "formatForbiddenMessage");
var formatUnexpectedMessage = /* @__PURE__ */ __name((issue) => issue.message ?? "is unexpected", "formatUnexpectedMessage");
var formatMissingMessage = /* @__PURE__ */ __name((issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
}, "formatMissingMessage");
var formatTree = /* @__PURE__ */ __name((issue) => {
  switch (issue._tag) {
    case "Type":
      return map26(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map26(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap17(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map26(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap17(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        return map26(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map26(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap17(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty6(issue.issues) ? map26(forEach11(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map26(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
}, "formatTree");
var makeArrayFormatterIssue = /* @__PURE__ */ __name((_tag, path, message) => ({
  _tag,
  path,
  message
}), "makeArrayFormatterIssue");
var ArrayFormatter = {
  formatIssue: /* @__PURE__ */ __name((issue) => getArrayFormatterIssues(issue, void 0, []), "formatIssue"),
  formatIssueSync: /* @__PURE__ */ __name((issue) => {
    const e = ArrayFormatter.formatIssue(issue);
    return isEither3(e) ? getOrThrow(e) : runSync(e);
  }, "formatIssueSync"),
  formatError: /* @__PURE__ */ __name((error5) => ArrayFormatter.formatIssue(error5.issue), "formatError"),
  formatErrorSync: /* @__PURE__ */ __name((error5) => ArrayFormatter.formatIssueSync(error5.issue), "formatErrorSync")
};
var getArrayFormatterIssues = /* @__PURE__ */ __name((issue, parentTag, path) => {
  const _tag = issue._tag;
  switch (_tag) {
    case "Type":
      return map26(formatTypeMessage(issue), (message) => [makeArrayFormatterIssue(parentTag ?? _tag, path, message)]);
    case "Forbidden":
      return right2([makeArrayFormatterIssue(_tag, path, formatForbiddenMessage(issue))]);
    case "Unexpected":
      return right2([makeArrayFormatterIssue(_tag, path, formatUnexpectedMessage(issue))]);
    case "Missing":
      return map26(formatMissingMessage(issue), (message) => [makeArrayFormatterIssue(_tag, path, message)]);
    case "Pointer":
      return getArrayFormatterIssues(issue.issue, void 0, path.concat(issue.path));
    case "Composite":
      return flatMap17(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return isNonEmpty6(issue.issues) ? map26(forEach11(issue.issues, (issue2) => getArrayFormatterIssues(issue2, void 0, path)), flatten2) : getArrayFormatterIssues(issue.issues, void 0, path);
      });
    case "Refinement":
      return flatMap17(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Predicate" ? _tag : void 0, path);
      });
    case "Transformation":
      return flatMap17(getMessage(issue), (message) => {
        if (message !== void 0) {
          return right2([makeArrayFormatterIssue(_tag, path, message)]);
        }
        return getArrayFormatterIssues(issue.issue, issue.kind === "Transformation" ? _tag : void 0, path);
      });
  }
}, "getArrayFormatterIssues");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Struct.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var pick4 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys6) => {
  const out = {};
  for (const k of keys6) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit4 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys6) => {
  const out = {
    ...s
  };
  for (const k of keys6) {
    delete out[k];
  }
  return out;
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Schema.js
var TypeId21 = /* @__PURE__ */ Symbol.for("effect/Schema");
function make50(ast) {
  return class SchemaClass {
    static {
      __name(this, "SchemaClass");
    }
    [TypeId21] = variance5;
    static ast = ast;
    static annotations(annotations3) {
      return make50(mergeSchemaAnnotations(this.ast, annotations3));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId21] = variance5;
  };
}
__name(make50, "make");
var variance5 = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  /* c8 ignore next */
  _I: /* @__PURE__ */ __name((_) => _, "_I"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var makeStandardResult = /* @__PURE__ */ __name((exit5) => isSuccess2(exit5) ? exit5.value : makeStandardFailureResult(pretty3(exit5.cause)), "makeStandardResult");
var makeStandardFailureResult = /* @__PURE__ */ __name((message) => ({
  issues: [{
    message
  }]
}), "makeStandardFailureResult");
var makeStandardFailureFromParseIssue = /* @__PURE__ */ __name((issue) => map22(ArrayFormatter.formatIssue(issue), (issues) => ({
  issues: issues.map((issue2) => ({
    path: issue2.path,
    message: issue2.message
  }))
})), "makeStandardFailureFromParseIssue");
var standardSchemaV1 = /* @__PURE__ */ __name((schema4, overrideOptions) => {
  const decodeUnknown4 = decodeUnknown2(schema4, {
    errors: "all"
  });
  return class StandardSchemaV1Class extends make50(schema4.ast) {
    static {
      __name(this, "StandardSchemaV1Class");
    }
    static "~standard" = {
      version: 1,
      vendor: "effect",
      validate(value6) {
        const scheduler2 = new SyncScheduler();
        const fiber = runFork2(matchEffect3(decodeUnknown4(value6, overrideOptions), {
          onFailure: makeStandardFailureFromParseIssue,
          onSuccess: /* @__PURE__ */ __name((value7) => succeed11({
            value: value7
          }), "onSuccess")
        }), {
          scheduler: scheduler2
        });
        scheduler2.flush();
        const exit5 = fiber.unsafePoll();
        if (exit5) {
          return makeStandardResult(exit5);
        }
        return new Promise((resolve3) => {
          fiber.addObserver((exit6) => {
            resolve3(makeStandardResult(exit6));
          });
        });
      }
    };
  };
}, "standardSchemaV1");
var builtInAnnotations = {
  typeConstructor: TypeConstructorAnnotationId,
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = /* @__PURE__ */ __name((annotations3) => {
  if (!annotations3) {
    return {};
  }
  const out = {
    ...annotations3
  };
  for (const key in builtInAnnotations) {
    if (key in annotations3) {
      const id4 = builtInAnnotations[key];
      out[id4] = annotations3[key];
      delete out[key];
    }
  }
  return out;
}, "toASTAnnotations");
var mergeSchemaAnnotations = /* @__PURE__ */ __name((ast, annotations3) => annotations(ast, toASTAnnotations(annotations3)), "mergeSchemaAnnotations");
function asSchema(schema4) {
  return schema4;
}
__name(asSchema, "asSchema");
var format6 = /* @__PURE__ */ __name((schema4) => String(schema4.ast), "format");
var encodedSchema = /* @__PURE__ */ __name((schema4) => make50(encodedAST(schema4.ast)), "encodedSchema");
var encodedBoundSchema = /* @__PURE__ */ __name((schema4) => make50(encodedBoundAST(schema4.ast)), "encodedBoundSchema");
var typeSchema = /* @__PURE__ */ __name((schema4) => make50(typeAST(schema4.ast)), "typeSchema");
var encodeUnknown2 = /* @__PURE__ */ __name((schema4, options4) => {
  const encodeUnknown3 = encodeUnknown(schema4, options4);
  return (u, overrideOptions) => mapError6(encodeUnknown3(u, overrideOptions), parseError);
}, "encodeUnknown");
var encodeUnknownEither2 = /* @__PURE__ */ __name((schema4, options4) => {
  const encodeUnknownEither3 = encodeUnknownEither(schema4, options4);
  return (u, overrideOptions) => mapLeft(encodeUnknownEither3(u, overrideOptions), parseError);
}, "encodeUnknownEither");
var encodeUnknownPromise2 = /* @__PURE__ */ __name((schema4, options4) => {
  const parser = encodeUnknown2(schema4, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "encodeUnknownPromise");
var encode5 = encodeUnknown2;
var encodeEither2 = encodeUnknownEither2;
var encodePromise2 = encodeUnknownPromise2;
var decodeUnknown3 = /* @__PURE__ */ __name((schema4, options4) => {
  const decodeUnknown4 = decodeUnknown2(schema4, options4);
  return (u, overrideOptions) => mapError6(decodeUnknown4(u, overrideOptions), parseError);
}, "decodeUnknown");
var decodeUnknownEither2 = /* @__PURE__ */ __name((schema4, options4) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema4, options4);
  return (u, overrideOptions) => mapLeft(decodeUnknownEither3(u, overrideOptions), parseError);
}, "decodeUnknownEither");
var decodeUnknownPromise2 = /* @__PURE__ */ __name((schema4, options4) => {
  const parser = decodeUnknown3(schema4, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "decodeUnknownPromise");
var decode6 = decodeUnknown3;
var decodeEither2 = decodeUnknownEither2;
var decodePromise2 = decodeUnknownPromise2;
var validate5 = /* @__PURE__ */ __name((schema4, options4) => {
  const validate6 = validate4(schema4, options4);
  return (u, overrideOptions) => mapError6(validate6(u, overrideOptions), parseError);
}, "validate");
var validateEither2 = /* @__PURE__ */ __name((schema4, options4) => {
  const validateEither3 = validateEither(schema4, options4);
  return (u, overrideOptions) => mapLeft(validateEither3(u, overrideOptions), parseError);
}, "validateEither");
var validatePromise2 = /* @__PURE__ */ __name((schema4, options4) => {
  const parser = validate5(schema4, options4);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
}, "validatePromise");
var isSchema = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId21) && isObject(u[TypeId21]), "isSchema");
function getDefaultLiteralAST(literals) {
  return isMembers(literals) ? Union.make(mapMembers(literals, (literal2) => new Literal(literal2))) : new Literal(literals[0]);
}
__name(getDefaultLiteralAST, "getDefaultLiteralAST");
function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
  return class LiteralClass extends make50(ast) {
    static {
      __name(this, "LiteralClass");
    }
    static annotations(annotations3) {
      return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static literals = [...literals];
  };
}
__name(makeLiteralClass, "makeLiteralClass");
function Literal2(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
}
__name(Literal2, "Literal");
var pickLiteral = /* @__PURE__ */ __name((...literals) => (_schema) => Literal2(...literals), "pickLiteral");
var UniqueSymbolFromSelf = /* @__PURE__ */ __name((symbol6) => make50(new UniqueSymbol(symbol6)), "UniqueSymbolFromSelf");
var getDefaultEnumsAST = /* @__PURE__ */ __name((enums) => new Enums(Object.keys(enums).filter((key) => typeof enums[enums[key]] !== "number").map((key) => [key, enums[key]])), "getDefaultEnumsAST");
var makeEnumsClass = /* @__PURE__ */ __name((enums, ast = getDefaultEnumsAST(enums)) => class EnumsClass extends make50(ast) {
  static {
    __name(this, "EnumsClass");
  }
  static annotations(annotations3) {
    return makeEnumsClass(this.enums, mergeSchemaAnnotations(this.ast, annotations3));
  }
  static enums = {
    ...enums
  };
}, "makeEnumsClass");
var Enums2 = /* @__PURE__ */ __name((enums) => makeEnumsClass(enums), "Enums");
var TemplateLiteral2 = /* @__PURE__ */ __name((...[head13, ...tail3]) => {
  const spans = [];
  let h = "";
  let ts = tail3;
  if (isSchema(head13)) {
    if (isLiteral(head13.ast)) {
      h = String(head13.ast.literal);
    } else {
      ts = [head13, ...ts];
    }
  } else {
    h = String(head13);
  }
  for (let i = 0; i < ts.length; i++) {
    const item = ts[i];
    if (isSchema(item)) {
      if (i < ts.length - 1) {
        const next4 = ts[i + 1];
        if (isSchema(next4)) {
          if (isLiteral(next4.ast)) {
            spans.push(new TemplateLiteralSpan(item.ast, String(next4.ast.literal)));
            i++;
            continue;
          }
        } else {
          spans.push(new TemplateLiteralSpan(item.ast, String(next4)));
          i++;
          continue;
        }
      }
      spans.push(new TemplateLiteralSpan(item.ast, ""));
    } else {
      spans.push(new TemplateLiteralSpan(new Literal(item), ""));
    }
  }
  if (isNonEmptyArray2(spans)) {
    return make50(new TemplateLiteral(h, spans));
  } else {
    return make50(new TemplateLiteral("", [new TemplateLiteralSpan(new Literal(h), "")]));
  }
}, "TemplateLiteral");
function getTemplateLiteralParserCoercedElement(encoded, schema4) {
  const ast = encoded.ast;
  switch (ast._tag) {
    case "Literal": {
      const literal2 = ast.literal;
      if (!isString(literal2)) {
        const s = String(literal2);
        return transform2(Literal2(s), schema4, {
          strict: true,
          decode: /* @__PURE__ */ __name(() => literal2, "decode"),
          encode: /* @__PURE__ */ __name(() => s, "encode")
        });
      }
      break;
    }
    case "NumberKeyword":
      return compose4(NumberFromString, schema4);
    case "Union": {
      const members = [];
      let hasCoercions = false;
      for (const member of ast.types) {
        const schema5 = make50(member);
        const encoded2 = encodedSchema(schema5);
        const coerced = getTemplateLiteralParserCoercedElement(encoded2, schema5);
        if (coerced) {
          hasCoercions = true;
        }
        members.push(coerced ?? schema5);
      }
      return hasCoercions ? compose4(Union2(...members), schema4) : schema4;
    }
  }
}
__name(getTemplateLiteralParserCoercedElement, "getTemplateLiteralParserCoercedElement");
var TemplateLiteralParser = /* @__PURE__ */ __name((...params2) => {
  const encodedSchemas = [];
  const elements = [];
  const schemas = [];
  let coerced = false;
  for (let i = 0; i < params2.length; i++) {
    const param = params2[i];
    const schema4 = isSchema(param) ? param : Literal2(param);
    schemas.push(schema4);
    const encoded = encodedSchema(schema4);
    encodedSchemas.push(encoded);
    const element2 = getTemplateLiteralParserCoercedElement(encoded, schema4);
    if (element2) {
      elements.push(element2);
      coerced = true;
    } else {
      elements.push(schema4);
    }
  }
  const from = TemplateLiteral2(...encodedSchemas);
  const re = getTemplateLiteralCapturingRegExp(from.ast);
  let to = Tuple(...elements);
  if (coerced) {
    to = to.annotations({
      [AutoTitleAnnotationId]: format6(Tuple(...schemas))
    });
  }
  return class TemplateLiteralParserClass extends transformOrFail(from, to, {
    strict: false,
    decode: /* @__PURE__ */ __name((i, _, ast) => {
      const match24 = re.exec(i);
      return match24 ? succeed14(match24.slice(1, params2.length + 1)) : fail13(new Type2(ast, i, `${re.source}: no match for ${JSON.stringify(i)}`));
    }, "decode"),
    encode: /* @__PURE__ */ __name((tuple5) => succeed14(tuple5.join("")), "encode")
  }) {
    static {
      __name(this, "TemplateLiteralParserClass");
    }
    static params = params2.slice();
  };
}, "TemplateLiteralParser");
var declareConstructor = /* @__PURE__ */ __name((typeParameters, options4, annotations3) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options4.decode(...typeParameters2.map(make50)), (...typeParameters2) => options4.encode(...typeParameters2.map(make50)), toASTAnnotations(annotations3))), "declareConstructor");
var declarePrimitive = /* @__PURE__ */ __name((is4, annotations3) => {
  const decodeUnknown4 = /* @__PURE__ */ __name(() => (input, _, ast) => is4(input) ? succeed14(input) : fail13(new Type2(ast, input)), "decodeUnknown");
  const encodeUnknown3 = decodeUnknown4;
  return makeDeclareClass([], new Declaration([], decodeUnknown4, encodeUnknown3, toASTAnnotations(annotations3)));
}, "declarePrimitive");
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make50(ast) {
    static {
      __name(this, "DeclareClass");
    }
    static annotations(annotations3) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static typeParameters = [...typeParameters];
  };
}
__name(makeDeclareClass, "makeDeclareClass");
var declare = /* @__PURE__ */ __name(function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options4 = arguments[1];
    const annotations4 = arguments[2];
    return declareConstructor(typeParameters, options4, annotations4);
  }
  const is4 = arguments[0];
  const annotations3 = arguments[1];
  return declarePrimitive(is4, annotations3);
}, "declare");
var BrandSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Brand");
var fromBrand = /* @__PURE__ */ __name((constructor, annotations3) => (self2) => {
  const out = makeBrandClass(self2, new Refinement(self2.ast, /* @__PURE__ */ __name(function predicate(a, _, ast) {
    const either12 = constructor.either(a);
    return isLeft2(either12) ? some3(new Type2(ast, a, either12.left.map((v) => v.message).join(", "))) : none2();
  }, "predicate"), toASTAnnotations({
    schemaId: BrandSchemaId,
    [BrandSchemaId]: {
      constructor
    },
    ...annotations3
  })));
  return out;
}, "fromBrand");
var InstanceOfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/InstanceOf");
var instanceOf = /* @__PURE__ */ __name((constructor, annotations3) => declare((u) => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: /* @__PURE__ */ __name(() => String, "pretty"),
  schemaId: InstanceOfSchemaId,
  [InstanceOfSchemaId]: {
    constructor
  },
  ...annotations3
}), "instanceOf");
var Undefined = class extends (/* @__PURE__ */ make50(undefinedKeyword)) {
  static {
    __name(this, "Undefined");
  }
};
var Void = class extends (/* @__PURE__ */ make50(voidKeyword)) {
  static {
    __name(this, "Void");
  }
};
var Null = class extends (/* @__PURE__ */ make50($null)) {
  static {
    __name(this, "Null");
  }
};
var Never = class extends (/* @__PURE__ */ make50(neverKeyword)) {
  static {
    __name(this, "Never");
  }
};
var Unknown = class extends (/* @__PURE__ */ make50(unknownKeyword)) {
  static {
    __name(this, "Unknown");
  }
};
var Any = class extends (/* @__PURE__ */ make50(anyKeyword)) {
  static {
    __name(this, "Any");
  }
};
var BigIntFromSelf = class extends (/* @__PURE__ */ make50(bigIntKeyword)) {
  static {
    __name(this, "BigIntFromSelf");
  }
};
var SymbolFromSelf = class extends (/* @__PURE__ */ make50(symbolKeyword)) {
  static {
    __name(this, "SymbolFromSelf");
  }
};
var String$ = class extends (/* @__PURE__ */ make50(stringKeyword)) {
  static {
    __name(this, "String$");
  }
};
var Number$ = class extends (/* @__PURE__ */ make50(numberKeyword)) {
  static {
    __name(this, "Number$");
  }
};
var Boolean$ = class extends (/* @__PURE__ */ make50(booleanKeyword)) {
  static {
    __name(this, "Boolean$");
  }
};
var Object$ = class extends (/* @__PURE__ */ make50(objectKeyword)) {
  static {
    __name(this, "Object$");
  }
};
var getDefaultUnionAST = /* @__PURE__ */ __name((members) => Union.make(members.map((m) => m.ast)), "getDefaultUnionAST");
function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
  return class UnionClass extends make50(ast) {
    static {
      __name(this, "UnionClass");
    }
    static annotations(annotations3) {
      return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static members = [...members];
  };
}
__name(makeUnionClass, "makeUnionClass");
function Union2(...members) {
  return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
}
__name(Union2, "Union");
var NullOr = /* @__PURE__ */ __name((self2) => Union2(self2, Null), "NullOr");
var UndefinedOr = /* @__PURE__ */ __name((self2) => Union2(self2, Undefined), "UndefinedOr");
var NullishOr = /* @__PURE__ */ __name((self2) => Union2(self2, Null, Undefined), "NullishOr");
var keyof2 = /* @__PURE__ */ __name((self2) => make50(keyof(self2.ast)), "keyof");
var element = /* @__PURE__ */ __name((self2) => new ElementImpl(new OptionalType(self2.ast, false), self2), "element");
var optionalElement = /* @__PURE__ */ __name((self2) => new ElementImpl(new OptionalType(self2.ast, true), self2), "optionalElement");
var ElementImpl = class _ElementImpl {
  static {
    __name(this, "ElementImpl");
  }
  ast;
  from;
  [TypeId21];
  _Token;
  constructor(ast, from) {
    this.ast = ast;
    this.from = from;
  }
  annotations(annotations3) {
    return new _ElementImpl(new OptionalType(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations(annotations3)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
};
var getDefaultTupleTypeAST = /* @__PURE__ */ __name((elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type(el.ast) : el.ast), true), "getDefaultTupleTypeAST");
function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
  return class TupleTypeClass extends make50(ast) {
    static {
      __name(this, "TupleTypeClass");
    }
    static annotations(annotations3) {
      return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static elements = [...elements];
    static rest = [...rest];
  };
}
__name(makeTupleTypeClass, "makeTupleTypeClass");
function Tuple(...args2) {
  return Array.isArray(args2[0]) ? makeTupleTypeClass(args2[0], args2.slice(1)) : makeTupleTypeClass(args2, []);
}
__name(Tuple, "Tuple");
function makeArrayClass(value6, ast) {
  return class ArrayClass extends makeTupleTypeClass([], [value6], ast) {
    static {
      __name(this, "ArrayClass");
    }
    static annotations(annotations3) {
      return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static value = value6;
  };
}
__name(makeArrayClass, "makeArrayClass");
var Array$ = /* @__PURE__ */ __name((value6) => makeArrayClass(value6), "Array$");
function makeNonEmptyArrayClass(value6, ast) {
  return class NonEmptyArrayClass extends makeTupleTypeClass([value6], [value6], ast) {
    static {
      __name(this, "NonEmptyArrayClass");
    }
    static annotations(annotations3) {
      return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static value = value6;
  };
}
__name(makeNonEmptyArrayClass, "makeNonEmptyArrayClass");
var NonEmptyArray = /* @__PURE__ */ __name((value6) => makeNonEmptyArrayClass(value6), "NonEmptyArray");
function ArrayEnsure(value6) {
  return transform2(Union2(value6, Array$(value6)), Array$(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => ensure(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => a.length === 1 ? a[0] : a, "encode")
  });
}
__name(ArrayEnsure, "ArrayEnsure");
function NonEmptyArrayEnsure(value6) {
  return transform2(Union2(value6, NonEmptyArray(value6)), NonEmptyArray(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => isNonEmptyReadonlyArray(i) ? i : of(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => a.length === 1 ? a[0] : a, "encode")
  });
}
__name(NonEmptyArrayEnsure, "NonEmptyArrayEnsure");
var formatPropertySignatureToken = /* @__PURE__ */ __name((isOptional) => isOptional ? '"?:"' : '":"', "formatPropertySignatureToken");
var PropertySignatureDeclaration = class extends OptionalType {
  static {
    __name(this, "PropertySignatureDeclaration");
  }
  isReadonly;
  defaultValue;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureDeclaration";
  constructor(type3, isOptional, isReadonly, annotations3, defaultValue) {
    super(type3, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type3 = String(this.type);
    return `PropertySignature<${token}, ${type3}, never, ${token}, ${type3}>`;
  }
};
var FromPropertySignature = class extends OptionalType {
  static {
    __name(this, "FromPropertySignature");
  }
  isReadonly;
  fromKey;
  constructor(type3, isOptional, isReadonly, annotations3, fromKey2) {
    super(type3, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.fromKey = fromKey2;
  }
};
var ToPropertySignature = class extends OptionalType {
  static {
    __name(this, "ToPropertySignature");
  }
  isReadonly;
  defaultValue;
  constructor(type3, isOptional, isReadonly, annotations3, defaultValue) {
    super(type3, isOptional, annotations3);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
};
var formatPropertyKey2 = /* @__PURE__ */ __name((p) => {
  if (p === void 0) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
}, "formatPropertyKey");
var PropertySignatureTransformation2 = class {
  static {
    __name(this, "PropertySignatureTransformation");
  }
  from;
  to;
  decode;
  encode;
  /**
   * @since 3.10.0
   */
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode9, encode8) {
    this.from = from;
    this.to = to;
    this.decode = decode9;
    this.encode = encode8;
  }
  /**
   * @since 3.10.0
   */
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey2(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
};
var mergeSignatureAnnotations = /* @__PURE__ */ __name((ast, annotations3) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations3
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations3
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
}, "mergeSignatureAnnotations");
var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
var isPropertySignature = /* @__PURE__ */ __name((u) => hasProperty(u, PropertySignatureTypeId), "isPropertySignature");
var PropertySignatureImpl = class _PropertySignatureImpl {
  static {
    __name(this, "PropertySignatureImpl");
  }
  ast;
  [TypeId21];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations3) {
    return new _PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations3)));
  }
  toString() {
    return String(this.ast);
  }
};
var makePropertySignature = /* @__PURE__ */ __name((ast) => new PropertySignatureImpl(ast), "makePropertySignature");
var PropertySignatureWithFromImpl = class _PropertySignatureWithFromImpl extends PropertySignatureImpl {
  static {
    __name(this, "PropertySignatureWithFromImpl");
  }
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations3) {
    return new _PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations3)), this.from);
  }
};
var propertySignature = /* @__PURE__ */ __name((self2) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self2.ast, false, true, {}, void 0), self2), "propertySignature");
var withConstructorDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var applyDefaultValue = /* @__PURE__ */ __name((o, defaultValue) => match2(o, {
  onNone: /* @__PURE__ */ __name(() => some3(defaultValue()), "onNone"),
  onSome: /* @__PURE__ */ __name((value6) => some3(value6 === void 0 ? defaultValue() : value6), "onSome")
}), "applyDefaultValue");
var pruneUndefined2 = /* @__PURE__ */ __name((ast) => pruneUndefined(ast, pruneUndefined2, (ast2) => {
  const pruned = pruneUndefined2(ast2.to);
  if (pruned) {
    return new Transformation(ast2.from, pruned, ast2.transformation);
  }
}), "pruneUndefined");
var withDecodingDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      const to = typeAST(ast.type);
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined2(to) ?? to, false, true, {}, ast.defaultValue), (o) => applyDefaultValue(o, defaultValue), identity));
    }
    case "PropertySignatureTransformation": {
      const to = ast.to.type;
      return makePropertySignature(new PropertySignatureTransformation2(ast.from, new ToPropertySignature(pruneUndefined2(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o) => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
    }
  }
});
var withDefaults = /* @__PURE__ */ dual(2, (self2, defaults) => self2.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
var fromKey = /* @__PURE__ */ dual(2, (self2, key) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(typeAST(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
    }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
var optionalToRequired = /* @__PURE__ */ __name((from, to, options4) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, false, true, {}, void 0), (o) => some3(options4.decode(o)), flatMap2(options4.encode))), "optionalToRequired");
var requiredToOptional = /* @__PURE__ */ __name((from, to, options4) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, false, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), flatMap2(options4.decode), (o) => some3(options4.encode(o)))), "requiredToOptional");
var optionalToOptional = /* @__PURE__ */ __name((from, to, options4) => makePropertySignature(new PropertySignatureTransformation2(new FromPropertySignature(from.ast, true, true, {}, void 0), new ToPropertySignature(to.ast, true, true, {}, void 0), options4.decode, options4.encode)), "optionalToOptional");
var optionalPropertySignatureAST = /* @__PURE__ */ __name((self2, options4) => {
  const isExact = options4?.exact;
  const defaultValue = options4?.default;
  const isNullable2 = options4?.nullable;
  const asOption = options4?.as == "Option";
  const asOptionEncode = options4?.onNoneEncoding ? orElse2(options4.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullOr(self2), typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: /* @__PURE__ */ __name((a) => a === null ? defaultValue() : a, "onSome")
          }),
          encode: some3
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(self2, typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: some3
        }), defaultValue).ast;
      }
    } else if (asOption) {
      const to = OptionFromSelf_(typeSchema(self2));
      if (isNullable2) {
        return optionalToRequired(NullOr(self2), to, {
          decode: filter(isNotNull),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(self2, to, {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullOr(self2), typeSchema(self2), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(self2.ast, true, true, {}, void 0);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullishOr(self2), typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: /* @__PURE__ */ __name((a) => a == null ? defaultValue() : a, "onSome")
          }),
          encode: some3
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(UndefinedOr(self2), typeSchema(self2), {
          decode: match2({
            onNone: defaultValue,
            onSome: /* @__PURE__ */ __name((a) => a === void 0 ? defaultValue() : a, "onSome")
          }),
          encode: some3
        }), defaultValue).ast;
      }
    } else if (asOption) {
      const to = OptionFromSelf_(typeSchema(self2));
      if (isNullable2) {
        return optionalToRequired(NullishOr(self2), to, {
          decode: filter((a) => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(UndefinedOr(self2), to, {
          decode: filter(isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullishOr(self2), UndefinedOr(typeSchema(self2)), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(self2).ast, true, true, {}, void 0);
      }
    }
  }
}, "optionalPropertySignatureAST");
var optional = /* @__PURE__ */ __name((self2) => {
  const ast = self2.ast === undefinedKeyword || self2.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self2).ast;
  return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, void 0), self2);
}, "optional");
var optionalWith = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, options4) => {
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(self2, options4), self2);
});
var preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
var getDefaultTypeLiteralAST = /* @__PURE__ */ __name((fields, records) => {
  const ownKeys = Reflect.ownKeys(fields);
  const pss = [];
  if (ownKeys.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0; i < ownKeys.length; i++) {
      const key = ownKeys[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type3 = ast.type;
            const isOptional = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature(key, type3, isOptional, true, preserveMissingMessageAnnotation(ast)));
            to.push(new PropertySignature(key, typeAST(type3), isOptional, true, toAnnotations));
            pss.push(new PropertySignature(key, type3, isOptional, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey2 = ast.from.fromKey ?? key;
            from.push(new PropertySignature(fromKey2, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation(fromKey2, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature(key, field.ast, false, true));
        to.push(new PropertySignature(key, typeAST(field.ast), false, true));
        pss.push(new PropertySignature(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record2(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is4) => {
          issFrom.push(is4);
          issTo.push(new IndexSignature(is4.parameter, typeAST(is4.type), is4.isReadonly));
        });
      }
      return new Transformation(new TypeLiteral(from, issFrom, {
        [AutoTitleAnnotationId]: "Struct (Encoded side)"
      }), new TypeLiteral(to, issTo, {
        [AutoTitleAnnotationId]: "Struct (Type side)"
      }), new TypeLiteralTransformation(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record2(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is4) => iss.push(is4));
  }
  return new TypeLiteral(pss, iss);
}, "getDefaultTypeLiteralAST");
var lazilyMergeDefaults = /* @__PURE__ */ __name((fields, out) => {
  const ownKeys = Reflect.ownKeys(fields);
  for (const key of ownKeys) {
    const field = fields[key];
    if (out[key] === void 0 && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== void 0) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
}, "lazilyMergeDefaults");
function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
  return class TypeLiteralClass extends make50(ast) {
    static {
      __name(this, "TypeLiteralClass");
    }
    static annotations(annotations3) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = /* @__PURE__ */ __name((props, options4) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options4) ? propsWithDefaults : validateSync(this)(propsWithDefaults);
    }, "make");
    static pick(...keys6) {
      return Struct(pick4(fields, ...keys6));
    }
    static omit(...keys6) {
      return Struct(omit4(fields, ...keys6));
    }
  };
}
__name(makeTypeLiteralClass, "makeTypeLiteralClass");
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
__name(Struct, "Struct");
var tag = /* @__PURE__ */ __name((tag8) => Literal2(tag8).pipe(propertySignature, withConstructorDefault(() => tag8)), "tag");
var TaggedStruct = /* @__PURE__ */ __name((value6, fields) => Struct({
  _tag: tag(value6),
  ...fields
}), "TaggedStruct");
function makeRecordClass(key, value6, ast) {
  return class RecordClass extends makeTypeLiteralClass({}, [{
    key,
    value: value6
  }], ast) {
    static {
      __name(this, "RecordClass");
    }
    static annotations(annotations3) {
      return makeRecordClass(key, value6, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static key = key;
    static value = value6;
  };
}
__name(makeRecordClass, "makeRecordClass");
var Record = /* @__PURE__ */ __name((options4) => makeRecordClass(options4.key, options4.value), "Record");
var pick5 = /* @__PURE__ */ __name((...keys6) => (self2) => make50(pick3(self2.ast, keys6)), "pick");
var omit5 = /* @__PURE__ */ __name((...keys6) => (self2) => make50(omit3(self2.ast, keys6)), "omit");
var pluck = /* @__PURE__ */ dual(2, (schema4, key) => {
  const ps = getPropertyKeyIndexedAccess(typeAST(schema4.ast), key);
  const value6 = make50(ps.isOptional ? orUndefined(ps.type) : ps.type);
  const out = transform2(schema4.pipe(pick5(key)), value6, {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => i[key], "decode"),
    encode: /* @__PURE__ */ __name((a) => ps.isOptional && a === void 0 ? {} : {
      [key]: a
    }, "encode")
  });
  return out;
});
function makeBrandClass(from, ast) {
  return class BrandClass extends make50(ast) {
    static {
      __name(this, "BrandClass");
    }
    static annotations(annotations3) {
      return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static make = /* @__PURE__ */ __name((a, options4) => {
      return getDisableValidationMakeOption(options4) ? a : validateSync(this)(a);
    }, "make");
    static from = from;
  };
}
__name(makeBrandClass, "makeBrandClass");
var brand = /* @__PURE__ */ __name((brand2, annotations3) => (self2) => {
  const annotation = match2(getBrandAnnotation(self2.ast), {
    onNone: /* @__PURE__ */ __name(() => [brand2], "onNone"),
    onSome: /* @__PURE__ */ __name((brands) => [...brands, brand2], "onSome")
  });
  const ast = annotations(self2.ast, toASTAnnotations({
    [BrandAnnotationId]: annotation,
    ...annotations3
  }));
  return makeBrandClass(self2, ast);
}, "brand");
var partial2 = /* @__PURE__ */ __name((self2) => make50(partial(self2.ast)), "partial");
var partialWith = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, options4) => make50(partial(self2.ast, options4)));
var required2 = /* @__PURE__ */ __name((self2) => make50(required(self2.ast)), "required");
var mutable2 = /* @__PURE__ */ __name((schema4) => make50(mutable(schema4.ast)), "mutable");
var intersectTypeLiterals = /* @__PURE__ */ __name((x, y, path) => {
  if (isTypeLiteral(x) && isTypeLiteral(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional,
          type: type3
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature(name, extendAST(type3, ps.type, path.concat(name)), isOptional, true);
      }
    }
    return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
}, "intersectTypeLiterals");
var preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
var addRefinementToMembers = /* @__PURE__ */ __name((refinement, asts) => asts.map((ast) => new Refinement(ast, refinement.filter, preserveRefinementAnnotations(refinement))), "addRefinementToMembers");
var extendAST = /* @__PURE__ */ __name((x, y, path) => Union.make(intersectUnionMembers([x], [y], path)), "extendAST");
var getTypes = /* @__PURE__ */ __name((ast) => isUnion(ast) ? ast.types : [ast], "getTypes");
var intersectUnionMembers = /* @__PURE__ */ __name((xs, ys, path) => flatMap3(xs, (x) => flatMap3(ys, (y) => {
  switch (y._tag) {
    case "Literal": {
      if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
        return [y];
      }
      break;
    }
    case "StringKeyword": {
      if (y === stringKeyword) {
        if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === stringKeyword) {
        return [y];
      }
      break;
    }
    case "NumberKeyword": {
      if (y === numberKeyword) {
        if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === numberKeyword) {
        return [y];
      }
      break;
    }
    case "BooleanKeyword": {
      if (y === booleanKeyword) {
        if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
          return [x];
        } else if (isRefinement(x)) {
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        }
      } else if (x === booleanKeyword) {
        return [y];
      }
      break;
    }
    case "Union":
      return intersectUnionMembers(getTypes(x), y.types, path);
    case "Suspend":
      return [new Suspend(() => extendAST(x, y.f(), path))];
    case "Refinement":
      return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
    case "TypeLiteral": {
      switch (x._tag) {
        case "Union":
          return intersectUnionMembers(x.types, [y], path);
        case "Suspend":
          return [new Suspend(() => extendAST(x.f(), y, path))];
        case "Refinement":
          return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path)];
        case "Transformation": {
          const transformation = x.transformation;
          const from = intersectTypeLiterals(x.from, y, path);
          const to = intersectTypeLiterals(x.to, typeAST(y), path);
          switch (transformation._tag) {
            case "TypeLiteralTransformation":
              return [new Transformation(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
            case "ComposeTransformation":
              return [new Transformation(from, to, composeTransformation)];
            case "FinalTransformation":
              return [new Transformation(from, to, new FinalTransformation((fromA, options4, ast, fromI) => map26(transformation.decode(fromA, options4, ast, fromI), (partial3) => ({
                ...fromA,
                ...partial3
              })), (toI, options4, ast, toA) => map26(transformation.encode(toI, options4, ast, toA), (partial3) => ({
                ...toI,
                ...partial3
              }))))];
          }
        }
      }
      break;
    }
    case "Transformation": {
      if (isTransformation(x)) {
        if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
          return [new Transformation(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
        }
      } else {
        return intersectUnionMembers([y], [x], path);
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage(x, y, path));
})), "intersectUnionMembers");
var extend4 = /* @__PURE__ */ dual(2, (self2, that) => make50(extendAST(self2.ast, that.ast, [])));
var compose4 = /* @__PURE__ */ dual((args2) => isSchema(args2[1]), (from, to) => makeTransformationClass(from, to, compose3(from.ast, to.ast)));
var suspend7 = /* @__PURE__ */ __name((f) => make50(new Suspend(() => f().ast)), "suspend");
var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
function makeRefineClass(from, filter18, ast) {
  return class RefineClass extends make50(ast) {
    static {
      __name(this, "RefineClass");
    }
    static annotations(annotations3) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter18;
    static make = /* @__PURE__ */ __name((a, options4) => {
      return getDisableValidationMakeOption(options4) ? a : validateSync(this)(a);
    }, "make");
  };
}
__name(makeRefineClass, "makeRefineClass");
var fromFilterPredicateReturnTypeItem = /* @__PURE__ */ __name((item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some3(new Type2(ast, input));
  }
  if (isString(item)) {
    return some3(new Type2(ast, input, item));
  }
  if (item !== void 0) {
    if ("_tag" in item) {
      return some3(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some3(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
}, "fromFilterPredicateReturnTypeItem");
var toFilterParseIssue = /* @__PURE__ */ __name((out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap2(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some3(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
}, "toFilterParseIssue");
function filter13(predicate, annotations3) {
  return (self2) => {
    function filter18(input, options4, ast2) {
      return toFilterParseIssue(predicate(input, options4, ast2), ast2, input);
    }
    __name(filter18, "filter");
    const ast = new Refinement(self2.ast, filter18, toASTAnnotations(annotations3));
    return makeRefineClass(self2, filter18, ast);
  };
}
__name(filter13, "filter");
var filterEffect = /* @__PURE__ */ dual(2, (self2, f) => transformOrFail(self2, typeSchema(self2), {
  strict: true,
  decode: /* @__PURE__ */ __name((i, options4, ast) => flatMap17(f(i, options4, ast), (filterReturnType) => match2(toFilterParseIssue(filterReturnType, ast, i), {
    onNone: /* @__PURE__ */ __name(() => succeed14(i), "onNone"),
    onSome: fail13
  })), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(a), "encode")
}));
function makeTransformationClass(from, to, ast) {
  return class TransformationClass extends make50(ast) {
    static {
      __name(this, "TransformationClass");
    }
    static annotations(annotations3) {
      return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations3));
    }
    static from = from;
    static to = to;
  };
}
__name(makeTransformationClass, "makeTransformationClass");
var transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options4) => makeTransformationClass(from, to, new Transformation(from.ast, to.ast, new FinalTransformation(options4.decode, options4.encode))));
var transform2 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options4) => transformOrFail(from, to, {
  strict: true,
  decode: /* @__PURE__ */ __name((fromA, _options, _ast, toA) => succeed14(options4.decode(fromA, toA)), "decode"),
  encode: /* @__PURE__ */ __name((toI, _options, _ast, toA) => succeed14(options4.encode(toI, toA)), "encode")
}));
function transformLiteral(from, to) {
  return transform2(Literal2(from), Literal2(to), {
    strict: true,
    decode: /* @__PURE__ */ __name(() => to, "decode"),
    encode: /* @__PURE__ */ __name(() => from, "encode")
  });
}
__name(transformLiteral, "transformLiteral");
function transformLiterals(...pairs) {
  return Union2(...pairs.map(([from, to]) => transformLiteral(from, to)));
}
__name(transformLiterals, "transformLiterals");
var attachPropertySignature = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (schema4, key, value6, annotations3) => {
  const ast = extend4(typeSchema(schema4), Struct({
    [key]: isSymbol(value6) ? UniqueSymbolFromSelf(value6) : Literal2(value6)
  })).ast;
  return make50(new Transformation(schema4.ast, annotations3 ? mergeSchemaAnnotations(ast, annotations3) : ast, new TypeLiteralTransformation([new PropertySignatureTransformation(key, key, () => some3(value6), () => none2())])));
});
var annotations2 = /* @__PURE__ */ dual(2, (self2, annotations3) => self2.annotations(annotations3));
var rename2 = /* @__PURE__ */ dual(2, (self2, mapping) => make50(rename(self2.ast, mapping)));
var TrimmedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Trimmed");
var trimmed = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => a === a.trim(), {
  schemaId: TrimmedSchemaId,
  title: "trimmed",
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations3
})), "trimmed");
var MaxLengthSchemaId2 = MaxLengthSchemaId;
var maxLength = /* @__PURE__ */ __name((maxLength2, annotations3) => (self2) => self2.pipe(filter13((a) => a.length <= maxLength2, {
  schemaId: MaxLengthSchemaId2,
  title: `maxLength(${maxLength2})`,
  description: `a string at most ${maxLength2} character(s) long`,
  jsonSchema: {
    maxLength: maxLength2
  },
  ...annotations3
})), "maxLength");
var MinLengthSchemaId2 = MinLengthSchemaId;
var minLength = /* @__PURE__ */ __name((minLength2, annotations3) => (self2) => self2.pipe(filter13((a) => a.length >= minLength2, {
  schemaId: MinLengthSchemaId2,
  title: `minLength(${minLength2})`,
  description: `a string at least ${minLength2} character(s) long`,
  jsonSchema: {
    minLength: minLength2
  },
  ...annotations3
})), "minLength");
var LengthSchemaId2 = LengthSchemaId;
var length4 = /* @__PURE__ */ __name((length5, annotations3) => (self2) => {
  const minLength2 = isObject(length5) ? Math.max(0, Math.floor(length5.min)) : Math.max(0, Math.floor(length5));
  const maxLength2 = isObject(length5) ? Math.max(minLength2, Math.floor(length5.max)) : minLength2;
  if (minLength2 !== maxLength2) {
    return self2.pipe(filter13((a) => a.length >= minLength2 && a.length <= maxLength2, {
      schemaId: LengthSchemaId2,
      title: `length({ min: ${minLength2}, max: ${maxLength2})`,
      description: `a string at least ${minLength2} character(s) and at most ${maxLength2} character(s) long`,
      jsonSchema: {
        minLength: minLength2,
        maxLength: maxLength2
      },
      ...annotations3
    }));
  }
  return self2.pipe(filter13((a) => a.length === minLength2, {
    schemaId: LengthSchemaId2,
    title: `length(${minLength2})`,
    description: minLength2 === 1 ? `a single character` : `a string ${minLength2} character(s) long`,
    jsonSchema: {
      minLength: minLength2,
      maxLength: minLength2
    },
    ...annotations3
  }));
}, "length");
var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
var pattern = /* @__PURE__ */ __name((regex, annotations3) => (self2) => {
  const source = regex.source;
  return self2.pipe(filter13((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    // title: `pattern(/${source}/)`, // avoiding this because it can be very long
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations3
  }));
}, "pattern");
var StartsWithSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/StartsWith");
var startsWith = /* @__PURE__ */ __name((startsWith2, annotations3) => (self2) => {
  const formatted = JSON.stringify(startsWith2);
  return self2.pipe(filter13((a) => a.startsWith(startsWith2), {
    schemaId: StartsWithSchemaId,
    [StartsWithSchemaId]: {
      startsWith: startsWith2
    },
    title: `startsWith(${formatted})`,
    description: `a string starting with ${formatted}`,
    jsonSchema: {
      pattern: `^${startsWith2}`
    },
    ...annotations3
  }));
}, "startsWith");
var EndsWithSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/EndsWith");
var endsWith = /* @__PURE__ */ __name((endsWith2, annotations3) => (self2) => {
  const formatted = JSON.stringify(endsWith2);
  return self2.pipe(filter13((a) => a.endsWith(endsWith2), {
    schemaId: EndsWithSchemaId,
    [EndsWithSchemaId]: {
      endsWith: endsWith2
    },
    title: `endsWith(${formatted})`,
    description: `a string ending with ${formatted}`,
    jsonSchema: {
      pattern: `^.*${endsWith2}$`
    },
    ...annotations3
  }));
}, "endsWith");
var IncludesSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Includes");
var includes = /* @__PURE__ */ __name((searchString, annotations3) => (self2) => {
  const formatted = JSON.stringify(searchString);
  return self2.pipe(filter13((a) => a.includes(searchString), {
    schemaId: IncludesSchemaId,
    [IncludesSchemaId]: {
      includes: searchString
    },
    title: `includes(${formatted})`,
    description: `a string including ${formatted}`,
    jsonSchema: {
      pattern: `.*${searchString}.*`
    },
    ...annotations3
  }));
}, "includes");
var LowercasedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Lowercased");
var lowercased = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => a === a.toLowerCase(), {
  schemaId: LowercasedSchemaId,
  title: "lowercased",
  description: "a lowercase string",
  jsonSchema: {
    pattern: "^[^A-Z]*$"
  },
  ...annotations3
})), "lowercased");
var Lowercased = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ lowercased({
  identifier: "Lowercased"
}))) {
  static {
    __name(this, "Lowercased");
  }
};
var UppercasedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Uppercased");
var uppercased = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => a === a.toUpperCase(), {
  schemaId: UppercasedSchemaId,
  title: "uppercased",
  description: "an uppercase string",
  jsonSchema: {
    pattern: "^[^a-z]*$"
  },
  ...annotations3
})), "uppercased");
var Uppercased = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ uppercased({
  identifier: "Uppercased"
}))) {
  static {
    __name(this, "Uppercased");
  }
};
var CapitalizedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Capitalized");
var capitalized = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => a[0]?.toUpperCase() === a[0], {
  schemaId: CapitalizedSchemaId,
  title: "capitalized",
  description: "a capitalized string",
  jsonSchema: {
    pattern: "^[^a-z]?.*$"
  },
  ...annotations3
})), "capitalized");
var Capitalized = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ capitalized({
  identifier: "Capitalized"
}))) {
  static {
    __name(this, "Capitalized");
  }
};
var UncapitalizedSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Uncapitalized");
var uncapitalized = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => a[0]?.toLowerCase() === a[0], {
  schemaId: UncapitalizedSchemaId,
  title: "uncapitalized",
  description: "a uncapitalized string",
  jsonSchema: {
    pattern: "^[^A-Z]?.*$"
  },
  ...annotations3
})), "uncapitalized");
var Uncapitalized = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ uncapitalized({
  identifier: "Uncapitalized"
}))) {
  static {
    __name(this, "Uncapitalized");
  }
};
var Char = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ length4(1, {
  identifier: "Char"
}))) {
  static {
    __name(this, "Char");
  }
};
var nonEmptyString2 = /* @__PURE__ */ __name((annotations3) => minLength(1, {
  title: "nonEmptyString",
  description: "a non empty string",
  ...annotations3
}), "nonEmptyString");
var Lowercase = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to lowercase"
}), Lowercased, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => i.toLowerCase(), "decode"),
  encode: identity
}).annotations({
  identifier: "Lowercase"
})) {
  static {
    __name(this, "Lowercase");
  }
};
var Uppercase = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to uppercase"
}), Uppercased, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => i.toUpperCase(), "decode"),
  encode: identity
}).annotations({
  identifier: "Uppercase"
})) {
  static {
    __name(this, "Uppercase");
  }
};
var Capitalize = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to a capitalized format"
}), Capitalized, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => capitalize(i), "decode"),
  encode: identity
}).annotations({
  identifier: "Capitalize"
})) {
  static {
    __name(this, "Capitalize");
  }
};
var Uncapitalize = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be converted to an uncapitalized format"
}), Uncapitalized, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => uncapitalize(i), "decode"),
  encode: identity
}).annotations({
  identifier: "Uncapitalize"
})) {
  static {
    __name(this, "Uncapitalize");
  }
};
var Trimmed = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ trimmed({
  identifier: "Trimmed"
}))) {
  static {
    __name(this, "Trimmed");
  }
};
var NonEmptyTrimmedString = class extends (/* @__PURE__ */ Trimmed.pipe(/* @__PURE__ */ nonEmptyString2({
  identifier: "NonEmptyTrimmedString"
}))) {
  static {
    __name(this, "NonEmptyTrimmedString");
  }
};
var Trim = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string that will be trimmed"
}), Trimmed, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => i.trim(), "decode"),
  encode: identity
}).annotations({
  identifier: "Trim"
})) {
  static {
    __name(this, "Trim");
  }
};
var split3 = /* @__PURE__ */ __name((separator) => transform2(String$.annotations({
  description: "a string that will be split"
}), Array$(String$), {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => i.split(separator), "decode"),
  encode: /* @__PURE__ */ __name((a) => a.join(separator), "encode")
}), "split");
var getErrorMessage2 = /* @__PURE__ */ __name((e) => e instanceof Error ? e.message : String(e), "getErrorMessage");
var getParseJsonTransformation = /* @__PURE__ */ __name((options4) => transformOrFail(String$.annotations({
  description: "a string to be decoded into JSON"
}), Unknown, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => _try({
    try: /* @__PURE__ */ __name(() => JSON.parse(i, options4?.reviver), "try"),
    catch: /* @__PURE__ */ __name((e) => new Type2(ast, i, getErrorMessage2(e)), "catch")
  }), "decode"),
  encode: /* @__PURE__ */ __name((a, _, ast) => _try({
    try: /* @__PURE__ */ __name(() => JSON.stringify(a, options4?.replacer, options4?.space), "try"),
    catch: /* @__PURE__ */ __name((e) => new Type2(ast, a, getErrorMessage2(e)), "catch")
  }), "encode")
}).annotations({
  title: "parseJson",
  schemaId: ParseJsonSchemaId
}), "getParseJsonTransformation");
var parseJson = /* @__PURE__ */ __name((schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose4(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions), "parseJson");
var NonEmptyString = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ nonEmptyString2({
  identifier: "NonEmptyString"
}))) {
  static {
    __name(this, "NonEmptyString");
  }
};
var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
var UUID = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.uuid(), "arbitrary")
}))) {
  static {
    __name(this, "UUID");
  }
};
var ULIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ULID");
var ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;
var ULID = class extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(ulidRegexp, {
  schemaId: ULIDSchemaId,
  identifier: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.ulid(), "arbitrary")
}))) {
  static {
    __name(this, "ULID");
  }
};
var URLFromSelf = class extends (/* @__PURE__ */ instanceOf(URL, {
  typeConstructor: {
    _tag: "URL"
  },
  identifier: "URLFromSelf",
  arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.webUrl().map((s) => new URL(s)), "arbitrary"),
  pretty: /* @__PURE__ */ __name(() => (url2) => url2.toString(), "pretty")
})) {
  static {
    __name(this, "URLFromSelf");
  }
};
var URL$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a URL"
}), URLFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => _try({
    try: /* @__PURE__ */ __name(() => new URL(i), "try"),
    catch: /* @__PURE__ */ __name((e) => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a URL. ${getErrorMessage2(e)}`), "catch")
  }), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(a.toString()), "encode")
}).annotations({
  identifier: "URL",
  pretty: /* @__PURE__ */ __name(() => (url2) => url2.toString(), "pretty")
})) {
  static {
    __name(this, "URL$");
  }
};
var FiniteSchemaId2 = FiniteSchemaId;
var finite = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13(Number.isFinite, {
  schemaId: FiniteSchemaId2,
  title: "finite",
  description: "a finite number",
  jsonSchema: {},
  ...annotations3
})), "finite");
var GreaterThanSchemaId2 = GreaterThanSchemaId;
var greaterThan6 = /* @__PURE__ */ __name((exclusiveMinimum, annotations3) => (self2) => self2.pipe(filter13((a) => a > exclusiveMinimum, {
  schemaId: GreaterThanSchemaId2,
  title: `greaterThan(${exclusiveMinimum})`,
  description: exclusiveMinimum === 0 ? "a positive number" : `a number greater than ${exclusiveMinimum}`,
  jsonSchema: {
    exclusiveMinimum
  },
  ...annotations3
})), "greaterThan");
var GreaterThanOrEqualToSchemaId2 = GreaterThanOrEqualToSchemaId;
var greaterThanOrEqualTo5 = /* @__PURE__ */ __name((minimum, annotations3) => (self2) => self2.pipe(filter13((a) => a >= minimum, {
  schemaId: GreaterThanOrEqualToSchemaId2,
  title: `greaterThanOrEqualTo(${minimum})`,
  description: minimum === 0 ? "a non-negative number" : `a number greater than or equal to ${minimum}`,
  jsonSchema: {
    minimum
  },
  ...annotations3
})), "greaterThanOrEqualTo");
var MultipleOfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/MultipleOf");
var multipleOf = /* @__PURE__ */ __name((divisor, annotations3) => (self2) => {
  const positiveDivisor = Math.abs(divisor);
  return self2.pipe(filter13((a) => remainder(a, divisor) === 0, {
    schemaId: MultipleOfSchemaId,
    title: `multipleOf(${positiveDivisor})`,
    description: `a number divisible by ${positiveDivisor}`,
    jsonSchema: {
      multipleOf: positiveDivisor
    },
    ...annotations3
  }));
}, "multipleOf");
var IntSchemaId2 = IntSchemaId;
var int = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => Number.isSafeInteger(a), {
  schemaId: IntSchemaId2,
  title: "int",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations3
})), "int");
var LessThanSchemaId2 = LessThanSchemaId;
var lessThan10 = /* @__PURE__ */ __name((exclusiveMaximum, annotations3) => (self2) => self2.pipe(filter13((a) => a < exclusiveMaximum, {
  schemaId: LessThanSchemaId2,
  title: `lessThan(${exclusiveMaximum})`,
  description: exclusiveMaximum === 0 ? "a negative number" : `a number less than ${exclusiveMaximum}`,
  jsonSchema: {
    exclusiveMaximum
  },
  ...annotations3
})), "lessThan");
var LessThanOrEqualToSchemaId2 = LessThanOrEqualToSchemaId;
var lessThanOrEqualTo5 = /* @__PURE__ */ __name((maximum, annotations3) => (self2) => self2.pipe(filter13((a) => a <= maximum, {
  schemaId: LessThanOrEqualToSchemaId2,
  title: `lessThanOrEqualTo(${maximum})`,
  description: maximum === 0 ? "a non-positive number" : `a number less than or equal to ${maximum}`,
  jsonSchema: {
    maximum
  },
  ...annotations3
})), "lessThanOrEqualTo");
var BetweenSchemaId2 = BetweenSchemaId;
var between5 = /* @__PURE__ */ __name((minimum, maximum, annotations3) => (self2) => self2.pipe(filter13((a) => a >= minimum && a <= maximum, {
  schemaId: BetweenSchemaId2,
  title: `between(${minimum}, ${maximum})`,
  description: `a number between ${minimum} and ${maximum}`,
  jsonSchema: {
    minimum,
    maximum
  },
  ...annotations3
})), "between");
var NonNaNSchemaId2 = NonNaNSchemaId;
var nonNaN = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => !Number.isNaN(a), {
  schemaId: NonNaNSchemaId2,
  title: "nonNaN",
  description: "a number excluding NaN",
  ...annotations3
})), "nonNaN");
var positive = /* @__PURE__ */ __name((annotations3) => greaterThan6(0, {
  title: "positive",
  ...annotations3
}), "positive");
var negative = /* @__PURE__ */ __name((annotations3) => lessThan10(0, {
  title: "negative",
  ...annotations3
}), "negative");
var nonPositive = /* @__PURE__ */ __name((annotations3) => lessThanOrEqualTo5(0, {
  title: "nonPositive",
  ...annotations3
}), "nonPositive");
var nonNegative = /* @__PURE__ */ __name((annotations3) => greaterThanOrEqualTo5(0, {
  title: "nonNegative",
  ...annotations3
}), "nonNegative");
var clamp8 = /* @__PURE__ */ __name((minimum, maximum) => (self2) => {
  return transform2(self2, typeSchema(self2).pipe(between5(minimum, maximum)), {
    strict: false,
    decode: /* @__PURE__ */ __name((i) => clamp4(i, {
      minimum,
      maximum
    }), "decode"),
    encode: identity
  });
}, "clamp");
function parseNumber(self2) {
  return transformOrFail(self2, Number$, {
    strict: false,
    decode: /* @__PURE__ */ __name((i, _, ast) => fromOption5(parse(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a number`)), "decode"),
    encode: /* @__PURE__ */ __name((a) => succeed14(String(a)), "encode")
  });
}
__name(parseNumber, "parseNumber");
var NumberFromString = class extends (/* @__PURE__ */ parseNumber(String$.annotations({
  description: "a string to be decoded into a number"
})).annotations({
  identifier: "NumberFromString"
})) {
  static {
    __name(this, "NumberFromString");
  }
};
var Finite = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
  identifier: "Finite"
}))) {
  static {
    __name(this, "Finite");
  }
};
var Int = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
  identifier: "Int"
}))) {
  static {
    __name(this, "Int");
  }
};
var NonNaN = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNaN({
  identifier: "NonNaN"
}))) {
  static {
    __name(this, "NonNaN");
  }
};
var Positive = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ positive({
  identifier: "Positive"
}))) {
  static {
    __name(this, "Positive");
  }
};
var Negative = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ negative({
  identifier: "Negative"
}))) {
  static {
    __name(this, "Negative");
  }
};
var NonPositive = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonPositive({
  identifier: "NonPositive"
}))) {
  static {
    __name(this, "NonPositive");
  }
};
var NonNegative = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNegative({
  identifier: "NonNegative"
}))) {
  static {
    __name(this, "NonNegative");
  }
};
var JsonNumberSchemaId2 = JsonNumberSchemaId;
var JsonNumber = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
  schemaId: JsonNumberSchemaId2,
  identifier: "JsonNumber"
}))) {
  static {
    __name(this, "JsonNumber");
  }
};
var Not = class extends (/* @__PURE__ */ transform2(/* @__PURE__ */ Boolean$.annotations({
  description: "a boolean that will be negated"
}), Boolean$, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => not2(i), "decode"),
  encode: /* @__PURE__ */ __name((a) => not2(a), "encode")
})) {
  static {
    __name(this, "Not");
  }
};
var encodeSymbol2 = /* @__PURE__ */ __name((sym, ast) => {
  const key = Symbol.keyFor(sym);
  return key === void 0 ? fail13(new Type2(ast, sym, `Unable to encode a unique symbol ${String(sym)} into a string`)) : succeed14(key);
}, "encodeSymbol");
var decodeSymbol = /* @__PURE__ */ __name((s) => succeed14(Symbol.for(s)), "decodeSymbol");
var Symbol$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a globally shared symbol"
}), SymbolFromSelf, {
  strict: false,
  decode: /* @__PURE__ */ __name((i) => decodeSymbol(i), "decode"),
  encode: /* @__PURE__ */ __name((a, _, ast) => encodeSymbol2(a, ast), "encode")
}).annotations({
  identifier: "Symbol"
})) {
  static {
    __name(this, "Symbol$");
  }
};
var GreaterThanBigIntSchemaId = GreaterThanBigintSchemaId;
var greaterThanBigInt = /* @__PURE__ */ __name((min6, annotations3) => (self2) => self2.pipe(filter13((a) => a > min6, {
  schemaId: GreaterThanBigIntSchemaId,
  [GreaterThanBigIntSchemaId]: {
    min: min6
  },
  title: `greaterThanBigInt(${min6})`,
  description: min6 === 0n ? "a positive bigint" : `a bigint greater than ${min6}n`,
  ...annotations3
})), "greaterThanBigInt");
var GreaterThanOrEqualToBigIntSchemaId2 = GreaterThanOrEqualToBigIntSchemaId;
var greaterThanOrEqualToBigInt = /* @__PURE__ */ __name((min6, annotations3) => (self2) => self2.pipe(filter13((a) => a >= min6, {
  schemaId: GreaterThanOrEqualToBigIntSchemaId2,
  [GreaterThanOrEqualToBigIntSchemaId2]: {
    min: min6
  },
  title: `greaterThanOrEqualToBigInt(${min6})`,
  description: min6 === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min6}n`,
  ...annotations3
})), "greaterThanOrEqualToBigInt");
var LessThanBigIntSchemaId2 = LessThanBigIntSchemaId;
var lessThanBigInt = /* @__PURE__ */ __name((max9, annotations3) => (self2) => self2.pipe(filter13((a) => a < max9, {
  schemaId: LessThanBigIntSchemaId2,
  [LessThanBigIntSchemaId2]: {
    max: max9
  },
  title: `lessThanBigInt(${max9})`,
  description: max9 === 0n ? "a negative bigint" : `a bigint less than ${max9}n`,
  ...annotations3
})), "lessThanBigInt");
var LessThanOrEqualToBigIntSchemaId2 = LessThanOrEqualToBigIntSchemaId;
var lessThanOrEqualToBigInt = /* @__PURE__ */ __name((max9, annotations3) => (self2) => self2.pipe(filter13((a) => a <= max9, {
  schemaId: LessThanOrEqualToBigIntSchemaId2,
  [LessThanOrEqualToBigIntSchemaId2]: {
    max: max9
  },
  title: `lessThanOrEqualToBigInt(${max9})`,
  description: max9 === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max9}n`,
  ...annotations3
})), "lessThanOrEqualToBigInt");
var BetweenBigIntSchemaId = BetweenBigintSchemaId;
var betweenBigInt = /* @__PURE__ */ __name((min6, max9, annotations3) => (self2) => self2.pipe(filter13((a) => a >= min6 && a <= max9, {
  schemaId: BetweenBigIntSchemaId,
  [BetweenBigIntSchemaId]: {
    min: min6,
    max: max9
  },
  title: `betweenBigInt(${min6}, ${max9})`,
  description: `a bigint between ${min6}n and ${max9}n`,
  ...annotations3
})), "betweenBigInt");
var positiveBigInt = /* @__PURE__ */ __name((annotations3) => greaterThanBigInt(0n, {
  title: "positiveBigInt",
  ...annotations3
}), "positiveBigInt");
var negativeBigInt = /* @__PURE__ */ __name((annotations3) => lessThanBigInt(0n, {
  title: "negativeBigInt",
  ...annotations3
}), "negativeBigInt");
var nonNegativeBigInt = /* @__PURE__ */ __name((annotations3) => greaterThanOrEqualToBigInt(0n, {
  title: "nonNegativeBigInt",
  ...annotations3
}), "nonNegativeBigInt");
var nonPositiveBigInt = /* @__PURE__ */ __name((annotations3) => lessThanOrEqualToBigInt(0n, {
  title: "nonPositiveBigInt",
  ...annotations3
}), "nonPositiveBigInt");
var clampBigInt = /* @__PURE__ */ __name((minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: /* @__PURE__ */ __name((i) => clamp6(i, {
    minimum,
    maximum
  }), "decode"),
  encode: identity
}), "clampBigInt");
var BigInt$ = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a bigint"
}), BigIntFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => fromOption5(fromString2(i), () => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a bigint`)), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(String(a)), "encode")
}).annotations({
  identifier: "BigInt"
})) {
  static {
    __name(this, "BigInt$");
  }
};
var PositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ positiveBigInt({
  identifier: "PositiveBigintFromSelf"
}));
var PositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ positiveBigInt({
  identifier: "PositiveBigint"
}));
var NegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ negativeBigInt({
  identifier: "NegativeBigintFromSelf"
}));
var NegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ negativeBigInt({
  identifier: "NegativeBigint"
}));
var NonPositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf"
}));
var NonPositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonPositiveBigInt({
  identifier: "NonPositiveBigint"
}));
var NonNegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf"
}));
var NonNegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonNegativeBigInt({
  identifier: "NonNegativeBigint"
}));
var BigIntFromNumber = class extends (/* @__PURE__ */ transformOrFail(Number$.annotations({
  description: "a number to be decoded into a bigint"
}), BigIntFromSelf.pipe(betweenBigInt(BigInt(Number.MIN_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER))), {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => fromOption5(fromNumber(i), () => new Type2(ast, i, `Unable to decode ${i} into a bigint`)), "decode"),
  encode: /* @__PURE__ */ __name((a, _, ast) => fromOption5(toNumber(a), () => new Type2(ast, a, `Unable to encode ${a}n into a number`)), "encode")
}).annotations({
  identifier: "BigIntFromNumber"
})) {
  static {
    __name(this, "BigIntFromNumber");
  }
};
var redactedArbitrary = /* @__PURE__ */ __name((value6) => (fc) => value6(fc).map(make46), "redactedArbitrary");
var toComposite = /* @__PURE__ */ __name((eff, onSuccess, ast, actual) => mapBoth6(eff, {
  onFailure: /* @__PURE__ */ __name((e) => new Composite2(ast, actual, e), "onFailure"),
  onSuccess
}), "toComposite");
var redactedParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isRedacted2(u) ? toComposite(decodeUnknown4(value2(u), options4), make46, ast, u) : fail13(new Type2(ast, u)), "redactedParse");
var RedactedFromSelf = /* @__PURE__ */ __name((value6) => declare([value6], {
  decode: /* @__PURE__ */ __name((value7) => redactedParse(decodeUnknown2(value7)), "decode"),
  encode: /* @__PURE__ */ __name((value7) => redactedParse(encodeUnknown(value7)), "encode")
}, {
  typeConstructor: {
    _tag: "effect/Redacted"
  },
  description: "Redacted(<redacted>)",
  pretty: /* @__PURE__ */ __name(() => () => "Redacted(<redacted>)", "pretty"),
  arbitrary: redactedArbitrary,
  equivalence: getEquivalence8
}), "RedactedFromSelf");
function Redacted(value6) {
  return transform2(value6, RedactedFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => make46(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => value2(a), "encode")
  });
}
__name(Redacted, "Redacted");
var DurationFromSelf = class extends (/* @__PURE__ */ declare(isDuration, {
  typeConstructor: {
    _tag: "effect/Duration"
  },
  identifier: "DurationFromSelf",
  pretty: /* @__PURE__ */ __name(() => String, "pretty"),
  arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.oneof(fc.constant(infinity), fc.bigInt({
    min: 0n
  }).map((_) => nanos(_)), fc.maxSafeNat().map((_) => millis(_))), "arbitrary"),
  equivalence: /* @__PURE__ */ __name(() => Equivalence, "equivalence")
})) {
  static {
    __name(this, "DurationFromSelf");
  }
};
var DurationFromNanos = class extends (/* @__PURE__ */ transformOrFail(NonNegativeBigIntFromSelf.annotations({
  description: "a bigint to be decoded into a Duration"
}), DurationFromSelf.pipe(filter13((duration4) => isFinite(duration4), {
  description: "a finite duration"
})), {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => succeed14(nanos(i)), "decode"),
  encode: /* @__PURE__ */ __name((a, _, ast) => match2(toNanos(a), {
    onNone: /* @__PURE__ */ __name(() => fail13(new Type2(ast, a, `Unable to encode ${a} into a bigint`)), "onNone"),
    onSome: /* @__PURE__ */ __name((nanos2) => succeed14(nanos2), "onSome")
  }), "encode")
}).annotations({
  identifier: "DurationFromNanos"
})) {
  static {
    __name(this, "DurationFromNanos");
  }
};
var NonNegativeInt = /* @__PURE__ */ NonNegative.pipe(int()).annotations({
  identifier: "NonNegativeInt"
});
var DurationFromMillis = class extends (/* @__PURE__ */ transform2(NonNegative.annotations({
  description: "a non-negative number to be decoded into a Duration"
}), DurationFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => millis(i), "decode"),
  encode: /* @__PURE__ */ __name((a) => toMillis(a), "encode")
}).annotations({
  identifier: "DurationFromMillis"
})) {
  static {
    __name(this, "DurationFromMillis");
  }
};
var DurationValueMillis = /* @__PURE__ */ TaggedStruct("Millis", {
  millis: NonNegativeInt
});
var DurationValueNanos = /* @__PURE__ */ TaggedStruct("Nanos", {
  nanos: BigInt$
});
var DurationValueInfinity = /* @__PURE__ */ TaggedStruct("Infinity", {});
var durationValueInfinity = /* @__PURE__ */ DurationValueInfinity.make({});
var DurationValue = /* @__PURE__ */ Union2(DurationValueMillis, DurationValueNanos, DurationValueInfinity).annotations({
  identifier: "DurationValue",
  description: "an JSON-compatible tagged union to be decoded into a Duration"
});
var FiniteHRTime = /* @__PURE__ */ Tuple(element(NonNegativeInt).annotations({
  title: "seconds"
}), element(NonNegativeInt).annotations({
  title: "nanos"
})).annotations({
  identifier: "FiniteHRTime"
});
var InfiniteHRTime = /* @__PURE__ */ Tuple(Literal2(-1), Literal2(0)).annotations({
  identifier: "InfiniteHRTime"
});
var HRTime = /* @__PURE__ */ Union2(FiniteHRTime, InfiniteHRTime).annotations({
  identifier: "HRTime",
  description: "a tuple of seconds and nanos to be decoded into a Duration"
});
var isDurationValue = /* @__PURE__ */ __name((u) => typeof u === "object", "isDurationValue");
var Duration = class extends (/* @__PURE__ */ transform2(Union2(DurationValue, HRTime), DurationFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => {
    if (isDurationValue(i)) {
      switch (i._tag) {
        case "Millis":
          return millis(i.millis);
        case "Nanos":
          return nanos(i.nanos);
        case "Infinity":
          return infinity;
      }
    }
    const [seconds2, nanos2] = i;
    return seconds2 === -1 ? infinity : nanos(BigInt(seconds2) * BigInt(1e9) + BigInt(nanos2));
  }, "decode"),
  encode: /* @__PURE__ */ __name((a) => {
    switch (a.value._tag) {
      case "Millis":
        return DurationValueMillis.make({
          millis: a.value.millis
        });
      case "Nanos":
        return DurationValueNanos.make({
          nanos: a.value.nanos
        });
      case "Infinity":
        return durationValueInfinity;
    }
  }, "encode")
}).annotations({
  identifier: "Duration"
})) {
  static {
    __name(this, "Duration");
  }
};
var clampDuration = /* @__PURE__ */ __name((minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: /* @__PURE__ */ __name((i) => clamp3(i, {
    minimum,
    maximum
  }), "decode"),
  encode: identity
}), "clampDuration");
var LessThanDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanDuration");
var lessThanDuration = /* @__PURE__ */ __name((max9, annotations3) => (self2) => self2.pipe(filter13((a) => lessThan2(a, max9), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max9
  },
  title: `lessThanDuration(${max9})`,
  description: `a Duration less than ${decode(max9)}`,
  ...annotations3
})), "lessThanDuration");
var LessThanOrEqualToDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToDuration");
var lessThanOrEqualToDuration = /* @__PURE__ */ __name((max9, annotations3) => (self2) => self2.pipe(filter13((a) => lessThanOrEqualTo2(a, max9), {
  schemaId: LessThanDurationSchemaId,
  [LessThanDurationSchemaId]: {
    max: max9
  },
  title: `lessThanOrEqualToDuration(${max9})`,
  description: `a Duration less than or equal to ${decode(max9)}`,
  ...annotations3
})), "lessThanOrEqualToDuration");
var GreaterThanDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanDuration");
var greaterThanDuration = /* @__PURE__ */ __name((min6, annotations3) => (self2) => self2.pipe(filter13((a) => greaterThan2(a, min6), {
  schemaId: GreaterThanDurationSchemaId,
  [GreaterThanDurationSchemaId]: {
    min: min6
  },
  title: `greaterThanDuration(${min6})`,
  description: `a Duration greater than ${decode(min6)}`,
  ...annotations3
})), "greaterThanDuration");
var GreaterThanOrEqualToDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToDuration");
var greaterThanOrEqualToDuration = /* @__PURE__ */ __name((min6, annotations3) => (self2) => self2.pipe(filter13((a) => greaterThanOrEqualTo2(a, min6), {
  schemaId: GreaterThanOrEqualToDurationSchemaId,
  [GreaterThanOrEqualToDurationSchemaId]: {
    min: min6
  },
  title: `greaterThanOrEqualToDuration(${min6})`,
  description: `a Duration greater than or equal to ${decode(min6)}`,
  ...annotations3
})), "greaterThanOrEqualToDuration");
var BetweenDurationSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenDuration");
var betweenDuration = /* @__PURE__ */ __name((minimum, maximum, annotations3) => (self2) => self2.pipe(filter13((a) => between2(a, {
  minimum,
  maximum
}), {
  schemaId: BetweenDurationSchemaId,
  [BetweenDurationSchemaId]: {
    maximum,
    minimum
  },
  title: `betweenDuration(${minimum}, ${maximum})`,
  description: `a Duration between ${decode(minimum)} and ${decode(maximum)}`,
  ...annotations3
})), "betweenDuration");
var Uint8ArrayFromSelf = class extends (/* @__PURE__ */ declare(isUint8Array, {
  typeConstructor: {
    _tag: "Uint8Array"
  },
  identifier: "Uint8ArrayFromSelf",
  pretty: /* @__PURE__ */ __name(() => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`, "pretty"),
  arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.uint8Array(), "arbitrary"),
  equivalence: /* @__PURE__ */ __name(() => getEquivalence4(equals), "equivalence")
})) {
  static {
    __name(this, "Uint8ArrayFromSelf");
  }
};
var Uint8 = class extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ between5(0, 255, {
  identifier: "Uint8",
  description: "a 8-bit unsigned integer"
}))) {
  static {
    __name(this, "Uint8");
  }
};
var Uint8Array$ = class extends (/* @__PURE__ */ transform2(Array$(Uint8).annotations({
  description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => Uint8Array.from(i), "decode"),
  encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
}).annotations({
  identifier: "Uint8Array"
})) {
  static {
    __name(this, "Uint8Array$");
  }
};
var makeUint8ArrayTransformation = /* @__PURE__ */ __name((id4, decode9, encode8) => transformOrFail(String$.annotations({
  description: "a string to be decoded into a Uint8Array"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => mapLeft(decode9(i), (decodeException) => new Type2(ast, i, decodeException.message)), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(encode8(a)), "encode")
}).annotations({
  identifier: id4
}), "makeUint8ArrayTransformation");
var Uint8ArrayFromBase64 = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
var Uint8ArrayFromBase64Url = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64Url", decodeBase64Url, encodeBase64Url);
var Uint8ArrayFromHex = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromHex", decodeHex, encodeHex);
var makeEncodingTransformation = /* @__PURE__ */ __name((id4, decode9, encode8) => transformOrFail(String$.annotations({
  description: `A string that is interpreted as being ${id4}-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => mapLeft(decode9(i), (decodeException) => new Type2(ast, i, decodeException.message)), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(encode8(a)), "encode")
}).annotations({
  identifier: `StringFrom${id4}`
}), "makeEncodingTransformation");
var StringFromBase64 = /* @__PURE__ */ makeEncodingTransformation("Base64", decodeBase64String, encodeBase64);
var StringFromBase64Url = /* @__PURE__ */ makeEncodingTransformation("Base64Url", decodeBase64UrlString, encodeBase64Url);
var StringFromHex = /* @__PURE__ */ makeEncodingTransformation("Hex", decodeHexString, encodeHex);
var StringFromUriComponent = /* @__PURE__ */ transformOrFail(String$.annotations({
  description: `A string that is interpreted as being UriComponent-encoded and will be decoded into a UTF-8 string`
}), String$, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => mapLeft(decodeUriComponent(i), (decodeException) => new Type2(ast, i, decodeException.message)), "decode"),
  encode: /* @__PURE__ */ __name((a, _, ast) => mapLeft(encodeUriComponent(a), (encodeException) => new Type2(ast, a, encodeException.message)), "encode")
}).annotations({
  identifier: `StringFromUriComponent`
});
var MinItemsSchemaId2 = MinItemsSchemaId;
var minItems = /* @__PURE__ */ __name((n, annotations3) => (self2) => {
  const minItems2 = Math.floor(n);
  if (minItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self2.pipe(filter13((a) => a.length >= minItems2, {
    schemaId: MinItemsSchemaId2,
    title: `minItems(${minItems2})`,
    description: `an array of at least ${minItems2} item(s)`,
    jsonSchema: {
      minItems: minItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
}, "minItems");
var MaxItemsSchemaId2 = MaxItemsSchemaId;
var maxItems = /* @__PURE__ */ __name((n, annotations3) => (self2) => {
  const maxItems2 = Math.floor(n);
  if (maxItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self2.pipe(filter13((a) => a.length <= maxItems2, {
    schemaId: MaxItemsSchemaId2,
    title: `maxItems(${maxItems2})`,
    description: `an array of at most ${maxItems2} item(s)`,
    jsonSchema: {
      maxItems: maxItems2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
}, "maxItems");
var ItemsCountSchemaId2 = ItemsCountSchemaId;
var itemsCount = /* @__PURE__ */ __name((n, annotations3) => (self2) => {
  const itemsCount2 = Math.floor(n);
  if (itemsCount2 < 0) {
    throw new Error(getInvalidArgumentErrorMessage(`Expected an integer greater than or equal to 0, actual ${n}`));
  }
  return self2.pipe(filter13((a) => a.length === itemsCount2, {
    schemaId: ItemsCountSchemaId2,
    title: `itemsCount(${itemsCount2})`,
    description: `an array of exactly ${itemsCount2} item(s)`,
    jsonSchema: {
      minItems: itemsCount2,
      maxItems: itemsCount2
    },
    [StableFilterAnnotationId]: true,
    ...annotations3
  }));
}, "itemsCount");
var getNumberIndexedAccess2 = /* @__PURE__ */ __name((self2) => make50(getNumberIndexedAccess(self2.ast)), "getNumberIndexedAccess");
function head6(self2) {
  return transform2(self2, OptionFromSelf(getNumberIndexedAccess2(typeSchema(self2))), {
    strict: false,
    decode: /* @__PURE__ */ __name((i) => head2(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => match2(a, {
      onNone: /* @__PURE__ */ __name(() => [], "onNone"),
      onSome: of
    }), "encode")
  });
}
__name(head6, "head");
function headNonEmpty3(self2) {
  return transform2(self2, getNumberIndexedAccess2(typeSchema(self2)), {
    strict: false,
    decode: /* @__PURE__ */ __name((i) => headNonEmpty(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => of(a), "encode")
  });
}
__name(headNonEmpty3, "headNonEmpty");
var headOrElse = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, fallback) => transformOrFail(self2, getNumberIndexedAccess2(typeSchema(self2)), {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => i.length > 0 ? succeed14(i[0]) : fallback ? succeed14(fallback()) : fail13(new Type2(ast, i, "Unable to retrieve the first element of an empty array")), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(of(a)), "encode")
}));
var ValidDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ValidDate");
var validDate = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => !Number.isNaN(a.getTime()), {
  schemaId: ValidDateSchemaId,
  [ValidDateSchemaId]: {
    noInvalidDate: true
  },
  title: "validDate",
  description: "a valid Date",
  ...annotations3
})), "validDate");
var LessThanDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanDate");
var lessThanDate = /* @__PURE__ */ __name((max9, annotations3) => (self2) => self2.pipe(filter13((a) => a < max9, {
  schemaId: LessThanDateSchemaId,
  [LessThanDateSchemaId]: {
    max: max9
  },
  title: `lessThanDate(${formatDate(max9)})`,
  description: `a date before ${formatDate(max9)}`,
  ...annotations3
})), "lessThanDate");
var LessThanOrEqualToDateSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToDate");
var lessThanOrEqualToDate = /* @__PURE__ */ __name((max9, annotations3) => (self2) => self2.pipe(filter13((a) => a <= max9, {
  schemaId: LessThanOrEqualToDateSchemaId,
  [LessThanOrEqualToDateSchemaId]: {
    max: max9
  },
  title: `lessThanOrEqualToDate(${formatDate(max9)})`,
  description: `a date before or equal to ${formatDate(max9)}`,
  ...annotations3
})), "lessThanOrEqualToDate");
var GreaterThanDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanDate");
var greaterThanDate = /* @__PURE__ */ __name((min6, annotations3) => (self2) => self2.pipe(filter13((a) => a > min6, {
  schemaId: GreaterThanDateSchemaId,
  [GreaterThanDateSchemaId]: {
    min: min6
  },
  title: `greaterThanDate(${formatDate(min6)})`,
  description: `a date after ${formatDate(min6)}`,
  ...annotations3
})), "greaterThanDate");
var GreaterThanOrEqualToDateSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToDate");
var greaterThanOrEqualToDate = /* @__PURE__ */ __name((min6, annotations3) => (self2) => self2.pipe(filter13((a) => a >= min6, {
  schemaId: GreaterThanOrEqualToDateSchemaId,
  [GreaterThanOrEqualToDateSchemaId]: {
    min: min6
  },
  title: `greaterThanOrEqualToDate(${formatDate(min6)})`,
  description: `a date after or equal to ${formatDate(min6)}`,
  ...annotations3
})), "greaterThanOrEqualToDate");
var BetweenDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenDate");
var betweenDate = /* @__PURE__ */ __name((min6, max9, annotations3) => (self2) => self2.pipe(filter13((a) => a <= max9 && a >= min6, {
  schemaId: BetweenDateSchemaId,
  [BetweenDateSchemaId]: {
    max: max9,
    min: min6
  },
  title: `betweenDate(${formatDate(min6)}, ${formatDate(max9)})`,
  description: `a date between ${formatDate(min6)} and ${formatDate(max9)}`,
  ...annotations3
})), "betweenDate");
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;
var DateFromSelf = class extends (/* @__PURE__ */ declare(isDate, {
  typeConstructor: {
    _tag: "Date"
  },
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: /* @__PURE__ */ __name(() => (date4) => `new Date(${JSON.stringify(date4)})`, "pretty"),
  arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.date({
    noInvalidDate: false
  }), "arbitrary"),
  equivalence: /* @__PURE__ */ __name(() => Date2, "equivalence")
})) {
  static {
    __name(this, "DateFromSelf");
  }
};
var ValidDateFromSelf = class extends (/* @__PURE__ */ DateFromSelf.pipe(/* @__PURE__ */ validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
}))) {
  static {
    __name(this, "ValidDateFromSelf");
  }
};
var DateFromString = class extends (/* @__PURE__ */ transform2(String$.annotations({
  description: "a string to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => new Date(i), "decode"),
  encode: /* @__PURE__ */ __name((a) => formatDate(a), "encode")
}).annotations({
  identifier: "DateFromString"
})) {
  static {
    __name(this, "DateFromString");
  }
};
var Date$ = class extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
  identifier: "Date"
}))) {
  static {
    __name(this, "Date$");
  }
};
var DateFromNumber = class extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a Date"
}), DateFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => new Date(i), "decode"),
  encode: /* @__PURE__ */ __name((a) => a.getTime(), "encode")
}).annotations({
  identifier: "DateFromNumber"
})) {
  static {
    __name(this, "DateFromNumber");
  }
};
var DateTimeUtcFromSelf = class extends (/* @__PURE__ */ declare((u) => isDateTime2(u) && isUtc2(u), {
  typeConstructor: {
    _tag: "effect/DateTime.Utc"
  },
  identifier: "DateTimeUtcFromSelf",
  description: "a DateTime.Utc instance",
  pretty: /* @__PURE__ */ __name(() => (dateTime) => dateTime.toString(), "pretty"),
  arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.date({
    noInvalidDate: true
  }).map((date4) => unsafeFromDate2(date4)), "arbitrary"),
  equivalence: /* @__PURE__ */ __name(() => Equivalence6, "equivalence")
})) {
  static {
    __name(this, "DateTimeUtcFromSelf");
  }
};
var decodeDateTimeUtc = /* @__PURE__ */ __name((input, ast) => _try({
  try: /* @__PURE__ */ __name(() => unsafeMake12(input), "try"),
  catch: /* @__PURE__ */ __name(() => new Type2(ast, input, `Unable to decode ${formatUnknown(input)} into a DateTime.Utc`), "catch")
}), "decodeDateTimeUtc");
var DateTimeUtcFromNumber = class extends (/* @__PURE__ */ transformOrFail(Number$.annotations({
  description: "a number to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => decodeDateTimeUtc(i, ast), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(toEpochMillis2(a)), "encode")
}).annotations({
  identifier: "DateTimeUtcFromNumber"
})) {
  static {
    __name(this, "DateTimeUtcFromNumber");
  }
};
var DateTimeUtcFromDate = class extends (/* @__PURE__ */ transformOrFail(DateFromSelf.annotations({
  description: "a Date to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => decodeDateTimeUtc(i, ast), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(toDateUtc2(a)), "encode")
}).annotations({
  identifier: "DateTimeUtcFromDate"
})) {
  static {
    __name(this, "DateTimeUtcFromDate");
  }
};
var DateTimeUtc = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Utc"
}), DateTimeUtcFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => decodeDateTimeUtc(i, ast), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(formatIso3(a)), "encode")
}).annotations({
  identifier: "DateTimeUtc"
})) {
  static {
    __name(this, "DateTimeUtc");
  }
};
var timeZoneOffsetArbitrary = /* @__PURE__ */ __name(() => (fc) => fc.integer({
  min: -12 * 60 * 60 * 1e3,
  max: 14 * 60 * 60 * 1e3
}).map(zoneMakeOffset2), "timeZoneOffsetArbitrary");
var TimeZoneOffsetFromSelf = class extends (/* @__PURE__ */ declare(isTimeZoneOffset2, {
  typeConstructor: {
    _tag: "effect/DateTime.TimeZone.Offset"
  },
  identifier: "TimeZoneOffsetFromSelf",
  description: "a TimeZone.Offset instance",
  pretty: /* @__PURE__ */ __name(() => (zone) => zone.toString(), "pretty"),
  arbitrary: timeZoneOffsetArbitrary
})) {
  static {
    __name(this, "TimeZoneOffsetFromSelf");
  }
};
var TimeZoneOffset = class extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a TimeZone.Offset"
}), TimeZoneOffsetFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => zoneMakeOffset2(i), "decode"),
  encode: /* @__PURE__ */ __name((a) => a.offset, "encode")
}).annotations({
  identifier: "TimeZoneOffset"
})) {
  static {
    __name(this, "TimeZoneOffset");
  }
};
var timeZoneNamedArbitrary = /* @__PURE__ */ __name(() => (fc) => fc.constantFrom(...Intl.supportedValuesOf("timeZone")).map(zoneUnsafeMakeNamed2), "timeZoneNamedArbitrary");
var TimeZoneNamedFromSelf = class extends (/* @__PURE__ */ declare(isTimeZoneNamed2, {
  typeConstructor: {
    _tag: "effect/DateTime.TimeZone.Named"
  },
  identifier: "TimeZoneNamedFromSelf",
  description: "a TimeZone.Named instance",
  pretty: /* @__PURE__ */ __name(() => (zone) => zone.toString(), "pretty"),
  arbitrary: timeZoneNamedArbitrary
})) {
  static {
    __name(this, "TimeZoneNamedFromSelf");
  }
};
var TimeZoneNamed = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone.Named"
}), TimeZoneNamedFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => _try({
    try: /* @__PURE__ */ __name(() => zoneUnsafeMakeNamed2(i), "try"),
    catch: /* @__PURE__ */ __name(() => new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone.Named`), "catch")
  }), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(a.id), "encode")
}).annotations({
  identifier: "TimeZoneNamed"
})) {
  static {
    __name(this, "TimeZoneNamed");
  }
};
var TimeZoneFromSelf = class extends (/* @__PURE__ */ Union2(TimeZoneOffsetFromSelf, TimeZoneNamedFromSelf)) {
  static {
    __name(this, "TimeZoneFromSelf");
  }
};
var TimeZone = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a TimeZone"
}), TimeZoneFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => match2(zoneFromString2(i), {
    onNone: /* @__PURE__ */ __name(() => fail13(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a TimeZone`)), "onNone"),
    onSome: succeed14
  }), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(zoneToString2(a)), "encode")
}).annotations({
  identifier: "TimeZone"
})) {
  static {
    __name(this, "TimeZone");
  }
};
var timeZoneArbitrary = /* @__PURE__ */ __name((fc) => fc.oneof(timeZoneOffsetArbitrary()(fc), timeZoneNamedArbitrary()(fc)), "timeZoneArbitrary");
var DateTimeZonedFromSelf = class extends (/* @__PURE__ */ declare((u) => isDateTime2(u) && isZoned2(u), {
  typeConstructor: {
    _tag: "effect/DateTime.Zoned"
  },
  identifier: "DateTimeZonedFromSelf",
  description: "a DateTime.Zoned instance",
  pretty: /* @__PURE__ */ __name(() => (dateTime) => dateTime.toString(), "pretty"),
  arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.tuple(fc.integer({
    // time zone db supports +/- 1000 years or so
    min: -31536e9,
    max: 31536e9
  }), timeZoneArbitrary(fc)).map(([millis2, timeZone]) => unsafeMakeZoned2(millis2, {
    timeZone
  })), "arbitrary"),
  equivalence: /* @__PURE__ */ __name(() => Equivalence6, "equivalence")
})) {
  static {
    __name(this, "DateTimeZonedFromSelf");
  }
};
var DateTimeZoned = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a DateTime.Zoned"
}), DateTimeZonedFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => match2(makeZonedFromString2(i), {
    onNone: /* @__PURE__ */ __name(() => fail13(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a DateTime.Zoned`)), "onNone"),
    onSome: succeed14
  }), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(formatIsoZoned2(a)), "encode")
}).annotations({
  identifier: "DateTimeZoned"
})) {
  static {
    __name(this, "DateTimeZoned");
  }
};
var OptionNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  description: "NoneEncoded"
});
var optionSomeEncoded = /* @__PURE__ */ __name((value6) => Struct({
  _tag: Literal2("Some"),
  value: value6
}).annotations({
  description: `SomeEncoded<${format6(value6)}>`
}), "optionSomeEncoded");
var optionEncoded = /* @__PURE__ */ __name((value6) => Union2(OptionNoneEncoded, optionSomeEncoded(value6)).annotations({
  description: `OptionEncoded<${format6(value6)}>`
}), "optionEncoded");
var optionDecode = /* @__PURE__ */ __name((input) => input._tag === "None" ? none2() : some3(input.value), "optionDecode");
var optionArbitrary = /* @__PURE__ */ __name((value6, ctx) => (fc) => fc.oneof(ctx, fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value6(fc)
})).map(optionDecode), "optionArbitrary");
var optionPretty = /* @__PURE__ */ __name((value6) => match2({
  onNone: /* @__PURE__ */ __name(() => "none()", "onNone"),
  onSome: /* @__PURE__ */ __name((a) => `some(${value6(a)})`, "onSome")
}), "optionPretty");
var optionParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isOption2(u) ? isNone2(u) ? succeed14(none2()) : toComposite(decodeUnknown4(u.value, options4), some3, ast, u) : fail13(new Type2(ast, u)), "optionParse");
var OptionFromSelf_ = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: /* @__PURE__ */ __name((value7) => optionParse(decodeUnknown2(value7)), "decode"),
    encode: /* @__PURE__ */ __name((value7) => optionParse(encodeUnknown(value7)), "encode")
  }, {
    typeConstructor: {
      _tag: "effect/Option"
    },
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: getEquivalence2
  });
}, "OptionFromSelf_");
var OptionFromSelf = /* @__PURE__ */ __name((value6) => {
  return OptionFromSelf_(value6).annotations({
    description: `Option<${format6(value6)}>`
  });
}, "OptionFromSelf");
var makeNoneEncoded = {
  _tag: "None"
};
var makeSomeEncoded = /* @__PURE__ */ __name((value6) => ({
  _tag: "Some",
  value: value6
}), "makeSomeEncoded");
function Option(value6) {
  const value_ = asSchema(value6);
  const out = transform2(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => optionDecode(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => match2(a, {
      onNone: /* @__PURE__ */ __name(() => makeNoneEncoded, "onNone"),
      onSome: makeSomeEncoded
    }), "encode")
  });
  return out;
}
__name(Option, "Option");
function OptionFromNullOr(value6) {
  return transform2(NullOr(value6), OptionFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromNullable2(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => getOrNull2(a), "encode")
  });
}
__name(OptionFromNullOr, "OptionFromNullOr");
function OptionFromNullishOr(value6, onNoneEncoding) {
  return transform2(NullishOr(value6), OptionFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromNullable2(i), "decode"),
    encode: onNoneEncoding === null ? (a) => getOrNull2(a) : (a) => getOrUndefined2(a)
  });
}
__name(OptionFromNullishOr, "OptionFromNullishOr");
function OptionFromUndefinedOr(value6) {
  return transform2(UndefinedOr(value6), OptionFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromNullable2(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => getOrUndefined2(a), "encode")
  });
}
__name(OptionFromUndefinedOr, "OptionFromUndefinedOr");
var OptionFromNonEmptyTrimmedString = class extends (/* @__PURE__ */ transform2(String$, /* @__PURE__ */ OptionFromSelf(NonEmptyTrimmedString), {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => filter(some3(i.trim()), isNonEmpty5), "decode"),
  encode: /* @__PURE__ */ __name((a) => getOrElse2(a, () => ""), "encode")
})) {
  static {
    __name(this, "OptionFromNonEmptyTrimmedString");
  }
};
var rightEncoded = /* @__PURE__ */ __name((right3) => Struct({
  _tag: Literal2("Right"),
  right: right3
}).annotations({
  description: `RightEncoded<${format6(right3)}>`
}), "rightEncoded");
var leftEncoded = /* @__PURE__ */ __name((left3) => Struct({
  _tag: Literal2("Left"),
  left: left3
}).annotations({
  description: `LeftEncoded<${format6(left3)}>`
}), "leftEncoded");
var eitherEncoded = /* @__PURE__ */ __name((right3, left3) => Union2(rightEncoded(right3), leftEncoded(left3)).annotations({
  description: `EitherEncoded<${format6(left3)}, ${format6(right3)}>`
}), "eitherEncoded");
var eitherDecode = /* @__PURE__ */ __name((input) => input._tag === "Left" ? left2(input.left) : right2(input.right), "eitherDecode");
var eitherArbitrary = /* @__PURE__ */ __name((right3, left3) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left3(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right3(fc)
})).map(eitherDecode), "eitherArbitrary");
var eitherPretty = /* @__PURE__ */ __name((right3, left3) => match({
  onLeft: /* @__PURE__ */ __name((e) => `left(${left3(e)})`, "onLeft"),
  onRight: /* @__PURE__ */ __name((a) => `right(${right3(a)})`, "onRight")
}), "eitherPretty");
var eitherParse = /* @__PURE__ */ __name((parseRight, decodeUnknownLeft) => (u, options4, ast) => isEither2(u) ? match(u, {
  onLeft: /* @__PURE__ */ __name((left3) => toComposite(decodeUnknownLeft(left3, options4), left2, ast, u), "onLeft"),
  onRight: /* @__PURE__ */ __name((right3) => toComposite(parseRight(right3, options4), right2, ast, u), "onRight")
}) : fail13(new Type2(ast, u)), "eitherParse");
var EitherFromSelf = /* @__PURE__ */ __name(({
  left: left3,
  right: right3
}) => {
  return declare([right3, left3], {
    decode: /* @__PURE__ */ __name((right4, left4) => eitherParse(decodeUnknown2(right4), decodeUnknown2(left4)), "decode"),
    encode: /* @__PURE__ */ __name((right4, left4) => eitherParse(encodeUnknown(right4), encodeUnknown(left4)), "encode")
  }, {
    typeConstructor: {
      _tag: "effect/Either"
    },
    description: `Either<${format6(right3)}, ${format6(left3)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: /* @__PURE__ */ __name((right4, left4) => getEquivalence({
      left: left4,
      right: right4
    }), "equivalence")
  });
}, "EitherFromSelf");
var makeLeftEncoded = /* @__PURE__ */ __name((left3) => ({
  _tag: "Left",
  left: left3
}), "makeLeftEncoded");
var makeRightEncoded = /* @__PURE__ */ __name((right3) => ({
  _tag: "Right",
  right: right3
}), "makeRightEncoded");
var Either = /* @__PURE__ */ __name(({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const out = transform2(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => eitherDecode(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    }), "encode")
  });
  return out;
}, "Either");
var EitherFromUnion = /* @__PURE__ */ __name(({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform2(right_, rightEncoded(toright), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => makeRightEncoded(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => a.right, "encode")
  });
  const fromLeft = transform2(left_, leftEncoded(toleft), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => makeLeftEncoded(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => a.left, "encode")
  });
  const out = transform2(Union2(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => i._tag === "Left" ? left2(i.left) : right2(i.right), "decode"),
    encode: /* @__PURE__ */ __name((a) => match(a, {
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    }), "encode")
  });
  return out;
}, "EitherFromUnion");
var mapArbitrary = /* @__PURE__ */ __name((key, value6, ctx) => {
  return (fc) => {
    const items = fc.array(fc.tuple(key(fc), value6(fc)));
    return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as16) => new Map(as16));
  };
}, "mapArbitrary");
var readonlyMapPretty = /* @__PURE__ */ __name((key, value6) => (map38) => `new Map([${Array.from(map38.entries()).map(([k, v]) => `[${key(k)}, ${value6(v)}]`).join(", ")}])`, "readonlyMapPretty");
var readonlyMapEquivalence = /* @__PURE__ */ __name((key, value6) => {
  const arrayEquivalence = getEquivalence4(make(([ka, va], [kb, vb]) => key(ka, kb) && value6(va, vb)));
  return make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
}, "readonlyMapEquivalence");
var readonlyMapParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isMap(u) ? toComposite(decodeUnknown4(Array.from(u.entries()), options4), (as16) => new Map(as16), ast, u) : fail13(new Type2(ast, u)), "readonlyMapParse");
var mapFromSelf_ = /* @__PURE__ */ __name((key, value6, description) => declare([key, value6], {
  decode: /* @__PURE__ */ __name((Key2, Value2) => readonlyMapParse(decodeUnknown2(Array$(Tuple(Key2, Value2)))), "decode"),
  encode: /* @__PURE__ */ __name((Key2, Value2) => readonlyMapParse(encodeUnknown(Array$(Tuple(Key2, Value2)))), "encode")
}, {
  typeConstructor: {
    _tag: "ReadonlyMap"
  },
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
}), "mapFromSelf_");
var ReadonlyMapFromSelf = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => mapFromSelf_(key, value6, `ReadonlyMap<${format6(key)}, ${format6(value6)}>`), "ReadonlyMapFromSelf");
var MapFromSelf = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => mapFromSelf_(key, value6, `Map<${format6(key)}, ${format6(value6)}>`), "MapFromSelf");
function ReadonlyMap({
  key,
  value: value6
}) {
  return transform2(Array$(Tuple(key, value6)), ReadonlyMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value6))
  }), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => new Map(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a.entries()), "encode")
  });
}
__name(ReadonlyMap, "ReadonlyMap");
function map27({
  key,
  value: value6
}) {
  return transform2(Array$(Tuple(key, value6)), MapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value6))
  }), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => new Map(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a.entries()), "encode")
  });
}
__name(map27, "map");
var ReadonlyMapFromRecord = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => transform2(Record({
  key: encodedBoundSchema(key),
  value: value6
}).annotations({
  description: "a record to be decoded into a ReadonlyMap"
}), ReadonlyMapFromSelf({
  key,
  value: typeSchema(value6)
}), {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => new Map(Object.entries(i)), "decode"),
  encode: /* @__PURE__ */ __name((a) => Object.fromEntries(a), "encode")
}), "ReadonlyMapFromRecord");
var MapFromRecord = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => transform2(Record({
  key: encodedBoundSchema(key),
  value: value6
}).annotations({
  description: "a record to be decoded into a Map"
}), MapFromSelf({
  key,
  value: typeSchema(value6)
}), {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => new Map(Object.entries(i)), "decode"),
  encode: /* @__PURE__ */ __name((a) => Object.fromEntries(a), "encode")
}), "MapFromRecord");
var setArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as16) => new Set(as16));
}, "setArbitrary");
var readonlySetPretty = /* @__PURE__ */ __name((item) => (set20) => `new Set([${Array.from(set20.values()).map((a) => item(a)).join(", ")}])`, "readonlySetPretty");
var readonlySetEquivalence = /* @__PURE__ */ __name((item) => {
  const arrayEquivalence = getEquivalence4(item);
  return make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
}, "readonlySetEquivalence");
var readonlySetParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isSet(u) ? toComposite(decodeUnknown4(Array.from(u.values()), options4), (as16) => new Set(as16), ast, u) : fail13(new Type2(ast, u)), "readonlySetParse");
var setFromSelf_ = /* @__PURE__ */ __name((value6, description) => declare([value6], {
  decode: /* @__PURE__ */ __name((item) => readonlySetParse(decodeUnknown2(Array$(item))), "decode"),
  encode: /* @__PURE__ */ __name((item) => readonlySetParse(encodeUnknown(Array$(item))), "encode")
}, {
  typeConstructor: {
    _tag: "ReadonlySet"
  },
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
}), "setFromSelf_");
var ReadonlySetFromSelf = /* @__PURE__ */ __name((value6) => setFromSelf_(value6, `ReadonlySet<${format6(value6)}>`), "ReadonlySetFromSelf");
var SetFromSelf = /* @__PURE__ */ __name((value6) => setFromSelf_(value6, `Set<${format6(value6)}>`), "SetFromSelf");
function ReadonlySet(value6) {
  return transform2(Array$(value6), ReadonlySetFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => new Set(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
  });
}
__name(ReadonlySet, "ReadonlySet");
function set8(value6) {
  return transform2(Array$(value6), SetFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => new Set(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
  });
}
__name(set8, "set");
var bigDecimalPretty = /* @__PURE__ */ __name(() => (val) => `BigDecimal(${format4(normalize(val))})`, "bigDecimalPretty");
var bigDecimalArbitrary = /* @__PURE__ */ __name(() => (fc) => fc.tuple(fc.bigInt(), fc.integer({
  min: -18,
  max: 18
})).map(([value6, scale2]) => make48(value6, scale2)), "bigDecimalArbitrary");
var BigDecimalFromSelf = class extends (/* @__PURE__ */ declare(isBigDecimal, {
  typeConstructor: {
    _tag: "effect/BigDecimal"
  },
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: /* @__PURE__ */ __name(() => Equivalence5, "equivalence")
})) {
  static {
    __name(this, "BigDecimalFromSelf");
  }
};
var BigDecimal = class extends (/* @__PURE__ */ transformOrFail(String$.annotations({
  description: "a string to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i, _, ast) => fromString(i).pipe(match2({
    onNone: /* @__PURE__ */ __name(() => fail13(new Type2(ast, i, `Unable to decode ${JSON.stringify(i)} into a BigDecimal`)), "onNone"),
    onSome: /* @__PURE__ */ __name((val) => succeed14(normalize(val)), "onSome")
  })), "decode"),
  encode: /* @__PURE__ */ __name((a) => succeed14(format4(normalize(a))), "encode")
}).annotations({
  identifier: "BigDecimal"
})) {
  static {
    __name(this, "BigDecimal");
  }
};
var BigDecimalFromNumber = class extends (/* @__PURE__ */ transform2(Number$.annotations({
  description: "a number to be decoded into a BigDecimal"
}), BigDecimalFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => unsafeFromNumber(i), "decode"),
  encode: /* @__PURE__ */ __name((a) => unsafeToNumber(a), "encode")
}).annotations({
  identifier: "BigDecimalFromNumber"
})) {
  static {
    __name(this, "BigDecimalFromNumber");
  }
};
var GreaterThanBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanBigDecimal");
var greaterThanBigDecimal = /* @__PURE__ */ __name((min6, annotations3) => (self2) => {
  const formatted = format4(min6);
  return self2.pipe(filter13((a) => greaterThan4(a, min6), {
    schemaId: GreaterThanBigDecimalSchemaId,
    [GreaterThanBigDecimalSchemaId]: {
      min: min6
    },
    title: `greaterThanBigDecimal(${formatted})`,
    description: `a BigDecimal greater than ${formatted}`,
    ...annotations3
  }));
}, "greaterThanBigDecimal");
var GreaterThanOrEqualToBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/GreaterThanOrEqualToBigDecimal");
var greaterThanOrEqualToBigDecimal = /* @__PURE__ */ __name((min6, annotations3) => (self2) => {
  const formatted = format4(min6);
  return self2.pipe(filter13((a) => greaterThanOrEqualTo3(a, min6), {
    schemaId: GreaterThanOrEqualToBigDecimalSchemaId,
    [GreaterThanOrEqualToBigDecimalSchemaId]: {
      min: min6
    },
    title: `greaterThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal greater than or equal to ${formatted}`,
    ...annotations3
  }));
}, "greaterThanOrEqualToBigDecimal");
var LessThanBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/LessThanBigDecimal");
var lessThanBigDecimal = /* @__PURE__ */ __name((max9, annotations3) => (self2) => {
  const formatted = format4(max9);
  return self2.pipe(filter13((a) => lessThan8(a, max9), {
    schemaId: LessThanBigDecimalSchemaId,
    [LessThanBigDecimalSchemaId]: {
      max: max9
    },
    title: `lessThanBigDecimal(${formatted})`,
    description: `a BigDecimal less than ${formatted}`,
    ...annotations3
  }));
}, "lessThanBigDecimal");
var LessThanOrEqualToBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/LessThanOrEqualToBigDecimal");
var lessThanOrEqualToBigDecimal = /* @__PURE__ */ __name((max9, annotations3) => (self2) => {
  const formatted = format4(max9);
  return self2.pipe(filter13((a) => lessThanOrEqualTo3(a, max9), {
    schemaId: LessThanOrEqualToBigDecimalSchemaId,
    [LessThanOrEqualToBigDecimalSchemaId]: {
      max: max9
    },
    title: `lessThanOrEqualToBigDecimal(${formatted})`,
    description: `a BigDecimal less than or equal to ${formatted}`,
    ...annotations3
  }));
}, "lessThanOrEqualToBigDecimal");
var PositiveBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/PositiveBigDecimal");
var positiveBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => isPositive(a), {
  schemaId: PositiveBigDecimalSchemaId,
  title: "positiveBigDecimal",
  description: `a positive BigDecimal`,
  ...annotations3
})), "positiveBigDecimal");
var PositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf"
}));
var NonNegativeBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NonNegativeBigDecimal");
var nonNegativeBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => a.value >= 0n, {
  schemaId: NonNegativeBigDecimalSchemaId,
  title: "nonNegativeBigDecimal",
  description: `a non-negative BigDecimal`,
  ...annotations3
})), "nonNegativeBigDecimal");
var NonNegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf"
}));
var NegativeBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NegativeBigDecimal");
var negativeBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => isNegative(a), {
  schemaId: NegativeBigDecimalSchemaId,
  title: "negativeBigDecimal",
  description: `a negative BigDecimal`,
  ...annotations3
})), "negativeBigDecimal");
var NegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf"
}));
var NonPositiveBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/NonPositiveBigDecimal");
var nonPositiveBigDecimal = /* @__PURE__ */ __name((annotations3) => (self2) => self2.pipe(filter13((a) => a.value <= 0n, {
  schemaId: NonPositiveBigDecimalSchemaId,
  title: "nonPositiveBigDecimal",
  description: `a non-positive BigDecimal`,
  ...annotations3
})), "nonPositiveBigDecimal");
var NonPositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf"
}));
var BetweenBigDecimalSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/BetweenBigDecimal");
var betweenBigDecimal = /* @__PURE__ */ __name((minimum, maximum, annotations3) => (self2) => {
  const formattedMinimum = format4(minimum);
  const formattedMaximum = format4(maximum);
  return self2.pipe(filter13((a) => between3(a, {
    minimum,
    maximum
  }), {
    schemaId: BetweenBigDecimalSchemaId,
    [BetweenBigDecimalSchemaId]: {
      maximum,
      minimum
    },
    title: `betweenBigDecimal(${formattedMinimum}, ${formattedMaximum})`,
    description: `a BigDecimal between ${formattedMinimum} and ${formattedMaximum}`,
    ...annotations3
  }));
}, "betweenBigDecimal");
var clampBigDecimal = /* @__PURE__ */ __name((minimum, maximum) => (self2) => transform2(self2, self2.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: /* @__PURE__ */ __name((i) => clamp5(i, {
    minimum,
    maximum
  }), "decode"),
  encode: identity
}), "clampBigDecimal");
var chunkArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable3);
}, "chunkArbitrary");
var chunkPretty = /* @__PURE__ */ __name((item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`, "chunkPretty");
var chunkParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isChunk(u) ? isEmpty(u) ? succeed14(empty4()) : toComposite(decodeUnknown4(toReadonlyArray(u), options4), fromIterable3, ast, u) : fail13(new Type2(ast, u)), "chunkParse");
var ChunkFromSelf = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: /* @__PURE__ */ __name((item) => chunkParse(decodeUnknown2(Array$(item))), "decode"),
    encode: /* @__PURE__ */ __name((item) => chunkParse(encodeUnknown(Array$(item))), "encode")
  }, {
    typeConstructor: {
      _tag: "effect/Chunk"
    },
    description: `Chunk<${format6(value6)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: getEquivalence5
  });
}, "ChunkFromSelf");
function Chunk(value6) {
  return transform2(Array$(value6), ChunkFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => i.length === 0 ? empty4() : fromIterable3(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => toReadonlyArray(a), "encode")
  });
}
__name(Chunk, "Chunk");
var nonEmptyChunkArbitrary = /* @__PURE__ */ __name((item) => (fc) => array6(item(fc), {
  minLength: 1
}).map((as16) => unsafeFromNonEmptyArray(as16)), "nonEmptyChunkArbitrary");
var nonEmptyChunkPretty = /* @__PURE__ */ __name((item) => (c) => `NonEmptyChunk(${toReadonlyArray(c).map(item).join(", ")})`, "nonEmptyChunkPretty");
var nonEmptyChunkParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isChunk(u) && isNonEmpty(u) ? toComposite(decodeUnknown4(toReadonlyArray(u), options4), unsafeFromNonEmptyArray, ast, u) : fail13(new Type2(ast, u)), "nonEmptyChunkParse");
var NonEmptyChunkFromSelf = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: /* @__PURE__ */ __name((item) => nonEmptyChunkParse(decodeUnknown2(NonEmptyArray(item))), "decode"),
    encode: /* @__PURE__ */ __name((item) => nonEmptyChunkParse(encodeUnknown(NonEmptyArray(item))), "encode")
  }, {
    typeConstructor: {
      _tag: "effect/Chunk.NonEmptyChunk"
    },
    description: `NonEmptyChunk<${format6(value6)}>`,
    pretty: nonEmptyChunkPretty,
    arbitrary: nonEmptyChunkArbitrary,
    equivalence: getEquivalence5
  });
}, "NonEmptyChunkFromSelf");
function NonEmptyChunk(value6) {
  return transform2(NonEmptyArray(value6), NonEmptyChunkFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => unsafeFromNonEmptyArray(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => toReadonlyArray(a), "encode")
  });
}
__name(NonEmptyChunk, "NonEmptyChunk");
var decodeData = /* @__PURE__ */ __name((a) => Array.isArray(a) ? array4(a) : struct3(a), "decodeData");
var dataArbitrary = /* @__PURE__ */ __name((item) => (fc) => item(fc).map(decodeData), "dataArbitrary");
var dataPretty = /* @__PURE__ */ __name((item) => (d) => `Data(${item(d)})`, "dataPretty");
var dataParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isEqual(u) ? toComposite(decodeUnknown4(u, options4), decodeData, ast, u) : fail13(new Type2(ast, u)), "dataParse");
var DataFromSelf = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: /* @__PURE__ */ __name((item) => dataParse(decodeUnknown2(item)), "decode"),
    encode: /* @__PURE__ */ __name((item) => dataParse(encodeUnknown(item)), "encode")
  }, {
    description: `Data<${format6(value6)}>`,
    pretty: dataPretty,
    arbitrary: dataArbitrary
  });
}, "DataFromSelf");
var Data = /* @__PURE__ */ __name((value6) => {
  return transform2(value6, DataFromSelf(typeSchema(value6)), {
    strict: false,
    decode: /* @__PURE__ */ __name((i) => decodeData(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a), "encode")
  });
}, "Data");
var isField = /* @__PURE__ */ __name((u) => isSchema(u) || isPropertySignature(u), "isField");
var isFields = /* @__PURE__ */ __name((fields) => Reflect.ownKeys(fields).every((key) => isField(fields[key])), "isFields");
var getFields = /* @__PURE__ */ __name((hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]), "getFields");
var getSchemaFromFieldsOr = /* @__PURE__ */ __name((fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr)), "getSchemaFromFieldsOr");
var getFieldsFromFieldsOr = /* @__PURE__ */ __name((fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr), "getFieldsFromFieldsOr");
var Class6 = /* @__PURE__ */ __name((identifier2) => (fieldsOr, annotations3) => makeClass({
  kind: "Class",
  identifier: identifier2,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: Class4,
  annotations: annotations3
}), "Class");
var getClassTag = /* @__PURE__ */ __name((tag8) => withConstructorDefault(propertySignature(Literal2(tag8)), () => tag8), "getClassTag");
var TaggedClass3 = /* @__PURE__ */ __name((identifier2) => (tag8, fieldsOr, annotations3) => {
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema4 = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag8)
  };
  const taggedFields = extendFields(newFields, fields);
  return class TaggedClass extends makeClass({
    kind: "TaggedClass",
    identifier: identifier2 ?? tag8,
    schema: extend4(schema4, Struct(newFields)),
    fields: taggedFields,
    Base: Class4,
    annotations: annotations3
  }) {
    static {
      __name(this, "TaggedClass");
    }
    static _tag = tag8;
  };
}, "TaggedClass");
var TaggedError2 = /* @__PURE__ */ __name((identifier2) => (tag8, fieldsOr, annotations3) => {
  class Base4 extends Error3 {
    static {
      __name(this, "Base");
    }
  }
  ;
  Base4.prototype.name = tag8;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema4 = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag8)
  };
  const taggedFields = extendFields(newFields, fields);
  const hasMessageField = "message" in taggedFields;
  class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag8,
    schema: extend4(schema4, Struct(newFields)),
    fields: taggedFields,
    Base: Base4,
    annotations: annotations3,
    disableToString: true
  }) {
    static {
      __name(this, "TaggedErrorClass");
    }
    static _tag = tag8;
  }
  if (!hasMessageField) {
    Object.defineProperty(TaggedErrorClass.prototype, "message", {
      get() {
        return `{ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
      },
      enumerable: false,
      // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
      configurable: true
    });
  }
  return TaggedErrorClass;
}, "TaggedError");
var extendFields = /* @__PURE__ */ __name((a, b) => {
  const out = {
    ...a
  };
  for (const key of Reflect.ownKeys(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
    }
    out[key] = b[key];
  }
  return out;
}, "extendFields");
function getDisableValidationMakeOption(options4) {
  return isBoolean(options4) ? options4 : options4?.disableValidation ?? false;
}
__name(getDisableValidationMakeOption, "getDisableValidationMakeOption");
var astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
var getClassAnnotations = /* @__PURE__ */ __name((annotations3) => {
  if (annotations3 === void 0) {
    return [];
  } else if (Array.isArray(annotations3)) {
    return annotations3;
  } else {
    return [annotations3];
  }
}, "getClassAnnotations");
var makeClass = /* @__PURE__ */ __name(({
  Base: Base4,
  annotations: annotations3,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema: schema4
}) => {
  const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
  const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations3);
  const typeSchema_ = typeSchema(schema4);
  const declarationSurrogate = typeSchema_.annotations({
    identifier: identifier2,
    ...typeAnnotations
  });
  const typeSide = typeSchema_.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
    ...typeAnnotations
  });
  const constructorSchema = schema4.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
    ...typeAnnotations
  });
  const encodedSide = schema4.annotations({
    [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
    ...encodedAnnotations
  });
  const transformationSurrogate = schema4.annotations({
    ...encodedAnnotations,
    ...typeAnnotations,
    ...transformationAnnotations
  });
  const fallbackInstanceOf = /* @__PURE__ */ __name((u) => hasProperty(u, classSymbol) && is(typeSide)(u), "fallbackInstanceOf");
  const klass = class extends Base4 {
    static {
      __name(this, "klass");
    }
    constructor(props = {}, options4 = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption(options4)) {
        props = validateSync(constructorSchema)(props);
      }
      super(props, true);
    }
    // ----------------
    // Schema interface
    // ----------------
    static [TypeId21] = variance5;
    static get ast() {
      let out = astCache.get(this);
      if (out) {
        return out;
      }
      const declaration = declare([schema4], {
        decode: /* @__PURE__ */ __name(() => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed14(input) : fail13(new Type2(ast, input)), "decode"),
        encode: /* @__PURE__ */ __name(() => (input, options4) => input instanceof this ? succeed14(input) : map26(encodeUnknown(typeSide)(input, options4), (props) => new this(props, true)), "encode")
      }, {
        identifier: identifier2,
        pretty: /* @__PURE__ */ __name((pretty6) => (self2) => `${identifier2}(${pretty6(self2)})`, "pretty"),
        // @ts-expect-error
        arbitrary: /* @__PURE__ */ __name((arb) => (fc) => arb(fc).map((props) => new this(props)), "arbitrary"),
        equivalence: identity,
        [SurrogateAnnotationId]: declarationSurrogate.ast,
        ...typeAnnotations
      });
      out = transform2(encodedSide, declaration, {
        strict: true,
        decode: /* @__PURE__ */ __name((i) => new this(i, true), "decode"),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId]: transformationSurrogate.ast,
        ...transformationAnnotations
      }).ast;
      astCache.set(this, out);
      return out;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations4) {
      return make50(this.ast).annotations(annotations4);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    // ----------------
    // Class interface
    // ----------------
    static make(...args2) {
      return new this(...args2);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier2;
    static extend(identifier3) {
      return (newFieldsOr, annotations4) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend4(schema4, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFieldsOr, options4, annotations4) => {
        const transformedFields = extendFields(fields, newFieldsOr);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema4, typeSchema(Struct(transformedFields)), options4),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options4, annotations4) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema4), Struct(transformedFields), options4),
          fields: transformedFields,
          Base: this,
          annotations: annotations4
        });
      };
    }
    // ----------------
    // other
    // ----------------
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${Reflect.ownKeys(fields).map((p) => `${formatPropertyKey(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
      },
      configurable: true,
      writable: true
    });
  }
  return klass;
}, "makeClass");
var FiberIdNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Runtime"),
  id: Int,
  startTimeMillis: Int
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal2("Composite"),
  left: suspend7(() => FiberIdEncoded),
  right: suspend7(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = /* @__PURE__ */ Union2(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = /* @__PURE__ */ __name((fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode), "fiberIdArbitrary");
var fiberIdPretty = /* @__PURE__ */ __name((fiberId5) => {
  switch (fiberId5._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId5.id}, ${fiberId5.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId5.right)}, ${fiberIdPretty(fiberId5.left)})`;
  }
}, "fiberIdPretty");
var FiberIdFromSelf = class extends (/* @__PURE__ */ declare(isFiberId2, {
  typeConstructor: {
    _tag: "effect/FiberId"
  },
  identifier: "FiberIdFromSelf",
  pretty: /* @__PURE__ */ __name(() => fiberIdPretty, "pretty"),
  arbitrary: /* @__PURE__ */ __name(() => fiberIdArbitrary, "arbitrary")
})) {
  static {
    __name(this, "FiberIdFromSelf");
  }
};
var fiberIdDecode = /* @__PURE__ */ __name((input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
}, "fiberIdDecode");
var fiberIdEncode = /* @__PURE__ */ __name((input) => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
}, "fiberIdEncode");
var FiberId = class extends (/* @__PURE__ */ transform2(FiberIdEncoded, FiberIdFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => fiberIdDecode(i), "decode"),
  encode: /* @__PURE__ */ __name((a) => fiberIdEncode(a), "encode")
}).annotations({
  identifier: "FiberId"
})) {
  static {
    __name(this, "FiberId");
  }
};
var causeDieEncoded = /* @__PURE__ */ __name((defect) => Struct({
  _tag: Literal2("Die"),
  defect
}), "causeDieEncoded");
var CauseEmptyEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Empty")
});
var causeFailEncoded = /* @__PURE__ */ __name((error5) => Struct({
  _tag: Literal2("Fail"),
  error: error5
}), "causeFailEncoded");
var CauseInterruptEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal2("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeEncodedId = 0;
var causeEncoded = /* @__PURE__ */ __name((error5, defect) => {
  const error_ = asSchema(error5);
  const defect_ = asSchema(defect);
  const suspended3 = suspend7(() => out);
  const out = Union2(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
    _tag: Literal2("Sequential"),
    left: suspended3,
    right: suspended3
  }), Struct({
    _tag: Literal2("Parallel"),
    left: suspended3,
    right: suspended3
  })).annotations({
    title: `CauseEncoded<${format6(error5)}>`,
    [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
  });
  return out;
}, "causeEncoded");
var causeArbitrary = /* @__PURE__ */ __name((error5, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error5(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode), "causeArbitrary");
var causePretty = /* @__PURE__ */ __name((error5) => (cause3) => {
  const f = /* @__PURE__ */ __name((cause4) => {
    switch (cause4._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error5(cause4.error)})`;
      case "Die":
        return `Cause.die(${pretty3(cause4)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause4.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause4.left)}, ${f(cause4.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause4.left)}, ${f(cause4.right)})`;
    }
  }, "f");
  return f(cause3);
}, "causePretty");
var causeParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isCause2(u) ? toComposite(decodeUnknown4(causeEncode(u), options4), causeDecode, ast, u) : fail13(new Type2(ast, u)), "causeParse");
var CauseFromSelf = /* @__PURE__ */ __name(({
  defect,
  error: error5
}) => {
  return declare([error5, defect], {
    decode: /* @__PURE__ */ __name((error6, defect2) => causeParse(decodeUnknown2(causeEncoded(error6, defect2))), "decode"),
    encode: /* @__PURE__ */ __name((error6, defect2) => causeParse(encodeUnknown(causeEncoded(error6, defect2))), "encode")
  }, {
    typeConstructor: {
      _tag: "effect/Cause"
    },
    title: `Cause<${error5.ast}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
}, "CauseFromSelf");
function causeDecode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return empty27;
    case "Fail":
      return fail5(cause3.error);
    case "Die":
      return die4(cause3.defect);
    case "Interrupt":
      return interrupt4(fiberIdDecode(cause3.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause3.left), causeDecode(cause3.right));
    case "Parallel":
      return parallel4(causeDecode(cause3.left), causeDecode(cause3.right));
  }
}
__name(causeDecode, "causeDecode");
function causeEncode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause3.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause3.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause3.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
  }
}
__name(causeEncode, "causeEncode");
var Cause = /* @__PURE__ */ __name(({
  defect,
  error: error5
}) => {
  const error_ = asSchema(error5);
  const defect_ = asSchema(defect);
  const out = transform2(causeEncoded(error_, defect_), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: /* @__PURE__ */ __name((i) => causeDecode(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => causeEncode(a), "encode")
  });
  return out;
}, "Cause");
var Defect = class extends (/* @__PURE__ */ transform2(Unknown, Unknown, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => {
    if (isObject(i) && "message" in i && typeof i.message === "string") {
      const err = new Error(i.message, {
        cause: i
      });
      if ("name" in i && typeof i.name === "string") {
        err.name = i.name;
      }
      err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
      return err;
    }
    return prettyErrorMessage(i);
  }, "decode"),
  encode: /* @__PURE__ */ __name((a) => {
    if (a instanceof Error) {
      return {
        name: a.name,
        message: a.message
        // no stack because of security reasons
      };
    }
    return prettyErrorMessage(a);
  }, "encode")
}).annotations({
  identifier: "Defect"
})) {
  static {
    __name(this, "Defect");
  }
};
var exitFailureEncoded = /* @__PURE__ */ __name((error5, defect) => Struct({
  _tag: Literal2("Failure"),
  cause: causeEncoded(error5, defect)
}), "exitFailureEncoded");
var exitSuccessEncoded = /* @__PURE__ */ __name((value6) => Struct({
  _tag: Literal2("Success"),
  value: value6
}), "exitSuccessEncoded");
var exitEncoded = /* @__PURE__ */ __name((value6, error5, defect) => {
  return Union2(exitFailureEncoded(error5, defect), exitSuccessEncoded(value6)).annotations({
    title: `ExitEncoded<${format6(value6)}, ${format6(error5)}, ${format6(defect)}>`
  });
}, "exitEncoded");
var exitDecode = /* @__PURE__ */ __name((input) => {
  switch (input._tag) {
    case "Failure":
      return failCause3(causeDecode(input.cause));
    case "Success":
      return succeed3(input.value);
  }
}, "exitDecode");
var exitArbitrary = /* @__PURE__ */ __name((value6, error5, defect) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error5, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value6(fc)
})).map(exitDecode), "exitArbitrary");
var exitPretty = /* @__PURE__ */ __name((value6, error5) => (exit5) => exit5._tag === "Failure" ? `Exit.failCause(${causePretty(error5)(exit5.cause)})` : `Exit.succeed(${value6(exit5.value)})`, "exitPretty");
var exitParse = /* @__PURE__ */ __name((decodeUnknownValue, decodeUnknownCause) => (u, options4, ast) => isExit(u) ? match9(u, {
  onFailure: /* @__PURE__ */ __name((cause3) => toComposite(decodeUnknownCause(cause3, options4), failCause3, ast, u), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((value6) => toComposite(decodeUnknownValue(value6, options4), succeed3, ast, u), "onSuccess")
}) : fail13(new Type2(ast, u)), "exitParse");
var ExitFromSelf = /* @__PURE__ */ __name(({
  defect,
  failure,
  success
}) => declare([success, failure, defect], {
  decode: /* @__PURE__ */ __name((success2, failure2, defect2) => exitParse(decodeUnknown2(success2), decodeUnknown2(CauseFromSelf({
    error: failure2,
    defect: defect2
  }))), "decode"),
  encode: /* @__PURE__ */ __name((success2, failure2, defect2) => exitParse(encodeUnknown(success2), encodeUnknown(CauseFromSelf({
    error: failure2,
    defect: defect2
  }))), "encode")
}, {
  typeConstructor: {
    _tag: "effect/Exit"
  },
  title: `Exit<${success.ast}, ${failure.ast}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
}), "ExitFromSelf");
var Exit = /* @__PURE__ */ __name(({
  defect,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  const defect_ = asSchema(defect);
  const out = transform2(exitEncoded(success_, failure_, defect_), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect_)
  }), {
    strict: false,
    decode: /* @__PURE__ */ __name((i) => exitDecode(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => a._tag === "Failure" ? {
      _tag: "Failure",
      cause: a.cause
    } : {
      _tag: "Success",
      value: a.value
    }, "encode")
  });
  return out;
}, "Exit");
var hashSetArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable6);
}, "hashSetArbitrary");
var hashSetPretty = /* @__PURE__ */ __name((item) => (set20) => `HashSet(${Array.from(set20).map((a) => item(a)).join(", ")})`, "hashSetPretty");
var hashSetEquivalence = /* @__PURE__ */ __name((item) => {
  const arrayEquivalence = getEquivalence4(item);
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
}, "hashSetEquivalence");
var hashSetParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isHashSet2(u) ? toComposite(decodeUnknown4(Array.from(u), options4), fromIterable6, ast, u) : fail13(new Type2(ast, u)), "hashSetParse");
var HashSetFromSelf = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: /* @__PURE__ */ __name((item) => hashSetParse(decodeUnknown2(Array$(item))), "decode"),
    encode: /* @__PURE__ */ __name((item) => hashSetParse(encodeUnknown(Array$(item))), "encode")
  }, {
    typeConstructor: {
      _tag: "effect/HashSet"
    },
    description: `HashSet<${format6(value6)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
}, "HashSetFromSelf");
function HashSet(value6) {
  return transform2(Array$(value6), HashSetFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromIterable6(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
  });
}
__name(HashSet, "HashSet");
var hashMapArbitrary = /* @__PURE__ */ __name((key, value6, ctx) => (fc) => {
  const items = fc.array(fc.tuple(key(fc), value6(fc)));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable7);
}, "hashMapArbitrary");
var hashMapPretty = /* @__PURE__ */ __name((key, value6) => (map38) => `HashMap([${Array.from(map38).map(([k, v]) => `[${key(k)}, ${value6(v)}]`).join(", ")}])`, "hashMapPretty");
var hashMapEquivalence = /* @__PURE__ */ __name((key, value6) => {
  const arrayEquivalence = getEquivalence4(make(([ka, va], [kb, vb]) => key(ka, kb) && value6(va, vb)));
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
}, "hashMapEquivalence");
var hashMapParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isHashMap2(u) ? toComposite(decodeUnknown4(Array.from(u), options4), fromIterable7, ast, u) : fail13(new Type2(ast, u)), "hashMapParse");
var HashMapFromSelf = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => {
  return declare([key, value6], {
    decode: /* @__PURE__ */ __name((key2, value7) => hashMapParse(decodeUnknown2(Array$(Tuple(key2, value7)))), "decode"),
    encode: /* @__PURE__ */ __name((key2, value7) => hashMapParse(encodeUnknown(Array$(Tuple(key2, value7)))), "encode")
  }, {
    typeConstructor: {
      _tag: "effect/HashMap"
    },
    description: `HashMap<${format6(key)}, ${format6(value6)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
}, "HashMapFromSelf");
var HashMap = /* @__PURE__ */ __name(({
  key,
  value: value6
}) => {
  return transform2(Array$(Tuple(key, value6)), HashMapFromSelf({
    key: typeSchema(asSchema(key)),
    value: typeSchema(asSchema(value6))
  }), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromIterable7(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
  });
}, "HashMap");
var listArbitrary = /* @__PURE__ */ __name((item, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map(fromIterable8);
}, "listArbitrary");
var listPretty = /* @__PURE__ */ __name((item) => (set20) => `List(${Array.from(set20).map((a) => item(a)).join(", ")})`, "listPretty");
var listEquivalence = /* @__PURE__ */ __name((item) => {
  const arrayEquivalence = getEquivalence4(item);
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
}, "listEquivalence");
var listParse = /* @__PURE__ */ __name((decodeUnknown4) => (u, options4, ast) => isList(u) ? toComposite(decodeUnknown4(Array.from(u), options4), fromIterable8, ast, u) : fail13(new Type2(ast, u)), "listParse");
var ListFromSelf = /* @__PURE__ */ __name((value6) => {
  return declare([value6], {
    decode: /* @__PURE__ */ __name((item) => listParse(decodeUnknown2(Array$(item))), "decode"),
    encode: /* @__PURE__ */ __name((item) => listParse(encodeUnknown(Array$(item))), "encode")
  }, {
    typeConstructor: {
      _tag: "effect/List"
    },
    description: `List<${format6(value6)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
}, "ListFromSelf");
function List(value6) {
  return transform2(Array$(value6), ListFromSelf(typeSchema(asSchema(value6))), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromIterable8(i), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(a), "encode")
  });
}
__name(List, "List");
var sortedSetArbitrary = /* @__PURE__ */ __name((item, ord, ctx) => (fc) => {
  const items = fc.array(item(fc));
  return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as16) => fromIterable12(as16, ord));
}, "sortedSetArbitrary");
var sortedSetPretty = /* @__PURE__ */ __name((item) => (set20) => `new SortedSet([${Array.from(values5(set20)).map((a) => item(a)).join(", ")}])`, "sortedSetPretty");
var sortedSetParse = /* @__PURE__ */ __name((decodeUnknown4, ord) => (u, options4, ast) => isSortedSet(u) ? toComposite(decodeUnknown4(Array.from(values5(u)), options4), (as16) => fromIterable12(as16, ord), ast, u) : fail13(new Type2(ast, u)), "sortedSetParse");
var SortedSetFromSelf = /* @__PURE__ */ __name((value6, ordA, ordI) => {
  return declare([value6], {
    decode: /* @__PURE__ */ __name((item) => sortedSetParse(decodeUnknown2(Array$(item)), ordA), "decode"),
    encode: /* @__PURE__ */ __name((item) => sortedSetParse(encodeUnknown(Array$(item)), ordI), "encode")
  }, {
    typeConstructor: {
      _tag: "effect/SortedSet"
    },
    description: `SortedSet<${format6(value6)}>`,
    pretty: sortedSetPretty,
    arbitrary: /* @__PURE__ */ __name((arb, ctx) => sortedSetArbitrary(arb, ordA, ctx), "arbitrary"),
    equivalence: /* @__PURE__ */ __name(() => getEquivalence7(), "equivalence")
  });
}, "SortedSetFromSelf");
function SortedSet(value6, ordA) {
  const to = typeSchema(asSchema(value6));
  return transform2(Array$(value6), SortedSetFromSelf(to, ordA, ordA), {
    strict: true,
    decode: /* @__PURE__ */ __name((i) => fromIterable12(i, ordA), "decode"),
    encode: /* @__PURE__ */ __name((a) => Array.from(values5(a)), "encode")
  });
}
__name(SortedSet, "SortedSet");
var BooleanFromUnknown = class extends (/* @__PURE__ */ transform2(Unknown, Boolean$, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => isTruthy(i), "decode"),
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
})) {
  static {
    __name(this, "BooleanFromUnknown");
  }
};
var BooleanFromString = class extends (/* @__PURE__ */ transform2(Literal2("true", "false").annotations({
  description: "a string to be decoded into a boolean"
}), Boolean$, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => i === "true", "decode"),
  encode: /* @__PURE__ */ __name((a) => a ? "true" : "false", "encode")
}).annotations({
  identifier: "BooleanFromString"
})) {
  static {
    __name(this, "BooleanFromString");
  }
};
var Config = /* @__PURE__ */ __name((name, schema4) => {
  const decodeUnknownEither3 = decodeUnknownEither(schema4);
  return string4(name).pipe(mapOrFail2((s) => decodeUnknownEither3(s).pipe(mapLeft((error5) => InvalidData2([], TreeFormatter.formatIssueSync(error5))))));
}, "Config");
var symbolSerializable = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbol");
var asSerializable = /* @__PURE__ */ __name((serializable) => serializable, "asSerializable");
var serializableSchema = /* @__PURE__ */ __name((self2) => self2[symbolSerializable], "serializableSchema");
var serialize = /* @__PURE__ */ __name((self2) => encodeUnknown2(self2[symbolSerializable])(self2), "serialize");
var deserialize = /* @__PURE__ */ dual(2, (self2, value6) => decodeUnknown3(self2[symbolSerializable])(value6));
var symbolWithResult = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbolResult");
var asWithResult = /* @__PURE__ */ __name((withExit) => withExit, "asWithResult");
var failureSchema = /* @__PURE__ */ __name((self2) => self2[symbolWithResult].failure, "failureSchema");
var successSchema = /* @__PURE__ */ __name((self2) => self2[symbolWithResult].success, "successSchema");
var exitSchemaCache = /* @__PURE__ */ globalValue("effect/Schema/Serializable/exitSchemaCache", () => /* @__PURE__ */ new WeakMap());
var exitSchema = /* @__PURE__ */ __name((self2) => {
  const proto14 = Object.getPrototypeOf(self2);
  if (!(symbolWithResult in proto14)) {
    return Exit({
      failure: failureSchema(self2),
      success: successSchema(self2),
      defect: Defect
    });
  }
  let schema4 = exitSchemaCache.get(proto14);
  if (schema4 === void 0) {
    schema4 = Exit({
      failure: failureSchema(self2),
      success: successSchema(self2),
      defect: Defect
    });
    exitSchemaCache.set(proto14, schema4);
  }
  return schema4;
}, "exitSchema");
var serializeFailure = /* @__PURE__ */ dual(2, (self2, value6) => encode5(self2[symbolWithResult].failure)(value6));
var deserializeFailure = /* @__PURE__ */ dual(2, (self2, value6) => decodeUnknown3(self2[symbolWithResult].failure)(value6));
var serializeSuccess = /* @__PURE__ */ dual(2, (self2, value6) => encode5(self2[symbolWithResult].success)(value6));
var deserializeSuccess = /* @__PURE__ */ dual(2, (self2, value6) => decodeUnknown3(self2[symbolWithResult].success)(value6));
var serializeExit = /* @__PURE__ */ dual(2, (self2, value6) => encode5(exitSchema(self2))(value6));
var deserializeExit = /* @__PURE__ */ dual(2, (self2, value6) => decodeUnknown3(exitSchema(self2))(value6));
var asSerializableWithResult = /* @__PURE__ */ __name((procedure) => procedure, "asSerializableWithResult");
var TaggedRequest = /* @__PURE__ */ __name((identifier2) => (tag8, options4, annotations3) => {
  const taggedFields = extendFields({
    _tag: getClassTag(tag8)
  }, options4.payload);
  return class TaggedRequestClass extends makeClass({
    kind: "TaggedRequest",
    identifier: identifier2 ?? tag8,
    schema: Struct(taggedFields),
    fields: taggedFields,
    Base: Class5,
    annotations: annotations3
  }) {
    static {
      __name(this, "TaggedRequestClass");
    }
    static _tag = tag8;
    static success = options4.success;
    static failure = options4.failure;
    get [symbolSerializable]() {
      return this.constructor;
    }
    get [symbolWithResult]() {
      return {
        failure: options4.failure,
        success: options4.success
      };
    }
  };
}, "TaggedRequest");
var equivalence2 = /* @__PURE__ */ __name((schema4) => go2(schema4.ast, []), "equivalence");
var getEquivalenceAnnotation = /* @__PURE__ */ getAnnotation(EquivalenceAnnotationId);
var go2 = /* @__PURE__ */ __name((ast, path) => {
  const hook = getEquivalenceAnnotation(ast);
  if (isSome2(hook)) {
    switch (ast._tag) {
      case "Declaration":
        return hook.value(...ast.typeParameters.map((tp) => go2(tp, path)));
      case "Refinement":
        return hook.value(go2(ast.from, path));
      default:
        return hook.value();
    }
  }
  switch (ast._tag) {
    case "NeverKeyword":
      throw new Error(getEquivalenceUnsupportedErrorMessage(ast, path));
    case "Transformation":
      return go2(ast.to, path);
    case "Declaration":
    case "Literal":
    case "StringKeyword":
    case "TemplateLiteral":
    case "UniqueSymbol":
    case "SymbolKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "Enums":
    case "ObjectKeyword":
      return equals;
    case "Refinement":
      return go2(ast.from, path);
    case "Suspend": {
      const get29 = memoizeThunk(() => go2(ast.f(), path));
      return (a, b) => get29()(a, b);
    }
    case "TupleType": {
      const elements = ast.elements.map((element2, i) => go2(element2.type, path.concat(i)));
      const rest = ast.rest.map((annotatedAST) => go2(annotatedAST.type, path));
      return make((a, b) => {
        if (!Array.isArray(a) || !Array.isArray(b)) {
          return false;
        }
        const len = a.length;
        if (len !== b.length) {
          return false;
        }
        let i = 0;
        for (; i < Math.min(len, ast.elements.length); i++) {
          if (!elements[i](a[i], b[i])) {
            return false;
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head13, ...tail3] = rest;
          for (; i < len - tail3.length; i++) {
            if (!head13(a[i], b[i])) {
              return false;
            }
          }
          for (let j = 0; j < tail3.length; j++) {
            i += j;
            if (!tail3[j](a[i], b[i])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return equals;
      }
      const propertySignatures = ast.propertySignatures.map((ps) => go2(ps.type, path.concat(ps.name)));
      const indexSignatures = ast.indexSignatures.map((is4) => go2(is4.type, path));
      return make((a, b) => {
        if (!isRecord(a) || !isRecord(b)) {
          return false;
        }
        const aStringKeys = Object.keys(a);
        const aSymbolKeys = Object.getOwnPropertySymbols(a);
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = ast.propertySignatures[i];
          const name = ps.name;
          const aHas = Object.prototype.hasOwnProperty.call(a, name);
          const bHas = Object.prototype.hasOwnProperty.call(b, name);
          if (ps.isOptional) {
            if (aHas !== bHas) {
              return false;
            }
          }
          if (aHas && bHas && !propertySignatures[i](a[name], b[name])) {
            return false;
          }
        }
        let bSymbolKeys;
        let bStringKeys;
        for (let i = 0; i < indexSignatures.length; i++) {
          const is4 = ast.indexSignatures[i];
          const encodedParameter = getEncodedParameter(is4.parameter);
          const isSymbol2 = isSymbolKeyword(encodedParameter);
          if (isSymbol2) {
            bSymbolKeys = bSymbolKeys || Object.getOwnPropertySymbols(b);
            if (aSymbolKeys.length !== bSymbolKeys.length) {
              return false;
            }
          } else {
            bStringKeys = bStringKeys || Object.keys(b);
            if (aStringKeys.length !== bStringKeys.length) {
              return false;
            }
          }
          const aKeys = isSymbol2 ? aSymbolKeys : aStringKeys;
          for (let j = 0; j < aKeys.length; j++) {
            const key = aKeys[j];
            if (!Object.prototype.hasOwnProperty.call(b, key) || !indexSignatures[i](a[key], b[key])) {
              return false;
            }
          }
        }
        return true;
      });
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, true);
      const ownKeys = Reflect.ownKeys(searchTree.keys);
      const len = ownKeys.length;
      return make((a, b) => {
        let candidates = [];
        if (len > 0 && isRecordOrArray(a)) {
          for (let i = 0; i < len; i++) {
            const name = ownKeys[i];
            const buckets = searchTree.keys[name].buckets;
            if (Object.prototype.hasOwnProperty.call(a, name)) {
              const literal2 = String(a[name]);
              if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                candidates = candidates.concat(buckets[literal2]);
              }
            }
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        const tuples = candidates.map((ast2) => [go2(ast2, path), is({
          ast: ast2
        })]);
        for (let i = 0; i < tuples.length; i++) {
          const [equivalence3, is4] = tuples[i];
          if (is4(a) && is4(b)) {
            if (equivalence3(a, b)) {
              return true;
            }
          }
        }
        return false;
      });
    }
  }
}, "go");
var SymbolStruct = /* @__PURE__ */ TaggedStruct("symbol", {
  key: String$
}).annotations({
  description: "an object to be decoded into a globally shared symbol"
});
var SymbolFromStruct = /* @__PURE__ */ transformOrFail(SymbolStruct, SymbolFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((i) => decodeSymbol(i.key), "decode"),
  encode: /* @__PURE__ */ __name((a, _, ast) => map26(encodeSymbol2(a, ast), (key) => SymbolStruct.make({
    key
  })), "encode")
});
var PropertyKey$ = class extends (/* @__PURE__ */ Union2(String$, Number$, SymbolFromStruct).annotations({
  identifier: "PropertyKey"
})) {
  static {
    __name(this, "PropertyKey$");
  }
};
var ArrayFormatterIssue = class extends (/* @__PURE__ */ Struct({
  _tag: propertySignature(Literal2("Pointer", "Unexpected", "Missing", "Composite", "Refinement", "Transformation", "Type", "Forbidden")).annotations({
    description: "The tag identifying the type of parse issue"
  }),
  path: propertySignature(Array$(PropertyKey$)).annotations({
    description: "The path to the property where the issue occurred"
  }),
  message: propertySignature(String$).annotations({
    description: "A descriptive message explaining the issue"
  })
}).annotations({
  identifier: "ArrayFormatterIssue",
  description: "Represents an issue returned by the ArrayFormatter formatter"
})) {
  static {
    __name(this, "ArrayFormatterIssue");
  }
};

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Headers.js
var HeadersTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Headers");
var isHeaders = /* @__PURE__ */ __name((u) => hasProperty(u, HeadersTypeId), "isHeaders");
var Proto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
  [HeadersTypeId]: HeadersTypeId,
  [symbolRedactable](fiberRefs3) {
    return redact2(this, getOrDefault2(fiberRefs3, currentRedactedNames));
  }
});
var make51 = /* @__PURE__ */ __name((input) => Object.assign(Object.create(Proto3), input), "make");
var schemaFromSelf = /* @__PURE__ */ declare(isHeaders, {
  identifier: "Headers",
  equivalence: /* @__PURE__ */ __name(() => getEquivalence3(Equivalence3), "equivalence")
});
var schema = /* @__PURE__ */ transform2(/* @__PURE__ */ Record({
  key: String$,
  value: String$
}), schemaFromSelf, {
  strict: true,
  decode: /* @__PURE__ */ __name((record4) => fromInput(record4), "decode"),
  encode: identity
});
var empty34 = /* @__PURE__ */ Object.create(Proto3);
var fromInput = /* @__PURE__ */ __name((input) => {
  if (input === void 0) {
    return empty34;
  } else if (Symbol.iterator in input) {
    const out2 = Object.create(Proto3);
    for (const [k, v] of input) {
      out2[k.toLowerCase()] = v;
    }
    return out2;
  }
  const out = Object.create(Proto3);
  for (const [k, v] of Object.entries(input)) {
    if (Array.isArray(v)) {
      out[k.toLowerCase()] = v.join(", ");
    } else if (v !== void 0) {
      out[k.toLowerCase()] = v;
    }
  }
  return out;
}, "fromInput");
var unsafeFromRecord = /* @__PURE__ */ __name((input) => Object.setPrototypeOf(input, Proto3), "unsafeFromRecord");
var has10 = /* @__PURE__ */ dual(2, (self2, key) => key.toLowerCase() in self2);
var get15 = /* @__PURE__ */ dual(2, (self2, key) => get(self2, key.toLowerCase()));
var set9 = /* @__PURE__ */ dual(3, (self2, key, value6) => {
  const out = make51(self2);
  out[key.toLowerCase()] = value6;
  return out;
});
var setAll3 = /* @__PURE__ */ dual(2, (self2, headers) => make51({
  ...self2,
  ...fromInput(headers)
}));
var merge9 = /* @__PURE__ */ dual(2, (self2, headers) => {
  const out = make51(self2);
  Object.assign(out, headers);
  return out;
});
var remove10 = /* @__PURE__ */ dual(2, (self2, key) => {
  const out = make51(self2);
  const modify15 = /* @__PURE__ */ __name((key2) => {
    if (typeof key2 === "string") {
      const k = key2.toLowerCase();
      if (k in self2) {
        delete out[k];
      }
    } else {
      for (const name in self2) {
        if (key2.test(name)) {
          delete out[name];
        }
      }
    }
  }, "modify");
  if (Array.isArray(key)) {
    for (let i = 0; i < key.length; i++) {
      modify15(key[i]);
    }
  } else {
    modify15(key);
  }
  return out;
});
var redact2 = /* @__PURE__ */ dual(2, (self2, key) => {
  const out = {
    ...self2
  };
  const modify15 = /* @__PURE__ */ __name((key2) => {
    if (typeof key2 === "string") {
      const k = key2.toLowerCase();
      if (k in self2) {
        out[k] = make46(self2[k]);
      }
    } else {
      for (const name in self2) {
        if (key2.test(name)) {
          out[name] = make46(self2[name]);
        }
      }
    }
  }, "modify");
  if (Array.isArray(key)) {
    for (let i = 0; i < key.length; i++) {
      modify15(key[i]);
    }
  } else {
    modify15(key);
  }
  return out;
});
var currentRedactedNames = /* @__PURE__ */ globalValue("@effect/platform/Headers/currentRedactedNames", () => unsafeMake11(["authorization", "cookie", "set-cookie", "x-api-key"]));

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/UrlParams.js
var UrlParams_exports = {};
__export(UrlParams_exports, {
  append: () => append4,
  appendAll: () => appendAll4,
  empty: () => empty35,
  fromInput: () => fromInput2,
  getAll: () => getAll,
  getFirst: () => getFirst,
  getLast: () => getLast,
  makeUrl: () => makeUrl,
  remove: () => remove11,
  schemaFromSelf: () => schemaFromSelf2,
  schemaFromString: () => schemaFromString,
  schemaJson: () => schemaJson,
  schemaParse: () => schemaParse,
  schemaRecord: () => schemaRecord,
  schemaStruct: () => schemaStruct,
  set: () => set10,
  setAll: () => setAll4,
  toRecord: () => toRecord,
  toString: () => toString
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var fromInput2 = /* @__PURE__ */ __name((input) => {
  const parsed = fromInputNested(input);
  const out = [];
  for (let i = 0; i < parsed.length; i++) {
    if (Array.isArray(parsed[i][0])) {
      const [keys6, value6] = parsed[i];
      out.push([`${keys6[0]}[${keys6.slice(1).join("][")}]`, value6]);
    } else {
      out.push(parsed[i]);
    }
  }
  return out;
}, "fromInput");
var fromInputNested = /* @__PURE__ */ __name((input) => {
  const entries3 = Symbol.iterator in input ? fromIterable2(input) : Object.entries(input);
  const out = [];
  for (const [key, value6] of entries3) {
    if (Array.isArray(value6)) {
      for (let i = 0; i < value6.length; i++) {
        if (value6[i] !== void 0) {
          out.push([key, String(value6[i])]);
        }
      }
    } else if (typeof value6 === "object") {
      const nested3 = fromInputNested(value6);
      for (const [k, v] of nested3) {
        out.push([[key, ...typeof k === "string" ? [k] : k], v]);
      }
    } else if (value6 !== void 0) {
      out.push([key, String(value6)]);
    }
  }
  return out;
}, "fromInputNested");
var schemaFromSelf2 = /* @__PURE__ */ Array$(Tuple(String$, String$)).annotations({
  identifier: "UrlParams"
});
var empty35 = [];
var getAll = /* @__PURE__ */ dual(2, (self2, key) => reduce(self2, [], (acc, [k, value6]) => {
  if (k === key) {
    acc.push(value6);
  }
  return acc;
}));
var getFirst = /* @__PURE__ */ dual(2, (self2, key) => map2(findFirst2(self2, ([k]) => k === key), ([, value6]) => value6));
var getLast = /* @__PURE__ */ dual(2, (self2, key) => map2(findLast(self2, ([k]) => k === key), ([, value6]) => value6));
var set10 = /* @__PURE__ */ dual(3, (self2, key, value6) => append(filter3(self2, ([k]) => k !== key), [key, String(value6)]));
var setAll4 = /* @__PURE__ */ dual(2, (self2, input) => {
  const toSet4 = fromInput2(input);
  const keys6 = toSet4.map(([k]) => k);
  return appendAll(filter3(self2, ([k]) => keys6.includes(k)), toSet4);
});
var append4 = /* @__PURE__ */ dual(3, (self2, key, value6) => append(self2, [key, String(value6)]));
var appendAll4 = /* @__PURE__ */ dual(2, (self2, input) => appendAll(self2, fromInput2(input)));
var remove11 = /* @__PURE__ */ dual(2, (self2, key) => filter3(self2, ([k]) => k !== key));
var makeUrl = /* @__PURE__ */ __name((url2, params2, hash5) => {
  try {
    const urlInstance = new URL(url2, baseUrl());
    for (let i = 0; i < params2.length; i++) {
      const [key, value6] = params2[i];
      if (value6 !== void 0) {
        urlInstance.searchParams.append(key, value6);
      }
    }
    if (hash5._tag === "Some") {
      urlInstance.hash = hash5.value;
    }
    return right2(urlInstance);
  } catch (e) {
    return left2(e);
  }
}, "makeUrl");
var toString = /* @__PURE__ */ __name((self2) => new URLSearchParams(self2).toString(), "toString");
var baseUrl = /* @__PURE__ */ __name(() => {
  if ("location" in globalThis && globalThis.location !== void 0 && globalThis.location.origin !== void 0 && globalThis.location.pathname !== void 0) {
    return location.origin + location.pathname;
  }
  return void 0;
}, "baseUrl");
var toRecord = /* @__PURE__ */ __name((self2) => {
  const out = /* @__PURE__ */ Object.create(null);
  for (const [k, value6] of self2) {
    const curr = out[k];
    if (curr === void 0) {
      out[k] = value6;
    } else if (typeof curr === "string") {
      out[k] = [curr, value6];
    } else {
      curr.push(value6);
    }
  }
  return {
    ...out
  };
}, "toRecord");
var schemaJson = /* @__PURE__ */ __name((schema4, options4) => {
  const parse5 = decodeUnknown3(parseJson(schema4), options4);
  return dual(2, (self2, field) => parse5(getOrElse2(getLast(self2, field), () => "")));
}, "schemaJson");
var schemaStruct = /* @__PURE__ */ __name((schema4, options4) => (self2) => {
  const parse5 = decodeUnknown3(schema4, options4);
  return parse5(toRecord(self2));
}, "schemaStruct");
var schemaFromString = /* @__PURE__ */ transform2(String$, schemaFromSelf2, {
  decode(fromA) {
    return fromInput2(new URLSearchParams(fromA));
  },
  encode(toI) {
    return toString(toI);
  }
});
var schemaRecord = /* @__PURE__ */ __name((schema4) => transform2(schemaFromSelf2, schema4, {
  decode(fromA) {
    return toRecord(fromA);
  },
  encode(toI) {
    return fromInput2(toI);
  }
}), "schemaRecord");
var schemaParse = /* @__PURE__ */ __name((schema4) => compose4(schemaFromString, schemaRecord(schema4)), "schemaParse");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpBody.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Stream.js
var Stream_exports = {};
__export(Stream_exports, {
  DefaultChunkSize: () => DefaultChunkSize2,
  Do: () => Do7,
  StreamTypeId: () => StreamTypeId4,
  accumulate: () => accumulate2,
  accumulateChunks: () => accumulateChunks2,
  acquireRelease: () => acquireRelease4,
  aggregate: () => aggregate2,
  aggregateWithin: () => aggregateWithin2,
  aggregateWithinEither: () => aggregateWithinEither2,
  as: () => as13,
  async: () => _async2,
  asyncEffect: () => asyncEffect4,
  asyncPush: () => asyncPush2,
  asyncScoped: () => asyncScoped2,
  bind: () => bind9,
  bindEffect: () => bindEffect2,
  bindTo: () => bindTo9,
  branchAfter: () => branchAfter2,
  broadcast: () => broadcast2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  buffer: () => buffer2,
  bufferChunks: () => bufferChunks2,
  catchAll: () => catchAll8,
  catchAllCause: () => catchAllCause7,
  catchSome: () => catchSome5,
  catchSomeCause: () => catchSomeCause4,
  catchTag: () => catchTag5,
  catchTags: () => catchTags5,
  changes: () => changes2,
  changesWith: () => changesWith2,
  changesWithEffect: () => changesWithEffect2,
  chunks: () => chunks2,
  chunksWith: () => chunksWith2,
  combine: () => combine10,
  combineChunks: () => combineChunks2,
  concat: () => concat3,
  concatAll: () => concatAll3,
  context: () => context9,
  contextWith: () => contextWith5,
  contextWithEffect: () => contextWithEffect4,
  contextWithStream: () => contextWithStream2,
  cross: () => cross2,
  crossLeft: () => crossLeft2,
  crossRight: () => crossRight2,
  crossWith: () => crossWith2,
  debounce: () => debounce2,
  decodeText: () => decodeText2,
  die: () => die12,
  dieMessage: () => dieMessage5,
  dieSync: () => dieSync8,
  distributedWith: () => distributedWith2,
  distributedWithDynamic: () => distributedWithDynamic2,
  drain: () => drain4,
  drainFork: () => drainFork2,
  drop: () => drop4,
  dropRight: () => dropRight4,
  dropUntil: () => dropUntil4,
  dropUntilEffect: () => dropUntilEffect2,
  dropWhile: () => dropWhile6,
  dropWhileEffect: () => dropWhileEffect2,
  either: () => either8,
  empty: () => empty37,
  encodeText: () => encodeText2,
  ensuring: () => ensuring8,
  ensuringWith: () => ensuringWith3,
  execute: () => execute2,
  fail: () => fail19,
  failCause: () => failCause15,
  failCauseSync: () => failCauseSync8,
  failSync: () => failSync9,
  filter: () => filter16,
  filterEffect: () => filterEffect3,
  filterMap: () => filterMap9,
  filterMapEffect: () => filterMapEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  finalizer: () => finalizer2,
  find: () => find4,
  findEffect: () => findEffect2,
  flatMap: () => flatMap22,
  flatten: () => flatten16,
  flattenChunks: () => flattenChunks2,
  flattenEffect: () => flattenEffect2,
  flattenExitOption: () => flattenExitOption2,
  flattenIterables: () => flattenIterables2,
  flattenTake: () => flattenTake2,
  forever: () => forever6,
  fromAsyncIterable: () => fromAsyncIterable2,
  fromChannel: () => fromChannel3,
  fromChunk: () => fromChunk2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunks: () => fromChunks2,
  fromEffect: () => fromEffect9,
  fromEffectOption: () => fromEffectOption2,
  fromEventListener: () => fromEventListener2,
  fromIterable: () => fromIterable15,
  fromIterableEffect: () => fromIterableEffect2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromPubSub: () => fromPubSub2,
  fromPull: () => fromPull3,
  fromQueue: () => fromQueue3,
  fromReadableStream: () => fromReadableStream2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromSchedule: () => fromSchedule2,
  fromTPubSub: () => fromTPubSub2,
  fromTQueue: () => fromTQueue2,
  groupAdjacentBy: () => groupAdjacentBy2,
  groupBy: () => groupBy3,
  groupByKey: () => groupByKey2,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin2,
  haltAfter: () => haltAfter2,
  haltWhen: () => haltWhen2,
  haltWhenDeferred: () => haltWhenDeferred2,
  identity: () => identity5,
  interleave: () => interleave2,
  interleaveWith: () => interleaveWith2,
  interruptAfter: () => interruptAfter2,
  interruptWhen: () => interruptWhen3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  intersperse: () => intersperse3,
  intersperseAffixes: () => intersperseAffixes2,
  iterate: () => iterate5,
  let: () => let_9,
  make: () => make65,
  map: () => map33,
  mapAccum: () => mapAccum6,
  mapAccumEffect: () => mapAccumEffect2,
  mapBoth: () => mapBoth10,
  mapChunks: () => mapChunks2,
  mapChunksEffect: () => mapChunksEffect2,
  mapConcat: () => mapConcat2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatEffect: () => mapConcatEffect2,
  mapEffect: () => mapEffect7,
  mapError: () => mapError10,
  mapErrorCause: () => mapErrorCause6,
  mapInputContext: () => mapInputContext7,
  merge: () => merge12,
  mergeAll: () => mergeAll10,
  mergeEither: () => mergeEither2,
  mergeLeft: () => mergeLeft2,
  mergeRight: () => mergeRight2,
  mergeWith: () => mergeWith4,
  mergeWithTag: () => mergeWithTag2,
  mkString: () => mkString3,
  never: () => never6,
  onDone: () => onDone2,
  onEnd: () => onEnd2,
  onError: () => onError4,
  onStart: () => onStart2,
  orDie: () => orDie7,
  orDieWith: () => orDieWith6,
  orElse: () => orElse14,
  orElseEither: () => orElseEither7,
  orElseFail: () => orElseFail5,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseSucceed: () => orElseSucceed5,
  paginate: () => paginate2,
  paginateChunk: () => paginateChunk2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateEffect: () => paginateEffect2,
  partition: () => partition9,
  partitionEither: () => partitionEither2,
  peel: () => peel2,
  pipeThrough: () => pipeThrough2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  prepend: () => prepend5,
  provideContext: () => provideContext8,
  provideLayer: () => provideLayer2,
  provideService: () => provideService9,
  provideServiceEffect: () => provideServiceEffect4,
  provideServiceStream: () => provideServiceStream2,
  provideSomeContext: () => provideSomeContext4,
  provideSomeLayer: () => provideSomeLayer3,
  race: () => race4,
  raceAll: () => raceAll4,
  range: () => range4,
  rechunk: () => rechunk2,
  refineOrDie: () => refineOrDie3,
  refineOrDieWith: () => refineOrDieWith3,
  repeat: () => repeat4,
  repeatEffect: () => repeatEffect2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEither: () => repeatEither2,
  repeatElements: () => repeatElements2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatValue: () => repeatValue2,
  repeatWith: () => repeatWith2,
  retry: () => retry7,
  run: () => run5,
  runCollect: () => runCollect2,
  runCount: () => runCount2,
  runDrain: () => runDrain3,
  runFold: () => runFold2,
  runFoldEffect: () => runFoldEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runForEach: () => runForEach2,
  runForEachChunk: () => runForEachChunk2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachScoped: () => runForEachScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runHead: () => runHead2,
  runIntoPubSub: () => runIntoPubSub2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runLast: () => runLast2,
  runScoped: () => runScoped3,
  runSum: () => runSum2,
  scan: () => scan3,
  scanEffect: () => scanEffect2,
  scanReduce: () => scanReduce2,
  scanReduceEffect: () => scanReduceEffect2,
  schedule: () => schedule3,
  scheduleWith: () => scheduleWith2,
  scoped: () => scoped7,
  scopedWith: () => scopedWith5,
  share: () => share2,
  sliding: () => sliding9,
  slidingSize: () => slidingSize2,
  some: () => some12,
  someOrElse: () => someOrElse2,
  someOrFail: () => someOrFail2,
  split: () => split5,
  splitLines: () => splitLines3,
  splitOnChunk: () => splitOnChunk2,
  succeed: () => succeed20,
  suspend: () => suspend13,
  sync: () => sync14,
  take: () => take9,
  takeRight: () => takeRight4,
  takeUntil: () => takeUntil4,
  takeUntilEffect: () => takeUntilEffect2,
  takeWhile: () => takeWhile6,
  tap: () => tap8,
  tapBoth: () => tapBoth5,
  tapError: () => tapError7,
  tapErrorCause: () => tapErrorCause6,
  tapSink: () => tapSink2,
  throttle: () => throttle2,
  throttleEffect: () => throttleEffect2,
  tick: () => tick2,
  timeout: () => timeout4,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutTo: () => timeoutTo4,
  toAsyncIterable: () => toAsyncIterable2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toChannel: () => toChannel3,
  toPubSub: () => toPubSub3,
  toPull: () => toPull3,
  toQueue: () => toQueue3,
  toQueueOfElements: () => toQueueOfElements2,
  toReadableStream: () => toReadableStream2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  transduce: () => transduce2,
  unfold: () => unfold5,
  unfoldChunk: () => unfoldChunk2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldEffect: () => unfoldEffect2,
  unwrap: () => unwrap5,
  unwrapScoped: () => unwrapScoped5,
  unwrapScopedWith: () => unwrapScopedWith4,
  updateService: () => updateService5,
  void: () => void_11,
  when: () => when5,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect2,
  whenEffect: () => whenEffect4,
  withExecutionPlan: () => withExecutionPlan4,
  withSpan: () => withSpan7,
  zip: () => zip13,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft2,
  zipAllRight: () => zipAllRight2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllWith: () => zipAllWith2,
  zipFlatten: () => zipFlatten2,
  zipLatest: () => zipLatest2,
  zipLatestAll: () => zipLatestAll2,
  zipLatestWith: () => zipLatestWith2,
  zipLeft: () => zipLeft12,
  zipRight: () => zipRight13,
  zipWith: () => zipWith17,
  zipWithChunks: () => zipWithChunks2,
  zipWithIndex: () => zipWithIndex2,
  zipWithNext: () => zipWithNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/groupBy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Queue.js
var Queue_exports = {};
__export(Queue_exports, {
  BackingQueueTypeId: () => BackingQueueTypeId2,
  DequeueTypeId: () => DequeueTypeId2,
  EnqueueTypeId: () => EnqueueTypeId2,
  QueueStrategyTypeId: () => QueueStrategyTypeId2,
  awaitShutdown: () => awaitShutdown2,
  backPressureStrategy: () => backPressureStrategy2,
  bounded: () => bounded3,
  capacity: () => capacity3,
  dropping: () => dropping2,
  droppingStrategy: () => droppingStrategy2,
  isDequeue: () => isDequeue2,
  isEmpty: () => isEmpty12,
  isEnqueue: () => isEnqueue2,
  isFull: () => isFull2,
  isQueue: () => isQueue2,
  isShutdown: () => isShutdown2,
  make: () => make53,
  offer: () => offer3,
  offerAll: () => offerAll3,
  poll: () => poll6,
  shutdown: () => shutdown2,
  size: () => size14,
  sliding: () => sliding2,
  slidingStrategy: () => slidingStrategy2,
  take: () => take4,
  takeAll: () => takeAll2,
  takeBetween: () => takeBetween2,
  takeN: () => takeN2,
  takeUpTo: () => takeUpTo2,
  unbounded: () => unbounded3,
  unsafeOffer: () => unsafeOffer2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/queue.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var EnqueueSymbolKey = "effect/QueueEnqueue";
var EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
var DequeueSymbolKey = "effect/QueueDequeue";
var DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
var QueueStrategySymbolKey = "effect/QueueStrategy";
var QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
var BackingQueueSymbolKey = "effect/BackingQueue";
var BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
var queueStrategyVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var backingQueueVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var enqueueVariance = {
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In")
};
var dequeueVariance = {
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var QueueImpl = class extends Class2 {
  static {
    __name(this, "QueueImpl");
  }
  queue;
  takers;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
    super();
    this.queue = queue;
    this.takers = takers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
  capacity() {
    return this.queue.capacity();
  }
  get size() {
    return suspend(() => catchAll(this.unsafeSize(), () => interrupt2));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.queue.length() - length3(this.takers) + this.strategy.surplusSize());
  }
  get isEmpty() {
    return map12(this.size, (size22) => size22 <= 0);
  }
  get isFull() {
    return map12(this.size, (size22) => size22 >= this.capacity());
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state2) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state2.id()), false, false), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  unsafeOffer(value6) {
    if (get7(this.shutdownFlag)) {
      return false;
    }
    let noRemaining;
    if (this.queue.length() === 0) {
      const taker = pipe(this.takers, poll4(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, value6);
        noRemaining = true;
      } else {
        noRemaining = false;
      }
    } else {
      noRemaining = false;
    }
    if (noRemaining) {
      return true;
    }
    const succeeded = this.queue.offer(value6);
    unsafeCompleteTakers(this.strategy, this.queue, this.takers);
    return succeeded;
  }
  offer(value6) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll4(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred(taker, value6);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return succeed(true);
      }
      const succeeded = this.queue.offer(value6);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded ? succeed(true) : this.strategy.handleSurplus([value6], this.queue, this.takers, this.shutdownFlag);
    });
  }
  offerAll(iterable) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const values6 = fromIterable2(iterable);
      const pTakers = this.queue.length() === 0 ? fromIterable2(unsafePollN(this.takers, values6.length)) : empty3;
      const [forTakers, remaining] = pipe(values6, splitAt(pTakers.length));
      for (let i = 0; i < pTakers.length; i++) {
        const taker = pTakers[i];
        const item = forTakers[i];
        unsafeCompleteDeferred(taker, item);
      }
      if (remaining.length === 0) {
        return succeed(true);
      }
      const surplus = this.queue.offerAll(remaining);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return isEmpty(surplus) ? succeed(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
    });
  }
  get take() {
    return withFiberRuntime((state2) => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const item = this.queue.poll(EmptyMutableQueue);
      if (item !== EmptyMutableQueue) {
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return succeed(item);
      } else {
        const deferred = deferredUnsafeMake(state2.id());
        return pipe(suspend(() => {
          pipe(this.takers, offer(deferred));
          unsafeCompleteTakers(this.strategy, this.queue, this.takers);
          return get7(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => {
          return sync(() => unsafeRemove(this.takers, deferred));
        }));
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      return get7(this.shutdownFlag) ? interrupt2 : sync(() => {
        const values6 = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable3(values6);
      });
    });
  }
  takeUpTo(max9) {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : sync(() => {
      const values6 = this.queue.pollUpTo(max9);
      this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
      return fromIterable3(values6);
    }));
  }
  takeBetween(min6, max9) {
    return suspend(() => takeRemainderLoop(this, min6, max9, empty4()));
  }
};
var takeRemainderLoop = /* @__PURE__ */ __name((self2, min6, max9, acc) => {
  if (max9 < min6) {
    return succeed(acc);
  }
  return pipe(takeUpTo(self2, max9), flatMap10((bs) => {
    const remaining = min6 - bs.length;
    if (remaining === 1) {
      return pipe(take3(self2), map12((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(take3(self2), flatMap10((b) => takeRemainderLoop(self2, remaining - 1, max9 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
}, "takeRemainderLoop");
var isQueue = /* @__PURE__ */ __name((u) => isEnqueue(u) && isDequeue(u), "isQueue");
var isEnqueue = /* @__PURE__ */ __name((u) => hasProperty(u, EnqueueTypeId), "isEnqueue");
var isDequeue = /* @__PURE__ */ __name((u) => hasProperty(u, DequeueTypeId), "isDequeue");
var bounded2 = /* @__PURE__ */ __name((requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap10((queue) => make52(backingQueueFromMutableQueue(queue), backPressureStrategy()))), "bounded");
var dropping = /* @__PURE__ */ __name((requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap10((queue) => make52(backingQueueFromMutableQueue(queue), droppingStrategy()))), "dropping");
var sliding = /* @__PURE__ */ __name((requestedCapacity) => pipe(sync(() => bounded(requestedCapacity)), flatMap10((queue) => make52(backingQueueFromMutableQueue(queue), slidingStrategy()))), "sliding");
var unbounded2 = /* @__PURE__ */ __name(() => pipe(sync(() => unbounded()), flatMap10((queue) => make52(backingQueueFromMutableQueue(queue), droppingStrategy()))), "unbounded");
var unsafeMake13 = /* @__PURE__ */ __name((queue, takers, shutdownHook, shutdownFlag, strategy) => {
  return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
}, "unsafeMake");
var make52 = /* @__PURE__ */ __name((queue, strategy) => pipe(deferredMake(), map12((deferred) => unsafeMake13(queue, unbounded(), deferred, make13(false), strategy))), "make");
var BackingQueueFromMutableQueue = class {
  static {
    __name(this, "BackingQueueFromMutableQueue");
  }
  mutable;
  [BackingQueueTypeId] = backingQueueVariance;
  constructor(mutable3) {
    this.mutable = mutable3;
  }
  poll(def) {
    return poll4(this.mutable, def);
  }
  pollUpTo(limit) {
    return pollUpTo(this.mutable, limit);
  }
  offerAll(elements) {
    return offerAll(this.mutable, elements);
  }
  offer(element2) {
    return offer(this.mutable, element2);
  }
  capacity() {
    return capacity(this.mutable);
  }
  length() {
    return length3(this.mutable);
  }
};
var backingQueueFromMutableQueue = /* @__PURE__ */ __name((mutable3) => new BackingQueueFromMutableQueue(mutable3), "backingQueueFromMutableQueue");
var capacity2 = /* @__PURE__ */ __name((self2) => self2.capacity(), "capacity");
var size13 = /* @__PURE__ */ __name((self2) => self2.size, "size");
var isFull = /* @__PURE__ */ __name((self2) => self2.isFull, "isFull");
var isEmpty11 = /* @__PURE__ */ __name((self2) => self2.isEmpty, "isEmpty");
var isShutdown = /* @__PURE__ */ __name((self2) => self2.isShutdown, "isShutdown");
var awaitShutdown = /* @__PURE__ */ __name((self2) => self2.awaitShutdown, "awaitShutdown");
var shutdown = /* @__PURE__ */ __name((self2) => self2.shutdown, "shutdown");
var offer2 = /* @__PURE__ */ dual(2, (self2, value6) => self2.offer(value6));
var unsafeOffer = /* @__PURE__ */ dual(2, (self2, value6) => self2.unsafeOffer(value6));
var offerAll2 = /* @__PURE__ */ dual(2, (self2, iterable) => self2.offerAll(iterable));
var poll5 = /* @__PURE__ */ __name((self2) => map12(self2.takeUpTo(1), head3), "poll");
var take3 = /* @__PURE__ */ __name((self2) => self2.take, "take");
var takeAll = /* @__PURE__ */ __name((self2) => self2.takeAll, "takeAll");
var takeUpTo = /* @__PURE__ */ dual(2, (self2, max9) => self2.takeUpTo(max9));
var takeBetween = /* @__PURE__ */ dual(3, (self2, min6, max9) => self2.takeBetween(min6, max9));
var takeN = /* @__PURE__ */ dual(2, (self2, n) => self2.takeBetween(n, n));
var backPressureStrategy = /* @__PURE__ */ __name(() => new BackPressureStrategy(), "backPressureStrategy");
var droppingStrategy = /* @__PURE__ */ __name(() => new DroppingStrategy(), "droppingStrategy");
var slidingStrategy = /* @__PURE__ */ __name(() => new SlidingStrategy(), "slidingStrategy");
var BackPressureStrategy = class {
  static {
    __name(this, "BackPressureStrategy");
  }
  [QueueStrategyTypeId] = queueStrategyVariance;
  putters = /* @__PURE__ */ unbounded();
  surplusSize() {
    return length3(this.putters);
  }
  onCompleteTakersWithEmptyQueue(takers) {
    while (!isEmpty10(this.putters) && !isEmpty10(takers)) {
      const taker = poll4(takers, void 0);
      const putter = poll4(this.putters, void 0);
      if (putter[2]) {
        unsafeCompleteDeferred(putter[1], true);
      }
      unsafeCompleteDeferred(taker, putter[0]);
    }
  }
  get shutdown() {
    return pipe(fiberId, flatMap10((fiberId5) => pipe(sync(() => unsafePollAll(this.putters)), flatMap10((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId5), asVoid2) : void_3, false, false)))));
  }
  handleSurplus(iterable, queue, takers, isShutdown8) {
    return withFiberRuntime((state2) => {
      const deferred = deferredUnsafeMake(state2.id());
      return pipe(suspend(() => {
        this.unsafeOffer(iterable, deferred);
        this.unsafeOnQueueEmptySpace(queue, takers);
        unsafeCompleteTakers(this, queue, takers);
        return get7(isShutdown8) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnQueueEmptySpace(queue, takers) {
    let keepPolling = true;
    while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
      const putter = pipe(this.putters, poll4(EmptyMutableQueue));
      if (putter === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const offered = queue.offer(putter[0]);
        if (offered && putter[2]) {
          unsafeCompleteDeferred(putter[1], true);
        } else if (!offered) {
          unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), prepend2(putter)));
        }
        unsafeCompleteTakers(this, queue, takers);
      }
    }
  }
  unsafeOffer(iterable, deferred) {
    const stuff = fromIterable2(iterable);
    for (let i = 0; i < stuff.length; i++) {
      const value6 = stuff[i];
      if (i === stuff.length - 1) {
        pipe(this.putters, offer([value6, deferred, true]));
      } else {
        pipe(this.putters, offer([value6, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll(this.putters, pipe(unsafePollAll(this.putters), filter4(([, _]) => _ !== deferred)));
  }
};
var DroppingStrategy = class {
  static {
    __name(this, "DroppingStrategy");
  }
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_3;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(_iterable, _queue, _takers, _isShutdown) {
    return succeed(false);
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
};
var SlidingStrategy = class {
  static {
    __name(this, "SlidingStrategy");
  }
  [QueueStrategyTypeId] = queueStrategyVariance;
  surplusSize() {
    return 0;
  }
  get shutdown() {
    return void_3;
  }
  onCompleteTakersWithEmptyQueue() {
  }
  handleSurplus(iterable, queue, takers, _isShutdown) {
    return sync(() => {
      this.unsafeOffer(queue, iterable);
      unsafeCompleteTakers(this, queue, takers);
      return true;
    });
  }
  unsafeOnQueueEmptySpace(_queue, _takers) {
  }
  unsafeOffer(queue, iterable) {
    const iterator = iterable[Symbol.iterator]();
    let next4;
    let offering = true;
    while (!(next4 = iterator.next()).done && offering) {
      if (queue.capacity() === 0) {
        return;
      }
      queue.poll(EmptyMutableQueue);
      offering = queue.offer(next4.value);
    }
  }
};
var unsafeCompleteDeferred = /* @__PURE__ */ __name((deferred, a) => {
  return deferredUnsafeDone(deferred, succeed(a));
}, "unsafeCompleteDeferred");
var unsafeOfferAll = /* @__PURE__ */ __name((queue, as16) => {
  return pipe(queue, offerAll(as16));
}, "unsafeOfferAll");
var unsafePollAll = /* @__PURE__ */ __name((queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
}, "unsafePollAll");
var unsafePollN = /* @__PURE__ */ __name((queue, max9) => {
  return pipe(queue, pollUpTo(max9));
}, "unsafePollN");
var unsafeRemove = /* @__PURE__ */ __name((queue, a) => {
  unsafeOfferAll(queue, pipe(unsafePollAll(queue), filter4((b) => a !== b)));
}, "unsafeRemove");
var unsafeCompleteTakers = /* @__PURE__ */ __name((strategy, queue, takers) => {
  let keepPolling = true;
  while (keepPolling && queue.length() !== 0) {
    const taker = pipe(takers, poll4(EmptyMutableQueue));
    if (taker !== EmptyMutableQueue) {
      const element2 = queue.poll(EmptyMutableQueue);
      if (element2 !== EmptyMutableQueue) {
        unsafeCompleteDeferred(taker, element2);
        strategy.unsafeOnQueueEmptySpace(queue, takers);
      } else {
        unsafeOfferAll(takers, pipe(unsafePollAll(takers), prepend2(taker)));
      }
      keepPolling = true;
    } else {
      keepPolling = false;
    }
  }
  if (keepPolling && queue.length() === 0 && !isEmpty10(takers)) {
    strategy.onCompleteTakersWithEmptyQueue(takers);
  }
}, "unsafeCompleteTakers");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Queue.js
var EnqueueTypeId2 = EnqueueTypeId;
var DequeueTypeId2 = DequeueTypeId;
var QueueStrategyTypeId2 = QueueStrategyTypeId;
var BackingQueueTypeId2 = BackingQueueTypeId;
var isQueue2 = isQueue;
var isDequeue2 = isDequeue;
var isEnqueue2 = isEnqueue;
var backPressureStrategy2 = backPressureStrategy;
var droppingStrategy2 = droppingStrategy;
var slidingStrategy2 = slidingStrategy;
var make53 = make52;
var bounded3 = bounded2;
var dropping2 = dropping;
var sliding2 = sliding;
var unbounded3 = unbounded2;
var capacity3 = capacity2;
var size14 = size13;
var isEmpty12 = isEmpty11;
var isFull2 = isFull;
var isShutdown2 = isShutdown;
var awaitShutdown2 = awaitShutdown;
var shutdown2 = shutdown;
var offer3 = offer2;
var unsafeOffer2 = unsafeOffer;
var offerAll3 = offerAll2;
var poll6 = poll5;
var take4 = take3;
var takeAll2 = takeAll;
var takeUpTo2 = takeUpTo;
var takeBetween2 = takeBetween;
var takeN2 = takeN;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/PubSub.js
var PubSub_exports = {};
__export(PubSub_exports, {
  awaitShutdown: () => awaitShutdown4,
  bounded: () => bounded5,
  capacity: () => capacity5,
  dropping: () => dropping4,
  isEmpty: () => isEmpty14,
  isFull: () => isFull4,
  isShutdown: () => isShutdown4,
  publish: () => publish2,
  publishAll: () => publishAll2,
  shutdown: () => shutdown4,
  size: () => size16,
  sliding: () => sliding4,
  subscribe: () => subscribe2,
  unbounded: () => unbounded5
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/pubsub.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
var addSubscribers = /* @__PURE__ */ __name((subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    subscribers.set(subscription, /* @__PURE__ */ new Set());
  }
  const set20 = subscribers.get(subscription);
  set20.add(pollers);
}, "addSubscribers");
var removeSubscribers = /* @__PURE__ */ __name((subscription, pollers) => (subscribers) => {
  if (!subscribers.has(subscription)) {
    return;
  }
  const set20 = subscribers.get(subscription);
  set20.delete(pollers);
  if (set20.size === 0) {
    subscribers.delete(subscription);
  }
}, "removeSubscribers");
var bounded4 = /* @__PURE__ */ __name((capacity9) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity9);
  return makePubSub(pubsub, new BackPressureStrategy2());
}), "bounded");
var dropping3 = /* @__PURE__ */ __name((capacity9) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity9);
  return makePubSub(pubsub, new DroppingStrategy2());
}), "dropping");
var sliding3 = /* @__PURE__ */ __name((capacity9) => suspend(() => {
  const pubsub = makeBoundedPubSub(capacity9);
  return makePubSub(pubsub, new SlidingStrategy2());
}), "sliding");
var unbounded4 = /* @__PURE__ */ __name((options4) => suspend(() => {
  const pubsub = makeUnboundedPubSub(options4);
  return makePubSub(pubsub, new DroppingStrategy2());
}), "unbounded");
var capacity4 = /* @__PURE__ */ __name((self2) => self2.capacity(), "capacity");
var size15 = /* @__PURE__ */ __name((self2) => self2.size, "size");
var isFull3 = /* @__PURE__ */ __name((self2) => self2.isFull, "isFull");
var isEmpty13 = /* @__PURE__ */ __name((self2) => self2.isEmpty, "isEmpty");
var shutdown3 = /* @__PURE__ */ __name((self2) => self2.shutdown, "shutdown");
var isShutdown3 = /* @__PURE__ */ __name((self2) => self2.isShutdown, "isShutdown");
var awaitShutdown3 = /* @__PURE__ */ __name((self2) => self2.awaitShutdown, "awaitShutdown");
var publish = /* @__PURE__ */ dual(2, (self2, value6) => self2.publish(value6));
var publishAll = /* @__PURE__ */ dual(2, (self2, elements) => self2.publishAll(elements));
var subscribe = /* @__PURE__ */ __name((self2) => self2.subscribe, "subscribe");
var makeBoundedPubSub = /* @__PURE__ */ __name((capacity9) => {
  const options4 = typeof capacity9 === "number" ? {
    capacity: capacity9
  } : capacity9;
  ensureCapacity(options4.capacity);
  const replayBuffer = options4.replay && options4.replay > 0 ? new ReplayBuffer(Math.ceil(options4.replay)) : void 0;
  if (options4.capacity === 1) {
    return new BoundedPubSubSingle(replayBuffer);
  } else if (nextPow2(options4.capacity) === options4.capacity) {
    return new BoundedPubSubPow2(options4.capacity, replayBuffer);
  } else {
    return new BoundedPubSubArb(options4.capacity, replayBuffer);
  }
}, "makeBoundedPubSub");
var makeUnboundedPubSub = /* @__PURE__ */ __name((options4) => new UnboundedPubSub(options4?.replay ? new ReplayBuffer(options4.replay) : void 0), "makeUnboundedPubSub");
var makeSubscription = /* @__PURE__ */ __name((pubsub, subscribers, strategy) => map12(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded(), deferred, make13(false), strategy)), "makeSubscription");
var unsafeMakeSubscription = /* @__PURE__ */ __name((pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow()), "unsafeMakeSubscription");
var BoundedPubSubArb = class {
  static {
    __name(this, "BoundedPubSubArb");
  }
  capacity;
  replayBuffer;
  array;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity9, replayBuffer) {
    this.capacity = capacity9;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity9
    });
    this.subscribers = Array.from({
      length: capacity9
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value6) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index2 = this.publisherIndex % this.capacity;
      this.array[index2] = value6;
      this.subscribers[index2] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty4();
    }
    const chunk4 = fromIterable3(elements);
    const n = chunk4.length;
    const size22 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size22;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk4;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const a = unsafeGet2(chunk4, iteratorIndex++);
      const index2 = this.publisherIndex % this.capacity;
      this.array[index2] = a;
      this.subscribers[index2] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(a);
      }
    }
    return drop2(chunk4, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index2 = this.subscribersIndex % this.capacity;
      this.array[index2] = AbsentValue;
      this.subscribers[index2] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubArbSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubArbSubscription = class {
  static {
    __name(this, "BoundedPubSubArbSubscription");
  }
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index2 = this.subscriberIndex % this.self.capacity;
      const elem = this.self.array[index2];
      this.self.subscribers[index2] -= 1;
      if (this.self.subscribers[index2] === 0) {
        this.self.array[index2] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty4();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size22 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size22);
    if (toPoll <= 0) {
      return empty4();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index2 = this.subscriberIndex % this.self.capacity;
      const a = this.self.array[index2];
      this.self.subscribers[index2] -= 1;
      if (this.self.subscribers[index2] === 0) {
        this.self.array[index2] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(a);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index2 = this.subscriberIndex % this.self.capacity;
        this.self.subscribers[index2] -= 1;
        if (this.self.subscribers[index2] === 0) {
          this.self.array[index2] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubPow2 = class {
  static {
    __name(this, "BoundedPubSubPow2");
  }
  capacity;
  replayBuffer;
  array;
  mask;
  publisherIndex = 0;
  subscribers;
  subscriberCount = 0;
  subscribersIndex = 0;
  constructor(capacity9, replayBuffer) {
    this.capacity = capacity9;
    this.replayBuffer = replayBuffer;
    this.array = Array.from({
      length: capacity9
    });
    this.mask = capacity9 - 1;
    this.subscribers = Array.from({
      length: capacity9
    });
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherIndex === this.subscribersIndex;
  }
  isFull() {
    return this.publisherIndex === this.subscribersIndex + this.capacity;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value6) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      const index2 = this.publisherIndex & this.mask;
      this.array[index2] = value6;
      this.subscribers[index2] = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty4();
    }
    const chunk4 = fromIterable3(elements);
    const n = chunk4.length;
    const size22 = this.publisherIndex - this.subscribersIndex;
    const available = this.capacity - size22;
    const forPubSub = Math.min(n, available);
    if (forPubSub === 0) {
      return chunk4;
    }
    let iteratorIndex = 0;
    const publishAllIndex = this.publisherIndex + forPubSub;
    while (this.publisherIndex !== publishAllIndex) {
      const elem = unsafeGet2(chunk4, iteratorIndex++);
      const index2 = this.publisherIndex & this.mask;
      this.array[index2] = elem;
      this.subscribers[index2] = this.subscriberCount;
      this.publisherIndex += 1;
      if (this.replayBuffer) {
        this.replayBuffer.offer(elem);
      }
    }
    return drop2(chunk4, iteratorIndex);
  }
  slide() {
    if (this.subscribersIndex !== this.publisherIndex) {
      const index2 = this.subscribersIndex & this.mask;
      this.array[index2] = AbsentValue;
      this.subscribers[index2] = 0;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubPow2Subscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubPow2Subscription = class {
  static {
    __name(this, "BoundedPubSubPow2Subscription");
  }
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.publisherIndex === this.subscriberIndex || this.self.publisherIndex === this.self.subscribersIndex;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    if (this.subscriberIndex !== this.self.publisherIndex) {
      const index2 = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index2];
      this.self.subscribers[index2] -= 1;
      if (this.self.subscribers[index2] === 0) {
        this.self.array[index2] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      this.subscriberIndex += 1;
      return elem;
    }
    return default_;
  }
  pollUpTo(n) {
    if (this.unsubscribed) {
      return empty4();
    }
    this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
    const size22 = this.self.publisherIndex - this.subscriberIndex;
    const toPoll = Math.min(n, size22);
    if (toPoll <= 0) {
      return empty4();
    }
    const builder = [];
    const pollUpToIndex = this.subscriberIndex + toPoll;
    while (this.subscriberIndex !== pollUpToIndex) {
      const index2 = this.subscriberIndex & this.self.mask;
      const elem = this.self.array[index2];
      this.self.subscribers[index2] -= 1;
      if (this.self.subscribers[index2] === 0) {
        this.self.array[index2] = AbsentValue;
        this.self.subscribersIndex += 1;
      }
      builder.push(elem);
      this.subscriberIndex += 1;
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      this.subscriberIndex = Math.max(this.subscriberIndex, this.self.subscribersIndex);
      while (this.subscriberIndex !== this.self.publisherIndex) {
        const index2 = this.subscriberIndex & this.self.mask;
        this.self.subscribers[index2] -= 1;
        if (this.self.subscribers[index2] === 0) {
          this.self.array[index2] = AbsentValue;
          this.self.subscribersIndex += 1;
        }
        this.subscriberIndex += 1;
      }
    }
  }
};
var BoundedPubSubSingle = class {
  static {
    __name(this, "BoundedPubSubSingle");
  }
  replayBuffer;
  publisherIndex = 0;
  subscriberCount = 0;
  subscribers = 0;
  value = AbsentValue;
  capacity = 1;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  isEmpty() {
    return this.subscribers === 0;
  }
  isFull() {
    return !this.isEmpty();
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  publish(value6) {
    if (this.isFull()) {
      return false;
    }
    if (this.subscriberCount !== 0) {
      this.value = value6;
      this.subscribers = this.subscriberCount;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.subscriberCount === 0) {
      if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty4();
    }
    const chunk4 = fromIterable3(elements);
    if (isEmpty(chunk4)) {
      return chunk4;
    }
    if (this.publish(unsafeHead2(chunk4))) {
      return drop2(chunk4, 1);
    } else {
      return chunk4;
    }
  }
  slide() {
    if (this.isFull()) {
      this.subscribers = 0;
      this.value = AbsentValue;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.subscriberCount += 1;
    return new BoundedPubSubSingleSubscription(this, this.publisherIndex, false);
  }
};
var BoundedPubSubSingleSubscription = class {
  static {
    __name(this, "BoundedPubSubSingleSubscription");
  }
  self;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    return this.unsubscribed || this.self.subscribers === 0 || this.subscriberIndex === this.self.publisherIndex;
  }
  size() {
    return this.isEmpty() ? 0 : 1;
  }
  poll(default_) {
    if (this.isEmpty()) {
      return default_;
    }
    const elem = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return elem;
  }
  pollUpTo(n) {
    if (this.isEmpty() || n < 1) {
      return empty4();
    }
    const a = this.self.value;
    this.self.subscribers -= 1;
    if (this.self.subscribers === 0) {
      this.self.value = AbsentValue;
    }
    this.subscriberIndex += 1;
    return of2(a);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.subscriberCount -= 1;
      if (this.subscriberIndex !== this.self.publisherIndex) {
        this.self.subscribers -= 1;
        if (this.self.subscribers === 0) {
          this.self.value = AbsentValue;
        }
      }
    }
  }
};
var UnboundedPubSub = class {
  static {
    __name(this, "UnboundedPubSub");
  }
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value6) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value: value6,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value6);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty4();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
};
var UnboundedPubSubSubscription = class {
  static {
    __name(this, "UnboundedPubSubSubscription");
  }
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty45 = true;
    let loop5 = true;
    while (loop5) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop5 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty45 = false;
          loop5 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty45;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop5 = true;
    let polled = default_;
    while (loop5) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop5 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop5 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable3(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
};
var SubscriptionImpl = class extends Class2 {
  static {
    __name(this, "SubscriptionImpl");
  }
  pubsub;
  subscribers;
  subscription;
  pollers;
  shutdownHook;
  shutdownFlag;
  strategy;
  replayWindow;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
    super();
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.subscription = subscription;
    this.pollers = pollers;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
    this.replayWindow = replayWindow;
  }
  commit() {
    return this.take;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  capacity() {
    return this.pubsub.capacity;
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  get size() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() + this.replayWindow.remaining));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.subscription.size() + this.replayWindow.remaining);
  }
  get isFull() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : succeed(this.subscription.size() === this.capacity()));
  }
  get isEmpty() {
    return map12(this.size, (size22) => size22 === 0);
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state2) => {
      set2(this.shutdownFlag, true);
      return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state2.id()), false), zipRight2(sync(() => {
        this.subscribers.delete(this.subscription);
        this.subscription.unsubscribe();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      })), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get take() {
    return withFiberRuntime((state2) => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.replayWindow.remaining > 0) {
        const message2 = this.replayWindow.take();
        return succeed(message2);
      }
      const message = isEmpty10(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
      if (message === EmptyMutableQueue) {
        const deferred = deferredUnsafeMake(state2.id());
        return pipe(suspend(() => {
          pipe(this.pollers, offer(deferred));
          pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
          this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
          return get7(this.shutdownFlag) ? interrupt2 : deferredAwait(deferred);
        }), onInterrupt(() => sync(() => unsafeRemove2(this.pollers, deferred))));
      } else {
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return succeed(message);
      }
    });
  }
  get takeAll() {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const as16 = isEmpty10(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty4();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      if (this.replayWindow.remaining > 0) {
        return succeed(appendAll2(this.replayWindow.takeAll(), as16));
      }
      return succeed(as16);
    });
  }
  takeUpTo(max9) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      let replay = void 0;
      if (this.replayWindow.remaining >= max9) {
        const as17 = this.replayWindow.takeN(max9);
        return succeed(as17);
      } else if (this.replayWindow.remaining > 0) {
        replay = this.replayWindow.takeAll();
        max9 = max9 - replay.length;
      }
      const as16 = isEmpty10(this.pollers) ? unsafePollN2(this.subscription, max9) : empty4();
      this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
      return replay ? succeed(appendAll2(replay, as16)) : succeed(as16);
    });
  }
  takeBetween(min6, max9) {
    return suspend(() => takeRemainderLoop2(this, min6, max9, empty4()));
  }
};
var takeRemainderLoop2 = /* @__PURE__ */ __name((self2, min6, max9, acc) => {
  if (max9 < min6) {
    return succeed(acc);
  }
  return pipe(self2.takeUpTo(max9), flatMap10((bs) => {
    const remaining = min6 - bs.length;
    if (remaining === 1) {
      return pipe(self2.take, map12((b) => pipe(acc, appendAll2(bs), append2(b))));
    }
    if (remaining > 1) {
      return pipe(self2.take, flatMap10((b) => takeRemainderLoop2(self2, remaining - 1, max9 - bs.length - 1, pipe(acc, appendAll2(bs), append2(b)))));
    }
    return succeed(pipe(acc, appendAll2(bs)));
  }));
}, "takeRemainderLoop");
var PubSubImpl = class {
  static {
    __name(this, "PubSubImpl");
  }
  pubsub;
  subscribers;
  scope;
  shutdownHook;
  shutdownFlag;
  strategy;
  [EnqueueTypeId] = enqueueVariance;
  [DequeueTypeId] = dequeueVariance;
  constructor(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) {
    this.pubsub = pubsub;
    this.subscribers = subscribers;
    this.scope = scope5;
    this.shutdownHook = shutdownHook;
    this.shutdownFlag = shutdownFlag;
    this.strategy = strategy;
  }
  capacity() {
    return this.pubsub.capacity;
  }
  get size() {
    return suspend(() => get7(this.shutdownFlag) ? interrupt2 : sync(() => this.pubsub.size()));
  }
  unsafeSize() {
    if (get7(this.shutdownFlag)) {
      return none2();
    }
    return some3(this.pubsub.size());
  }
  get isFull() {
    return map12(this.size, (size22) => size22 === this.capacity());
  }
  get isEmpty() {
    return map12(this.size, (size22) => size22 === 0);
  }
  get awaitShutdown() {
    return deferredAwait(this.shutdownHook);
  }
  get isShutdown() {
    return sync(() => get7(this.shutdownFlag));
  }
  get shutdown() {
    return uninterruptible(withFiberRuntime((state2) => {
      pipe(this.shutdownFlag, set2(true));
      return pipe(this.scope.close(exitInterrupt(state2.id())), zipRight2(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid2);
    }));
  }
  publish(value6) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      if (this.pubsub.publish(value6)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, of2(value6), this.shutdownFlag);
    });
  }
  isActive() {
    return !get7(this.shutdownFlag);
  }
  unsafeOffer(value6) {
    if (get7(this.shutdownFlag)) {
      return false;
    }
    if (this.pubsub.publish(value6)) {
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      return true;
    }
    return false;
  }
  publishAll(elements) {
    return suspend(() => {
      if (get7(this.shutdownFlag)) {
        return interrupt2;
      }
      const surplus = unsafePublishAll(this.pubsub, elements);
      this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
      if (isEmpty(surplus)) {
        return succeed(true);
      }
      return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
    });
  }
  get subscribe() {
    const acquire = tap2(all6([this.scope.fork(sequential2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple5) => tuple5[0].addFinalizer(() => tuple5[1].shutdown));
    return map12(acquireRelease(acquire, (tuple5, exit5) => tuple5[0].close(exit5)), (tuple5) => tuple5[1]);
  }
  offer(value6) {
    return this.publish(value6);
  }
  offerAll(elements) {
    return this.publishAll(elements);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makePubSub = /* @__PURE__ */ __name((pubsub, strategy) => flatMap10(scopeMake(), (scope5) => map12(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, /* @__PURE__ */ new Map(), scope5, deferred, make13(false), strategy))), "makePubSub");
var unsafeMakePubSub = /* @__PURE__ */ __name((pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope5, shutdownHook, shutdownFlag, strategy), "unsafeMakePubSub");
var ensureCapacity = /* @__PURE__ */ __name((capacity9) => {
  if (capacity9 <= 0) {
    throw new InvalidPubSubCapacityException(`Cannot construct PubSub with capacity of ${capacity9}`);
  }
}, "ensureCapacity");
var unsafeCompleteDeferred2 = /* @__PURE__ */ __name((deferred, a) => {
  deferredUnsafeDone(deferred, succeed(a));
}, "unsafeCompleteDeferred");
var unsafeOfferAll2 = /* @__PURE__ */ __name((queue, as16) => {
  return pipe(queue, offerAll(as16));
}, "unsafeOfferAll");
var unsafePollAllQueue = /* @__PURE__ */ __name((queue) => {
  return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
}, "unsafePollAllQueue");
var unsafePollAllSubscription = /* @__PURE__ */ __name((subscription) => {
  return subscription.pollUpTo(Number.POSITIVE_INFINITY);
}, "unsafePollAllSubscription");
var unsafePollN2 = /* @__PURE__ */ __name((subscription, max9) => {
  return subscription.pollUpTo(max9);
}, "unsafePollN");
var unsafePublishAll = /* @__PURE__ */ __name((pubsub, as16) => {
  return pubsub.publishAll(as16);
}, "unsafePublishAll");
var unsafeRemove2 = /* @__PURE__ */ __name((queue, value6) => {
  unsafeOfferAll2(queue, pipe(unsafePollAllQueue(queue), filter4((elem) => elem !== value6)));
}, "unsafeRemove");
var BackPressureStrategy2 = class {
  static {
    __name(this, "BackPressureStrategy");
  }
  publishers = /* @__PURE__ */ unbounded();
  get shutdown() {
    return flatMap10(fiberId, (fiberId5) => flatMap10(sync(() => unsafePollAllQueue(this.publishers)), (publishers) => forEachConcurrentDiscard(publishers, ([_, deferred, last5]) => last5 ? pipe(deferredInterruptWith(deferred, fiberId5), asVoid2) : void_3, false, false)));
  }
  handleSurplus(pubsub, subscribers, elements, isShutdown8) {
    return withFiberRuntime((state2) => {
      const deferred = deferredUnsafeMake(state2.id());
      return pipe(suspend(() => {
        this.unsafeOffer(elements, deferred);
        this.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        this.unsafeCompleteSubscribers(pubsub, subscribers);
        return get7(isShutdown8) ? interrupt2 : deferredAwait(deferred);
      }), onInterrupt(() => sync(() => this.unsafeRemove(deferred))));
    });
  }
  unsafeOnPubSubEmptySpace(pubsub, subscribers) {
    let keepPolling = true;
    while (keepPolling && !pubsub.isFull()) {
      const publisher = pipe(this.publishers, poll4(EmptyMutableQueue));
      if (publisher === EmptyMutableQueue) {
        keepPolling = false;
      } else {
        const published = pubsub.publish(publisher[0]);
        if (published && publisher[2]) {
          unsafeCompleteDeferred2(publisher[1], true);
        } else if (!published) {
          unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), prepend2(publisher)));
        }
        this.unsafeCompleteSubscribers(pubsub, subscribers);
      }
    }
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeOffer(elements, deferred) {
    const iterator = elements[Symbol.iterator]();
    let next4 = iterator.next();
    if (!next4.done) {
      while (1) {
        const value6 = next4.value;
        next4 = iterator.next();
        if (next4.done) {
          pipe(this.publishers, offer([value6, deferred, true]));
          break;
        }
        pipe(this.publishers, offer([value6, deferred, false]));
      }
    }
  }
  unsafeRemove(deferred) {
    unsafeOfferAll2(this.publishers, pipe(unsafePollAllQueue(this.publishers), filter4(([_, a]) => a !== deferred)));
  }
};
var DroppingStrategy2 = class {
  static {
    __name(this, "DroppingStrategy");
  }
  get shutdown() {
    return void_3;
  }
  handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
    return succeed(false);
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
};
var SlidingStrategy2 = class {
  static {
    __name(this, "SlidingStrategy");
  }
  get shutdown() {
    return void_3;
  }
  handleSurplus(pubsub, subscribers, elements, _isShutdown) {
    return sync(() => {
      this.unsafeSlidingPublish(pubsub, elements);
      this.unsafeCompleteSubscribers(pubsub, subscribers);
      return true;
    });
  }
  unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
  }
  unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
    return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
  }
  unsafeCompleteSubscribers(pubsub, subscribers) {
    return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
  }
  unsafeSlidingPublish(pubsub, elements) {
    const it = elements[Symbol.iterator]();
    let next4 = it.next();
    if (!next4.done && pubsub.capacity > 0) {
      let a = next4.value;
      let loop5 = true;
      while (loop5) {
        pubsub.slide();
        const pub = pubsub.publish(a);
        if (pub && (next4 = it.next()) && !next4.done) {
          a = next4.value;
        } else if (pub) {
          loop5 = false;
        }
      }
    }
  }
};
var unsafeStrategyCompletePollers = /* @__PURE__ */ __name((strategy, pubsub, subscribers, subscription, pollers) => {
  let keepPolling = true;
  while (keepPolling && !subscription.isEmpty()) {
    const poller = pipe(pollers, poll4(EmptyMutableQueue));
    if (poller === EmptyMutableQueue) {
      pipe(subscribers, removeSubscribers(subscription, pollers));
      if (isEmpty10(pollers)) {
        keepPolling = false;
      } else {
        pipe(subscribers, addSubscribers(subscription, pollers));
      }
    } else {
      const pollResult = subscription.poll(EmptyMutableQueue);
      if (pollResult === EmptyMutableQueue) {
        unsafeOfferAll2(pollers, pipe(unsafePollAllQueue(pollers), prepend2(poller)));
      } else {
        unsafeCompleteDeferred2(poller, pollResult);
        strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
      }
    }
  }
}, "unsafeStrategyCompletePollers");
var unsafeStrategyCompleteSubscribers = /* @__PURE__ */ __name((strategy, pubsub, subscribers) => {
  for (const [subscription, pollersSet] of subscribers) {
    for (const pollers of pollersSet) {
      strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
    }
  }
}, "unsafeStrategyCompleteSubscribers");
var ReplayBuffer = class {
  static {
    __name(this, "ReplayBuffer");
  }
  capacity;
  constructor(capacity9) {
    this.capacity = capacity9;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as16) {
    for (const a of as16) {
      this.offer(a);
    }
  }
};
var ReplayWindowImpl = class {
  static {
    __name(this, "ReplayWindowImpl");
  }
  buffer;
  head;
  index;
  remaining;
  constructor(buffer4) {
    this.buffer = buffer4;
    this.index = buffer4.index;
    this.remaining = buffer4.size;
    this.head = buffer4.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return void 0;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value6 = this.head.value;
    this.head = this.head.next;
    return value6;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty4();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0; i < len; i++) {
      const value6 = this.head.value;
      this.head = this.head.next;
      items[i] = value6;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
};
var emptyReplayWindow = {
  remaining: 0,
  take: /* @__PURE__ */ __name(() => void 0, "take"),
  takeN: /* @__PURE__ */ __name(() => empty4(), "takeN"),
  takeAll: /* @__PURE__ */ __name(() => empty4(), "takeAll")
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/PubSub.js
var bounded5 = bounded4;
var dropping4 = dropping3;
var sliding4 = sliding3;
var unbounded5 = unbounded4;
var capacity5 = capacity4;
var size16 = size15;
var isFull4 = isFull3;
var isEmpty14 = isEmpty13;
var shutdown4 = shutdown3;
var isShutdown4 = isShutdown3;
var awaitShutdown4 = awaitShutdown3;
var publish2 = publish;
var publishAll2 = publishAll;
var subscribe2 = subscribe;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/channelExecutor.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/core-stream.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/channelChildExecutorDecision.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_CONTINUE2 = "Continue";
var OP_CLOSE = "Close";
var OP_YIELD2 = "Yield";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto6 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};
var Continue = /* @__PURE__ */ __name((_) => {
  const op = Object.create(proto6);
  op._tag = OP_CONTINUE2;
  return op;
}, "Continue");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/continuation.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/continuation.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_CONTINUATION_K = "ContinuationK";
var OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/continuation.js
var ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
var continuationVariance = {
  /* c8 ignore next */
  _Env: /* @__PURE__ */ __name((_) => _, "_Env"),
  /* c8 ignore next */
  _InErr: /* @__PURE__ */ __name((_) => _, "_InErr"),
  /* c8 ignore next */
  _InElem: /* @__PURE__ */ __name((_) => _, "_InElem"),
  /* c8 ignore next */
  _InDone: /* @__PURE__ */ __name((_) => _, "_InDone"),
  /* c8 ignore next */
  _OutErr: /* @__PURE__ */ __name((_) => _, "_OutErr"),
  /* c8 ignore next */
  _OutDone: /* @__PURE__ */ __name((_) => _, "_OutDone"),
  /* c8 ignore next */
  _OutErr2: /* @__PURE__ */ __name((_) => _, "_OutErr2"),
  /* c8 ignore next */
  _OutElem: /* @__PURE__ */ __name((_) => _, "_OutElem"),
  /* c8 ignore next */
  _OutDone2: /* @__PURE__ */ __name((_) => _, "_OutDone2")
};
var ContinuationKImpl = class {
  static {
    __name(this, "ContinuationKImpl");
  }
  onSuccess;
  onHalt;
  _tag = OP_CONTINUATION_K;
  [ContinuationTypeId] = continuationVariance;
  constructor(onSuccess, onHalt) {
    this.onSuccess = onSuccess;
    this.onHalt = onHalt;
  }
  onExit(exit5) {
    return isFailure3(exit5) ? this.onHalt(exit5.cause) : this.onSuccess(exit5.value);
  }
};
var ContinuationFinalizerImpl = class {
  static {
    __name(this, "ContinuationFinalizerImpl");
  }
  finalizer;
  _tag = OP_CONTINUATION_FINALIZER;
  [ContinuationTypeId] = continuationVariance;
  constructor(finalizer3) {
    this.finalizer = finalizer3;
  }
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullStrategy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_PULL_AFTER_NEXT = "PullAfterNext";
var OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var proto7 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};
var PullAfterNext = /* @__PURE__ */ __name((emitSeparator) => {
  const op = Object.create(proto7);
  op._tag = OP_PULL_AFTER_NEXT;
  op.emitSeparator = emitSeparator;
  return op;
}, "PullAfterNext");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/channel.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_BRACKET_OUT = "BracketOut";
var OP_BRIDGE = "Bridge";
var OP_CONCAT_ALL = "ConcatAll";
var OP_EMIT = "Emit";
var OP_ENSURING = "Ensuring";
var OP_FAIL3 = "Fail";
var OP_FOLD2 = "Fold";
var OP_FROM_EFFECT2 = "FromEffect";
var OP_PIPE_TO = "PipeTo";
var OP_PROVIDE2 = "Provide";
var OP_READ = "Read";
var OP_SUCCEED = "Succeed";
var OP_SUCCEED_NOW = "SucceedNow";
var OP_SUSPEND2 = "Suspend";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId3 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  /* c8 ignore next */
  _Env: /* @__PURE__ */ __name((_) => _, "_Env"),
  /* c8 ignore next */
  _InErr: /* @__PURE__ */ __name((_) => _, "_InErr"),
  /* c8 ignore next */
  _InElem: /* @__PURE__ */ __name((_) => _, "_InElem"),
  /* c8 ignore next */
  _InDone: /* @__PURE__ */ __name((_) => _, "_InDone"),
  /* c8 ignore next */
  _OutErr: /* @__PURE__ */ __name((_) => _, "_OutErr"),
  /* c8 ignore next */
  _OutElem: /* @__PURE__ */ __name((_) => _, "_OutElem"),
  /* c8 ignore next */
  _OutDone: /* @__PURE__ */ __name((_) => _, "_OutDone")
};
var proto8 = {
  [ChannelTypeId3]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isChannel = /* @__PURE__ */ __name((u) => hasProperty(u, ChannelTypeId3) || isEffect2(u), "isChannel");
var acquireReleaseOut = /* @__PURE__ */ dual(2, (self2, release2) => {
  const op = Object.create(proto8);
  op._tag = OP_BRACKET_OUT;
  op.acquire = () => self2;
  op.finalizer = release2;
  return op;
});
var catchAllCause5 = /* @__PURE__ */ dual(2, (self2, f) => {
  const op = Object.create(proto8);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(succeed15, f);
  return op;
});
var collectElements = /* @__PURE__ */ __name((self2) => {
  return suspend8(() => {
    const builder = [];
    return flatMap18(pipeTo(self2, collectElementsReader(builder)), (value6) => sync10(() => [fromIterable3(builder), value6]));
  });
}, "collectElements");
var collectElementsReader = /* @__PURE__ */ __name((builder) => readWith({
  onInput: /* @__PURE__ */ __name((outElem) => flatMap18(sync10(() => {
    builder.push(outElem);
  }), () => collectElementsReader(builder)), "onInput"),
  onFailure: fail14,
  onDone: succeedNow
}), "collectElementsReader");
var concatAllWith = /* @__PURE__ */ __name((channels, f, g) => {
  const op = Object.create(proto8);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = f;
  op.combineAll = g;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => channels;
  op.k = identity;
  return op;
}, "concatAllWith");
var concatMapWith = /* @__PURE__ */ dual(4, (self2, f, g, h) => {
  const op = Object.create(proto8);
  op._tag = OP_CONCAT_ALL;
  op.combineInners = g;
  op.combineAll = h;
  op.onPull = () => PullAfterNext(none2());
  op.onEmit = () => Continue;
  op.value = () => self2;
  op.k = f;
  return op;
});
var embedInput = /* @__PURE__ */ dual(2, (self2, input) => {
  const op = Object.create(proto8);
  op._tag = OP_BRIDGE;
  op.input = input;
  op.channel = self2;
  return op;
});
var ensuringWith = /* @__PURE__ */ dual(2, (self2, finalizer3) => {
  const op = Object.create(proto8);
  op._tag = OP_ENSURING;
  op.channel = self2;
  op.finalizer = finalizer3;
  return op;
});
var fail14 = /* @__PURE__ */ __name((error5) => failCause11(fail5(error5)), "fail");
var failCause11 = /* @__PURE__ */ __name((cause3) => failCauseSync6(() => cause3), "failCause");
var failCauseSync6 = /* @__PURE__ */ __name((evaluate3) => {
  const op = Object.create(proto8);
  op._tag = OP_FAIL3;
  op.error = evaluate3;
  return op;
}, "failCauseSync");
var flatMap18 = /* @__PURE__ */ dual(2, (self2, f) => {
  const op = Object.create(proto8);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(f, failCause11);
  return op;
});
var foldCauseChannel = /* @__PURE__ */ dual(2, (self2, options4) => {
  const op = Object.create(proto8);
  op._tag = OP_FOLD2;
  op.channel = self2;
  op.k = new ContinuationKImpl(options4.onSuccess, options4.onFailure);
  return op;
});
var fromEffect5 = /* @__PURE__ */ __name((effect4) => {
  const op = Object.create(proto8);
  op._tag = OP_FROM_EFFECT2;
  op.effect = () => effect4;
  return op;
}, "fromEffect");
var pipeTo = /* @__PURE__ */ dual(2, (self2, that) => {
  const op = Object.create(proto8);
  op._tag = OP_PIPE_TO;
  op.left = () => self2;
  op.right = () => that;
  return op;
});
var provideContext4 = /* @__PURE__ */ dual(2, (self2, env3) => {
  const op = Object.create(proto8);
  op._tag = OP_PROVIDE2;
  op.context = () => env3;
  op.inner = self2;
  return op;
});
var readWith = /* @__PURE__ */ __name((options4) => readWithCause({
  onInput: options4.onInput,
  onFailure: /* @__PURE__ */ __name((cause3) => match(failureOrCause2(cause3), {
    onLeft: options4.onFailure,
    onRight: failCause11
  }), "onFailure"),
  onDone: options4.onDone
}), "readWith");
var readWithCause = /* @__PURE__ */ __name((options4) => {
  const op = Object.create(proto8);
  op._tag = OP_READ;
  op.more = options4.onInput;
  op.done = new ContinuationKImpl(options4.onDone, options4.onFailure);
  return op;
}, "readWithCause");
var succeed15 = /* @__PURE__ */ __name((value6) => sync10(() => value6), "succeed");
var succeedNow = /* @__PURE__ */ __name((result) => {
  const op = Object.create(proto8);
  op._tag = OP_SUCCEED_NOW;
  op.terminal = result;
  return op;
}, "succeedNow");
var suspend8 = /* @__PURE__ */ __name((evaluate3) => {
  const op = Object.create(proto8);
  op._tag = OP_SUSPEND2;
  op.channel = evaluate3;
  return op;
}, "suspend");
var sync10 = /* @__PURE__ */ __name((evaluate3) => {
  const op = Object.create(proto8);
  op._tag = OP_SUCCEED;
  op.evaluate = evaluate3;
  return op;
}, "sync");
var void_8 = /* @__PURE__ */ succeedNow(void 0);
var write = /* @__PURE__ */ __name((out) => {
  const op = Object.create(proto8);
  op._tag = OP_EMIT;
  op.out = out;
  return op;
}, "write");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/channelState.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_DONE3 = "Done";
var OP_EMIT2 = "Emit";
var OP_FROM_EFFECT3 = "FromEffect";
var OP_READ2 = "Read";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/channelState.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var proto9 = {
  [ChannelStateTypeId]: channelStateVariance
};
var Done2 = /* @__PURE__ */ __name(() => {
  const op = Object.create(proto9);
  op._tag = OP_DONE3;
  return op;
}, "Done");
var Emit = /* @__PURE__ */ __name(() => {
  const op = Object.create(proto9);
  op._tag = OP_EMIT2;
  return op;
}, "Emit");
var fromEffect6 = /* @__PURE__ */ __name((effect4) => {
  const op = Object.create(proto9);
  op._tag = OP_FROM_EFFECT3;
  op.effect = effect4;
  return op;
}, "fromEffect");
var Read = /* @__PURE__ */ __name((upstream, onEffect, onEmit, onDone3) => {
  const op = Object.create(proto9);
  op._tag = OP_READ2;
  op.upstream = upstream;
  op.onEffect = onEffect;
  op.onEmit = onEmit;
  op.onDone = onDone3;
  return op;
}, "Read");
var isFromEffect = /* @__PURE__ */ __name((self2) => self2._tag === OP_FROM_EFFECT3, "isFromEffect");
var effect2 = /* @__PURE__ */ __name((self2) => isFromEffect(self2) ? self2.effect : _void, "effect");
var effectOrUndefinedIgnored = /* @__PURE__ */ __name((self2) => isFromEffect(self2) ? ignore2(self2.effect) : void 0, "effectOrUndefinedIgnored");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/subexecutor.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_PULL_FROM_CHILD = "PullFromChild";
var OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
var OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
var OP_EMIT3 = "Emit";
var PullFromChild = class {
  static {
    __name(this, "PullFromChild");
  }
  childExecutor;
  parentSubexecutor;
  onEmit;
  _tag = OP_PULL_FROM_CHILD;
  constructor(childExecutor, parentSubexecutor, onEmit) {
    this.childExecutor = childExecutor;
    this.parentSubexecutor = parentSubexecutor;
    this.onEmit = onEmit;
  }
  close(exit5) {
    const fin1 = this.childExecutor.close(exit5);
    const fin2 = this.parentSubexecutor.close(exit5);
    if (fin1 !== void 0 && fin2 !== void 0) {
      return zipWith10(exit4(fin1), exit4(fin2), (exit1, exit22) => pipe(exit1, zipRight3(exit22)));
    } else if (fin1 !== void 0) {
      return fin1;
    } else if (fin2 !== void 0) {
      return fin2;
    } else {
      return void 0;
    }
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};
var PullFromUpstream = class _PullFromUpstream {
  static {
    __name(this, "PullFromUpstream");
  }
  upstreamExecutor;
  createChild;
  lastDone;
  activeChildExecutors;
  combineChildResults;
  combineWithChildResult;
  onPull;
  onEmit;
  _tag = OP_PULL_FROM_UPSTREAM;
  constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
    this.upstreamExecutor = upstreamExecutor;
    this.createChild = createChild;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
    this.onEmit = onEmit;
  }
  close(exit5) {
    const fin1 = this.upstreamExecutor.close(exit5);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit5) : void 0), fin1];
    const result = fins.reduce((acc, next4) => {
      if (acc !== void 0 && next4 !== void 0) {
        return zipWith10(acc, exit4(next4), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next4 !== void 0) {
        return exit4(next4);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
  }
};
var DrainChildExecutors = class _DrainChildExecutors {
  static {
    __name(this, "DrainChildExecutors");
  }
  upstreamExecutor;
  lastDone;
  activeChildExecutors;
  upstreamDone;
  combineChildResults;
  combineWithChildResult;
  onPull;
  _tag = OP_DRAIN_CHILD_EXECUTORS;
  constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
    this.upstreamExecutor = upstreamExecutor;
    this.lastDone = lastDone;
    this.activeChildExecutors = activeChildExecutors;
    this.upstreamDone = upstreamDone;
    this.combineChildResults = combineChildResults;
    this.combineWithChildResult = combineWithChildResult;
    this.onPull = onPull;
  }
  close(exit5) {
    const fin1 = this.upstreamExecutor.close(exit5);
    const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit5) : void 0), fin1];
    const result = fins.reduce((acc, next4) => {
      if (acc !== void 0 && next4 !== void 0) {
        return zipWith10(acc, exit4(next4), (exit1, exit22) => zipRight3(exit1, exit22));
      } else if (acc !== void 0) {
        return acc;
      } else if (next4 !== void 0) {
        return exit4(next4);
      } else {
        return void 0;
      }
    }, void 0);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(child) {
    return new _DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
  }
};
var Emit2 = class {
  static {
    __name(this, "Emit");
  }
  value;
  next;
  _tag = OP_EMIT3;
  constructor(value6, next4) {
    this.value = value6;
    this.next = next4;
  }
  close(exit5) {
    const result = this.next.close(exit5);
    return result === void 0 ? result : result;
  }
  enqueuePullFromChild(_child) {
    return this;
  }
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/channelUpstreamPullRequest.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_PULLED = "Pulled";
var OP_NO_UPSTREAM = "NoUpstream";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var proto10 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};
var Pulled = /* @__PURE__ */ __name((value6) => {
  const op = Object.create(proto10);
  op._tag = OP_PULLED;
  op.value = value6;
  return op;
}, "Pulled");
var NoUpstream = /* @__PURE__ */ __name((activeDownstreamCount) => {
  const op = Object.create(proto10);
  op._tag = OP_NO_UPSTREAM;
  op.activeDownstreamCount = activeDownstreamCount;
  return op;
}, "NoUpstream");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/channelExecutor.js
var ChannelExecutor = class _ChannelExecutor {
  static {
    __name(this, "ChannelExecutor");
  }
  _activeSubexecutor = void 0;
  _cancelled = void 0;
  _closeLastSubstream = void 0;
  _currentChannel;
  _done = void 0;
  _doneStack = [];
  _emitted = void 0;
  _executeCloseLastSubstream;
  _input = void 0;
  _inProgressFinalizer = void 0;
  _providedEnv;
  constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
    this._currentChannel = initialChannel;
    this._executeCloseLastSubstream = executeCloseLastSubstream;
    this._providedEnv = providedEnv;
  }
  run() {
    let result = void 0;
    while (result === void 0) {
      if (this._cancelled !== void 0) {
        result = this.processCancellation();
      } else if (this._activeSubexecutor !== void 0) {
        result = this.runSubexecutor();
      } else {
        try {
          if (this._currentChannel === void 0) {
            result = Done2();
          } else {
            if (isEffect2(this._currentChannel)) {
              this._currentChannel = fromEffect5(this._currentChannel);
            }
            switch (this._currentChannel._tag) {
              case OP_BRACKET_OUT: {
                result = this.runBracketOut(this._currentChannel);
                break;
              }
              case OP_BRIDGE: {
                const bridgeInput = this._currentChannel.input;
                this._currentChannel = this._currentChannel.channel;
                if (this._input !== void 0) {
                  const inputExecutor = this._input;
                  this._input = void 0;
                  const drainer = /* @__PURE__ */ __name(() => flatMap15(bridgeInput.awaitRead(), () => suspend4(() => {
                    const state2 = inputExecutor.run();
                    switch (state2._tag) {
                      case OP_DONE3: {
                        return match9(inputExecutor.getDone(), {
                          onFailure: /* @__PURE__ */ __name((cause3) => bridgeInput.error(cause3), "onFailure"),
                          onSuccess: /* @__PURE__ */ __name((value6) => bridgeInput.done(value6), "onSuccess")
                        });
                      }
                      case OP_EMIT2: {
                        return flatMap15(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                      }
                      case OP_FROM_EFFECT3: {
                        return matchCauseEffect3(state2.effect, {
                          onFailure: /* @__PURE__ */ __name((cause3) => bridgeInput.error(cause3), "onFailure"),
                          onSuccess: /* @__PURE__ */ __name(() => drainer(), "onSuccess")
                        });
                      }
                      case OP_READ2: {
                        return readUpstream(state2, () => drainer(), (cause3) => bridgeInput.error(cause3));
                      }
                    }
                  })), "drainer");
                  result = fromEffect6(flatMap15(forkDaemon2(interruptible4(drainer())), (fiber) => sync7(() => this.addFinalizer((exit5) => flatMap15(interrupt5(fiber), () => suspend4(() => {
                    const effect4 = this.restorePipe(exit5, inputExecutor);
                    return effect4 !== void 0 ? effect4 : _void;
                  }))))));
                }
                break;
              }
              case OP_CONCAT_ALL: {
                const executor = new _ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect4) => sync7(() => {
                  const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                  this._closeLastSubstream = pipe(prevLastClose, zipRight7(effect4));
                }));
                executor._input = this._input;
                const channel2 = this._currentChannel;
                this._activeSubexecutor = new PullFromUpstream(executor, (value6) => channel2.k(value6), void 0, [], (x, y) => channel2.combineInners(x, y), (x, y) => channel2.combineAll(x, y), (request2) => channel2.onPull(request2), (value6) => channel2.onEmit(value6));
                this._closeLastSubstream = void 0;
                this._currentChannel = void 0;
                break;
              }
              case OP_EMIT: {
                this._emitted = this._currentChannel.out;
                this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_8;
                result = Emit();
                break;
              }
              case OP_ENSURING: {
                this.runEnsuring(this._currentChannel);
                break;
              }
              case OP_FAIL3: {
                result = this.doneHalt(this._currentChannel.error());
                break;
              }
              case OP_FOLD2: {
                this._doneStack.push(this._currentChannel.k);
                this._currentChannel = this._currentChannel.channel;
                break;
              }
              case OP_FROM_EFFECT2: {
                const effect4 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide2(this._providedEnv));
                result = fromEffect6(matchCauseEffect3(effect4, {
                  onFailure: /* @__PURE__ */ __name((cause3) => {
                    const state2 = this.doneHalt(cause3);
                    return state2 !== void 0 && isFromEffect(state2) ? state2.effect : _void;
                  }, "onFailure"),
                  onSuccess: /* @__PURE__ */ __name((value6) => {
                    const state2 = this.doneSucceed(value6);
                    return state2 !== void 0 && isFromEffect(state2) ? state2.effect : _void;
                  }, "onSuccess")
                }));
                break;
              }
              case OP_PIPE_TO: {
                const previousInput = this._input;
                const leftExec = new _ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect4) => this._executeCloseLastSubstream(effect4));
                leftExec._input = previousInput;
                this._input = leftExec;
                this.addFinalizer((exit5) => {
                  const effect4 = this.restorePipe(exit5, previousInput);
                  return effect4 !== void 0 ? effect4 : _void;
                });
                this._currentChannel = this._currentChannel.right();
                break;
              }
              case OP_PROVIDE2: {
                const previousEnv = this._providedEnv;
                this._providedEnv = this._currentChannel.context();
                this._currentChannel = this._currentChannel.inner;
                this.addFinalizer(() => sync7(() => {
                  this._providedEnv = previousEnv;
                }));
                break;
              }
              case OP_READ: {
                const read4 = this._currentChannel;
                result = Read(this._input, identity, (emitted) => {
                  try {
                    this._currentChannel = read4.more(emitted);
                  } catch (error5) {
                    this._currentChannel = read4.done.onExit(die3(error5));
                  }
                  return void 0;
                }, (exit5) => {
                  const onExit4 = /* @__PURE__ */ __name((exit6) => {
                    return read4.done.onExit(exit6);
                  }, "onExit");
                  this._currentChannel = onExit4(exit5);
                  return void 0;
                });
                break;
              }
              case OP_SUCCEED: {
                result = this.doneSucceed(this._currentChannel.evaluate());
                break;
              }
              case OP_SUCCEED_NOW: {
                result = this.doneSucceed(this._currentChannel.terminal);
                break;
              }
              case OP_SUSPEND2: {
                this._currentChannel = this._currentChannel.channel();
                break;
              }
            }
          }
        } catch (error5) {
          this._currentChannel = failCause11(die4(error5));
        }
      }
    }
    return result;
  }
  getDone() {
    return this._done;
  }
  getEmit() {
    return this._emitted;
  }
  cancelWith(exit5) {
    this._cancelled = exit5;
  }
  clearInProgressFinalizer() {
    this._inProgressFinalizer = void 0;
  }
  storeInProgressFinalizer(finalizer3) {
    this._inProgressFinalizer = finalizer3;
  }
  popAllFinalizers(exit5) {
    const finalizers = [];
    let next4 = this._doneStack.pop();
    while (next4) {
      if (next4._tag === "ContinuationFinalizer") {
        finalizers.push(next4.finalizer);
      }
      next4 = this._doneStack.pop();
    }
    const effect4 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit5);
    this.storeInProgressFinalizer(effect4);
    return effect4;
  }
  popNextFinalizers() {
    const builder = [];
    while (this._doneStack.length !== 0) {
      const cont = this._doneStack[this._doneStack.length - 1];
      if (cont._tag === OP_CONTINUATION_K) {
        return builder;
      }
      builder.push(cont);
      this._doneStack.pop();
    }
    return builder;
  }
  restorePipe(exit5, prev) {
    const currInput = this._input;
    this._input = prev;
    if (currInput !== void 0) {
      const effect4 = currInput.close(exit5);
      return effect4;
    }
    return _void;
  }
  close(exit5) {
    let runInProgressFinalizers = void 0;
    const finalizer3 = this._inProgressFinalizer;
    if (finalizer3 !== void 0) {
      runInProgressFinalizers = pipe(finalizer3, ensuring3(sync7(() => this.clearInProgressFinalizer())));
    }
    let closeSelf = void 0;
    const selfFinalizers = this.popAllFinalizers(exit5);
    if (selfFinalizers !== void 0) {
      closeSelf = pipe(selfFinalizers, ensuring3(sync7(() => this.clearInProgressFinalizer())));
    }
    const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit5);
    if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
      return void 0;
    }
    return pipe(
      exit4(ifNotNull(closeSubexecutors)),
      zip8(exit4(ifNotNull(runInProgressFinalizers))),
      zip8(exit4(ifNotNull(closeSelf))),
      map22(([[exit1, exit22], exit32]) => pipe(exit1, zipRight3(exit22), zipRight3(exit32))),
      uninterruptible2,
      // TODO: remove
      flatMap15((exit6) => suspend4(() => exit6))
    );
  }
  doneSucceed(value6) {
    if (this._doneStack.length === 0) {
      this._done = succeed3(value6);
      this._currentChannel = void 0;
      return Done2();
    }
    const head13 = this._doneStack[this._doneStack.length - 1];
    if (head13._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      this._currentChannel = head13.onSuccess(value6);
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = succeed3(value6);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed3(value6));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring3(sync7(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap15(() => sync7(() => this.doneSucceed(value6))));
    return fromEffect6(effect4);
  }
  doneHalt(cause3) {
    if (this._doneStack.length === 0) {
      this._done = failCause3(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const head13 = this._doneStack[this._doneStack.length - 1];
    if (head13._tag === OP_CONTINUATION_K) {
      this._doneStack.pop();
      try {
        this._currentChannel = head13.onHalt(cause3);
      } catch (error5) {
        this._currentChannel = failCause11(die4(error5));
      }
      return void 0;
    }
    const finalizers = this.popNextFinalizers();
    if (this._doneStack.length === 0) {
      this._doneStack = finalizers.reverse();
      this._done = failCause3(cause3);
      this._currentChannel = void 0;
      return Done2();
    }
    const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause3(cause3));
    this.storeInProgressFinalizer(finalizerEffect);
    const effect4 = pipe(finalizerEffect, ensuring3(sync7(() => this.clearInProgressFinalizer())), uninterruptible2, flatMap15(() => sync7(() => this.doneHalt(cause3))));
    return fromEffect6(effect4);
  }
  processCancellation() {
    this._currentChannel = void 0;
    this._done = this._cancelled;
    this._cancelled = void 0;
    return Done2();
  }
  runBracketOut(bracketOut) {
    const effect4 = uninterruptible2(matchCauseEffect3(this.provide(bracketOut.acquire()), {
      onFailure: /* @__PURE__ */ __name((cause3) => sync7(() => {
        this._currentChannel = failCause11(cause3);
      }), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((out) => sync7(() => {
        this.addFinalizer((exit5) => this.provide(bracketOut.finalizer(out, exit5)));
        this._currentChannel = write(out);
      }), "onSuccess")
    }));
    return fromEffect6(effect4);
  }
  provide(effect4) {
    if (this._providedEnv === void 0) {
      return effect4;
    }
    return pipe(effect4, provide2(this._providedEnv));
  }
  runEnsuring(ensuring11) {
    this.addFinalizer(ensuring11.finalizer);
    this._currentChannel = ensuring11.channel;
  }
  addFinalizer(f) {
    this._doneStack.push(new ContinuationFinalizerImpl(f));
  }
  runSubexecutor() {
    const subexecutor = this._activeSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_CHILD: {
        return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
      }
      case OP_PULL_FROM_UPSTREAM: {
        return this.pullFromUpstream(subexecutor);
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        return this.drainChildExecutors(subexecutor);
      }
      case OP_EMIT3: {
        this._emitted = subexecutor.value;
        this._activeSubexecutor = subexecutor.next;
        return Emit();
      }
    }
  }
  replaceSubexecutor(nextSubExec) {
    this._currentChannel = void 0;
    this._activeSubexecutor = nextSubExec;
  }
  finishWithExit(exit5) {
    const state2 = match9(exit5, {
      onFailure: /* @__PURE__ */ __name((cause3) => this.doneHalt(cause3), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((value6) => this.doneSucceed(value6), "onSuccess")
    });
    this._activeSubexecutor = void 0;
    return state2 === void 0 ? _void : effect2(state2);
  }
  finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
    this.addFinalizer(() => pipe(closeFuncs, forEach11((closeFunc) => pipe(sync7(() => closeFunc(subexecutorDone)), flatMap15((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
      discard: true
    })));
    const state2 = pipe(subexecutorDone, match9({
      onFailure: /* @__PURE__ */ __name((cause3) => this.doneHalt(cause3), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((value6) => this.doneSucceed(value6), "onSuccess")
    }));
    this._activeSubexecutor = void 0;
    return state2;
  }
  applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
    switch (strategy._tag) {
      case OP_PULL_AFTER_NEXT: {
        const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
      }
      case OP_PULL_AFTER_ALL_ENQUEUED: {
        const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
        return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
      }
    }
  }
  pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
    return Read(childExecutor, identity, (emitted) => {
      const childExecutorDecision = onEmitted(emitted);
      switch (childExecutorDecision._tag) {
        case OP_CONTINUE2: {
          break;
        }
        case OP_CLOSE: {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
          break;
        }
        case OP_YIELD2: {
          const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
      this._activeSubexecutor = new Emit2(emitted, this._activeSubexecutor);
      return void 0;
    }, match9({
      onFailure: /* @__PURE__ */ __name((cause3) => {
        const state2 = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3);
        return state2 === void 0 ? void 0 : effectOrUndefinedIgnored(state2);
      }, "onFailure"),
      onSuccess: /* @__PURE__ */ __name((doneValue) => {
        this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
        return void 0;
      }, "onSuccess")
    }));
  }
  finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
    const subexecutor = parentSubexecutor;
    switch (subexecutor._tag) {
      case OP_PULL_FROM_UPSTREAM: {
        const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      case OP_DRAIN_CHILD_EXECUTORS: {
        const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        this._closeLastSubstream = childExecutor.close(succeed3(doneValue));
        this.replaceSubexecutor(modifiedParent);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleSubexecutorFailure(childExecutor, parentSubexecutor, cause3) {
    return this.finishSubexecutorWithCloseEffect(failCause3(cause3), (exit5) => parentSubexecutor.close(exit5), (exit5) => childExecutor.close(exit5));
  }
  pullFromUpstream(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      return this.performPullFromUpstream(subexecutor);
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
    if (activeChild === void 0) {
      return this.performPullFromUpstream(parentSubexecutor);
    }
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
  performPullFromUpstream(subexecutor) {
    return Read(subexecutor.upstreamExecutor, (effect4) => {
      const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
      this._closeLastSubstream = void 0;
      return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight7(effect4));
    }, (emitted) => {
      if (this._closeLastSubstream !== void 0) {
        const closeLastSubstream = this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), map22(() => {
          const childExecutor2 = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
          childExecutor2._input = this._input;
          const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
          this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
          if (isSome2(emitSeparator2)) {
            this._activeSubexecutor = new Emit2(emitSeparator2.value, this._activeSubexecutor);
          }
          return void 0;
        }));
      }
      const childExecutor = new _ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
      childExecutor._input = this._input;
      const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
      this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
      if (isSome2(emitSeparator)) {
        this._activeSubexecutor = new Emit2(emitSeparator.value, this._activeSubexecutor);
      }
      return void 0;
    }, (exit5) => {
      if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
        const drain5 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream2 = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map22(() => this.replaceSubexecutor(drain5)));
        }
        this.replaceSubexecutor(drain5);
        return void 0;
      }
      const closeLastSubstream = this._closeLastSubstream;
      const state2 = this.finishSubexecutorWithCloseEffect(pipe(exit5, map15((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit6) => subexecutor.upstreamExecutor.close(exit6));
      return state2 === void 0 ? void 0 : (
        // NOTE: assuming finalizers cannot fail
        effectOrUndefinedIgnored(state2)
      );
    });
  }
  drainChildExecutors(subexecutor) {
    if (subexecutor.activeChildExecutors.length === 0) {
      const lastClose = this._closeLastSubstream;
      if (lastClose !== void 0) {
        this.addFinalizer(() => succeed11(lastClose));
      }
      return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit5) => subexecutor.upstreamExecutor.close(exit5));
    }
    const activeChild = subexecutor.activeChildExecutors[0];
    const rest = subexecutor.activeChildExecutors.slice(1);
    if (activeChild === void 0) {
      const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
      this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
      if (isSome2(emitSeparator)) {
        this._emitted = emitSeparator.value;
        return Emit();
      }
      return void 0;
    }
    const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
    this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
    return void 0;
  }
};
var ifNotNull = /* @__PURE__ */ __name((effect4) => effect4 !== void 0 ? effect4 : _void, "ifNotNull");
var runFinalizers = /* @__PURE__ */ __name((finalizers, exit5) => {
  return pipe(forEach11(finalizers, (fin) => exit4(fin(exit5))), map22((exits) => pipe(all5(exits), getOrElse2(() => void_5))), flatMap15((exit6) => suspend4(() => exit6)));
}, "runFinalizers");
var readUpstream = /* @__PURE__ */ __name((r, onSuccess, onFailure) => {
  const readStack = [r];
  const read4 = /* @__PURE__ */ __name(() => {
    const current2 = readStack.pop();
    if (current2 === void 0 || current2.upstream === void 0) {
      return dieMessage2("Unexpected end of input for channel execution");
    }
    const state2 = current2.upstream.run();
    switch (state2._tag) {
      case OP_EMIT2: {
        const emitEffect = current2.onEmit(current2.upstream.getEmit());
        if (readStack.length === 0) {
          if (emitEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(emitEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (emitEffect === void 0) {
          return suspend4(() => read4());
        }
        return pipe(emitEffect, matchCauseEffect3({
          onFailure,
          onSuccess: /* @__PURE__ */ __name(() => read4(), "onSuccess")
        }));
      }
      case OP_DONE3: {
        const doneEffect = current2.onDone(current2.upstream.getDone());
        if (readStack.length === 0) {
          if (doneEffect === void 0) {
            return suspend4(onSuccess);
          }
          return pipe(doneEffect, matchCauseEffect3({
            onFailure,
            onSuccess
          }));
        }
        if (doneEffect === void 0) {
          return suspend4(() => read4());
        }
        return pipe(doneEffect, matchCauseEffect3({
          onFailure,
          onSuccess: /* @__PURE__ */ __name(() => read4(), "onSuccess")
        }));
      }
      case OP_FROM_EFFECT3: {
        readStack.push(current2);
        return pipe(current2.onEffect(state2.effect), catchAllCause3((cause3) => suspend4(() => {
          const doneEffect = current2.onDone(failCause3(cause3));
          return doneEffect === void 0 ? _void : doneEffect;
        })), matchCauseEffect3({
          onFailure,
          onSuccess: /* @__PURE__ */ __name(() => read4(), "onSuccess")
        }));
      }
      case OP_READ2: {
        readStack.push(current2);
        readStack.push(state2);
        return suspend4(() => read4());
      }
    }
  }, "read");
  return read4();
}, "readUpstream");
var runIn = /* @__PURE__ */ dual(2, (self2, scope5) => {
  const run10 = /* @__PURE__ */ __name((channelDeferred, scopeDeferred, scope6) => acquireUseRelease2(sync7(() => new ChannelExecutor(self2, void 0, identity)), (exec) => suspend4(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred2(channelDeferred), zipRight7(_await3(channelDeferred)), zipLeft7(_await3(scopeDeferred)))), (exec, exit5) => {
    const finalize = exec.close(exit5);
    if (finalize === void 0) {
      return _void;
    }
    return tapErrorCause3(finalize, (cause3) => addFinalizer2(scope6, failCause9(cause3)));
  }), "run");
  return uninterruptibleMask3((restore) => all8([fork2(scope5, sequential3), make43(), make43()]).pipe(flatMap15(([child, channelDeferred, scopeDeferred]) => restore(run10(channelDeferred, scopeDeferred, child)).pipe(forkIn2(scope5), flatMap15((fiber) => scope5.addFinalizer((exit5) => {
    const interruptors3 = isFailure3(exit5) ? interruptors2(exit5.cause) : void 0;
    return isDone5(channelDeferred).pipe(flatMap15((isDone7) => isDone7 ? succeed9(scopeDeferred, void 0).pipe(zipRight7(_await2(fiber)), zipRight7(inheritAll2(fiber))) : succeed9(scopeDeferred, void 0).pipe(zipRight7(interruptors3 && size4(interruptors3) > 0 ? interruptAs(fiber, combineAll3(interruptors3)) : interrupt5(fiber)), zipRight7(inheritAll2(fiber)))));
  }).pipe(zipRight7(restore(_await3(channelDeferred)))))))));
});
var runScopedInterpret = /* @__PURE__ */ __name((channelState, exec) => {
  const op = channelState;
  switch (op._tag) {
    case OP_FROM_EFFECT3: {
      return pipe(op.effect, flatMap15(() => runScopedInterpret(exec.run(), exec)));
    }
    case OP_EMIT2: {
      return runScopedInterpret(exec.run(), exec);
    }
    case OP_DONE3: {
      return suspend4(() => exec.getDone());
    }
    case OP_READ2: {
      return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause9);
    }
  }
}, "runScopedInterpret");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/mergeDecision.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/channelMergeDecision.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_DONE4 = "Done";
var OP_AWAIT = "Await";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto11 = {
  [MergeDecisionTypeId]: {
    _R: /* @__PURE__ */ __name((_) => _, "_R"),
    _E0: /* @__PURE__ */ __name((_) => _, "_E0"),
    _Z0: /* @__PURE__ */ __name((_) => _, "_Z0"),
    _E: /* @__PURE__ */ __name((_) => _, "_E"),
    _Z: /* @__PURE__ */ __name((_) => _, "_Z")
  }
};
var Done3 = /* @__PURE__ */ __name((effect4) => {
  const op = Object.create(proto11);
  op._tag = OP_DONE4;
  op.effect = effect4;
  return op;
}, "Done");
var Await = /* @__PURE__ */ __name((f) => {
  const op = Object.create(proto11);
  op._tag = OP_AWAIT;
  op.f = f;
  return op;
}, "Await");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/mergeState.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/channelMergeState.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_BOTH_RUNNING = "BothRunning";
var OP_LEFT_DONE = "LeftDone";
var OP_RIGHT_DONE = "RightDone";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto12 = {
  [MergeStateTypeId]: MergeStateTypeId
};
var BothRunning = /* @__PURE__ */ __name((left3, right3) => {
  const op = Object.create(proto12);
  op._tag = OP_BOTH_RUNNING;
  op.left = left3;
  op.right = right3;
  return op;
}, "BothRunning");
var LeftDone = /* @__PURE__ */ __name((f) => {
  const op = Object.create(proto12);
  op._tag = OP_LEFT_DONE;
  op.f = f;
  return op;
}, "LeftDone");
var RightDone = /* @__PURE__ */ __name((f) => {
  const op = Object.create(proto12);
  op._tag = OP_RIGHT_DONE;
  op.f = f;
  return op;
}, "RightDone");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/channelMergeStrategy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_BACK_PRESSURE = "BackPressure";
var OP_BUFFER_SLIDING = "BufferSliding";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto13 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};
var BackPressure = /* @__PURE__ */ __name((_) => {
  const op = Object.create(proto13);
  op._tag = OP_BACK_PRESSURE;
  return op;
}, "BackPressure");
var BufferSliding = /* @__PURE__ */ __name((_) => {
  const op = Object.create(proto13);
  op._tag = OP_BUFFER_SLIDING;
  return op;
}, "BufferSliding");
var match18 = /* @__PURE__ */ dual(2, (self2, {
  onBackPressure,
  onBufferSliding
}) => {
  switch (self2._tag) {
    case OP_BACK_PRESSURE: {
      return onBackPressure();
    }
    case OP_BUFFER_SLIDING: {
      return onBufferSliding();
    }
  }
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel/singleProducerAsyncInput.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_STATE_EMPTY = "Empty";
var OP_STATE_EMIT = "Emit";
var OP_STATE_ERROR = "Error";
var OP_STATE_DONE2 = "Done";
var stateEmpty = /* @__PURE__ */ __name((notifyProducer) => ({
  _tag: OP_STATE_EMPTY,
  notifyProducer
}), "stateEmpty");
var stateEmit = /* @__PURE__ */ __name((notifyConsumers) => ({
  _tag: OP_STATE_EMIT,
  notifyConsumers
}), "stateEmit");
var stateError = /* @__PURE__ */ __name((cause3) => ({
  _tag: OP_STATE_ERROR,
  cause: cause3
}), "stateError");
var stateDone = /* @__PURE__ */ __name((done12) => ({
  _tag: OP_STATE_DONE2,
  done: done12
}), "stateDone");
var SingleProducerAsyncInputImpl = class {
  static {
    __name(this, "SingleProducerAsyncInputImpl");
  }
  ref;
  constructor(ref2) {
    this.ref = ref2;
  }
  awaitRead() {
    return flatten10(modify6(this.ref, (state2) => state2._tag === OP_STATE_EMPTY ? [_await3(state2.notifyProducer), state2] : [_void, state2]));
  }
  get close() {
    return fiberIdWith2((fiberId5) => this.error(interrupt4(fiberId5)));
  }
  done(value6) {
    return flatten10(modify6(this.ref, (state2) => {
      switch (state2._tag) {
        case OP_STATE_EMPTY: {
          return [_await3(state2.notifyProducer), state2];
        }
        case OP_STATE_EMIT: {
          return [forEach11(state2.notifyConsumers, (deferred) => succeed9(deferred, left2(value6)), {
            discard: true
          }), stateDone(value6)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state2];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state2];
        }
      }
    }));
  }
  emit(element2) {
    return flatMap15(make43(), (deferred) => flatten10(modify6(this.ref, (state2) => {
      switch (state2._tag) {
        case OP_STATE_EMPTY: {
          return [_await3(state2.notifyProducer), state2];
        }
        case OP_STATE_EMIT: {
          const notifyConsumer = state2.notifyConsumers[0];
          const notifyConsumers = state2.notifyConsumers.slice(1);
          if (notifyConsumer !== void 0) {
            return [succeed9(notifyConsumer, right2(element2)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
          }
          throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state2];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state2];
        }
      }
    })));
  }
  error(cause3) {
    return flatten10(modify6(this.ref, (state2) => {
      switch (state2._tag) {
        case OP_STATE_EMPTY: {
          return [_await3(state2.notifyProducer), state2];
        }
        case OP_STATE_EMIT: {
          return [forEach11(state2.notifyConsumers, (deferred) => failCause7(deferred, cause3), {
            discard: true
          }), stateError(cause3)];
        }
        case OP_STATE_ERROR: {
          return [interrupt7, state2];
        }
        case OP_STATE_DONE2: {
          return [interrupt7, state2];
        }
      }
    }));
  }
  get take() {
    return this.takeWith((cause3) => failCause3(map18(cause3, left2)), (elem) => succeed3(elem), (done12) => fail3(right2(done12)));
  }
  takeWith(onError5, onElement, onDone3) {
    return flatMap15(make43(), (deferred) => flatten10(modify6(this.ref, (state2) => {
      switch (state2._tag) {
        case OP_STATE_EMPTY: {
          return [zipRight7(succeed9(state2.notifyProducer, void 0), matchCause4(_await3(deferred), {
            onFailure: onError5,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          })), stateEmit([deferred])];
        }
        case OP_STATE_EMIT: {
          return [matchCause4(_await3(deferred), {
            onFailure: onError5,
            onSuccess: match({
              onLeft: onDone3,
              onRight: onElement
            })
          }), stateEmit([...state2.notifyConsumers, deferred])];
        }
        case OP_STATE_ERROR: {
          return [succeed11(onError5(state2.cause)), state2];
        }
        case OP_STATE_DONE2: {
          return [succeed11(onDone3(state2.done)), state2];
        }
      }
    })));
  }
};
var make54 = /* @__PURE__ */ __name(() => pipe(make43(), flatMap15((deferred) => make26(stateEmpty(deferred))), map22((ref2) => new SingleProducerAsyncInputImpl(ref2))), "make");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/channel.js
var acquireUseRelease3 = /* @__PURE__ */ __name((acquire, use3, release2) => flatMap18(fromEffect5(make26(() => _void)), (ref2) => pipe(fromEffect5(uninterruptible2(tap4(acquire, (a) => set5(ref2, (exit5) => release2(a, exit5))))), flatMap18(use3), ensuringWith((exit5) => flatMap15(get12(ref2), (f) => f(exit5))))), "acquireUseRelease");
var as9 = /* @__PURE__ */ dual(2, (self2, value6) => map28(self2, () => value6));
var catchAll5 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause11
})));
var concatMap = /* @__PURE__ */ dual(2, (self2, f) => concatMapWith(self2, f, () => void 0, () => void 0));
var drain = /* @__PURE__ */ __name((self2) => {
  const drainer = readWithCause({
    onInput: /* @__PURE__ */ __name(() => drainer, "onInput"),
    onFailure: failCause11,
    onDone: succeed15
  });
  return pipeTo(self2, drainer);
}, "drain");
var ensuring4 = /* @__PURE__ */ dual(2, (self2, finalizer3) => ensuringWith(self2, () => finalizer3));
var flatten13 = /* @__PURE__ */ __name((self2) => flatMap18(self2, identity), "flatten");
var foldChannel = /* @__PURE__ */ dual(2, (self2, options4) => foldCauseChannel(self2, {
  onFailure: /* @__PURE__ */ __name((cause3) => {
    const either12 = failureOrCause2(cause3);
    switch (either12._tag) {
      case "Left": {
        return options4.onFailure(either12.left);
      }
      case "Right": {
        return failCause11(either12.right);
      }
    }
  }, "onFailure"),
  onSuccess: options4.onSuccess
}));
var fromInput3 = /* @__PURE__ */ __name((input) => unwrap3(input.takeWith(failCause11, (elem) => flatMap18(write(elem), () => fromInput3(input)), succeed15)), "fromInput");
var fromQueue = /* @__PURE__ */ __name((queue) => suspend8(() => fromQueueInternal(queue)), "fromQueue");
var fromQueueInternal = /* @__PURE__ */ __name((queue) => pipe(fromEffect5(take4(queue)), flatMap18(match({
  onLeft: match9({
    onFailure: failCause11,
    onSuccess: succeedNow
  }),
  onRight: /* @__PURE__ */ __name((elem) => flatMap18(write(elem), () => fromQueueInternal(queue)), "onRight")
}))), "fromQueueInternal");
var identityChannel = /* @__PURE__ */ __name(() => readWith({
  onInput: /* @__PURE__ */ __name((input) => flatMap18(write(input), () => identityChannel()), "onInput"),
  onFailure: fail14,
  onDone: succeedNow
}), "identityChannel");
var interruptWhen = /* @__PURE__ */ dual(2, (self2, effect4) => mergeWith2(self2, {
  other: fromEffect5(effect4),
  onSelfDone: /* @__PURE__ */ __name((selfDone) => Done3(suspend4(() => selfDone)), "onSelfDone"),
  onOtherDone: /* @__PURE__ */ __name((effectDone) => Done3(suspend4(() => effectDone)), "onOtherDone")
}));
var interruptWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => interruptWhen(self2, _await3(deferred)));
var map28 = /* @__PURE__ */ dual(2, (self2, f) => flatMap18(self2, (a) => sync10(() => f(a))));
var mapError7 = /* @__PURE__ */ dual(2, (self2, f) => mapErrorCause4(self2, map18(f)));
var mapErrorCause4 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause5(self2, (cause3) => failCause11(f(cause3))));
var mapOut = /* @__PURE__ */ dual(2, (self2, f) => {
  const reader = readWith({
    onInput: /* @__PURE__ */ __name((outElem) => flatMap18(write(f(outElem)), () => reader), "onInput"),
    onFailure: fail14,
    onDone: succeedNow
  });
  return pipeTo(self2, reader);
});
var mapOutEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const reader = readWithCause({
    onInput: /* @__PURE__ */ __name((outElem) => pipe(fromEffect5(f(outElem)), flatMap18(write), flatMap18(() => reader)), "onInput"),
    onFailure: failCause11,
    onDone: succeedNow
  });
  return pipeTo(self2, reader);
});
var mapOutEffectPar = /* @__PURE__ */ dual(3, (self2, f, n) => unwrapScopedWith((scope5) => gen4(function* () {
  const input = yield* make54();
  const queueReader = fromInput3(input);
  const queue = yield* bounded3(n);
  yield* addFinalizer2(scope5, shutdown2(queue));
  const errorSignal = yield* make43();
  const withPermits = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore2(n)).withPermits;
  const pull = yield* queueReader.pipe(pipeTo(self2), toPullIn(scope5));
  yield* pull.pipe(matchCauseEffect3({
    onFailure: /* @__PURE__ */ __name((cause3) => offer3(queue, failCause9(cause3)), "onFailure"),
    onSuccess: match({
      onLeft: /* @__PURE__ */ __name((outDone) => zipRight7(interruptible4(withPermits(n)(_void)), asVoid5(offer3(queue, succeed11(left2(outDone))))), "onLeft"),
      onRight: /* @__PURE__ */ __name((outElem) => gen4(function* () {
        const deferred = yield* make43();
        const latch = yield* make43();
        yield* offer3(queue, map22(_await3(deferred), right2));
        yield* succeed9(latch, void 0).pipe(zipRight7(uninterruptibleMask3((restore) => exit4(restore(_await3(errorSignal))).pipe(raceFirst2(exit4(restore(f(outElem)))), flatMap15(identity))).pipe(tapErrorCause3((cause3) => failCause7(errorSignal, cause3)), intoDeferred2(deferred))), withPermits(1), forkIn2(scope5));
        yield* _await3(latch);
      }), "onRight")
    })
  }), forever3, interruptible4, forkIn2(scope5));
  const consumer = unwrap3(matchCause4(flatten10(take4(queue)), {
    onFailure: failCause11,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: /* @__PURE__ */ __name((outElem) => flatMap18(write(outElem), () => consumer), "onRight")
    })
  }));
  return embedInput(consumer, input);
})));
var mergeAll7 = /* @__PURE__ */ __name((options4) => {
  return (channels) => mergeAllWith(options4)(channels, constVoid);
}, "mergeAll");
var mergeAllWith = /* @__PURE__ */ __name(({
  bufferSize = 16,
  concurrency,
  mergeStrategy = BackPressure()
}) => (channels, f) => unwrapScopedWith((scope5) => gen4(function* () {
  const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
  const input = yield* make54();
  const queueReader = fromInput3(input);
  const queue = yield* bounded3(bufferSize);
  yield* addFinalizer2(scope5, shutdown2(queue));
  const cancelers = yield* unbounded3();
  yield* addFinalizer2(scope5, shutdown2(cancelers));
  const lastDone = yield* make26(none2());
  const errorSignal = yield* make43();
  const withPermits = (yield* makeSemaphore2(concurrencyN)).withPermits;
  const pull = yield* toPullIn(pipeTo(queueReader, channels), scope5);
  function evaluatePull(pull2) {
    return pull2.pipe(flatMap15(match({
      onLeft: /* @__PURE__ */ __name((done12) => succeed11(some3(done12)), "onLeft"),
      onRight: /* @__PURE__ */ __name((outElem) => as8(offer3(queue, succeed11(right2(outElem))), none2()), "onRight")
    })), repeat({
      until: /* @__PURE__ */ __name((_) => isSome2(_), "until")
    }), flatMap15((outDone) => update3(lastDone, match2({
      onNone: /* @__PURE__ */ __name(() => some3(outDone.value), "onNone"),
      onSome: /* @__PURE__ */ __name((lastDone2) => some3(f(lastDone2, outDone.value)), "onSome")
    }))), catchAllCause3((cause3) => isInterrupted3(cause3) ? failCause9(cause3) : offer3(queue, failCause9(cause3)).pipe(zipRight7(succeed9(errorSignal, void 0)), asVoid5)));
  }
  __name(evaluatePull, "evaluatePull");
  yield* pull.pipe(matchCauseEffect3({
    onFailure: /* @__PURE__ */ __name((cause3) => offer3(queue, failCause9(cause3)).pipe(zipRight7(succeed11(false))), "onFailure"),
    onSuccess: match({
      onLeft: /* @__PURE__ */ __name((outDone) => raceWith2(interruptible4(_await3(errorSignal)), interruptible4(withPermits(concurrencyN)(_void)), {
        onSelfDone: /* @__PURE__ */ __name((_, permitAcquisition) => as8(interrupt5(permitAcquisition), false), "onSelfDone"),
        onOtherDone: /* @__PURE__ */ __name((_, failureAwait) => zipRight7(interrupt5(failureAwait), get12(lastDone).pipe(flatMap15(match2({
          onNone: /* @__PURE__ */ __name(() => offer3(queue, succeed11(left2(outDone))), "onNone"),
          onSome: /* @__PURE__ */ __name((lastDone2) => offer3(queue, succeed11(left2(f(lastDone2, outDone)))), "onSome")
        })), as8(false))), "onOtherDone")
      }), "onLeft"),
      onRight: /* @__PURE__ */ __name((channel2) => match18(mergeStrategy, {
        onBackPressure: /* @__PURE__ */ __name(() => gen4(function* () {
          const latch = yield* make43();
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel2), scope6).pipe(flatMap15((pull2) => race2(exit4(evaluatePull(pull2)), exit4(interruptible4(_await3(errorSignal))))), flatMap15(identity)));
          yield* succeed9(latch, void 0).pipe(zipRight7(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await3(latch);
          const errored = yield* isDone5(errorSignal);
          return !errored;
        }), "onBackPressure"),
        onBufferSliding: /* @__PURE__ */ __name(() => gen4(function* () {
          const canceler = yield* make43();
          const latch = yield* make43();
          const size22 = yield* size14(cancelers);
          yield* take4(cancelers).pipe(flatMap15((canceler2) => succeed9(canceler2, void 0)), when2(() => size22 >= concurrencyN));
          yield* offer3(cancelers, canceler);
          const raceEffects = scopedWith2((scope6) => toPullIn(pipeTo(queueReader, channel2), scope6).pipe(flatMap15((pull2) => exit4(evaluatePull(pull2)).pipe(race2(exit4(interruptible4(_await3(errorSignal)))), race2(exit4(interruptible4(_await3(canceler)))))), flatMap15(identity)));
          yield* succeed9(latch, void 0).pipe(zipRight7(raceEffects), withPermits(1), forkIn2(scope5));
          yield* _await3(latch);
          const errored = yield* isDone5(errorSignal);
          return !errored;
        }), "onBufferSliding")
      }), "onRight")
    })
  }), repeat({
    while: /* @__PURE__ */ __name((_) => _, "while")
  }), forkIn2(scope5));
  const consumer = pipe(take4(queue), flatten10, matchCause4({
    onFailure: failCause11,
    onSuccess: match({
      onLeft: succeedNow,
      onRight: /* @__PURE__ */ __name((outElem) => flatMap18(write(outElem), () => consumer), "onRight")
    })
  }), unwrap3);
  return embedInput(consumer, input);
})), "mergeAllWith");
var mergeMap = /* @__PURE__ */ dual(3, (self2, f, options4) => mergeAll7(options4)(mapOut(self2, f)));
var mergeWith2 = /* @__PURE__ */ dual(2, (self2, options4) => {
  function merge16(scope5) {
    return gen4(function* () {
      const input = yield* make54();
      const queueReader = fromInput3(input);
      const pullL = yield* toPullIn(pipeTo(queueReader, self2), scope5);
      const pullR = yield* toPullIn(pipeTo(queueReader, options4.other), scope5);
      function handleSide(exit5, fiber, pull) {
        return (done12, both2, single2) => {
          function onDecision3(decision) {
            const op = decision;
            if (op._tag === OP_DONE4) {
              return succeed11(fromEffect5(zipRight7(interrupt5(fiber), op.effect)));
            }
            return map22(_await2(fiber), match9({
              onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(op.f(failCause3(cause3))), "onFailure"),
              onSuccess: match({
                onLeft: /* @__PURE__ */ __name((done13) => fromEffect5(op.f(succeed3(done13))), "onLeft"),
                onRight: /* @__PURE__ */ __name((elem) => zipRight8(write(elem), go3(single2(op.f))), "onRight")
              })
            }));
          }
          __name(onDecision3, "onDecision");
          return match9(exit5, {
            onFailure: /* @__PURE__ */ __name((cause3) => onDecision3(done12(failCause3(cause3))), "onFailure"),
            onSuccess: match({
              onLeft: /* @__PURE__ */ __name((z) => onDecision3(done12(succeed3(z))), "onLeft"),
              onRight: /* @__PURE__ */ __name((elem) => succeed11(flatMap18(write(elem), () => flatMap18(fromEffect5(forkIn2(interruptible4(pull), scope5)), (leftFiber) => go3(both2(leftFiber, fiber))))), "onRight")
            })
          });
        };
      }
      __name(handleSide, "handleSide");
      function go3(state2) {
        switch (state2._tag) {
          case OP_BOTH_RUNNING: {
            const leftJoin = interruptible4(join4(state2.left));
            const rightJoin = interruptible4(join4(state2.right));
            return unwrap3(raceWith2(leftJoin, rightJoin, {
              onSelfDone: /* @__PURE__ */ __name((leftExit, rf) => zipRight7(interrupt5(rf), handleSide(leftExit, state2.right, pullL)(options4.onSelfDone, BothRunning, (f) => LeftDone(f))), "onSelfDone"),
              onOtherDone: /* @__PURE__ */ __name((rightExit, lf) => zipRight7(interrupt5(lf), handleSide(rightExit, state2.left, pullR)(options4.onOtherDone, (left3, right3) => BothRunning(right3, left3), (f) => RightDone(f))), "onOtherDone")
            }));
          }
          case OP_LEFT_DONE: {
            return unwrap3(map22(exit4(pullR), match9({
              onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(state2.f(failCause3(cause3))), "onFailure"),
              onSuccess: match({
                onLeft: /* @__PURE__ */ __name((done12) => fromEffect5(state2.f(succeed3(done12))), "onLeft"),
                onRight: /* @__PURE__ */ __name((elem) => flatMap18(write(elem), () => go3(LeftDone(state2.f))), "onRight")
              })
            })));
          }
          case OP_RIGHT_DONE: {
            return unwrap3(map22(exit4(pullL), match9({
              onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(state2.f(failCause3(cause3))), "onFailure"),
              onSuccess: match({
                onLeft: /* @__PURE__ */ __name((done12) => fromEffect5(state2.f(succeed3(done12))), "onLeft"),
                onRight: /* @__PURE__ */ __name((elem) => flatMap18(write(elem), () => go3(RightDone(state2.f))), "onRight")
              })
            })));
          }
        }
      }
      __name(go3, "go");
      return fromEffect5(withFiberRuntime2((parent) => {
        const inherit = withFiberRuntime2((state2) => {
          ;
          state2.transferChildren(parent.scope());
          return _void;
        });
        const leftFiber = interruptible4(pullL).pipe(ensuring3(inherit), forkIn2(scope5));
        const rightFiber = interruptible4(pullR).pipe(ensuring3(inherit), forkIn2(scope5));
        return zipWith10(leftFiber, rightFiber, (left3, right3) => BothRunning(left3, right3));
      })).pipe(flatMap18(go3), embedInput(input));
    });
  }
  __name(merge16, "merge");
  return unwrapScopedWith(merge16);
});
var orDieWith3 = /* @__PURE__ */ dual(2, (self2, f) => catchAll5(self2, (e) => failCauseSync6(() => die4(f(e)))));
var orElse11 = /* @__PURE__ */ dual(2, (self2, that) => catchAll5(self2, that));
var pipeToOrFail = /* @__PURE__ */ dual(2, (self2, that) => suspend8(() => {
  let channelException = void 0;
  const reader = readWith({
    onInput: /* @__PURE__ */ __name((outElem) => flatMap18(write(outElem), () => reader), "onInput"),
    onFailure: /* @__PURE__ */ __name((outErr) => {
      channelException = ChannelException(outErr);
      return failCause11(die4(channelException));
    }, "onFailure"),
    onDone: succeedNow
  });
  const writer = readWithCause({
    onInput: /* @__PURE__ */ __name((outElem) => pipe(write(outElem), flatMap18(() => writer)), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => isDieType2(cause3) && isChannelException(cause3.defect) && equals(cause3.defect, channelException) ? fail14(cause3.defect.error) : failCause11(cause3), "onFailure"),
    onDone: succeedNow
  });
  return pipeTo(pipeTo(pipeTo(self2, reader), that), writer);
}));
var repeated = /* @__PURE__ */ __name((self2) => flatMap18(self2, () => repeated(self2)), "repeated");
var run2 = /* @__PURE__ */ __name((self2) => scopedWith2((scope5) => runIn(self2, scope5)), "run");
var runDrain = /* @__PURE__ */ __name((self2) => run2(drain(self2)), "runDrain");
var runScoped = /* @__PURE__ */ __name((self2) => scopeWith2((scope5) => runIn(self2, scope5)), "runScoped");
var scoped5 = /* @__PURE__ */ __name((effect4) => unwrap3(uninterruptibleMask3((restore) => map22(make40(), (scope5) => acquireReleaseOut(tapErrorCause3(restore(extend3(effect4, scope5)), (cause3) => close(scope5, failCause3(cause3))), (_, exit5) => close(scope5, exit5))))), "scoped");
var scopedWith3 = /* @__PURE__ */ __name((f) => unwrapScoped3(map22(scope3, (scope5) => flatMap18(fromEffect5(f(scope5)), write))), "scopedWith");
var splitLines = /* @__PURE__ */ __name(() => suspend8(() => {
  let stringBuilder = "";
  let midCRLF = false;
  const splitLinesChunk = /* @__PURE__ */ __name((chunk4) => {
    const chunkBuilder = [];
    map6(chunk4, (str) => {
      if (str.length !== 0) {
        let from = 0;
        let indexOfCR = str.indexOf("\r");
        let indexOfLF = str.indexOf("\n");
        if (midCRLF) {
          if (indexOfLF === 0) {
            chunkBuilder.push(stringBuilder);
            stringBuilder = "";
            from = 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            stringBuilder = stringBuilder + "\r";
          }
          midCRLF = false;
        }
        while (indexOfCR !== -1 || indexOfLF !== -1) {
          if (indexOfCR === -1 || indexOfLF !== -1 && indexOfLF < indexOfCR) {
            if (stringBuilder.length === 0) {
              chunkBuilder.push(str.substring(from, indexOfLF));
            } else {
              chunkBuilder.push(stringBuilder + str.substring(from, indexOfLF));
              stringBuilder = "";
            }
            from = indexOfLF + 1;
            indexOfLF = str.indexOf("\n", from);
          } else {
            if (str.length === indexOfCR + 1) {
              midCRLF = true;
              indexOfCR = -1;
            } else {
              if (indexOfLF === indexOfCR + 1) {
                if (stringBuilder.length === 0) {
                  chunkBuilder.push(str.substring(from, indexOfCR));
                } else {
                  stringBuilder = stringBuilder + str.substring(from, indexOfCR);
                  chunkBuilder.push(stringBuilder);
                  stringBuilder = "";
                }
                from = indexOfCR + 2;
                indexOfCR = str.indexOf("\r", from);
                indexOfLF = str.indexOf("\n", from);
              } else {
                indexOfCR = str.indexOf("\r", indexOfCR + 1);
              }
            }
          }
        }
        if (midCRLF) {
          stringBuilder = stringBuilder + str.substring(from, str.length - 1);
        } else {
          stringBuilder = stringBuilder + str.substring(from, str.length);
        }
      }
    });
    return unsafeFromArray(chunkBuilder);
  }, "splitLinesChunk");
  const loop5 = readWithCause({
    onInput: /* @__PURE__ */ __name((input) => {
      const out = splitLinesChunk(input);
      return isEmpty(out) ? loop5 : flatMap18(write(out), () => loop5);
    }, "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => stringBuilder.length === 0 ? failCause11(cause3) : flatMap18(write(of2(stringBuilder)), () => failCause11(cause3)), "onFailure"),
    onDone: /* @__PURE__ */ __name((done12) => stringBuilder.length === 0 ? succeed15(done12) : flatMap18(write(of2(stringBuilder)), () => succeed15(done12)), "onDone")
  });
  return loop5;
}), "splitLines");
var toPubSub = /* @__PURE__ */ __name((pubsub) => toQueue(pubsub), "toPubSub");
var toPull = /* @__PURE__ */ __name((self2) => flatMap15(scope3, (scope5) => toPullIn(self2, scope5)), "toPull");
var toPullIn = /* @__PURE__ */ dual(2, (self2, scope5) => zip8(sync7(() => new ChannelExecutor(self2, void 0, identity)), runtime4()).pipe(tap4(([executor, runtime8]) => addFinalizerExit(scope5, (exit5) => {
  const finalizer3 = executor.close(exit5);
  return finalizer3 !== void 0 ? provide2(finalizer3, runtime8) : _void;
})), uninterruptible2, map22(([executor]) => suspend4(() => interpretToPull(executor.run(), executor)))));
var interpretToPull = /* @__PURE__ */ __name((channelState, exec) => {
  const state2 = channelState;
  switch (state2._tag) {
    case OP_DONE3: {
      return match9(exec.getDone(), {
        onFailure: failCause9,
        onSuccess: /* @__PURE__ */ __name((done12) => succeed11(left2(done12)), "onSuccess")
      });
    }
    case OP_EMIT2: {
      return succeed11(right2(exec.getEmit()));
    }
    case OP_FROM_EFFECT3: {
      return pipe(state2.effect, flatMap15(() => interpretToPull(exec.run(), exec)));
    }
    case OP_READ2: {
      return readUpstream(state2, () => interpretToPull(exec.run(), exec), (cause3) => failCause9(cause3));
    }
  }
}, "interpretToPull");
var toQueue = /* @__PURE__ */ __name((queue) => suspend8(() => toQueueInternal(queue)), "toQueue");
var toQueueInternal = /* @__PURE__ */ __name((queue) => {
  return readWithCause({
    onInput: /* @__PURE__ */ __name((elem) => flatMap18(fromEffect5(offer3(queue, right2(elem))), () => toQueueInternal(queue)), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(offer3(queue, left2(failCause3(cause3)))), "onFailure"),
    onDone: /* @__PURE__ */ __name((done12) => fromEffect5(offer3(queue, left2(succeed3(done12)))), "onDone")
  });
}, "toQueueInternal");
var unwrap3 = /* @__PURE__ */ __name((channel2) => flatten13(fromEffect5(channel2)), "unwrap");
var unwrapScoped3 = /* @__PURE__ */ __name((self2) => concatAllWith(scoped5(self2), (d, _) => d, (d, _) => d), "unwrapScoped");
var unwrapScopedWith = /* @__PURE__ */ __name((f) => concatAllWith(scopedWith3(f), (d, _) => d, (d, _) => d), "unwrapScopedWith");
var withSpan5 = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options4 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  const acquire = all8([makeSpan2(name, options4), context4(), clock2, get14(currentTracerTimingEnabled2)]);
  if (dataFirst) {
    const self2 = arguments[0];
    return acquireUseRelease3(acquire, ([span4, context17]) => provideContext4(self2, add4(context17, spanTag, span4)), ([span4, , clock3, timingEnabled], exit5) => endSpan(span4, exit5, clock3, timingEnabled));
  }
  return (self2) => acquireUseRelease3(acquire, ([span4, context17]) => provideContext4(self2, add4(context17, spanTag, span4)), ([span4, , clock3, timingEnabled], exit5) => endSpan(span4, exit5, clock3, timingEnabled));
}, "withSpan");
var writeAll = /* @__PURE__ */ __name((...outs) => writeChunk(fromIterable3(outs)), "writeAll");
var writeChunk = /* @__PURE__ */ __name((outs) => writeChunkWriter(0, outs.length, outs), "writeChunk");
var writeChunkWriter = /* @__PURE__ */ __name((idx, len, chunk4) => {
  return idx === len ? void_8 : pipe(write(pipe(chunk4, unsafeGet2(idx))), flatMap18(() => writeChunkWriter(idx + 1, len, chunk4)));
}, "writeChunkWriter");
var zip10 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options4) => options4?.concurrent ? mergeWith2(self2, {
  other: that,
  onSelfDone: /* @__PURE__ */ __name((exit1) => Await((exit22) => suspend4(() => zip4(exit1, exit22))), "onSelfDone"),
  onOtherDone: /* @__PURE__ */ __name((exit22) => Await((exit1) => suspend4(() => zip4(exit1, exit22))), "onOtherDone")
}) : flatMap18(self2, (a) => map28(that, (b) => [a, b])));
var zipLeft8 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options4) => options4?.concurrent ? map28(zip10(self2, that, {
  concurrent: true
}), (tuple5) => tuple5[0]) : flatMap18(self2, (z) => as9(that, z)));
var zipRight8 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options4) => options4?.concurrent ? map28(zip10(self2, that, {
  concurrent: true
}), (tuple5) => tuple5[1]) : flatMap18(self2, () => that));
var ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
var ChannelException = /* @__PURE__ */ __name((error5) => ({
  _tag: "ChannelException",
  [ChannelExceptionTypeId]: ChannelExceptionTypeId,
  error: error5
}), "ChannelException");
var isChannelException = /* @__PURE__ */ __name((u) => hasProperty(u, ChannelExceptionTypeId), "isChannelException");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/MergeDecision.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Done4 = Done3;
var Await2 = Await;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/RcRef.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/rcRef.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId22 = /* @__PURE__ */ Symbol.for("effect/RcRef");
var stateEmpty2 = {
  _tag: "Empty"
};
var stateClosed = {
  _tag: "Closed"
};
var variance6 = {
  _A: identity,
  _E: identity
};
var RcRefImpl = class extends Class2 {
  static {
    __name(this, "RcRefImpl");
  }
  acquire;
  context;
  scope;
  idleTimeToLive;
  [TypeId22] = variance6;
  [TypeId12] = TypeId12;
  state = stateEmpty2;
  semaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  constructor(acquire, context17, scope5, idleTimeToLive) {
    super();
    this.acquire = acquire;
    this.context = context17;
    this.scope = scope5;
    this.idleTimeToLive = idleTimeToLive;
    this.get = get16(this);
  }
  get;
  commit() {
    return this.get;
  }
};
var make55 = /* @__PURE__ */ __name((options4) => withFiberRuntime((fiber) => {
  const context17 = fiber.getFiberRef(currentContext);
  const scope5 = get6(context17, scopeTag);
  const ref2 = new RcRefImpl(options4.acquire, context17, scope5, options4.idleTimeToLive ? decode(options4.idleTimeToLive) : void 0);
  return as3(scope5.addFinalizer(() => ref2.semaphore.withPermits(1)(suspend(() => {
    const close2 = ref2.state._tag === "Acquired" ? scopeClose(ref2.state.scope, exitVoid) : void_3;
    ref2.state = stateClosed;
    return close2;
  }))), ref2);
}), "make");
var get16 = /* @__PURE__ */ __name((self_) => {
  const self2 = self_;
  const isInfinite = self2.idleTimeToLive && !isFinite(self2.idleTimeToLive);
  return uninterruptibleMask((restore) => suspend(() => {
    switch (self2.state._tag) {
      case "Closed": {
        return interrupt2;
      }
      case "Acquired": {
        self2.state.refCount++;
        return self2.state.fiber ? as3(interruptFiber(self2.state.fiber), self2.state) : succeed(self2.state);
      }
      case "Empty": {
        return scopeMake().pipe(bindTo5("scope"), bind5("value", ({
          scope: scope5
        }) => restore(fiberRefLocally(self2.acquire, currentContext, add4(self2.context, scopeTag, scope5)))), map12(({
          scope: scope5,
          value: value6
        }) => {
          const state2 = {
            _tag: "Acquired",
            value: value6,
            scope: scope5,
            fiber: void 0,
            refCount: 1
          };
          self2.state = state2;
          return state2;
        }));
      }
    }
  })).pipe(self2.semaphore.withPermits(1), bindTo5("state"), bind5("scope", () => scopeTag), tap2(({
    scope: scope5,
    state: state2
  }) => scope5.addFinalizer(() => suspend(() => {
    state2.refCount--;
    if (state2.refCount > 0 || isInfinite) {
      return void_3;
    }
    if (self2.idleTimeToLive === void 0) {
      self2.state = stateEmpty2;
      return scopeClose(state2.scope, exitVoid);
    }
    return sleep3(self2.idleTimeToLive).pipe(interruptible2, zipRight2(suspend(() => {
      if (self2.state._tag === "Acquired" && self2.state.refCount === 0) {
        self2.state = stateEmpty2;
        return scopeClose(state2.scope, exitVoid);
      }
      return void_3;
    })), ensuring(sync(() => {
      state2.fiber = void 0;
    })), forkIn(self2.scope), tap2((fiber) => {
      state2.fiber = fiber;
    }), self2.semaphore.withPermits(1));
  }))), map12(({
    state: state2
  }) => state2.value));
}, "get");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/RcRef.js
var make56 = make55;
var get17 = get16;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Runtime.js
var Runtime_exports = {};
__export(Runtime_exports, {
  FiberFailureCauseId: () => FiberFailureCauseId2,
  FiberFailureId: () => FiberFailureId2,
  defaultRuntime: () => defaultRuntime2,
  defaultRuntimeFlags: () => defaultRuntimeFlags2,
  deleteFiberRef: () => deleteFiberRef2,
  disableRuntimeFlag: () => disableRuntimeFlag2,
  enableRuntimeFlag: () => enableRuntimeFlag2,
  isAsyncFiberException: () => isAsyncFiberException2,
  isFiberFailure: () => isFiberFailure2,
  make: () => make57,
  makeFiberFailure: () => makeFiberFailure,
  provideService: () => provideService5,
  runCallback: () => runCallback2,
  runFork: () => runFork3,
  runPromise: () => runPromise2,
  runPromiseExit: () => runPromiseExit2,
  runSync: () => runSync2,
  runSyncExit: () => runSyncExit2,
  setFiberRef: () => setFiberRef2,
  updateContext: () => updateContext3,
  updateFiberRefs: () => updateFiberRefs4,
  updateRuntimeFlags: () => updateRuntimeFlags3
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var runFork3 = unsafeFork3;
var runSyncExit2 = unsafeRunSyncExit;
var runSync2 = unsafeRunSync;
var runCallback2 = unsafeRunCallback;
var runPromise2 = unsafeRunPromise;
var runPromiseExit2 = unsafeRunPromiseExit;
var defaultRuntime2 = defaultRuntime;
var defaultRuntimeFlags2 = defaultRuntimeFlags;
var make57 = make41;
var FiberFailureId2 = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId2 = FiberFailureCauseId;
var isAsyncFiberException2 = isAsyncFiberException;
var isFiberFailure2 = isFiberFailure;
var makeFiberFailure = fiberFailure;
var updateRuntimeFlags3 = updateRuntimeFlags2;
var enableRuntimeFlag2 = enableRuntimeFlag;
var disableRuntimeFlag2 = disableRuntimeFlag;
var updateContext3 = updateContext2;
var provideService5 = provideService2;
var updateFiberRefs4 = updateFiberRefs2;
var setFiberRef2 = setFiberRef;
var deleteFiberRef2 = deleteFiberRef;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Schedule.js
var Schedule_exports = {};
__export(Schedule_exports, {
  CurrentIterationMetadata: () => CurrentIterationMetadata2,
  ScheduleDriverTypeId: () => ScheduleDriverTypeId2,
  ScheduleTypeId: () => ScheduleTypeId2,
  addDelay: () => addDelay2,
  addDelayEffect: () => addDelayEffect2,
  andThen: () => andThen9,
  andThenEither: () => andThenEither2,
  as: () => as10,
  asVoid: () => asVoid6,
  bothInOut: () => bothInOut2,
  check: () => check3,
  checkEffect: () => checkEffect2,
  collectAllInputs: () => collectAllInputs2,
  collectAllOutputs: () => collectAllOutputs2,
  collectUntil: () => collectUntil2,
  collectUntilEffect: () => collectUntilEffect2,
  collectWhile: () => collectWhile2,
  collectWhileEffect: () => collectWhileEffect2,
  compose: () => compose5,
  count: () => count4,
  cron: () => cron2,
  dayOfMonth: () => dayOfMonth2,
  dayOfWeek: () => dayOfWeek2,
  delayed: () => delayed2,
  delayedEffect: () => delayedEffect2,
  delayedSchedule: () => delayedSchedule2,
  delays: () => delays2,
  driver: () => driver2,
  duration: () => duration3,
  either: () => either5,
  eitherWith: () => eitherWith2,
  elapsed: () => elapsed2,
  ensuring: () => ensuring5,
  exponential: () => exponential3,
  fibonacci: () => fibonacci2,
  fixed: () => fixed4,
  forever: () => forever4,
  fromDelay: () => fromDelay2,
  fromDelays: () => fromDelays2,
  fromFunction: () => fromFunction4,
  hourOfDay: () => hourOfDay2,
  identity: () => identity4,
  intersect: () => intersect6,
  intersectWith: () => intersectWith2,
  isSchedule: () => isSchedule2,
  jittered: () => jittered2,
  jitteredWith: () => jitteredWith2,
  linear: () => linear2,
  makeWithState: () => makeWithState2,
  map: () => map29,
  mapBoth: () => mapBoth7,
  mapBothEffect: () => mapBothEffect2,
  mapEffect: () => mapEffect5,
  mapInput: () => mapInput6,
  mapInputContext: () => mapInputContext4,
  mapInputEffect: () => mapInputEffect2,
  minuteOfHour: () => minuteOfHour2,
  modifyDelay: () => modifyDelay2,
  modifyDelayEffect: () => modifyDelayEffect2,
  onDecision: () => onDecision2,
  once: () => once5,
  passthrough: () => passthrough4,
  provideContext: () => provideContext5,
  provideService: () => provideService6,
  recurUntil: () => recurUntil2,
  recurUntilEffect: () => recurUntilEffect2,
  recurUntilOption: () => recurUntilOption2,
  recurUpTo: () => recurUpTo2,
  recurWhile: () => recurWhile2,
  recurWhileEffect: () => recurWhileEffect2,
  recurs: () => recurs2,
  reduce: () => reduce14,
  reduceEffect: () => reduceEffect4,
  repeatForever: () => repeatForever,
  repetitions: () => repetitions2,
  resetAfter: () => resetAfter2,
  resetWhen: () => resetWhen2,
  run: () => run3,
  secondOfMinute: () => secondOfMinute2,
  spaced: () => spaced2,
  stop: () => stop2,
  succeed: () => succeed16,
  sync: () => sync11,
  tapInput: () => tapInput2,
  tapOutput: () => tapOutput2,
  unfold: () => unfold3,
  union: () => union11,
  unionWith: () => unionWith3,
  untilInput: () => untilInput2,
  untilInputEffect: () => untilInputEffect2,
  untilOutput: () => untilOutput2,
  untilOutputEffect: () => untilOutputEffect2,
  upTo: () => upTo2,
  whileInput: () => whileInput2,
  whileInputEffect: () => whileInputEffect2,
  whileOutput: () => whileOutput2,
  whileOutputEffect: () => whileOutputEffect2,
  windowed: () => windowed2,
  zipLeft: () => zipLeft9,
  zipRight: () => zipRight9,
  zipWith: () => zipWith13
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ScheduleTypeId2 = ScheduleTypeId;
var ScheduleDriverTypeId2 = ScheduleDriverTypeId;
var makeWithState2 = makeWithState;
var isSchedule2 = isSchedule;
var addDelay2 = addDelay;
var addDelayEffect2 = addDelayEffect;
var andThen9 = andThen7;
var andThenEither2 = andThenEither;
var as10 = as7;
var asVoid6 = asVoid4;
var bothInOut2 = bothInOut;
var check3 = check;
var checkEffect2 = checkEffect;
var collectAllInputs2 = collectAllInputs;
var collectAllOutputs2 = collectAllOutputs;
var collectUntil2 = collectUntil;
var collectUntilEffect2 = collectUntilEffect;
var collectWhile2 = collectWhile;
var collectWhileEffect2 = collectWhileEffect;
var compose5 = compose2;
var mapInput6 = mapInput5;
var mapInputEffect2 = mapInputEffect;
var mapInputContext4 = mapInputContext2;
var count4 = count3;
var cron2 = cron;
var secondOfMinute2 = secondOfMinute;
var minuteOfHour2 = minuteOfHour;
var hourOfDay2 = hourOfDay;
var dayOfMonth2 = dayOfMonth;
var dayOfWeek2 = dayOfWeek;
var delayed2 = delayed;
var delayedEffect2 = delayedEffect;
var delayedSchedule2 = delayedSchedule;
var delays2 = delays;
var mapBoth7 = mapBoth4;
var mapBothEffect2 = mapBothEffect;
var driver2 = driver;
var duration3 = duration;
var either5 = either3;
var eitherWith2 = eitherWith;
var elapsed2 = elapsed;
var ensuring5 = ensuring2;
var exponential3 = exponential2;
var fibonacci2 = fibonacci;
var fixed4 = fixed3;
var forever4 = forever2;
var fromDelay2 = fromDelay;
var fromDelays2 = fromDelays;
var fromFunction4 = fromFunction2;
var identity4 = identity2;
var passthrough4 = passthrough2;
var intersect6 = intersect5;
var intersectWith2 = intersectWith;
var jittered2 = jittered;
var jitteredWith2 = jitteredWith;
var linear2 = linear;
var map29 = map21;
var mapEffect5 = mapEffect4;
var modifyDelay2 = modifyDelay;
var modifyDelayEffect2 = modifyDelayEffect;
var onDecision2 = onDecision;
var once5 = once3;
var provideContext5 = provideContext3;
var provideService6 = provideService3;
var recurUntil2 = recurUntil;
var recurUntilEffect2 = recurUntilEffect;
var recurUntilOption2 = recurUntilOption;
var recurUpTo2 = recurUpTo;
var recurWhile2 = recurWhile;
var recurWhileEffect2 = recurWhileEffect;
var recurs2 = recurs;
var reduce14 = reduce12;
var reduceEffect4 = reduceEffect2;
var repeatForever = forever2;
var repetitions2 = repetitions;
var resetAfter2 = resetAfter;
var resetWhen2 = resetWhen;
var run3 = run;
var spaced2 = spaced;
var stop2 = stop;
var succeed16 = succeed8;
var sync11 = sync5;
var tapInput2 = tapInput;
var tapOutput2 = tapOutput;
var unfold3 = unfold2;
var union11 = union10;
var unionWith3 = unionWith2;
var untilInput2 = untilInput;
var untilInputEffect2 = untilInputEffect;
var untilOutput2 = untilOutput;
var untilOutputEffect2 = untilOutputEffect;
var upTo2 = upTo;
var whileInput2 = whileInput;
var whileInputEffect2 = whileInputEffect;
var whileOutput2 = whileOutput;
var whileOutputEffect2 = whileOutputEffect;
var windowed2 = windowed;
var zipLeft9 = zipLeft6;
var zipRight9 = zipRight6;
var zipWith13 = zipWith9;
var CurrentIterationMetadata2 = CurrentIterationMetadata;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/StreamHaltStrategy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/haltStrategy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/opCodes/streamHaltStrategy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_LEFT = "Left";
var OP_RIGHT = "Right";
var OP_BOTH = "Both";
var OP_EITHER = "Either";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/haltStrategy.js
var Left = {
  _tag: OP_LEFT
};
var Right = {
  _tag: OP_RIGHT
};
var Both = {
  _tag: OP_BOTH
};
var Either2 = {
  _tag: OP_EITHER
};
var fromInput4 = /* @__PURE__ */ __name((input) => {
  switch (input) {
    case "left":
      return Left;
    case "right":
      return Right;
    case "both":
      return Both;
    case "either":
      return Either2;
    default:
      return input;
  }
}, "fromInput");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/StreamHaltStrategy.js
var Both2 = Both;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/TPubSub.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/tPubSub.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/core.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/sink.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SinkTypeId3 = /* @__PURE__ */ Symbol.for("effect/Sink");
var sinkVariance2 = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In"),
  /* c8 ignore next */
  _L: /* @__PURE__ */ __name((_) => _, "_L"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R")
};
var SinkImpl = class {
  static {
    __name(this, "SinkImpl");
  }
  channel;
  [SinkTypeId3] = sinkVariance2;
  constructor(channel2) {
    this.channel = channel2;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSink = /* @__PURE__ */ __name((u) => hasProperty(u, SinkTypeId3), "isSink");
var suspend9 = /* @__PURE__ */ __name((evaluate3) => new SinkImpl(suspend8(() => toChannel(evaluate3()))), "suspend");
var collectAll = /* @__PURE__ */ __name(() => new SinkImpl(collectAllLoop(empty4())), "collectAll");
var collectAllLoop = /* @__PURE__ */ __name((acc) => readWithCause({
  onInput: /* @__PURE__ */ __name((chunk4) => collectAllLoop(pipe(acc, appendAll2(chunk4))), "onInput"),
  onFailure: failCause11,
  onDone: /* @__PURE__ */ __name(() => succeed15(acc), "onDone")
}), "collectAllLoop");
var collectAllN = /* @__PURE__ */ __name((n) => suspend9(() => fromChannel(collectAllNLoop(n, empty4()))), "collectAllN");
var collectAllNLoop = /* @__PURE__ */ __name((n, acc) => readWithCause({
  onInput: /* @__PURE__ */ __name((chunk4) => {
    const [collected, leftovers] = splitAt2(chunk4, n);
    if (collected.length < n) {
      return collectAllNLoop(n - collected.length, appendAll2(acc, collected));
    }
    if (isEmpty(leftovers)) {
      return succeed15(appendAll2(acc, collected));
    }
    return flatMap18(write(leftovers), () => succeed15(appendAll2(acc, collected)));
  }, "onInput"),
  onFailure: failCause11,
  onDone: /* @__PURE__ */ __name(() => succeed15(acc), "onDone")
}), "collectAllNLoop");
var collectLeftover = /* @__PURE__ */ __name((self2) => new SinkImpl(pipe(collectElements(toChannel(self2)), map28(([chunks3, z]) => [z, flatten3(chunks3)]))), "collectLeftover");
var drain2 = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain(/* @__PURE__ */ identityChannel()));
var fail15 = /* @__PURE__ */ __name((e) => new SinkImpl(fail14(e)), "fail");
var fold = /* @__PURE__ */ __name((s, contFn, f) => suspend9(() => new SinkImpl(foldReader(s, contFn, f))), "fold");
var foldReader = /* @__PURE__ */ __name((s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      const [nextS, leftovers] = foldChunkSplit(s, input, contFn, f, 0, input.length);
      if (isNonEmpty(leftovers)) {
        return pipe(write(leftovers), as9(nextS));
      }
      return foldReader(nextS, contFn, f);
    }, "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => succeedNow(s), "onDone")
  });
}, "foldReader");
var foldChunkSplit = /* @__PURE__ */ __name((s, chunk4, contFn, f, index2, length5) => {
  if (index2 === length5) {
    return [s, empty4()];
  }
  const s1 = f(s, pipe(chunk4, unsafeGet2(index2)));
  if (contFn(s1)) {
    return foldChunkSplit(s1, chunk4, contFn, f, index2 + 1, length5);
  }
  return [s1, pipe(chunk4, drop2(index2 + 1))];
}, "foldChunkSplit");
var foldSink = /* @__PURE__ */ dual(2, (self2, options4) => {
  const newChannel = pipe(toChannel(self2), collectElements, foldChannel({
    onFailure: /* @__PURE__ */ __name((error5) => toChannel(options4.onFailure(error5)), "onFailure"),
    onSuccess: /* @__PURE__ */ __name(([leftovers, z]) => suspend8(() => {
      const leftoversRef = {
        ref: pipe(leftovers, filter4(isNonEmpty))
      };
      const refReader = pipe(
        sync10(() => {
          const ref2 = leftoversRef.ref;
          leftoversRef.ref = empty4();
          return ref2;
        }),
        // This cast is safe because of the L1 >: L <: In1 bound. It follows that
        // L <: In1 and therefore Chunk[L] can be safely cast to Chunk[In1].
        flatMap18((chunk4) => writeChunk(chunk4))
      );
      const passthrough5 = identityChannel();
      const continuationSink = pipe(refReader, zipRight8(passthrough5), pipeTo(toChannel(options4.onSuccess(z))));
      return flatMap18(collectElements(continuationSink), ([newLeftovers, z1]) => pipe(succeed15(leftoversRef.ref), flatMap18(writeChunk), zipRight8(writeChunk(newLeftovers)), as9(z1)));
    }), "onSuccess")
  }));
  return new SinkImpl(newChannel);
});
var foldChunks = /* @__PURE__ */ __name((s, contFn, f) => suspend9(() => new SinkImpl(foldChunksReader(s, contFn, f))), "foldChunks");
var foldChunksReader = /* @__PURE__ */ __name((s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: /* @__PURE__ */ __name((input) => foldChunksReader(f(s, input), contFn, f), "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => succeedNow(s), "onDone")
  });
}, "foldChunksReader");
var foldEffect = /* @__PURE__ */ __name((s, contFn, f) => suspend9(() => new SinkImpl(foldEffectReader(s, contFn, f))), "foldEffect");
var foldEffectReader = /* @__PURE__ */ __name((s, contFn, f) => {
  if (!contFn(s)) {
    return succeedNow(s);
  }
  return readWith({
    onInput: /* @__PURE__ */ __name((input) => pipe(fromEffect5(foldChunkSplitEffect(s, input, contFn, f)), flatMap18(([nextS, leftovers]) => pipe(leftovers, match2({
      onNone: /* @__PURE__ */ __name(() => foldEffectReader(nextS, contFn, f), "onNone"),
      onSome: /* @__PURE__ */ __name((leftover2) => pipe(write(leftover2), as9(nextS)), "onSome")
    })))), "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => succeedNow(s), "onDone")
  });
}, "foldEffectReader");
var foldChunkSplitEffect = /* @__PURE__ */ __name((s, chunk4, contFn, f) => foldChunkSplitEffectInternal(s, chunk4, 0, chunk4.length, contFn, f), "foldChunkSplitEffect");
var foldChunkSplitEffectInternal = /* @__PURE__ */ __name((s, chunk4, index2, length5, contFn, f) => {
  if (index2 === length5) {
    return succeed11([s, none2()]);
  }
  return pipe(f(s, pipe(chunk4, unsafeGet2(index2))), flatMap15((s1) => contFn(s1) ? foldChunkSplitEffectInternal(s1, chunk4, index2 + 1, length5, contFn, f) : succeed11([s1, some3(pipe(chunk4, drop2(index2 + 1)))])));
}, "foldChunkSplitEffectInternal");
var foldLeftChunks = /* @__PURE__ */ __name((s, f) => foldChunks(s, constTrue, f), "foldLeftChunks");
var flatMap19 = /* @__PURE__ */ dual(2, (self2, f) => foldSink(self2, {
  onFailure: fail15,
  onSuccess: f
}));
var forEach12 = /* @__PURE__ */ __name((f) => {
  const process2 = readWithCause({
    onInput: /* @__PURE__ */ __name((input) => pipe(fromEffect5(forEach11(input, (v) => f(v), {
      discard: true
    })), flatMap18(() => process2)), "onInput"),
    onFailure: failCause11,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  });
  return new SinkImpl(process2);
}, "forEach");
var forEachChunk = /* @__PURE__ */ __name((f) => {
  const process2 = readWithCause({
    onInput: /* @__PURE__ */ __name((input) => pipe(fromEffect5(f(input)), flatMap18(() => process2)), "onInput"),
    onFailure: failCause11,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  });
  return new SinkImpl(process2);
}, "forEachChunk");
var forEachWhile = /* @__PURE__ */ __name((f) => {
  const process2 = readWithCause({
    onInput: /* @__PURE__ */ __name((input) => forEachWhileReader(f, input, 0, input.length, process2), "onInput"),
    onFailure: failCause11,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  });
  return new SinkImpl(process2);
}, "forEachWhile");
var forEachWhileReader = /* @__PURE__ */ __name((f, input, index2, length5, cont) => {
  if (index2 === length5) {
    return cont;
  }
  return pipe(fromEffect5(f(pipe(input, unsafeGet2(index2)))), flatMap18((bool) => bool ? forEachWhileReader(f, input, index2 + 1, length5, cont) : write(pipe(input, drop2(index2)))), catchAll5((error5) => pipe(write(pipe(input, drop2(index2))), zipRight8(fail14(error5)))));
}, "forEachWhileReader");
var fromChannel = /* @__PURE__ */ __name((channel2) => new SinkImpl(channel2), "fromChannel");
var fromEffect7 = /* @__PURE__ */ __name((effect4) => new SinkImpl(fromEffect5(effect4)), "fromEffect");
var head7 = /* @__PURE__ */ __name(() => fold(none2(), isNone2, (option9, input) => match2(option9, {
  onNone: /* @__PURE__ */ __name(() => some3(input), "onNone"),
  onSome: /* @__PURE__ */ __name(() => option9, "onSome")
})), "head");
var last4 = /* @__PURE__ */ __name(() => foldLeftChunks(none2(), (s, input) => orElse2(last2(input), () => s)), "last");
var map30 = /* @__PURE__ */ dual(2, (self2, f) => {
  return new SinkImpl(pipe(toChannel(self2), map28(f)));
});
var raceWith3 = /* @__PURE__ */ dual(2, (self2, options4) => {
  function race6(scope5) {
    return gen4(function* () {
      const pubsub = yield* bounded5(options4?.capacity ?? 16);
      const subscription1 = yield* extend3(subscribe2(pubsub), scope5);
      const subscription2 = yield* extend3(subscribe2(pubsub), scope5);
      const reader = toPubSub(pubsub);
      const writer = fromQueue(subscription1).pipe(pipeTo(toChannel(self2)), zipLeft8(fromEffect5(shutdown2(subscription1))), mergeWith2({
        other: fromQueue(subscription2).pipe(pipeTo(toChannel(options4.other)), zipLeft8(fromEffect5(shutdown2(subscription2)))),
        onSelfDone: options4.onSelfDone,
        onOtherDone: options4.onOtherDone
      }));
      const racedChannel = mergeWith2(reader, {
        other: writer,
        onSelfDone: /* @__PURE__ */ __name(() => Await(identity), "onSelfDone"),
        onOtherDone: /* @__PURE__ */ __name((exit5) => Done3(exit5), "onOtherDone")
      });
      return new SinkImpl(racedChannel);
    });
  }
  __name(race6, "race");
  return unwrapScopedWith2(race6);
});
var sum2 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk4) => acc + reduce2(chunk4, 0, (s, a) => s + a));
var toChannel = /* @__PURE__ */ __name((self2) => isEffect2(self2) ? toChannel(fromEffect7(self2)) : self2.channel, "toChannel");
var unwrapScopedWith2 = /* @__PURE__ */ __name((f) => new SinkImpl(unwrapScopedWith((scope5) => f(scope5).pipe(map22((sink) => toChannel(sink))))), "unwrapScopedWith");
var zipRight10 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, options4) => zipWith14(self2, that, (_, z2) => z2, options4));
var zipWith14 = /* @__PURE__ */ dual((args2) => isSink(args2[1]), (self2, that, f, options4) => options4?.concurrent ? raceWith3(self2, {
  other: that,
  onSelfDone: match9({
    onFailure: /* @__PURE__ */ __name((cause3) => Done3(failCause9(cause3)), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((leftZ) => Await(match9({
      onFailure: failCause9,
      onSuccess: /* @__PURE__ */ __name((rightZ) => succeed11(f(leftZ, rightZ)), "onSuccess")
    })), "onSuccess")
  }),
  onOtherDone: match9({
    onFailure: /* @__PURE__ */ __name((cause3) => Done3(failCause9(cause3)), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((rightZ) => Await(match9({
      onFailure: failCause9,
      onSuccess: /* @__PURE__ */ __name((leftZ) => succeed11(f(leftZ, rightZ)), "onSuccess")
    })), "onSuccess")
  })
}) : flatMap19(self2, (z) => map30(that, (z2) => f(z, z2))));
var count5 = /* @__PURE__ */ foldLeftChunks(0, (acc, chunk4) => acc + chunk4.length);
var mkString = /* @__PURE__ */ suspend9(() => {
  const strings3 = [];
  return pipe(foldLeftChunks(void 0, (_, elems) => map6(elems, (elem) => {
    strings3.push(String(elem));
  })), map30(() => strings3.join("")));
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/journal.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/entry.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/versioned.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Versioned = class {
  static {
    __name(this, "Versioned");
  }
  value;
  constructor(value6) {
    this.value = value6;
  }
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/entry.js
var make58 = /* @__PURE__ */ __name((ref2, isNew) => ({
  ref: ref2,
  isNew,
  isChanged: false,
  expected: ref2.versioned,
  newValue: ref2.versioned.value
}), "make");
var unsafeGet7 = /* @__PURE__ */ __name((self2) => {
  return self2.newValue;
}, "unsafeGet");
var unsafeSet = /* @__PURE__ */ __name((self2, value6) => {
  self2.isChanged = true;
  self2.newValue = value6;
}, "unsafeSet");
var commit = /* @__PURE__ */ __name((self2) => {
  self2.ref.versioned = new Versioned(self2.newValue);
}, "commit");
var copy3 = /* @__PURE__ */ __name((self2) => ({
  ref: self2.ref,
  isNew: self2.isNew,
  isChanged: self2.isChanged,
  expected: self2.expected,
  newValue: self2.newValue
}), "copy");
var isInvalid = /* @__PURE__ */ __name((self2) => {
  return self2.ref.versioned !== self2.expected;
}, "isInvalid");
var isChanged = /* @__PURE__ */ __name((self2) => {
  return self2.isChanged;
}, "isChanged");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = /* @__PURE__ */ __name((journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
}, "commitJournal");
var analyzeJournal = /* @__PURE__ */ __name((journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
}, "analyzeJournal");
var prepareResetJournal = /* @__PURE__ */ __name((journal) => {
  const saved = /* @__PURE__ */ new Map();
  for (const entry of journal) {
    saved.set(entry[0], copy3(entry[1]));
  }
  return () => {
    journal.clear();
    for (const entry of saved) {
      journal.set(entry[0], entry[1]);
    }
  };
}, "prepareResetJournal");
var collectTodos = /* @__PURE__ */ __name((journal) => {
  const allTodos = /* @__PURE__ */ new Map();
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = /* @__PURE__ */ new Map();
  }
  return allTodos;
}, "collectTodos");
var execTodos = /* @__PURE__ */ __name((todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
}, "execTodos");
var addTodo = /* @__PURE__ */ __name((txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
}, "addTodo");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/stmState.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
var isSTMState = /* @__PURE__ */ __name((u) => hasProperty(u, STMStateTypeId), "isSTMState");
var isRunning3 = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_RUNNING2;
}, "isRunning");
var isDone6 = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_DONE6;
}, "isDone");
var done9 = /* @__PURE__ */ __name((exit5) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit5,
    [symbol]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit5)), cached(this));
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit5, that.exit);
    }
  };
}, "done");
var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
var interrupted3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol]() {
    return interruptedHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol]() {
    return runningHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = /* @__PURE__ */ __name((tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done9(fail3(tExit.error));
    }
    case OP_DIE3: {
      return done9(die3(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done9(interrupt3(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done9(succeed3(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
}, "fromTExit");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/tExit.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
var variance7 = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E")
};
var isExit2 = /* @__PURE__ */ __name((u) => hasProperty(u, TExitTypeId), "isExit");
var isSuccess4 = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_SUCCEED3;
}, "isSuccess");
var isRetry = /* @__PURE__ */ __name((self2) => {
  return self2._tag === OP_RETRY2;
}, "isRetry");
var fail16 = /* @__PURE__ */ __name((error5) => ({
  [TExitTypeId]: variance7,
  _tag: OP_FAIL5,
  error: error5,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error5)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error5, that.error);
  }
}), "fail");
var die9 = /* @__PURE__ */ __name((defect) => ({
  [TExitTypeId]: variance7,
  _tag: OP_DIE3,
  defect,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
}), "die");
var interrupt8 = /* @__PURE__ */ __name((fiberId5) => ({
  [TExitTypeId]: variance7,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId5,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId5)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId5, that.fiberId);
  }
}), "interrupt");
var succeed17 = /* @__PURE__ */ __name((value6) => ({
  [TExitTypeId]: variance7,
  _tag: OP_SUCCEED3,
  value: value6,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value6)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value6, that.value);
  }
}), "succeed");
var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
var retry4 = {
  [TExitTypeId]: variance7,
  _tag: OP_RETRY2,
  [symbol]() {
    return retryHash;
  },
  [symbol2](that) {
    return isExit2(that) && isRetry(that);
  }
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/tryCommit.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var done10 = /* @__PURE__ */ __name((exit5) => {
  return {
    _tag: OP_DONE5,
    exit: exit5
  };
}, "done");
var suspend10 = /* @__PURE__ */ __name((journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
}, "suspend");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/txnId.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var txnCounter = {
  ref: 0
};
var make59 = /* @__PURE__ */ __name(() => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
}, "make");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
var stmVariance = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var STMPrimitive = class {
  static {
    __name(this, "STMPrimitive");
  }
  effect_instruction_i0;
  _op = OP_COMMIT;
  effect_instruction_i1 = void 0;
  effect_instruction_i2 = void 0;
  [EffectTypeId4];
  [StreamTypeId];
  [SinkTypeId3];
  [ChannelTypeId3];
  get [STMTypeId2]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId4] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId3] = stmVariance;
    this[ChannelTypeId3] = stmVariance;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSTM = /* @__PURE__ */ __name((u) => hasProperty(u, STMTypeId2), "isSTM");
var commit2 = /* @__PURE__ */ __name((self2) => unsafeAtomically(self2, constVoid, constVoid), "commit");
var unsafeAtomically = /* @__PURE__ */ __name((self2, onDone3, onInterrupt3) => withFiberRuntime((state2) => {
  const fiberId5 = state2.id();
  const env3 = state2.getFiberRef(currentContext2);
  const scheduler2 = state2.getFiberRef(currentScheduler2);
  const priority = state2.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId5, self2, env3, scheduler2, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone3(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make59();
      const state3 = {
        value: running3
      };
      const effect4 = async2((k) => tryCommitAsync(fiberId5, self2, txnId, state3, env3, scheduler2, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect4), catchAllCause3((cause3) => {
        let currentState = state3.value;
        if (isRunning3(currentState)) {
          state3.value = interrupted3;
        }
        currentState = state3.value;
        if (isDone6(currentState)) {
          onDone3(currentState.exit);
          return currentState.exit;
        }
        onInterrupt3();
        return failCause9(cause3);
      })));
    }
  }
}), "unsafeAtomically");
var tryCommit = /* @__PURE__ */ __name((fiberId5, stm, state2, env3, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId5, env3).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state2.value = fromTExit(tExit);
      return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      state2.value = fromTExit(tExit);
      const cause3 = fail5(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      state2.value = fromTExit(tExit);
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      state2.value = fromTExit(tExit);
      const cause3 = interrupt4(fiberId5);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend10(journal);
    }
  }
}, "tryCommit");
var tryCommitSync = /* @__PURE__ */ __name((fiberId5, stm, env3, scheduler2, priority) => {
  const journal = /* @__PURE__ */ new Map();
  const tExit = new STMDriver(stm, journal, fiberId5, env3).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed3(tExit.value), journal, scheduler2, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail5(tExit.error);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_DIE3: {
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt4(fiberId5);
      return completeTodos(failCause3(cause3), journal, scheduler2, priority);
    }
    case OP_RETRY2: {
      return suspend10(journal);
    }
  }
}, "tryCommitSync");
var tryCommitAsync = /* @__PURE__ */ __name((fiberId5, self2, txnId, state2, context17, scheduler2, priority, k) => {
  if (isRunning3(state2.value)) {
    const result = tryCommit(fiberId5, self2, state2, context17, scheduler2, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId5, self2, txnId, state2, context17, scheduler2, priority, k));
        break;
      }
    }
  }
}, "tryCommitAsync");
var completeTodos = /* @__PURE__ */ __name((exit5, journal, scheduler2, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler2.scheduleTask(() => execTodos(todos), priority);
  }
  return done10(exit5);
}, "completeTodos");
var completeTryCommit = /* @__PURE__ */ __name((exit5, k) => {
  k(exit5);
}, "completeTryCommit");
var context7 = /* @__PURE__ */ __name(() => effect3((_, __, env3) => env3), "context");
var contextWith3 = /* @__PURE__ */ __name((f) => map31(context7(), f), "contextWith");
var contextWithSTM = /* @__PURE__ */ __name((f) => flatMap20(context7(), f), "contextWithSTM");
var STMDriver = class {
  static {
    __name(this, "STMDriver");
  }
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self2, journal, fiberId5, r0) {
    this.self = self2;
    this.journal = journal;
    this.fiberId = fiberId5;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextFailure() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current2 = this.popStack();
    }
    return current2;
  }
  nextRetry() {
    let current2 = this.popStack();
    while (current2 !== void 0 && current2.effect_instruction_i0 !== OP_ON_RETRY) {
      current2 = this.popStack();
    }
    return current2;
  }
  run() {
    let curr = this.self;
    let exit5 = void 0;
    while (exit5 === void 0 && curr !== void 0) {
      try {
        const current2 = curr;
        if (current2) {
          switch (current2._op) {
            case "Tag": {
              curr = effect3((_, __, env3) => unsafeGet5(env3, current2));
              break;
            }
            case "Left": {
              curr = fail17(current2.left);
              break;
            }
            case "None": {
              curr = fail17(new NoSuchElementException2());
              break;
            }
            case "Right": {
              curr = succeed18(current2.right);
              break;
            }
            case "Some": {
              curr = succeed18(current2.value);
              break;
            }
            case "Commit": {
              switch (current2.effect_instruction_i0) {
                case OP_DIE2: {
                  exit5 = die9(internalCall(() => current2.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === void 0) {
                    exit5 = fail16(internalCall(() => current2.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current2.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === void 0) {
                    exit5 = retry4;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit5 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current2.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current2);
                  curr = current2.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env3 = this.env;
                  this.env = internalCall(() => current2.effect_instruction_i2(env3));
                  curr = pipe(current2.effect_instruction_i1, ensuring6(sync12(() => this.env = env3)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value6 = current2.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit5 = succeed17(value6);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value6));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value6 = internalCall(() => current2.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === void 0) {
                    exit5 = succeed17(value6);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value6));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die10(e);
      }
    }
    return exit5;
  }
};
var catchAll6 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var mapInputContext5 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_PROVIDE3);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var die10 = /* @__PURE__ */ __name((defect) => dieSync6(() => defect), "die");
var dieMessage3 = /* @__PURE__ */ __name((message) => dieSync6(() => new RuntimeException2(message)), "dieMessage");
var dieSync6 = /* @__PURE__ */ __name((evaluate3) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
}, "dieSync");
var effect3 = /* @__PURE__ */ __name((f) => withSTMRuntime((_) => succeed18(f(_.journal, _.fiberId, _.getEnv()))), "effect");
var ensuring6 = /* @__PURE__ */ dual(2, (self2, finalizer3) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name((e) => zipRight11(finalizer3, fail17(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => zipRight11(finalizer3, succeed18(a)), "onSuccess")
}));
var fail17 = /* @__PURE__ */ __name((error5) => failSync7(() => error5), "fail");
var failSync7 = /* @__PURE__ */ __name((evaluate3) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
}, "failSync");
var flatMap20 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var matchSTM = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => pipe(self2, map31(right2), catchAll6((e) => pipe(onFailure(e), map31(left2))), flatMap20((either12) => {
  switch (either12._tag) {
    case "Left": {
      return succeed18(either12.left);
    }
    case "Right": {
      return onSuccess(either12.right);
    }
  }
})));
var withSTMRuntime = /* @__PURE__ */ __name((f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
}, "withSTMRuntime");
var interrupt9 = /* @__PURE__ */ withSTMRuntime((_) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = _.fiberId;
  return stm;
});
var interruptAs2 = /* @__PURE__ */ __name((fiberId5) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId5;
  return stm;
}, "interruptAs");
var map31 = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, flatMap20((a) => sync12(() => f(a)))));
var orTry = /* @__PURE__ */ dual(2, (self2, that) => {
  const stm = new STMPrimitive(OP_ON_RETRY);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = that;
  return stm;
});
var retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
var succeed18 = /* @__PURE__ */ __name((value6) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value6;
  return stm;
}, "succeed");
var sync12 = /* @__PURE__ */ __name((evaluate3) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate3;
  return stm;
}, "sync");
var zip11 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith15(that, (a, a1) => [a, a1])));
var zipLeft10 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap20((a) => pipe(that, map31(() => a)))));
var zipRight11 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap20(() => that)));
var zipWith15 = /* @__PURE__ */ dual(3, (self2, that, f) => pipe(self2, flatMap20((a) => pipe(that, map31((b) => f(a, b))))));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/stm.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var acquireUseRelease4 = /* @__PURE__ */ dual(3, (acquire, use3, release2) => uninterruptibleMask3((restore) => {
  let state2 = running3;
  return pipe(restore(unsafeAtomically(acquire, (exit5) => {
    state2 = done9(exit5);
  }, () => {
    state2 = interrupted3;
  })), matchCauseEffect3({
    onFailure: /* @__PURE__ */ __name((cause3) => {
      if (isDone6(state2) && isSuccess2(state2.exit)) {
        return pipe(release2(state2.exit.value), matchCauseEffect3({
          onFailure: /* @__PURE__ */ __name((cause22) => failCause9(parallel4(cause3, cause22)), "onFailure"),
          onSuccess: /* @__PURE__ */ __name(() => failCause9(cause3), "onSuccess")
        }));
      }
      return failCause9(cause3);
    }, "onFailure"),
    onSuccess: /* @__PURE__ */ __name((a) => pipe(restore(use3(a)), matchCauseEffect3({
      onFailure: /* @__PURE__ */ __name((cause3) => pipe(release2(a), matchCauseEffect3({
        onFailure: /* @__PURE__ */ __name((cause22) => failCause9(parallel4(cause3, cause22)), "onFailure"),
        onSuccess: /* @__PURE__ */ __name(() => failCause9(cause3), "onSuccess")
      })), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((a2) => pipe(release2(a), as8(a2)), "onSuccess")
    })), "onSuccess")
  }));
}));
var as11 = /* @__PURE__ */ dual(2, (self2, value6) => pipe(self2, map31(() => value6)));
var asSome3 = /* @__PURE__ */ __name((self2) => pipe(self2, map31(some3)), "asSome");
var asSomeError3 = /* @__PURE__ */ __name((self2) => pipe(self2, mapError8(some3)), "asSomeError");
var asVoid7 = /* @__PURE__ */ __name((self2) => pipe(self2, map31(constVoid)), "asVoid");
var attempt = /* @__PURE__ */ __name((evaluate3) => suspend11(() => {
  try {
    return succeed18(evaluate3());
  } catch (defect) {
    return fail17(defect);
  }
}), "attempt");
var bind7 = /* @__PURE__ */ dual(3, (self2, tag8, f) => flatMap20(self2, (k) => map31(f(k), (a) => ({
  ...k,
  [tag8]: a
}))));
var bindTo7 = /* @__PURE__ */ dual(2, (self2, tag8) => map31(self2, (a) => ({
  [tag8]: a
})));
var let_7 = /* @__PURE__ */ dual(3, (self2, tag8, f) => map31(self2, (k) => ({
  ...k,
  [tag8]: f(k)
})));
var catchSome3 = /* @__PURE__ */ dual(2, (self2, pf) => catchAll6(self2, (e) => getOrElse2(pf(e), () => fail17(e))));
var catchTag3 = /* @__PURE__ */ dual(3, (self2, k, f) => catchAll6(self2, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail17(e);
}));
var catchTags3 = /* @__PURE__ */ dual(2, (self2, cases) => catchAll6(self2, (e) => {
  const keys6 = Object.keys(cases);
  if ("_tag" in e && keys6.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail17(e);
}));
var check4 = /* @__PURE__ */ __name((predicate) => suspend11(() => predicate() ? void_9 : retry5), "check");
var collect2 = /* @__PURE__ */ dual(2, (self2, pf) => collectSTM(self2, (a) => map2(pf(a), succeed18)));
var collectSTM = /* @__PURE__ */ dual(2, (self2, pf) => matchSTM(self2, {
  onFailure: fail17,
  onSuccess: /* @__PURE__ */ __name((a) => {
    const option9 = pf(a);
    return isSome2(option9) ? option9.value : retry5;
  }, "onSuccess")
}));
var commitEither = /* @__PURE__ */ __name((self2) => flatten10(commit2(either6(self2))), "commitEither");
var cond = /* @__PURE__ */ __name((predicate, error5, result) => {
  return suspend11(() => predicate() ? sync12(result) : failSync7(error5));
}, "cond");
var either6 = /* @__PURE__ */ __name((self2) => match21(self2, {
  onFailure: left2,
  onSuccess: right2
}), "either");
var eventually3 = /* @__PURE__ */ __name((self2) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name(() => eventually3(self2), "onFailure"),
  onSuccess: succeed18
}), "eventually");
var every11 = /* @__PURE__ */ dual(2, (iterable, predicate) => flatMap20(sync12(() => iterable[Symbol.iterator]()), (iterator) => {
  const loop5 = suspend11(() => {
    const next4 = iterator.next();
    if (next4.done) {
      return succeed18(true);
    }
    return pipe(predicate(next4.value), flatMap20((bool) => bool ? loop5 : succeed18(bool)));
  });
  return loop5;
}));
var exists5 = /* @__PURE__ */ dual(2, (iterable, predicate) => flatMap20(sync12(() => iterable[Symbol.iterator]()), (iterator) => {
  const loop5 = suspend11(() => {
    const next4 = iterator.next();
    if (next4.done) {
      return succeed18(false);
    }
    return flatMap20(predicate(next4.value), (bool) => bool ? succeed18(bool) : loop5);
  });
  return loop5;
}));
var fiberId3 = /* @__PURE__ */ effect3((_, fiberId5) => fiberId5);
var filter14 = /* @__PURE__ */ dual(2, (iterable, predicate) => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith15(predicate(curr), (as16, p) => {
  if (p) {
    as16.push(curr);
    return as16;
  }
  return as16;
})), succeed18([])));
var filterNot = /* @__PURE__ */ dual(2, (iterable, predicate) => filter14(iterable, (a) => negate3(predicate(a))));
var filterOrDie3 = /* @__PURE__ */ dual(3, (self2, predicate, defect) => filterOrElse3(self2, predicate, () => dieSync6(defect)));
var filterOrDieMessage3 = /* @__PURE__ */ dual(3, (self2, predicate, message) => filterOrElse3(self2, predicate, () => dieMessage3(message)));
var filterOrElse3 = /* @__PURE__ */ dual(3, (self2, predicate, orElse19) => flatMap20(self2, (a) => predicate(a) ? succeed18(a) : orElse19(a)));
var filterOrFail3 = /* @__PURE__ */ dual(3, (self2, predicate, orFailWith) => filterOrElse3(self2, predicate, (a) => failSync7(() => orFailWith(a))));
var flatten14 = /* @__PURE__ */ __name((self2) => flatMap20(self2, identity), "flatten");
var flip4 = /* @__PURE__ */ __name((self2) => matchSTM(self2, {
  onFailure: succeed18,
  onSuccess: fail17
}), "flip");
var flipWith3 = /* @__PURE__ */ dual(2, (self2, f) => flip4(f(flip4(self2))));
var match21 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name((e) => succeed18(onFailure(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed18(onSuccess(a)), "onSuccess")
}));
var forEach13 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options4) => {
  if (options4?.discard) {
    return pipe(sync12(() => iterable[Symbol.iterator]()), flatMap20((iterator) => {
      const loop5 = suspend11(() => {
        const next4 = iterator.next();
        if (next4.done) {
          return void_9;
        }
        return pipe(f(next4.value), flatMap20(() => loop5));
      });
      return loop5;
    }));
  }
  return suspend11(() => fromIterable2(iterable).reduce((acc, curr) => zipWith15(acc, f(curr), (array7, elem) => {
    array7.push(elem);
    return array7;
  }), succeed18([])));
});
var fromEither2 = /* @__PURE__ */ __name((either12) => {
  switch (either12._tag) {
    case "Left": {
      return fail17(either12.left);
    }
    case "Right": {
      return succeed18(either12.right);
    }
  }
}, "fromEither");
var fromOption6 = /* @__PURE__ */ __name((option9) => match2(option9, {
  onNone: /* @__PURE__ */ __name(() => fail17(none2()), "onNone"),
  onSome: succeed18
}), "fromOption");
var gen6 = /* @__PURE__ */ __name((...args2) => suspend11(() => {
  const f = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
  const iterator = f(pipe);
  const state2 = iterator.next();
  const run10 = /* @__PURE__ */ __name((state3) => state3.done ? succeed18(state3.value) : flatMap20(yieldWrapGet(state3.value), (val) => run10(iterator.next(val))), "run");
  return run10(state2);
}), "gen");
var head8 = /* @__PURE__ */ __name((self2) => pipe(self2, matchSTM({
  onFailure: /* @__PURE__ */ __name((e) => fail17(some3(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => {
    const i = a[Symbol.iterator]();
    const res = i.next();
    if (res.done) {
      return fail17(none2());
    } else {
      return succeed18(res.value);
    }
  }, "onSuccess")
})), "head");
var if_3 = /* @__PURE__ */ dual((args2) => typeof args2[0] === "boolean" || isSTM(args2[0]), (self2, {
  onFalse,
  onTrue
}) => {
  if (typeof self2 === "boolean") {
    return self2 ? onTrue : onFalse;
  }
  return flatMap20(self2, (bool) => bool ? onTrue : onFalse);
});
var ignore3 = /* @__PURE__ */ __name((self2) => match21(self2, {
  onFailure: /* @__PURE__ */ __name(() => void_9, "onFailure"),
  onSuccess: /* @__PURE__ */ __name(() => void_9, "onSuccess")
}), "ignore");
var isFailure6 = /* @__PURE__ */ __name((self2) => match21(self2, {
  onFailure: constTrue,
  onSuccess: constFalse
}), "isFailure");
var isSuccess5 = /* @__PURE__ */ __name((self2) => match21(self2, {
  onFailure: constFalse,
  onSuccess: constTrue
}), "isSuccess");
var iterate3 = /* @__PURE__ */ __name((initial, options4) => iterateLoop(initial, options4.while, options4.body), "iterate");
var iterateLoop = /* @__PURE__ */ __name((initial, cont, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap20((z) => iterateLoop(z, cont, body)));
  }
  return succeed18(initial);
}, "iterateLoop");
var loop3 = /* @__PURE__ */ __name((initial, options4) => options4.discard ? loopDiscardLoop(initial, options4.while, options4.step, options4.body) : map31(loopLoop(initial, options4.while, options4.step, options4.body), (a) => Array.from(a)), "loop");
var loopLoop = /* @__PURE__ */ __name((initial, cont, inc, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap20((a) => pipe(loopLoop(inc(initial), cont, inc, body), map31(append2(a)))));
  }
  return succeed18(empty4());
}, "loopLoop");
var loopDiscardLoop = /* @__PURE__ */ __name((initial, cont, inc, body) => {
  if (cont(initial)) {
    return pipe(body(initial), flatMap20(() => loopDiscardLoop(inc(initial), cont, inc, body)));
  }
  return void_9;
}, "loopDiscardLoop");
var mapAttempt2 = /* @__PURE__ */ dual(2, (self2, f) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name((e) => fail17(e), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => attempt(() => f(a)), "onSuccess")
}));
var mapBoth8 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name((e) => fail17(onFailure(e)), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => succeed18(onSuccess(a)), "onSuccess")
}));
var mapError8 = /* @__PURE__ */ dual(2, (self2, f) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name((e) => fail17(f(e)), "onFailure"),
  onSuccess: succeed18
}));
var merge10 = /* @__PURE__ */ __name((self2) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name((e) => succeed18(e), "onFailure"),
  onSuccess: succeed18
}), "merge");
var mergeAll8 = /* @__PURE__ */ dual(3, (iterable, zero3, f) => suspend11(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith15(curr, f)), succeed18(zero3))));
var negate3 = /* @__PURE__ */ __name((self2) => pipe(self2, map31((b) => !b)), "negate");
var none10 = /* @__PURE__ */ __name((self2) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name((e) => fail17(some3(e)), "onFailure"),
  onSuccess: match2({
    onNone: /* @__PURE__ */ __name(() => void_9, "onNone"),
    onSome: /* @__PURE__ */ __name(() => fail17(none2()), "onSome")
  })
}), "none");
var option5 = /* @__PURE__ */ __name((self2) => match21(self2, {
  onFailure: /* @__PURE__ */ __name(() => none2(), "onFailure"),
  onSuccess: some3
}), "option");
var orDie5 = /* @__PURE__ */ __name((self2) => pipe(self2, orDieWith4(identity)), "orDie");
var orDieWith4 = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapError8(f), catchAll6(die10)));
var orElse12 = /* @__PURE__ */ dual(2, (self2, that) => flatMap20(effect3((journal) => prepareResetJournal(journal)), (reset2) => pipe(orTry(self2, () => flatMap20(sync12(reset2), that)), catchAll6(() => flatMap20(sync12(reset2), that)))));
var orElseEither5 = /* @__PURE__ */ dual(2, (self2, that) => orElse12(map31(self2, left2), () => map31(that(), right2)));
var orElseFail3 = /* @__PURE__ */ dual(2, (self2, error5) => orElse12(self2, () => failSync7(error5)));
var orElseOptional = /* @__PURE__ */ dual(2, (self2, that) => catchAll6(self2, match2({
  onNone: that,
  onSome: /* @__PURE__ */ __name((e) => fail17(some3(e)), "onSome")
})));
var orElseSucceed3 = /* @__PURE__ */ dual(2, (self2, value6) => orElse12(self2, () => sync12(value6)));
var provideContext6 = /* @__PURE__ */ dual(2, (self2, env3) => mapInputContext5(self2, (_) => env3));
var provideSomeContext2 = /* @__PURE__ */ dual(2, (self2, context17) => mapInputContext5(self2, (parent) => merge3(parent, context17)));
var provideService7 = /* @__PURE__ */ dual(3, (self2, tag8, resource) => provideServiceSTM(self2, tag8, succeed18(resource)));
var provideServiceSTM = /* @__PURE__ */ dual(3, (self2, tag8, stm) => contextWithSTM((env3) => flatMap20(stm, (service3) => provideContext6(self2, add4(env3, tag8, service3)))));
var reduce15 = /* @__PURE__ */ dual(3, (iterable, zero3, f) => suspend11(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, flatMap20((s) => f(s, curr))), succeed18(zero3))));
var reduceAll = /* @__PURE__ */ dual(3, (iterable, initial, f) => suspend11(() => Array.from(iterable).reduce((acc, curr) => pipe(acc, zipWith15(curr, f)), initial)));
var reduceRight5 = /* @__PURE__ */ dual(3, (iterable, zero3, f) => suspend11(() => Array.from(iterable).reduceRight((acc, curr) => pipe(acc, flatMap20((s) => f(s, curr))), succeed18(zero3))));
var refineOrDie = /* @__PURE__ */ dual(2, (self2, pf) => refineOrDieWith(self2, pf, identity));
var refineOrDieWith = /* @__PURE__ */ dual(3, (self2, pf, f) => catchAll6(self2, (e) => match2(pf(e), {
  onNone: /* @__PURE__ */ __name(() => die10(f(e)), "onNone"),
  onSome: fail17
})));
var reject = /* @__PURE__ */ dual(2, (self2, pf) => rejectSTM(self2, (a) => map2(pf(a), fail17)));
var rejectSTM = /* @__PURE__ */ dual(2, (self2, pf) => flatMap20(self2, (a) => match2(pf(a), {
  onNone: /* @__PURE__ */ __name(() => succeed18(a), "onNone"),
  onSome: flatMap20(fail17)
})));
var repeatUntil = /* @__PURE__ */ dual(2, (self2, predicate) => repeatUntilLoop(self2, predicate));
var repeatUntilLoop = /* @__PURE__ */ __name((self2, predicate) => flatMap20(self2, (a) => predicate(a) ? succeed18(a) : repeatUntilLoop(self2, predicate)), "repeatUntilLoop");
var repeatWhile = /* @__PURE__ */ dual(2, (self2, predicate) => repeatWhileLoop(self2, predicate));
var repeatWhileLoop = /* @__PURE__ */ __name((self2, predicate) => flatMap20(self2, (a) => predicate(a) ? repeatWhileLoop(self2, predicate) : succeed18(a)), "repeatWhileLoop");
var replicate4 = /* @__PURE__ */ dual(2, (self2, n) => Array.from({
  length: n
}, () => self2));
var replicateSTM = /* @__PURE__ */ dual(2, (self2, n) => all10(replicate4(self2, n)));
var replicateSTMDiscard = /* @__PURE__ */ dual(2, (self2, n) => all10(replicate4(self2, n), {
  discard: true
}));
var retryUntil = /* @__PURE__ */ dual(2, (self2, predicate) => matchSTM(self2, {
  onFailure: fail17,
  onSuccess: /* @__PURE__ */ __name((a) => predicate(a) ? succeed18(a) : retry5, "onSuccess")
}));
var retryWhile = /* @__PURE__ */ dual(2, (self2, predicate) => matchSTM(self2, {
  onFailure: fail17,
  onSuccess: /* @__PURE__ */ __name((a) => !predicate(a) ? succeed18(a) : retry5, "onSuccess")
}));
var partition7 = /* @__PURE__ */ dual(2, (elements, f) => pipe(forEach13(elements, (a) => either6(f(a))), map31((as16) => partitionMap4(as16, identity))));
var some10 = /* @__PURE__ */ __name((self2) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name((e) => fail17(some3(e)), "onFailure"),
  onSuccess: match2({
    onNone: /* @__PURE__ */ __name(() => fail17(none2()), "onNone"),
    onSome: succeed18
  })
}), "some");
var all10 = /* @__PURE__ */ __name((input, options4) => {
  if (Symbol.iterator in input) {
    return forEach13(input, identity, options4);
  } else if (options4?.discard) {
    return forEach13(Object.values(input), identity, options4);
  }
  return map31(forEach13(Object.entries(input), ([_, e]) => map31(e, (a) => [_, a])), (values6) => {
    const res = {};
    for (const [k, v] of values6) {
      ;
      res[k] = v;
    }
    return res;
  });
}, "all");
var succeedNone3 = /* @__PURE__ */ succeed18(/* @__PURE__ */ none2());
var succeedSome3 = /* @__PURE__ */ __name((value6) => succeed18(some3(value6)), "succeedSome");
var summarized3 = /* @__PURE__ */ dual(3, (self2, summary6, f) => flatMap20(summary6, (start3) => flatMap20(self2, (value6) => map31(summary6, (end6) => [f(start3, end6), value6]))));
var suspend11 = /* @__PURE__ */ __name((evaluate3) => flatten14(sync12(evaluate3)), "suspend");
var tap6 = /* @__PURE__ */ dual(2, (self2, f) => flatMap20(self2, (a) => as11(f(a), a)));
var tapBoth3 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name((e) => pipe(onFailure(e), zipRight11(fail17(e))), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((a) => pipe(onSuccess(a), as11(a)), "onSuccess")
}));
var tapError5 = /* @__PURE__ */ dual(2, (self2, f) => matchSTM(self2, {
  onFailure: /* @__PURE__ */ __name((e) => zipRight11(f(e), fail17(e)), "onFailure"),
  onSuccess: succeed18
}));
var try_4 = /* @__PURE__ */ __name((arg) => {
  const evaluate3 = typeof arg === "function" ? arg : arg.try;
  return suspend11(() => {
    try {
      return succeed18(evaluate3());
    } catch (error5) {
      return fail17("catch" in arg ? arg.catch(error5) : error5);
    }
  });
}, "try_");
var void_9 = /* @__PURE__ */ succeed18(void 0);
var unless3 = /* @__PURE__ */ dual(2, (self2, predicate) => suspend11(() => predicate() ? succeedNone3 : asSome3(self2)));
var unlessSTM = /* @__PURE__ */ dual(2, (self2, predicate) => flatMap20(predicate, (bool) => bool ? succeedNone3 : asSome3(self2)));
var unsome = /* @__PURE__ */ __name((self2) => matchSTM(self2, {
  onFailure: match2({
    onNone: /* @__PURE__ */ __name(() => succeed18(none2()), "onNone"),
    onSome: fail17
  }),
  onSuccess: /* @__PURE__ */ __name((a) => succeed18(some3(a)), "onSuccess")
}), "unsome");
var validateAll3 = /* @__PURE__ */ dual(2, (elements, f) => flatMap20(partition7(elements, f), ([errors4, values6]) => isNonEmptyArray2(errors4) ? fail17(errors4) : succeed18(values6)));
var validateFirst3 = /* @__PURE__ */ dual(2, (elements, f) => flip4(forEach13(elements, (a) => flip4(f(a)))));
var when3 = /* @__PURE__ */ dual(2, (self2, predicate) => suspend11(() => predicate() ? asSome3(self2) : succeedNone3));
var whenSTM = /* @__PURE__ */ dual(2, (self2, predicate) => flatMap20(predicate, (bool) => bool ? asSome3(self2) : succeedNone3));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/tQueue.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/tRef.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
var tRefVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var TRefImpl = class {
  static {
    __name(this, "TRefImpl");
  }
  [TRefTypeId] = tRefVariance;
  /** @internal */
  todos;
  /** @internal */
  versioned;
  constructor(value6) {
    this.versioned = new Versioned(value6);
    this.todos = /* @__PURE__ */ new Map();
  }
  modify(f) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(unsafeGet7(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make60 = /* @__PURE__ */ __name((value6) => effect3((journal) => {
  const ref2 = new TRefImpl(value6);
  journal.set(ref2, make58(ref2, true));
  return ref2;
}), "make");
var get18 = /* @__PURE__ */ __name((self2) => self2.modify((a) => [a, a]), "get");
var set11 = /* @__PURE__ */ dual(2, (self2, value6) => self2.modify(() => [void 0, value6]));
var getAndSet4 = /* @__PURE__ */ dual(2, (self2, value6) => self2.modify((a) => [a, value6]));
var getAndUpdate4 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [a, f(a)]));
var getAndUpdateSome4 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => match2(f(a), {
  onNone: /* @__PURE__ */ __name(() => [a, a], "onNone"),
  onSome: /* @__PURE__ */ __name((b) => [a, b], "onSome")
})));
var setAndGet3 = /* @__PURE__ */ dual(2, (self2, value6) => self2.modify(() => [value6, value6]));
var modify8 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
var modifySome4 = /* @__PURE__ */ dual(3, (self2, fallback, f) => self2.modify((a) => match2(f(a), {
  onNone: /* @__PURE__ */ __name(() => [fallback, a], "onNone"),
  onSome: /* @__PURE__ */ __name((b) => b, "onSome")
})));
var update6 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [void 0, f(a)]));
var updateAndGet4 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => {
  const b = f(a);
  return [b, b];
}));
var updateSome4 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [void 0, match2(f(a), {
  onNone: /* @__PURE__ */ __name(() => a, "onNone"),
  onSome: /* @__PURE__ */ __name((b) => b, "onSome")
})]));
var updateSomeAndGet4 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => match2(f(a), {
  onNone: /* @__PURE__ */ __name(() => [a, a], "onNone"),
  onSome: /* @__PURE__ */ __name((b) => [b, b], "onSome")
})));
var getOrMakeEntry = /* @__PURE__ */ __name((self2, journal) => {
  if (journal.has(self2)) {
    return journal.get(self2);
  }
  const entry = make58(self2, false);
  journal.set(self2, entry);
  return entry;
}, "getOrMakeEntry");
var unsafeGet8 = /* @__PURE__ */ dual(2, (self2, journal) => unsafeGet7(getOrMakeEntry(self2, journal)));
var unsafeSet2 = /* @__PURE__ */ dual(3, (self2, value6, journal) => {
  const entry = getOrMakeEntry(self2, journal);
  unsafeSet(entry, value6);
  return void 0;
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
var BackPressure2 = {
  _tag: OP_BACKPRESSURE_STRATEGY
};
var Dropping = {
  _tag: OP_DROPPING_STRATEGY
};
var Sliding = {
  _tag: OP_SLIDING_STRATEGY
};
var tDequeueVariance = {
  /* c8 ignore next */
  _Out: /* @__PURE__ */ __name((_) => _, "_Out")
};
var tEnqueueVariance = {
  /* c8 ignore next */
  _In: /* @__PURE__ */ __name((_) => _, "_In")
};
var TQueueImpl = class {
  static {
    __name(this, "TQueueImpl");
  }
  ref;
  requestedCapacity;
  strategy;
  [TDequeueTypeId] = tDequeueVariance;
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(ref2, requestedCapacity, strategy) {
    this.ref = ref2;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    const queue = unsafeGet8(this.ref, runtime8.journal);
    if (queue === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    return succeed18(queue.length);
  });
  isFull = /* @__PURE__ */ map31(this.size, (size22) => size22 === this.requestedCapacity);
  isEmpty = /* @__PURE__ */ map31(this.size, (size22) => size22 === 0);
  shutdown = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    unsafeSet2(this.ref, void 0, runtime8.journal);
    return void_9;
  });
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const queue = unsafeGet8(this.ref, journal);
    return queue === void 0;
  });
  awaitShutdown = /* @__PURE__ */ flatMap20(this.isShutdown, (isShutdown8) => isShutdown8 ? void_9 : retry5);
  offer(value6) {
    return withSTMRuntime((runtime8) => {
      const queue = pipe(this.ref, unsafeGet8(runtime8.journal));
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value6);
        unsafeSet2(this.ref, queue, runtime8.journal);
        return succeed18(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed18(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed18(true);
          }
          queue.shift();
          queue.push(value6);
          unsafeSet2(this.ref, queue, runtime8.journal);
          return succeed18(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime8) => {
      const as16 = Array.from(iterable);
      const queue = unsafeGet8(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      if (queue.length + as16.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as16], runtime8.journal);
        return succeed18(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as16.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime8.journal);
          return succeed18(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as16.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime8.journal);
          return succeed18(true);
        }
      }
    });
  }
  peek = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    const queue = unsafeGet8(this.ref, runtime8.journal);
    if (queue === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    if (queue.length === 0) {
      return retry5;
    }
    return succeed18(queue[0]);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    const queue = unsafeGet8(this.ref, runtime8.journal);
    if (queue === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    return succeed18(fromNullable2(queue[0]));
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    const queue = unsafeGet8(this.ref, runtime8.journal);
    if (queue === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    if (queue.length === 0) {
      return retry5;
    }
    const dequeued = queue.shift();
    unsafeSet2(this.ref, queue, runtime8.journal);
    return succeed18(dequeued);
  });
  takeAll = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    const queue = unsafeGet8(this.ref, runtime8.journal);
    if (queue === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    unsafeSet2(this.ref, [], runtime8.journal);
    return succeed18(queue);
  });
  takeUpTo(max9) {
    return withSTMRuntime((runtime8) => {
      const queue = unsafeGet8(this.ref, runtime8.journal);
      if (queue === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max9);
      unsafeSet2(this.ref, Array.from(remaining), runtime8.journal);
      return succeed18(Array.from(toTake));
    });
  }
};
var isTQueue = /* @__PURE__ */ __name((u) => {
  return isTEnqueue(u) && isTDequeue(u);
}, "isTQueue");
var isTEnqueue = /* @__PURE__ */ __name((u) => hasProperty(u, TEnqueueTypeId), "isTEnqueue");
var isTDequeue = /* @__PURE__ */ __name((u) => hasProperty(u, TDequeueTypeId), "isTDequeue");
var awaitShutdown5 = /* @__PURE__ */ __name((self2) => self2.awaitShutdown, "awaitShutdown");
var bounded6 = /* @__PURE__ */ __name((requestedCapacity) => makeQueue(requestedCapacity, BackPressure2), "bounded");
var capacity6 = /* @__PURE__ */ __name((self2) => {
  return self2.capacity();
}, "capacity");
var dropping5 = /* @__PURE__ */ __name((requestedCapacity) => makeQueue(requestedCapacity, Dropping), "dropping");
var isEmpty15 = /* @__PURE__ */ __name((self2) => self2.isEmpty, "isEmpty");
var isFull5 = /* @__PURE__ */ __name((self2) => self2.isFull, "isFull");
var isShutdown5 = /* @__PURE__ */ __name((self2) => self2.isShutdown, "isShutdown");
var offer4 = /* @__PURE__ */ dual(2, (self2, value6) => self2.offer(value6));
var offerAll4 = /* @__PURE__ */ dual(2, (self2, iterable) => self2.offerAll(iterable));
var peek = /* @__PURE__ */ __name((self2) => self2.peek, "peek");
var peekOption = /* @__PURE__ */ __name((self2) => self2.peekOption, "peekOption");
var poll7 = /* @__PURE__ */ __name((self2) => pipe(self2.takeUpTo(1), map31(head2)), "poll");
var seek = /* @__PURE__ */ dual(2, (self2, predicate) => seekLoop(self2, predicate));
var seekLoop = /* @__PURE__ */ __name((self2, predicate) => flatMap20(self2.take, (a) => predicate(a) ? succeed18(a) : seekLoop(self2, predicate)), "seekLoop");
var shutdown5 = /* @__PURE__ */ __name((self2) => self2.shutdown, "shutdown");
var size17 = /* @__PURE__ */ __name((self2) => self2.size, "size");
var sliding5 = /* @__PURE__ */ __name((requestedCapacity) => makeQueue(requestedCapacity, Sliding), "sliding");
var take5 = /* @__PURE__ */ __name((self2) => self2.take, "take");
var takeAll3 = /* @__PURE__ */ __name((self2) => self2.takeAll, "takeAll");
var takeBetween3 = /* @__PURE__ */ dual(3, (self2, min6, max9) => suspend11(() => {
  const takeRemainder = /* @__PURE__ */ __name((min7, max10, acc) => {
    if (max10 < min7) {
      return succeed18(acc);
    }
    return pipe(self2.takeUpTo(max10), flatMap20((taken) => {
      const remaining = min7 - taken.length;
      if (remaining === 1) {
        return pipe(self2.take, map31((a) => pipe(acc, appendAll2(unsafeFromArray(taken)), append2(a))));
      }
      if (remaining > 1) {
        return pipe(self2.take, flatMap20((a) => takeRemainder(remaining - 1, max10 - taken.length - 1, pipe(acc, appendAll2(unsafeFromArray(taken)), append2(a)))));
      }
      return succeed18(pipe(acc, appendAll2(unsafeFromArray(taken))));
    }));
  }, "takeRemainder");
  return map31(takeRemainder(min6, max9, empty4()), (c) => Array.from(c));
}));
var takeN3 = /* @__PURE__ */ dual(2, (self2, n) => pipe(self2, takeBetween3(n, n)));
var takeUpTo3 = /* @__PURE__ */ dual(2, (self2, max9) => self2.takeUpTo(max9));
var unbounded6 = /* @__PURE__ */ __name(() => makeQueue(Number.MAX_SAFE_INTEGER, Dropping), "unbounded");
var makeQueue = /* @__PURE__ */ __name((requestedCapacity, strategy) => map31(make60([]), (ref2) => new TQueueImpl(ref2, requestedCapacity, strategy)), "makeQueue");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = /* @__PURE__ */ __name((head13, subscribers, tail3) => ({
  head: head13,
  subscribers,
  tail: tail3
}), "makeNode");
var TPubSubImpl = class {
  static {
    __name(this, "TPubSubImpl");
  }
  pubsubSize;
  publisherHead;
  publisherTail;
  requestedCapacity;
  strategy;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = {
    _A: /* @__PURE__ */ __name((_) => _, "_A")
  };
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    return currentPublisherTail === void 0;
  });
  awaitShutdown = /* @__PURE__ */ flatMap20(this.isShutdown, (isShutdown8) => isShutdown8 ? void_9 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, runtime8.journal);
    if (currentPublisherTail === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    return succeed18(unsafeGet8(this.pubsubSize, runtime8.journal));
  });
  isEmpty = /* @__PURE__ */ map31(this.size, (size22) => size22 === 0);
  isFull = /* @__PURE__ */ map31(this.size, (size22) => size22 === this.capacity());
  offer(value6) {
    return withSTMRuntime((runtime8) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, runtime8.journal);
      if (currentPublisherTail === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, runtime8.journal);
      if (currentSubscriberCount === 0) {
        return succeed18(true);
      }
      const currentPubSubSize = unsafeGet8(this.pubsubSize, runtime8.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(void 0);
        const updatedNode = makeNode2(value6, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime8.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime8.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime8.journal);
        return succeed18(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed18(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet8(this.publisherHead, runtime8.journal);
            let loop5 = true;
            while (loop5) {
              const node = unsafeGet8(currentPublisherHead, runtime8.journal);
              if (node === void 0) {
                return retry5;
              }
              const head13 = node.head;
              const tail3 = node.tail;
              if (head13 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime8.journal);
                unsafeSet2(this.publisherHead, tail3, runtime8.journal);
                loop5 = false;
              } else {
                currentPublisherHead = tail3;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(void 0);
          const updatedNode = makeNode2(value6, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime8.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime8.journal);
          return succeed18(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map31(forEach13(iterable, (a) => this.offer(a)), every2(identity));
  }
  shutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    if (currentPublisherTail !== void 0) {
      unsafeSet2(this.publisherTail, void 0, journal);
      const currentSubscribers = unsafeGet8(this.subscribers, journal);
      forEach5(currentSubscribers, (subscriber) => {
        unsafeSet2(subscriber, void 0, journal);
      });
      unsafeSet2(this.subscribers, empty7(), journal);
    }
  });
};
var TPubSubSubscriptionImpl = class {
  static {
    __name(this, "TPubSubSubscriptionImpl");
  }
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    return currentSubscriberHead === void 0;
  });
  awaitShutdown = /* @__PURE__ */ flatMap20(this.isShutdown, (isShutdown8) => isShutdown8 ? void_9 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime8.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    let loop5 = true;
    let size22 = 0;
    while (loop5) {
      const node = unsafeGet8(currentSubscriberHead, runtime8.journal);
      if (node === void 0) {
        loop5 = false;
      } else {
        const head13 = node.head;
        const tail3 = node.tail;
        if (head13 !== AbsentValue2) {
          size22 = size22 + 1;
          if (size22 >= Number.MAX_SAFE_INTEGER) {
            loop5 = false;
          }
        }
        currentSubscriberHead = tail3;
      }
    }
    return succeed18(size22);
  });
  isEmpty = /* @__PURE__ */ map31(this.size, (size22) => size22 === 0);
  isFull = /* @__PURE__ */ map31(this.size, (size22) => size22 === this.capacity());
  peek = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime8.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    let value6 = AbsentValue2;
    let loop5 = true;
    while (loop5) {
      const node = unsafeGet8(currentSubscriberHead, runtime8.journal);
      if (node === void 0) {
        return retry5;
      }
      const head13 = node.head;
      const tail3 = node.tail;
      if (head13 !== AbsentValue2) {
        value6 = head13;
        loop5 = false;
      } else {
        currentSubscriberHead = tail3;
      }
    }
    return succeed18(value6);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime8.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    let value6 = none2();
    let loop5 = true;
    while (loop5) {
      const node = unsafeGet8(currentSubscriberHead, runtime8.journal);
      if (node === void 0) {
        value6 = none2();
        loop5 = false;
      } else {
        const head13 = node.head;
        const tail3 = node.tail;
        if (head13 !== AbsentValue2) {
          value6 = some3(head13);
          loop5 = false;
        } else {
          currentSubscriberHead = tail3;
        }
      }
    }
    return succeed18(value6);
  });
  shutdown = /* @__PURE__ */ effect3((journal) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    if (currentSubscriberHead !== void 0) {
      unsafeSet2(this.subscriberHead, void 0, journal);
      let loop5 = true;
      while (loop5) {
        const node = unsafeGet8(currentSubscriberHead, journal);
        if (node === void 0) {
          loop5 = false;
        } else {
          const head13 = node.head;
          const tail3 = node.tail;
          if (head13 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size22 = unsafeGet8(this.pubsubSize, journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail3);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
              unsafeSet2(this.publisherHead, tail3, journal);
              unsafeSet2(this.pubsubSize, size22 - 1, journal);
            } else {
              const updatedNode = makeNode2(head13, subscribers - 1, tail3);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail3;
        }
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, journal);
      unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
      unsafeSet2(this.subscribers, remove5(unsafeGet8(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime8) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime8.journal);
    if (currentSubscriberHead === void 0) {
      return interruptAs2(runtime8.fiberId);
    }
    let value6 = AbsentValue2;
    let loop5 = true;
    while (loop5) {
      const node = unsafeGet8(currentSubscriberHead, runtime8.journal);
      if (node === void 0) {
        return retry5;
      }
      const head13 = node.head;
      const tail3 = node.tail;
      if (head13 !== AbsentValue2) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size22 = unsafeGet8(this.pubsubSize, runtime8.journal);
          const updatedNode = makeNode2(AbsentValue2, 0, tail3);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
          unsafeSet2(this.publisherHead, tail3, runtime8.journal);
          unsafeSet2(this.pubsubSize, size22 - 1, runtime8.journal);
        } else {
          const updatedNode = makeNode2(head13, subscribers - 1, tail3);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
        }
        unsafeSet2(this.subscriberHead, tail3, runtime8.journal);
        value6 = head13;
        loop5 = false;
      } else {
        currentSubscriberHead = tail3;
      }
    }
    return succeed18(value6);
  });
  takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max9) {
    return withSTMRuntime((runtime8) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime8.journal);
      if (currentSubscriberHead === void 0) {
        return interruptAs2(runtime8.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max9) {
        const node = unsafeGet8(currentSubscriberHead, runtime8.journal);
        if (node === void 0) {
          n = max9;
        } else {
          const head13 = node.head;
          const tail3 = node.tail;
          if (head13 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size22 = unsafeGet8(this.pubsubSize, runtime8.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail3);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
              unsafeSet2(this.publisherHead, tail3, runtime8.journal);
              unsafeSet2(this.pubsubSize, size22 - 1, runtime8.journal);
            } else {
              const updatedNode = makeNode2(head13, subscribers - 1, tail3);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime8.journal);
            }
            builder.push(head13);
            n = n + 1;
          }
          currentSubscriberHead = tail3;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime8.journal);
      return succeed18(builder);
    });
  }
};
var makeSubscription2 = /* @__PURE__ */ __name((pubsubSize, publisherHead, publisherTail, requestedCapacity, subscriberCount, subscribers) => pipe(get18(publisherTail), flatMap20((currentPublisherTail) => pipe(all10([make60(currentPublisherTail), get18(subscriberCount), get18(subscribers)]), tap6(([_, currentSubscriberCount]) => pipe(subscriberCount, set11(currentSubscriberCount + 1))), tap6(([subscriberHead, _, currentSubscribers]) => pipe(subscribers, set11(pipe(currentSubscribers, add2(subscriberHead))))), map31(([subscriberHead]) => new TPubSubSubscriptionImpl(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers))))), "makeSubscription");
var subscribe3 = /* @__PURE__ */ __name((self2) => makeSubscription2(self2.pubsubSize, self2.publisherHead, self2.publisherTail, self2.requestedCapacity, self2.subscriberCount, self2.subscribers), "subscribe");
var subscribeScoped = /* @__PURE__ */ __name((self2) => acquireRelease2(subscribe3(self2), (dequeue) => shutdown5(dequeue)), "subscribeScoped");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/TPubSub.js
var subscribeScoped2 = subscribeScoped;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/TQueue.js
var TQueue_exports = {};
__export(TQueue_exports, {
  TDequeueTypeId: () => TDequeueTypeId2,
  TEnqueueTypeId: () => TEnqueueTypeId2,
  awaitShutdown: () => awaitShutdown7,
  bounded: () => bounded8,
  capacity: () => capacity8,
  dropping: () => dropping7,
  isEmpty: () => isEmpty17,
  isFull: () => isFull7,
  isShutdown: () => isShutdown7,
  isTDequeue: () => isTDequeue2,
  isTEnqueue: () => isTEnqueue2,
  isTQueue: () => isTQueue2,
  offer: () => offer5,
  offerAll: () => offerAll5,
  peek: () => peek2,
  peekOption: () => peekOption2,
  poll: () => poll8,
  seek: () => seek2,
  shutdown: () => shutdown7,
  size: () => size19,
  sliding: () => sliding7,
  take: () => take6,
  takeAll: () => takeAll4,
  takeBetween: () => takeBetween4,
  takeN: () => takeN4,
  takeUpTo: () => takeUpTo4,
  unbounded: () => unbounded8
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TDequeueTypeId2 = TDequeueTypeId;
var TEnqueueTypeId2 = TEnqueueTypeId;
var isTQueue2 = isTQueue;
var isTDequeue2 = isTDequeue;
var isTEnqueue2 = isTEnqueue;
var awaitShutdown7 = awaitShutdown5;
var bounded8 = bounded6;
var capacity8 = capacity6;
var dropping7 = dropping5;
var isEmpty17 = isEmpty15;
var isFull7 = isFull5;
var isShutdown7 = isShutdown5;
var offer5 = offer4;
var offerAll5 = offerAll4;
var peek2 = peek;
var peekOption2 = peekOption;
var poll8 = poll7;
var seek2 = seek;
var shutdown7 = shutdown5;
var size19 = size17;
var sliding7 = sliding5;
var take6 = take5;
var takeAll4 = takeAll3;
var takeBetween4 = takeBetween3;
var takeN4 = takeN3;
var takeUpTo4 = takeUpTo3;
var unbounded8 = unbounded6;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/ringBuffer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var RingBuffer = class {
  static {
    __name(this, "RingBuffer");
  }
  capacity;
  array;
  size = 0;
  current = 0;
  constructor(capacity9) {
    this.capacity = capacity9;
    this.array = Array.from({
      length: capacity9
    }, constUndefined);
  }
  head() {
    return fromNullable2(this.array[this.current]);
  }
  lastOrNull() {
    if (this.size === 0) {
      return void 0;
    }
    const index2 = this.current === 0 ? this.array.length - 1 : this.current - 1;
    return this.array[index2] ?? void 0;
  }
  put(value6) {
    this.array[this.current] = value6;
    this.increment();
  }
  dropLast() {
    if (this.size > 0) {
      this.decrement();
      this.array[this.current] = void 0;
    }
  }
  toChunk() {
    const begin = this.current - this.size;
    const newArray = begin < 0 ? [...this.array.slice(this.capacity + begin, this.capacity), ...this.array.slice(0, this.current)] : this.array.slice(begin, this.current);
    return fromIterable3(newArray);
  }
  increment() {
    if (this.size < this.capacity) {
      this.size += 1;
    }
    this.current = (this.current + 1) % this.capacity;
  }
  decrement() {
    this.size -= 1;
    if (this.current > 0) {
      this.current -= 1;
    } else {
      this.current = this.capacity - 1;
    }
  }
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/debounceState.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_NOT_STARTED = "NotStarted";
var OP_PREVIOUS = "Previous";
var OP_CURRENT = "Current";
var notStarted = {
  _tag: OP_NOT_STARTED
};
var previous = /* @__PURE__ */ __name((fiber) => ({
  _tag: OP_PREVIOUS,
  fiber
}), "previous");
var current = /* @__PURE__ */ __name((fiber) => ({
  _tag: OP_CURRENT,
  fiber
}), "current");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/emit.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var make61 = /* @__PURE__ */ __name((emit3) => {
  const ops = {
    chunk(as16) {
      return this(succeed11(as16));
    },
    die(defect) {
      return this(die7(defect));
    },
    dieMessage(message) {
      return this(dieMessage2(message));
    },
    done(exit5) {
      return this(suspend4(() => mapBoth3(exit5, {
        onFailure: some3,
        onSuccess: of2
      })));
    },
    end() {
      return this(fail10(none2()));
    },
    fail(e) {
      return this(fail10(some3(e)));
    },
    fromEffect(effect4) {
      return this(mapBoth5(effect4, {
        onFailure: some3,
        onSuccess: of2
      }));
    },
    fromEffectChunk(effect4) {
      return this(pipe(effect4, mapError4(some3)));
    },
    halt(cause3) {
      return this(failCause9(pipe(cause3, map18(some3))));
    },
    single(value6) {
      return this(succeed11(of2(value6)));
    }
  };
  return Object.assign(emit3, ops);
}, "make");
var makePush = /* @__PURE__ */ __name((queue, scheduler2) => {
  let finished = false;
  let buffer4 = [];
  let running4 = false;
  function array7(items) {
    if (finished) return false;
    if (items.length <= 5e4) {
      buffer4.push.apply(buffer4, items);
    } else {
      for (let i = 0; i < items.length; i++) {
        buffer4.push(items[0]);
      }
    }
    if (!running4) {
      running4 = true;
      scheduler2.scheduleTask(flush, 0);
    }
    return true;
  }
  __name(array7, "array");
  function flush() {
    running4 = false;
    if (buffer4.length > 0) {
      queue.unsafeOffer(buffer4);
      buffer4 = [];
    }
  }
  __name(flush, "flush");
  function done12(exit5) {
    if (finished) return;
    finished = true;
    if (exit5._tag === "Success") {
      buffer4.push(exit5.value);
    }
    flush();
    queue.unsafeOffer(exit5._tag === "Success" ? void_5 : exit5);
  }
  __name(done12, "done");
  return {
    single(value6) {
      if (finished) return false;
      buffer4.push(value6);
      if (!running4) {
        running4 = true;
        scheduler2.scheduleTask(flush, 0);
      }
      return true;
    },
    array: array7,
    chunk(chunk4) {
      return array7(toReadonlyArray(chunk4));
    },
    done: done12,
    end() {
      if (finished) return;
      finished = true;
      flush();
      queue.unsafeOffer(void_5);
    },
    halt(cause3) {
      return done12(failCause3(cause3));
    },
    fail(error5) {
      return done12(fail3(error5));
    },
    die(defect) {
      return done12(die3(defect));
    },
    dieMessage(message) {
      return done12(die3(new Error(message)));
    }
  };
}, "makePush");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/handoff.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HandoffTypeId = /* @__PURE__ */ Symbol.for("effect/Stream/Handoff");
var OP_HANDOFF_STATE_EMPTY = "Empty";
var OP_HANDOFF_STATE_FULL = "Full";
var handoffStateEmpty = /* @__PURE__ */ __name((notifyConsumer) => ({
  _tag: OP_HANDOFF_STATE_EMPTY,
  notifyConsumer
}), "handoffStateEmpty");
var handoffStateFull = /* @__PURE__ */ __name((value6, notifyProducer) => ({
  _tag: OP_HANDOFF_STATE_FULL,
  value: value6,
  notifyProducer
}), "handoffStateFull");
var handoffStateMatch = /* @__PURE__ */ __name((onEmpty, onFull) => {
  return (self2) => {
    switch (self2._tag) {
      case OP_HANDOFF_STATE_EMPTY: {
        return onEmpty(self2.notifyConsumer);
      }
      case OP_HANDOFF_STATE_FULL: {
        return onFull(self2.value, self2.notifyProducer);
      }
    }
  };
}, "handoffStateMatch");
var handoffVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var make62 = /* @__PURE__ */ __name(() => pipe(make43(), flatMap15((deferred) => make26(handoffStateEmpty(deferred))), map22((ref2) => ({
  [HandoffTypeId]: handoffVariance,
  ref: ref2
}))), "make");
var offer6 = /* @__PURE__ */ dual(2, (self2, value6) => {
  return flatMap15(make43(), (deferred) => flatten10(modify6(self2.ref, (state2) => pipe(state2, handoffStateMatch((notifyConsumer) => [zipRight7(succeed9(notifyConsumer, void 0), _await3(deferred)), handoffStateFull(value6, deferred)], (_, notifyProducer) => [flatMap15(_await3(notifyProducer), () => pipe(self2, offer6(value6))), state2])))));
});
var take7 = /* @__PURE__ */ __name((self2) => flatMap15(make43(), (deferred) => flatten10(modify6(self2.ref, (state2) => pipe(state2, handoffStateMatch((notifyConsumer) => [flatMap15(_await3(notifyConsumer), () => take7(self2)), state2], (value6, notifyProducer) => [as8(succeed9(notifyProducer, void 0), value6), handoffStateEmpty(deferred)]))))), "take");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/handoffSignal.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_EMIT4 = "Emit";
var OP_HALT = "Halt";
var OP_END = "End";
var emit2 = /* @__PURE__ */ __name((elements) => ({
  _tag: OP_EMIT4,
  elements
}), "emit");
var halt = /* @__PURE__ */ __name((cause3) => ({
  _tag: OP_HALT,
  cause: cause3
}), "halt");
var end3 = /* @__PURE__ */ __name((reason) => ({
  _tag: OP_END,
  reason
}), "end");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/pull.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/take.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TakeSymbolKey = "effect/Take";
var TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
var takeVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E")
};
var TakeImpl = class {
  static {
    __name(this, "TakeImpl");
  }
  exit;
  [TakeTypeId] = takeVariance;
  constructor(exit5) {
    this.exit = exit5;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var chunk3 = /* @__PURE__ */ __name((chunk4) => new TakeImpl(succeed3(chunk4)), "chunk");
var done11 = /* @__PURE__ */ __name((self2) => suspend4(() => self2.exit), "done");
var end4 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail3(/* @__PURE__ */ none2()));
var failCause12 = /* @__PURE__ */ __name((cause3) => new TakeImpl(failCause3(pipe(cause3, map18(some3)))), "failCause");
var fromPull = /* @__PURE__ */ __name((pull) => matchCause4(pull, {
  onFailure: /* @__PURE__ */ __name((cause3) => match2(flipCauseOption2(cause3), {
    onNone: /* @__PURE__ */ __name(() => end4, "onNone"),
    onSome: failCause12
  }), "onFailure"),
  onSuccess: chunk3
}), "fromPull");
var match22 = /* @__PURE__ */ dual(2, (self2, {
  onEnd: onEnd3,
  onFailure,
  onSuccess
}) => match9(self2.exit, {
  onFailure: /* @__PURE__ */ __name((cause3) => match2(flipCauseOption2(cause3), {
    onNone: onEnd3,
    onSome: onFailure
  }), "onFailure"),
  onSuccess
}));
var of5 = /* @__PURE__ */ __name((value6) => new TakeImpl(succeed3(of2(value6))), "of");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/pull.js
var end5 = /* @__PURE__ */ __name(() => fail10(none2()), "end");
var failCause13 = /* @__PURE__ */ __name((cause3) => mapError4(failCause9(cause3), some3), "failCause");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/sinkEndReason.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_SCHEDULE_END = "ScheduleEnd";
var OP_UPSTREAM_END = "UpstreamEnd";
var ScheduleEnd = {
  _tag: OP_SCHEDULE_END
};
var UpstreamEnd = {
  _tag: OP_UPSTREAM_END
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/zipAllState.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_DRAIN_LEFT = "DrainLeft";
var OP_DRAIN_RIGHT = "DrainRight";
var OP_PULL_BOTH = "PullBoth";
var OP_PULL_LEFT = "PullLeft";
var OP_PULL_RIGHT = "PullRight";
var DrainLeft = {
  _tag: OP_DRAIN_LEFT
};
var DrainRight = {
  _tag: OP_DRAIN_RIGHT
};
var PullBoth = {
  _tag: OP_PULL_BOTH
};
var PullLeft = /* @__PURE__ */ __name((rightChunk) => ({
  _tag: OP_PULL_LEFT,
  rightChunk
}), "PullLeft");
var PullRight = /* @__PURE__ */ __name((leftChunk) => ({
  _tag: OP_PULL_RIGHT,
  leftChunk
}), "PullRight");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream/zipChunksState.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OP_PULL_BOTH2 = "PullBoth";
var OP_PULL_LEFT2 = "PullLet";
var OP_PULL_RIGHT2 = "PullRight";
var PullBoth2 = {
  _tag: OP_PULL_BOTH2
};
var PullLeft2 = /* @__PURE__ */ __name((rightChunk) => ({
  _tag: OP_PULL_LEFT2,
  rightChunk
}), "PullLeft");
var PullRight2 = /* @__PURE__ */ __name((leftChunk) => ({
  _tag: OP_PULL_RIGHT2,
  leftChunk
}), "PullRight");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/stream.js
var StreamSymbolKey = "effect/Stream";
var StreamTypeId3 = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
var streamVariance = {
  _R: /* @__PURE__ */ __name((_) => _, "_R"),
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var StreamImpl = class {
  static {
    __name(this, "StreamImpl");
  }
  channel;
  [StreamTypeId3] = streamVariance;
  constructor(channel2) {
    this.channel = channel2;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isStream = /* @__PURE__ */ __name((u) => hasProperty(u, StreamTypeId3) || isEffect2(u), "isStream");
var DefaultChunkSize = 4096;
var accumulate = /* @__PURE__ */ __name((self2) => chunks(accumulateChunks(self2)), "accumulate");
var accumulateChunks = /* @__PURE__ */ __name((self2) => {
  const accumulator = /* @__PURE__ */ __name((s) => readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      const next4 = appendAll2(s, input);
      return flatMap18(write(next4), () => accumulator(next4));
    }, "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  }), "accumulator");
  return new StreamImpl(pipeTo(toChannel2(self2), accumulator(empty4())));
}, "accumulateChunks");
var acquireRelease3 = /* @__PURE__ */ __name((acquire, release2) => scoped6(acquireRelease2(acquire, release2)), "acquireRelease");
var aggregate = /* @__PURE__ */ dual(2, (self2, sink) => aggregateWithin(self2, sink, forever4));
var aggregateWithin = /* @__PURE__ */ dual(3, (self2, sink, schedule4) => filterMap8(aggregateWithinEither(self2, sink, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some3
})));
var aggregateWithinEither = /* @__PURE__ */ dual(3, (self2, sink, schedule4) => {
  const layer14 = all8([make62(), make26(ScheduleEnd), make26(empty4()), driver2(schedule4), make26(false), make26(false)]);
  return fromEffect8(layer14).pipe(flatMap21(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {
    const handoffProducer = readWithCause({
      onInput: /* @__PURE__ */ __name((input) => flatMap18(fromEffect5(pipe(handoff, offer6(emit2(input)), when2(() => isNonEmpty(input)))), () => handoffProducer), "onInput"),
      onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(offer6(handoff, halt(cause3))), "onFailure"),
      onDone: /* @__PURE__ */ __name(() => fromEffect5(offer6(handoff, end3(UpstreamEnd))), "onDone")
    });
    const handoffConsumer = pipe(getAndSet2(sinkLeftovers, empty4()), flatMap15((leftovers) => {
      if (isNonEmpty(leftovers)) {
        return pipe(set5(consumed, true), zipRight7(succeed11(pipe(write(leftovers), flatMap18(() => handoffConsumer)))));
      }
      return pipe(take7(handoff), map22((signal) => {
        switch (signal._tag) {
          case OP_EMIT4: {
            return pipe(fromEffect5(set5(consumed, true)), zipRight8(write(signal.elements)), zipRight8(fromEffect5(get12(endAfterEmit))), flatMap18((bool) => bool ? void_8 : handoffConsumer));
          }
          case OP_HALT: {
            return failCause11(signal.cause);
          }
          case OP_END: {
            if (signal.reason._tag === OP_SCHEDULE_END) {
              return pipe(get12(consumed), map22((bool) => bool ? fromEffect5(pipe(set5(sinkEndReason, ScheduleEnd), zipRight7(set5(endAfterEmit, true)))) : pipe(fromEffect5(pipe(set5(sinkEndReason, ScheduleEnd), zipRight7(set5(endAfterEmit, true)))), flatMap18(() => handoffConsumer))), unwrap3);
            }
            return pipe(set5(sinkEndReason, signal.reason), zipRight7(set5(endAfterEmit, true)), fromEffect5);
          }
        }
      }));
    }), unwrap3);
    const timeout5 = /* @__PURE__ */ __name((lastB) => scheduleDriver.next(lastB), "timeout");
    const scheduledAggregator = /* @__PURE__ */ __name((sinkFiber, scheduleFiber, scope5) => {
      const forkSink = pipe(set5(consumed, false), zipRight7(set5(endAfterEmit, false)), zipRight7(pipe(handoffConsumer, pipeToOrFail(toChannel(sink)), collectElements, run2, forkIn2(scope5))));
      const handleSide = /* @__PURE__ */ __name((leftovers, b, c) => pipe(set5(sinkLeftovers, flatten3(leftovers)), zipRight7(map22(get12(sinkEndReason), (reason) => {
        switch (reason._tag) {
          case OP_SCHEDULE_END: {
            return pipe(all8([get12(consumed), forkSink, pipe(timeout5(some3(b)), forkIn2(scope5))]), map22(([wasConsumed, sinkFiber2, scheduleFiber2]) => {
              const toWrite = pipe(c, match2({
                onNone: /* @__PURE__ */ __name(() => of2(right2(b)), "onNone"),
                onSome: /* @__PURE__ */ __name((c2) => make5(right2(b), left2(c2)), "onSome")
              }));
              if (wasConsumed) {
                return pipe(write(toWrite), flatMap18(() => scheduledAggregator(sinkFiber2, scheduleFiber2, scope5)));
              }
              return scheduledAggregator(sinkFiber2, scheduleFiber2, scope5);
            }), unwrap3);
          }
          case OP_UPSTREAM_END: {
            return pipe(get12(consumed), map22((wasConsumed) => wasConsumed ? write(of2(right2(b))) : void_8), unwrap3);
          }
        }
      })), unwrap3), "handleSide");
      return unwrap3(raceWith2(join4(sinkFiber), join4(scheduleFiber), {
        onSelfDone: /* @__PURE__ */ __name((sinkExit, _) => pipe(interrupt5(scheduleFiber), zipRight7(pipe(suspend4(() => sinkExit), map22(([leftovers, b]) => handleSide(leftovers, b, none2()))))), "onSelfDone"),
        onOtherDone: /* @__PURE__ */ __name((scheduleExit, _) => matchCauseEffect3(suspend4(() => scheduleExit), {
          onFailure: /* @__PURE__ */ __name((cause3) => match(failureOrCause2(cause3), {
            onLeft: /* @__PURE__ */ __name(() => pipe(handoff, offer6(end3(ScheduleEnd)), forkDaemon2, zipRight7(pipe(join4(sinkFiber), map22(([leftovers, b]) => handleSide(leftovers, b, none2()))))), "onLeft"),
            onRight: /* @__PURE__ */ __name((cause4) => pipe(handoff, offer6(halt(cause4)), forkDaemon2, zipRight7(pipe(join4(sinkFiber), map22(([leftovers, b]) => handleSide(leftovers, b, none2()))))), "onRight")
          }), "onFailure"),
          onSuccess: /* @__PURE__ */ __name((c) => pipe(handoff, offer6(end3(ScheduleEnd)), forkDaemon2, zipRight7(pipe(join4(sinkFiber), map22(([leftovers, b]) => handleSide(leftovers, b, some3(c)))))), "onSuccess")
        }), "onOtherDone")
      }));
    }, "scheduledAggregator");
    return unwrapScopedWith3((scope5) => pipeTo(toChannel2(self2), handoffProducer).pipe(run2, forkIn2(scope5), zipRight7(pipeToOrFail(handoffConsumer, toChannel(sink)).pipe(collectElements, run2, forkIn2(scope5), flatMap15((sinkFiber) => timeout5(none2()).pipe(forkIn2(scope5), map22((scheduleFiber) => new StreamImpl(scheduledAggregator(sinkFiber, scheduleFiber, scope5)))))))));
  }));
});
var as12 = /* @__PURE__ */ dual(2, (self2, value6) => map32(self2, () => value6));
var queueFromBufferOptions = /* @__PURE__ */ __name((bufferSize) => {
  if (bufferSize === "unbounded") {
    return unbounded3();
  } else if (typeof bufferSize === "number" || bufferSize === void 0) {
    return bounded3(bufferSize ?? 16);
  }
  switch (bufferSize.strategy) {
    case "dropping":
      return dropping2(bufferSize.bufferSize ?? 16);
    case "sliding":
      return sliding2(bufferSize.bufferSize ?? 16);
    default:
      return bounded3(bufferSize.bufferSize ?? 16);
  }
}, "queueFromBufferOptions");
var _async = /* @__PURE__ */ __name((register, bufferSize) => acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)).pipe(flatMap15((output) => runtime4().pipe(flatMap15((runtime8) => sync7(() => {
  const runPromiseExit3 = runPromiseExit2(runtime8);
  const canceler = register(make61((resume2) => fromPull(resume2).pipe(flatMap15((take11) => offer3(output, take11)), asVoid5, runPromiseExit3).then((exit5) => {
    if (isFailure3(exit5)) {
      if (!isInterrupted3(exit5.cause)) {
        throw squash(exit5.cause);
      }
    }
  })));
  return canceler;
})), map22((value6) => {
  const loop5 = take4(output).pipe(flatMap15((take11) => done11(take11)), match15({
    onFailure: /* @__PURE__ */ __name((maybeError) => fromEffect5(shutdown2(output)).pipe(zipRight8(match2(maybeError, {
      onNone: /* @__PURE__ */ __name(() => void_8, "onNone"),
      onSome: /* @__PURE__ */ __name((error5) => fail14(error5), "onSome")
    }))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((chunk4) => write(chunk4).pipe(flatMap18(() => loop5)), "onSuccess")
  }), unwrap3);
  return fromChannel2(loop5).pipe(ensuring7(value6 ?? _void));
}))), unwrapScoped4), "_async");
var asyncEffect3 = /* @__PURE__ */ __name((register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)), flatMap15((output) => pipe(runtime4(), flatMap15((runtime8) => pipe(register(make61((k) => pipe(fromPull(k), flatMap15((take11) => offer3(output, take11)), asVoid5, runPromiseExit2(runtime8)).then((exit5) => {
  if (isFailure3(exit5)) {
    if (!isInterrupted3(exit5.cause)) {
      throw squash(exit5.cause);
    }
  }
}))), map22(() => {
  const loop5 = pipe(take4(output), flatMap15(done11), match15({
    onFailure: /* @__PURE__ */ __name((maybeError) => pipe(fromEffect5(shutdown2(output)), zipRight8(match2(maybeError, {
      onNone: /* @__PURE__ */ __name(() => void_8, "onNone"),
      onSome: fail14
    }))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((chunk4) => pipe(write(chunk4), flatMap18(() => loop5)), "onSuccess")
  }), unwrap3);
  return loop5;
}))))), unwrapScoped3, fromChannel2), "asyncEffect");
var queueFromBufferOptionsPush = /* @__PURE__ */ __name((options4) => {
  if (options4?.bufferSize === "unbounded" || options4?.bufferSize === void 0 && options4?.strategy === void 0) {
    return unbounded3();
  }
  switch (options4?.strategy) {
    case "sliding":
      return sliding2(options4.bufferSize ?? 16);
    default:
      return dropping2(options4?.bufferSize ?? 16);
  }
}, "queueFromBufferOptionsPush");
var asyncPush = /* @__PURE__ */ __name((register, options4) => acquireRelease2(queueFromBufferOptionsPush(options4), shutdown2).pipe(tap4((queue) => getWith(currentScheduler2, (scheduler2) => register(makePush(queue, scheduler2)))), map22((queue) => {
  const loop5 = flatMap18(take4(queue), (item) => isExit(item) ? isSuccess2(item) ? void_8 : failCause11(item.cause) : zipRight8(write(unsafeFromArray(item)), loop5));
  return loop5;
}), unwrapScoped3, fromChannel2), "asyncPush");
var asyncScoped = /* @__PURE__ */ __name((register, bufferSize) => pipe(acquireRelease2(queueFromBufferOptions(bufferSize), (queue) => shutdown2(queue)), flatMap15((output) => pipe(runtime4(), flatMap15((runtime8) => pipe(register(make61((k) => pipe(fromPull(k), flatMap15((take11) => offer3(output, take11)), asVoid5, runPromiseExit2(runtime8)).then((exit5) => {
  if (isFailure3(exit5)) {
    if (!isInterrupted3(exit5.cause)) {
      throw squash(exit5.cause);
    }
  }
}))), zipRight7(make26(false)), flatMap15((ref2) => pipe(get12(ref2), map22((isDone7) => isDone7 ? end5() : pipe(take4(output), flatMap15(done11), onError2(() => pipe(set5(ref2, true), zipRight7(shutdown2(output)))))))))))), scoped6, flatMap21(repeatEffectChunkOption)), "asyncScoped");
var branchAfter = /* @__PURE__ */ dual(3, (self2, n, f) => suspend12(() => {
  const buffering = /* @__PURE__ */ __name((acc) => readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      const nextSize = acc.length + input.length;
      if (nextSize >= n) {
        const [b1, b2] = pipe(input, splitAt2(n - acc.length));
        return running4(pipe(acc, appendAll2(b1)), b2);
      }
      return buffering(pipe(acc, appendAll2(input)));
    }, "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => running4(acc, empty4()), "onDone")
  }), "buffering");
  const running4 = /* @__PURE__ */ __name((prefix, leftover2) => pipeTo(zipRight8(write(leftover2), identityChannel()), toChannel2(f(prefix))), "running");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(buffering(empty4()))));
}));
var broadcast = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => pipe(self2, broadcastedQueues(n, maximumLag), map22((tuple5) => tuple5.map((queue) => flattenTake(fromQueue2(queue, {
  shutdown: true
}))))));
var broadcastDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map22(toPubSub2(self2, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))));
var share = /* @__PURE__ */ dual(2, (self2, options4) => map22(make56({
  acquire: broadcastDynamic(self2, options4),
  idleTimeToLive: options4.idleTimeToLive
}), (rcRef) => unwrapScoped4(get17(rcRef))));
var broadcastedQueues = /* @__PURE__ */ dual(3, (self2, n, maximumLag) => flatMap15(pubsubFromOptions(maximumLag), (pubsub) => pipe(all8(Array.from({
  length: n
}, () => subscribe2(pubsub))), tap4(() => forkScoped2(runIntoPubSubScoped(self2, pubsub))))));
var broadcastedQueuesDynamic = /* @__PURE__ */ dual(2, (self2, maximumLag) => map22(toPubSub2(self2, maximumLag), subscribe2));
var buffer = /* @__PURE__ */ dual(2, (self2, options4) => {
  if (options4.capacity === "unbounded") {
    return bufferUnbounded(self2);
  } else if (options4.strategy === "dropping") {
    return bufferDropping(self2, options4.capacity);
  } else if (options4.strategy === "sliding") {
    return bufferSliding(self2, options4.capacity);
  }
  const queue = toQueueOfElements(self2, options4);
  return new StreamImpl(unwrapScoped3(map22(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take4(queue2)), flatMap18(match9({
      onFailure: /* @__PURE__ */ __name((cause3) => pipe(flipCauseOption2(cause3), match2({
        onNone: /* @__PURE__ */ __name(() => void_8, "onNone"),
        onSome: failCause11
      })), "onFailure"),
      onSuccess: /* @__PURE__ */ __name((value6) => flatMap18(write(of2(value6)), () => process2), "onSuccess")
    })));
    return process2;
  })));
});
var bufferChunks = /* @__PURE__ */ dual(2, (self2, options4) => {
  if (options4.strategy === "dropping") {
    return bufferChunksDropping(self2, options4.capacity);
  } else if (options4.strategy === "sliding") {
    return bufferChunksSliding(self2, options4.capacity);
  }
  const queue = toQueue2(self2, options4);
  return new StreamImpl(unwrapScoped3(map22(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take4(queue2)), flatMap18(match22({
      onEnd: /* @__PURE__ */ __name(() => void_8, "onEnd"),
      onFailure: failCause11,
      onSuccess: /* @__PURE__ */ __name((value6) => pipe(write(value6), flatMap18(() => process2)), "onSuccess")
    })));
    return process2;
  })));
});
var bufferChunksDropping = /* @__PURE__ */ dual(2, (self2, capacity9) => {
  const queue = acquireRelease2(dropping2(capacity9), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
});
var bufferChunksSliding = /* @__PURE__ */ dual(2, (self2, capacity9) => {
  const queue = acquireRelease2(sliding2(capacity9), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(self2)));
});
var bufferDropping = /* @__PURE__ */ dual(2, (self2, capacity9) => {
  const queue = acquireRelease2(dropping2(capacity9), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(rechunk(1)(self2))));
});
var bufferSliding = /* @__PURE__ */ dual(2, (self2, capacity9) => {
  const queue = acquireRelease2(sliding2(capacity9), (queue2) => shutdown2(queue2));
  return new StreamImpl(bufferSignal(queue, toChannel2(pipe(self2, rechunk(1)))));
});
var bufferUnbounded = /* @__PURE__ */ __name((self2) => {
  const queue = toQueue2(self2, {
    strategy: "unbounded"
  });
  return new StreamImpl(unwrapScoped3(map22(queue, (queue2) => {
    const process2 = pipe(fromEffect5(take4(queue2)), flatMap18(match22({
      onEnd: /* @__PURE__ */ __name(() => void_8, "onEnd"),
      onFailure: failCause11,
      onSuccess: /* @__PURE__ */ __name((value6) => flatMap18(write(value6), () => process2), "onSuccess")
    })));
    return process2;
  })));
}, "bufferUnbounded");
var bufferSignal = /* @__PURE__ */ __name((scoped9, bufferChannel) => {
  const producer = /* @__PURE__ */ __name((queue, ref2) => {
    const terminate = /* @__PURE__ */ __name((take11) => pipe(get12(ref2), tap4(_await3), zipRight7(make43()), flatMap15((deferred) => pipe(offer3(queue, [take11, deferred]), zipRight7(set5(ref2, deferred)), zipRight7(_await3(deferred)))), asVoid5, fromEffect5), "terminate");
    return readWithCause({
      onInput: /* @__PURE__ */ __name((input) => pipe(make43(), flatMap15((deferred) => pipe(offer3(queue, [chunk3(input), deferred]), flatMap15((added) => pipe(set5(ref2, deferred), when2(() => added))))), asVoid5, fromEffect5, flatMap18(() => producer(queue, ref2))), "onInput"),
      onFailure: /* @__PURE__ */ __name((error5) => terminate(failCause12(error5)), "onFailure"),
      onDone: /* @__PURE__ */ __name(() => terminate(end4), "onDone")
    });
  }, "producer");
  const consumer = /* @__PURE__ */ __name((queue) => {
    const process2 = pipe(fromEffect5(take4(queue)), flatMap18(([take11, deferred]) => zipRight8(fromEffect5(succeed9(deferred, void 0)), match22(take11, {
      onEnd: /* @__PURE__ */ __name(() => void_8, "onEnd"),
      onFailure: failCause11,
      onSuccess: /* @__PURE__ */ __name((value6) => pipe(write(value6), flatMap18(() => process2)), "onSuccess")
    }))));
    return process2;
  }, "consumer");
  return unwrapScoped3(pipe(scoped9, flatMap15((queue) => pipe(make43(), tap4((start3) => succeed9(start3, void 0)), flatMap15((start3) => pipe(make26(start3), flatMap15((ref2) => pipe(bufferChannel, pipeTo(producer(queue, ref2)), runScoped, forkScoped2)), as8(consumer(queue))))))));
}, "bufferSignal");
var catchAll7 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause6(self2, (cause3) => match(failureOrCause2(cause3), {
  onLeft: f,
  onRight: failCause14
})));
var catchAllCause6 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), catchAllCause5((cause3) => toChannel2(f(cause3))))));
var catchSome4 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAll7((error5) => pipe(pf(error5), getOrElse2(() => fail18(error5))))));
var catchSomeCause3 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, catchAllCause6((cause3) => pipe(pf(cause3), getOrElse2(() => failCause14(cause3))))));
var catchTag4 = /* @__PURE__ */ dual(3, (self2, k, f) => catchAll7(self2, (e) => {
  if ("_tag" in e && e["_tag"] === k) {
    return f(e);
  }
  return fail18(e);
}));
var catchTags4 = /* @__PURE__ */ dual(2, (self2, cases) => catchAll7(self2, (e) => {
  const keys6 = Object.keys(cases);
  if ("_tag" in e && keys6.includes(e["_tag"])) {
    return cases[e["_tag"]](e);
  }
  return fail18(e);
}));
var changes = /* @__PURE__ */ __name((self2) => pipe(self2, changesWith((x, y) => equals(y)(x))), "changes");
var changesWith = /* @__PURE__ */ dual(2, (self2, f) => {
  const writer = /* @__PURE__ */ __name((last5) => readWithCause({
    onInput: /* @__PURE__ */ __name((input) => {
      const [newLast, newChunk] = reduce2(input, [last5, empty4()], ([option9, outputs], output) => {
        if (isSome2(option9) && f(option9.value, output)) {
          return [some3(output), outputs];
        }
        return [some3(output), pipe(outputs, append2(output))];
      });
      return flatMap18(write(newChunk), () => writer(newLast));
    }, "onInput"),
    onFailure: failCause11,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  }), "writer");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
});
var changesWithEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const writer = /* @__PURE__ */ __name((last5) => readWithCause({
    onInput: /* @__PURE__ */ __name((input) => pipe(input, reduce13([last5, empty4()], ([option9, outputs], output) => {
      if (isSome2(option9)) {
        return pipe(f(option9.value, output), map22((bool) => bool ? [some3(output), outputs] : [some3(output), pipe(outputs, append2(output))]));
      }
      return succeed11([some3(output), pipe(outputs, append2(output))]);
    }), fromEffect5, flatMap18(([newLast, newChunk]) => pipe(write(newChunk), flatMap18(() => writer(newLast))))), "onInput"),
    onFailure: failCause11,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  }), "writer");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer(none2()))));
});
var chunks = /* @__PURE__ */ __name((self2) => pipe(self2, mapChunks(of2)), "chunks");
var chunksWith = /* @__PURE__ */ dual(2, (self2, f) => flattenChunks(f(chunks(self2))));
var unsome2 = /* @__PURE__ */ __name((effect4) => catchAll3(asSome2(effect4), (o) => o._tag === "None" ? succeedNone2 : fail10(o.value)), "unsome");
var combine9 = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
  function producer(handoff, latch) {
    return fromEffect5(take7(latch)).pipe(zipRight8(readWithCause({
      onInput: /* @__PURE__ */ __name((input) => flatMap18(fromEffect5(offer6(handoff, succeed3(input))), () => producer(handoff, latch)), "onInput"),
      onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(offer6(handoff, failCause3(pipe(cause3, map18(some3))))), "onFailure"),
      onDone: /* @__PURE__ */ __name(() => flatMap18(fromEffect5(offer6(handoff, fail3(none2()))), () => producer(handoff, latch)), "onDone")
    })));
  }
  __name(producer, "producer");
  return new StreamImpl(unwrapScopedWith((scope5) => all8([make62(), make62(), make62(), make62()]).pipe(tap4(([left3, _, latchL]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3, latchL)), runIn(scope5), forkIn2(scope5))), tap4(([, right3, _, rightL]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3, rightL)), runIn(scope5), forkIn2(scope5))), map22(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer6(latchL, void 0).pipe(zipRight7(take7(left3).pipe(flatMap15(identity))));
    const pullRight = offer6(latchR, void 0).pipe(zipRight7(take7(right3).pipe(flatMap15(identity))));
    return toChannel2(unfoldEffect(s, (s2) => flatMap15(f(s2, pullLeft, pullRight), unsome2)));
  }))));
});
var combineChunks = /* @__PURE__ */ dual(4, (self2, that, s, f) => {
  const producer = /* @__PURE__ */ __name((handoff, latch) => zipRight8(fromEffect5(take7(latch)), readWithCause({
    onInput: /* @__PURE__ */ __name((input) => flatMap18(fromEffect5(pipe(handoff, offer6(chunk3(input)))), () => producer(handoff, latch)), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(offer6(handoff, failCause12(cause3))), "onFailure"),
    onDone: /* @__PURE__ */ __name(() => fromEffect5(offer6(handoff, end4)), "onDone")
  })), "producer");
  return new StreamImpl(unwrapScopedWith((scope5) => all8([make62(), make62(), make62(), make62()]).pipe(tap4(([left3, _, latchL]) => pipeTo(toChannel2(self2), producer(left3, latchL)).pipe(runIn(scope5), forkIn2(scope5))), tap4(([_, right3, __, latchR]) => pipeTo(toChannel2(that), producer(right3, latchR)).pipe(runIn(scope5), forkIn2(scope5))), map22(([left3, right3, latchL, latchR]) => {
    const pullLeft = offer6(latchL, void 0).pipe(zipRight7(take7(left3).pipe(flatMap15(done11))));
    const pullRight = offer6(latchR, void 0).pipe(zipRight7(take7(right3).pipe(flatMap15(done11))));
    return toChannel2(unfoldChunkEffect(s, (s2) => flatMap15(f(s2, pullLeft, pullRight), unsome2)));
  }))));
});
var concat2 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), zipRight8(toChannel2(that)))));
var concatAll2 = /* @__PURE__ */ __name((streams) => suspend12(() => pipe(streams, reduce2(empty36, (x, y) => concat2(y)(x)))), "concatAll");
var cross = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, a2) => [a, a2])));
var crossLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, crossWith(right3, (a, _) => a)));
var crossRight = /* @__PURE__ */ dual(2, (left3, right3) => flatMap21(left3, () => right3));
var crossWith = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, flatMap21((a) => pipe(right3, map32((b) => f(a, b))))));
var debounce = /* @__PURE__ */ dual(2, (self2, duration4) => unwrapScopedWith3((scope5) => gen4(function* () {
  const handoff = yield* make62();
  function enqueue(last5) {
    return sleep2(duration4).pipe(as8(last5), forkIn2(scope5), map22((fiber) => consumer(previous(fiber))));
  }
  __name(enqueue, "enqueue");
  const producer = readWithCause({
    onInput: /* @__PURE__ */ __name((input) => match2(last2(input), {
      onNone: /* @__PURE__ */ __name(() => producer, "onNone"),
      onSome: /* @__PURE__ */ __name((elem) => fromEffect5(offer6(handoff, emit2(of2(elem)))).pipe(flatMap18(() => producer)), "onSome")
    }), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(offer6(handoff, halt(cause3))), "onFailure"),
    onDone: /* @__PURE__ */ __name(() => fromEffect5(offer6(handoff, end3(UpstreamEnd))), "onDone")
  });
  function consumer(state2) {
    switch (state2._tag) {
      case OP_NOT_STARTED: {
        return unwrap3(take7(handoff).pipe(map22((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap3(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause11(signal.cause);
            }
            case OP_END: {
              return void_8;
            }
          }
        })));
      }
      case OP_PREVIOUS: {
        return unwrap3(take7(handoff).pipe(forkIn2(scope5), flatMap15((handoffFiber) => raceWith2(join4(state2.fiber), join4(handoffFiber), {
          onSelfDone: /* @__PURE__ */ __name((leftExit, current2) => match9(leftExit, {
            onFailure: /* @__PURE__ */ __name((cause3) => interrupt5(current2).pipe(as8(failCause11(cause3))), "onFailure"),
            onSuccess: /* @__PURE__ */ __name((chunk4) => interrupt5(current2).pipe(zipRight7(succeed11(write(chunk4).pipe(flatMap18(() => consumer(current(handoffFiber))))))), "onSuccess")
          }), "onSelfDone"),
          onOtherDone: /* @__PURE__ */ __name((rightExit, previous2) => match9(rightExit, {
            onFailure: /* @__PURE__ */ __name((cause3) => interrupt5(previous2).pipe(as8(failCause11(cause3))), "onFailure"),
            onSuccess: /* @__PURE__ */ __name((signal) => {
              switch (signal._tag) {
                case OP_EMIT4: {
                  return interrupt5(previous2).pipe(zipRight7(enqueue(signal.elements)));
                }
                case OP_HALT: {
                  return interrupt5(previous2).pipe(as8(failCause11(signal.cause)));
                }
                case OP_END: {
                  return join4(previous2).pipe(map22((chunk4) => write(chunk4).pipe(zipRight8(void_8))));
                }
              }
            }, "onSuccess")
          }), "onOtherDone")
        }))));
      }
      case OP_CURRENT: {
        return unwrap3(join4(state2.fiber).pipe(map22((signal) => {
          switch (signal._tag) {
            case OP_EMIT4: {
              return unwrap3(enqueue(signal.elements));
            }
            case OP_HALT: {
              return failCause11(signal.cause);
            }
            case OP_END: {
              return void_8;
            }
          }
        })));
      }
    }
  }
  __name(consumer, "consumer");
  return scopedWith4((scope6) => pipeTo(toChannel2(self2), producer).pipe(runIn(scope6), forkIn2(scope6))).pipe(crossRight(new StreamImpl(consumer(notStarted))));
})));
var die11 = /* @__PURE__ */ __name((defect) => fromEffect8(die7(defect)), "die");
var dieSync7 = /* @__PURE__ */ __name((evaluate3) => fromEffect8(dieSync4(evaluate3)), "dieSync");
var dieMessage4 = /* @__PURE__ */ __name((message) => fromEffect8(dieMessage2(message)), "dieMessage");
var distributedWith = /* @__PURE__ */ dual(2, (self2, options4) => pipe(make43(), flatMap15((deferred) => pipe(self2, distributedWithDynamic({
  maximumLag: options4.maximumLag,
  decide: /* @__PURE__ */ __name((a) => flatMap15(_await3(deferred), (f) => f(a)), "decide")
}), flatMap15((next4) => pipe(all8(map6(range2(0, options4.size - 1), (id4) => map22(next4, ([key, queue]) => [[key, id4], queue]))), map22(unsafeFromArray), flatMap15((entries3) => {
  const [mappings, queues] = reduceRight2(entries3, [/* @__PURE__ */ new Map(), empty4()], ([mappings2, queues2], [mapping, queue]) => [mappings2.set(mapping[0], mapping[1]), pipe(queues2, prepend2(queue))]);
  return pipe(succeed9(deferred, (a) => map22(options4.decide(a), (f) => (key) => f(mappings.get(key)))), as8(Array.from(queues)));
})))))));
var distributedWithDynamicId = {
  ref: 0
};
var newDistributedWithDynamicId = /* @__PURE__ */ __name(() => {
  const current2 = distributedWithDynamicId.ref;
  distributedWithDynamicId.ref = current2 + 1;
  return current2;
}, "newDistributedWithDynamicId");
var distributedWithDynamic = /* @__PURE__ */ dual(2, (self2, options4) => distributedWithDynamicCallback(self2, options4.maximumLag, options4.decide, () => _void));
var distributedWithDynamicCallback = /* @__PURE__ */ dual(4, (self2, maximumLag, decide, done12) => pipe(acquireRelease2(make26(/* @__PURE__ */ new Map()), (ref2, _) => pipe(get12(ref2), flatMap15((queues) => pipe(queues.values(), forEach11(shutdown2))))), flatMap15((queuesRef) => gen4(function* () {
  const offer7 = /* @__PURE__ */ __name((a) => pipe(decide(a), flatMap15((shouldProcess) => pipe(get12(queuesRef), flatMap15((queues) => pipe(queues.entries(), reduce13(empty4(), (acc, [id4, queue]) => {
    if (shouldProcess(id4)) {
      return pipe(offer3(queue, succeed3(a)), matchCauseEffect3({
        onFailure: /* @__PURE__ */ __name((cause3) => (
          // Ignore all downstream queues that were shut
          // down and remove them later
          isInterrupted3(cause3) ? succeed11(pipe(acc, prepend2(id4))) : failCause9(cause3)
        ), "onFailure"),
        onSuccess: /* @__PURE__ */ __name(() => succeed11(acc), "onSuccess")
      }));
    }
    return succeed11(acc);
  }), flatMap15((ids3) => {
    if (isNonEmpty(ids3)) {
      return update3(queuesRef, (map38) => {
        for (const id4 of ids3) {
          map38.delete(id4);
        }
        return map38;
      });
    }
    return _void;
  }))))), asVoid5), "offer");
  const queuesLock = yield* makeSemaphore2(1);
  const newQueue = yield* make26(pipe(bounded3(maximumLag), flatMap15((queue) => {
    const id4 = newDistributedWithDynamicId();
    return pipe(update3(queuesRef, (map38) => map38.set(id4, queue)), as8([id4, queue]));
  })));
  const finalize = /* @__PURE__ */ __name((endTake) => (
    // Make sure that no queues are currently being added
    queuesLock.withPermits(1)(pipe(set5(newQueue, pipe(
      // All newly created queues should end immediately
      bounded3(1),
      tap4((queue) => offer3(queue, endTake)),
      flatMap15((queue) => {
        const id4 = newDistributedWithDynamicId();
        return pipe(update3(queuesRef, (map38) => map38.set(id4, queue)), as8(make3(id4, queue)));
      })
    )), zipRight7(pipe(get12(queuesRef), flatMap15((map38) => pipe(fromIterable3(map38.values()), forEach11((queue) => pipe(offer3(queue, endTake), catchSomeCause2((cause3) => isInterrupted3(cause3) ? some3(_void) : none2()))))))), zipRight7(done12(endTake)), asVoid5))
  ), "finalize");
  yield* pipe(self2, runForEachScoped(offer7), matchCauseEffect3({
    onFailure: /* @__PURE__ */ __name((cause3) => finalize(failCause3(pipe(cause3, map18(some3)))), "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => finalize(fail3(none2())), "onSuccess")
  }), forkScoped2);
  return queuesLock.withPermits(1)(flatten10(get12(newQueue)));
}))));
var drain3 = /* @__PURE__ */ __name((self2) => new StreamImpl(drain(toChannel2(self2))), "drain");
var drainFork = /* @__PURE__ */ dual(2, (self2, that) => fromEffect8(make43()).pipe(flatMap21((backgroundDied) => scopedWith4((scope5) => toChannel2(that).pipe(drain, runIn(scope5), catchAllCause3((cause3) => failCause7(backgroundDied, cause3)), forkIn2(scope5))).pipe(crossRight(interruptWhenDeferred2(self2, backgroundDied))))));
var drop3 = /* @__PURE__ */ dual(2, (self2, n) => {
  const loop5 = /* @__PURE__ */ __name((r) => readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      const dropped = pipe(input, drop2(r));
      const leftover2 = Math.max(0, r - input.length);
      const more = isEmpty(input) || leftover2 > 0;
      if (more) {
        return loop5(leftover2);
      }
      return pipe(write(dropped), zipRight8(identityChannel()));
    }, "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  }), "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop5(n))));
});
var dropRight3 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return identityStream();
  }
  return suspend12(() => {
    const queue = new RingBuffer(n);
    const reader = readWith({
      onInput: /* @__PURE__ */ __name((input) => {
        const outputs = pipe(input, filterMap3((elem) => {
          const head13 = queue.head();
          queue.put(elem);
          return head13;
        }));
        return pipe(write(outputs), flatMap18(() => reader));
      }, "onInput"),
      onFailure: fail14,
      onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
    });
    return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(reader)));
  });
});
var dropUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => drop3(dropWhile5(self2, (a) => !predicate(a)), 1));
var dropUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop5 = readWith({
    onInput: /* @__PURE__ */ __name((input) => pipe(dropUntil2(input, predicate), map22(unsafeFromArray), map22((leftover2) => {
      const more = isEmpty(leftover2);
      if (more) {
        return suspend8(() => loop5);
      }
      return pipe(write(leftover2), zipRight8(identityChannel()));
    }), unwrap3), "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop5)));
});
var dropWhile5 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop5 = readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      const output = dropWhile2(input, predicate);
      if (isEmpty(output)) {
        return suspend8(() => loop5);
      }
      return zipRight8(write(output), identityChannel());
    }, "onInput"),
    onFailure: fail14,
    onDone: succeedNow
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), loop5));
});
var dropWhileEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop5 = readWith({
    onInput: /* @__PURE__ */ __name((input) => pipe(dropWhile4(input, predicate), map22(unsafeFromArray), map22((leftover2) => {
      const more = isEmpty(leftover2);
      if (more) {
        return suspend8(() => loop5);
      }
      return zipRight8(write(leftover2), identityChannel());
    }), unwrap3), "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  });
  return new StreamImpl(pipeToOrFail(toChannel2(self2), loop5));
});
var either7 = /* @__PURE__ */ __name((self2) => pipe(self2, map32(right2), catchAll7((error5) => make63(left2(error5)))), "either");
var empty36 = /* @__PURE__ */ new StreamImpl(void_8);
var ensuring7 = /* @__PURE__ */ dual(2, (self2, finalizer3) => new StreamImpl(pipe(toChannel2(self2), ensuring4(finalizer3))));
var ensuringWith2 = /* @__PURE__ */ dual(2, (self2, finalizer3) => new StreamImpl(ensuringWith(toChannel2(self2), finalizer3)));
var context8 = /* @__PURE__ */ __name(() => fromEffect8(context4()), "context");
var contextWith4 = /* @__PURE__ */ __name((f) => pipe(context8(), map32(f)), "contextWith");
var contextWithEffect3 = /* @__PURE__ */ __name((f) => pipe(context8(), mapEffectSequential(f)), "contextWithEffect");
var contextWithStream = /* @__PURE__ */ __name((f) => pipe(context8(), flatMap21(f)), "contextWithStream");
var execute = /* @__PURE__ */ __name((effect4) => drain3(fromEffect8(effect4)), "execute");
var fail18 = /* @__PURE__ */ __name((error5) => fromEffectOption(fail10(some3(error5))), "fail");
var failSync8 = /* @__PURE__ */ __name((evaluate3) => fromEffectOption(failSync4(() => some3(evaluate3()))), "failSync");
var failCause14 = /* @__PURE__ */ __name((cause3) => fromEffect8(failCause9(cause3)), "failCause");
var failCauseSync7 = /* @__PURE__ */ __name((evaluate3) => fromEffect8(failCauseSync4(evaluate3)), "failCauseSync");
var filter15 = /* @__PURE__ */ dual(2, (self2, predicate) => mapChunks(self2, filter4(predicate)));
var filterEffect2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop5 = /* @__PURE__ */ __name((iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: /* @__PURE__ */ __name((input) => loop5(input[Symbol.iterator]()), "onInput"),
        onFailure: failCause11,
        onDone: succeed15
      });
    } else {
      return pipe(f(next4.value), map22((bool) => bool ? pipe(write(of2(next4.value)), flatMap18(() => loop5(iterator))) : loop5(iterator)), unwrap3);
    }
  }, "loop");
  return new StreamImpl(suspend8(() => pipe(toChannel2(self2), pipeTo(loop5(empty4()[Symbol.iterator]())))));
});
var filterMap8 = /* @__PURE__ */ dual(2, (self2, pf) => mapChunks(self2, filterMap3(pf)));
var filterMapEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend12(() => {
  const loop5 = /* @__PURE__ */ __name((iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: /* @__PURE__ */ __name((input) => loop5(input[Symbol.iterator]()), "onInput"),
        onFailure: failCause11,
        onDone: succeed15
      });
    } else {
      return pipe(pf(next4.value), match2({
        onNone: /* @__PURE__ */ __name(() => sync7(() => loop5(iterator)), "onNone"),
        onSome: map22((a2) => flatMap18(write(of2(a2)), () => loop5(iterator)))
      }), unwrap3);
    }
  }, "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop5(empty4()[Symbol.iterator]()))));
}));
var filterMapWhile3 = /* @__PURE__ */ dual(2, (self2, pf) => {
  const loop5 = readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      const mapped = filterMapWhile2(input, pf);
      if (mapped.length === input.length) {
        return pipe(write(mapped), flatMap18(() => loop5));
      }
      return write(mapped);
    }, "onInput"),
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop5)));
});
var filterMapWhileEffect = /* @__PURE__ */ dual(2, (self2, pf) => suspend12(() => {
  const loop5 = /* @__PURE__ */ __name((iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: /* @__PURE__ */ __name((input) => loop5(input[Symbol.iterator]()), "onInput"),
        onFailure: failCause11,
        onDone: succeed15
      });
    } else {
      return unwrap3(match2(pf(next4.value), {
        onNone: /* @__PURE__ */ __name(() => succeed11(void_8), "onNone"),
        onSome: map22((a2) => flatMap18(write(of2(a2)), () => loop5(iterator)))
      }));
    }
  }, "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop5(empty4()[Symbol.iterator]()))));
}));
var finalizer = /* @__PURE__ */ __name((finalizer3) => acquireRelease3(_void, () => finalizer3), "finalizer");
var find3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop5 = readWith({
    onInput: /* @__PURE__ */ __name((input) => match2(findFirst3(input, predicate), {
      onNone: /* @__PURE__ */ __name(() => loop5, "onNone"),
      onSome: /* @__PURE__ */ __name((n) => write(of2(n)), "onSome")
    }), "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop5)));
});
var findEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop5 = readWith({
    onInput: /* @__PURE__ */ __name((input) => pipe(findFirst8(input, predicate), map22(match2({
      onNone: /* @__PURE__ */ __name(() => loop5, "onNone"),
      onSome: /* @__PURE__ */ __name((n) => write(of2(n)), "onSome")
    })), unwrap3), "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop5)));
});
var flatMap21 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options4) => {
  const bufferSize = options4?.bufferSize ?? 16;
  if (options4?.switch) {
    return matchConcurrency(options4?.concurrency, () => flatMapParSwitchBuffer(self2, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self2, n, bufferSize, f));
  }
  return matchConcurrency(options4?.concurrency, () => new StreamImpl(concatMap(toChannel2(self2), (as16) => pipe(as16, map6((a) => toChannel2(f(a))), reduce2(void_8, (left3, right3) => pipe(left3, zipRight8(right3)))))), (_) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), options4))));
});
var matchConcurrency = /* @__PURE__ */ __name((concurrency, sequential5, bounded9) => {
  switch (concurrency) {
    case void 0:
      return sequential5();
    case "unbounded":
      return bounded9(Number.MAX_SAFE_INTEGER);
    default:
      return concurrency > 1 ? bounded9(concurrency) : sequential5();
  }
}, "matchConcurrency");
var flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self2, n, bufferSize, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mergeMap((out) => toChannel2(f(out)), {
  concurrency: n,
  mergeStrategy: BufferSliding(),
  bufferSize
}))));
var flatten15 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => flatMap21(self2, identity, options4));
var flattenChunks = /* @__PURE__ */ __name((self2) => {
  const flatten18 = readWithCause({
    onInput: /* @__PURE__ */ __name((chunks3) => flatMap18(writeChunk(chunks3), () => flatten18), "onInput"),
    onFailure: failCause11,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(flatten18)));
}, "flattenChunks");
var flattenEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => options4?.unordered ? flatMap21(self2, (a) => fromEffect8(a), {
  concurrency: options4.concurrency
}) : matchConcurrency(options4?.concurrency, () => mapEffectSequential(self2, identity), (n) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(identity, n), mapOut(of2)))));
var flattenExitOption = /* @__PURE__ */ __name((self2) => {
  const processChunk = /* @__PURE__ */ __name((chunk4, cont) => {
    const [toEmit, rest] = pipe(chunk4, splitWhere2((exit5) => !isSuccess2(exit5)));
    const next4 = pipe(head3(rest), match2({
      onNone: /* @__PURE__ */ __name(() => cont, "onNone"),
      onSome: match9({
        onFailure: /* @__PURE__ */ __name((cause3) => match2(flipCauseOption2(cause3), {
          onNone: /* @__PURE__ */ __name(() => void_8, "onNone"),
          onSome: failCause11
        }), "onFailure"),
        onSuccess: /* @__PURE__ */ __name(() => void_8, "onSuccess")
      })
    }));
    return pipe(write(pipe(toEmit, filterMap3((exit5) => isSuccess2(exit5) ? some3(exit5.value) : none2()))), flatMap18(() => next4));
  }, "processChunk");
  const process2 = readWithCause({
    onInput: /* @__PURE__ */ __name((chunk4) => processChunk(chunk4, process2), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => failCause11(cause3), "onFailure"),
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
}, "flattenExitOption");
var flattenIterables = /* @__PURE__ */ __name((self2) => pipe(self2, map32(fromIterable3), flattenChunks), "flattenIterables");
var flattenTake = /* @__PURE__ */ __name((self2) => flattenChunks(flattenExitOption(pipe(self2, map32((take11) => take11.exit)))), "flattenTake");
var forever5 = /* @__PURE__ */ __name((self2) => new StreamImpl(repeated(toChannel2(self2))), "forever");
var fromAsyncIterable = /* @__PURE__ */ __name((iterable, onError5) => pipe(acquireRelease2(sync7(() => iterable[Symbol.asyncIterator]()), (iterator) => iterator.return ? promise2(async () => iterator.return()) : _void), map22((iterator) => repeatEffectOption(pipe(tryPromise2({
  try: /* @__PURE__ */ __name(async () => iterator.next(), "try"),
  catch: /* @__PURE__ */ __name((reason) => some3(onError5(reason)), "catch")
}), flatMap15((result) => result.done ? fail10(none2()) : succeed11(result.value))))), unwrapScoped4), "fromAsyncIterable");
var fromChannel2 = /* @__PURE__ */ __name((channel2) => new StreamImpl(channel2), "fromChannel");
var toChannel2 = /* @__PURE__ */ __name((stream6) => {
  if ("channel" in stream6) {
    return stream6.channel;
  } else if (isEffect2(stream6)) {
    return toChannel2(fromEffect8(stream6));
  } else {
    throw new TypeError(`Expected a Stream.`);
  }
}, "toChannel");
var fromChunk = /* @__PURE__ */ __name((chunk4) => new StreamImpl(isEmpty(chunk4) ? void_8 : write(chunk4)), "fromChunk");
var fromChunkPubSub = /* @__PURE__ */ __name((pubsub, options4) => {
  if (options4?.scoped) {
    const effect4 = map22(subscribe2(pubsub), fromChunkQueue);
    return options4.shutdown ? map22(effect4, ensuring7(shutdown4(pubsub))) : effect4;
  }
  const stream6 = flatMap21(scoped6(subscribe2(pubsub)), fromChunkQueue);
  return options4?.shutdown ? ensuring7(stream6, shutdown4(pubsub)) : stream6;
}, "fromChunkPubSub");
var fromChunkQueue = /* @__PURE__ */ __name((queue, options4) => pipe(take4(queue), catchAllCause3((cause3) => pipe(isShutdown2(queue), flatMap15((isShutdown8) => isShutdown8 && isInterrupted3(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption, options4?.shutdown ? ensuring7(shutdown2(queue)) : identity), "fromChunkQueue");
var fromChunks = /* @__PURE__ */ __name((...chunks3) => pipe(fromIterable14(chunks3), flatMap21(fromChunk)), "fromChunks");
var fromEffect8 = /* @__PURE__ */ __name((effect4) => pipe(effect4, mapError4(some3), fromEffectOption), "fromEffect");
var fromEffectOption = /* @__PURE__ */ __name((effect4) => new StreamImpl(unwrap3(match15(effect4, {
  onFailure: match2({
    onNone: /* @__PURE__ */ __name(() => void_8, "onNone"),
    onSome: fail14
  }),
  onSuccess: /* @__PURE__ */ __name((a) => write(of2(a)), "onSuccess")
}))), "fromEffectOption");
var fromPubSub = /* @__PURE__ */ __name((pubsub, options4) => {
  const maxChunkSize = options4?.maxChunkSize ?? DefaultChunkSize;
  if (options4?.scoped) {
    const effect4 = map22(subscribe2(pubsub), (queue) => fromQueue2(queue, {
      maxChunkSize,
      shutdown: true
    }));
    return options4.shutdown ? map22(effect4, ensuring7(shutdown4(pubsub))) : effect4;
  }
  const stream6 = flatMap21(scoped6(subscribe2(pubsub)), (queue) => fromQueue2(queue, {
    maxChunkSize
  }));
  return options4?.shutdown ? ensuring7(stream6, shutdown4(pubsub)) : stream6;
}, "fromPubSub");
var fromTPubSub = /* @__PURE__ */ __name((pubsub) => {
  return unwrapScoped4(map22(subscribeScoped2(pubsub), (queue) => fromTQueue(queue)));
}, "fromTPubSub");
var fromIterable14 = /* @__PURE__ */ __name((iterable) => suspend12(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]())), "fromIterable");
var fromIterableEffect = /* @__PURE__ */ __name((effect4) => pipe(effect4, map22(fromIterable14), unwrap4), "fromIterableEffect");
var fromIteratorSucceed = /* @__PURE__ */ __name((iterator, maxChunkSize = DefaultChunkSize) => {
  return pipe(sync7(() => {
    let builder = [];
    const loop5 = /* @__PURE__ */ __name((iterator2) => pipe(sync7(() => {
      let next4 = iterator2.next();
      if (maxChunkSize === 1) {
        if (next4.done) {
          return void_8;
        }
        return pipe(write(of2(next4.value)), flatMap18(() => loop5(iterator2)));
      }
      builder = [];
      let count7 = 0;
      while (next4.done === false) {
        builder.push(next4.value);
        count7 = count7 + 1;
        if (count7 >= maxChunkSize) {
          break;
        }
        next4 = iterator2.next();
      }
      if (count7 > 0) {
        return pipe(write(unsafeFromArray(builder)), flatMap18(() => loop5(iterator2)));
      }
      return void_8;
    }), unwrap3), "loop");
    return new StreamImpl(loop5(iterator));
  }), unwrap4);
}, "fromIteratorSucceed");
var fromPull2 = /* @__PURE__ */ __name((effect4) => pipe(effect4, map22(repeatEffectChunkOption), unwrapScoped4), "fromPull");
var fromQueue2 = /* @__PURE__ */ __name((queue, options4) => pipe(takeBetween2(queue, 1, options4?.maxChunkSize ?? DefaultChunkSize), catchAllCause3((cause3) => pipe(isShutdown2(queue), flatMap15((isShutdown8) => isShutdown8 && isInterrupted3(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption, options4?.shutdown ? ensuring7(shutdown2(queue)) : identity), "fromQueue");
var fromTQueue = /* @__PURE__ */ __name((queue) => pipe(take6(queue), map22(of2), catchAllCause3((cause3) => pipe(isShutdown7(queue), flatMap15((isShutdown8) => isShutdown8 && isInterrupted3(cause3) ? end5() : failCause13(cause3)))), repeatEffectChunkOption), "fromTQueue");
var fromSchedule = /* @__PURE__ */ __name((schedule4) => pipe(driver2(schedule4), map22((driver3) => repeatEffectOption(driver3.next(void 0))), unwrap4), "fromSchedule");
var fromReadableStream = /* @__PURE__ */ __name((...args2) => {
  const evaluate3 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError5 = args2.length === 1 ? args2[0].onError : args2[1];
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map22(acquireRelease2(sync7(() => evaluate3().getReader()), (reader) => releaseLockOnEnd ? sync7(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => repeatEffectOption(flatMap15(tryPromise2({
    try: /* @__PURE__ */ __name(() => reader.read(), "try"),
    catch: /* @__PURE__ */ __name((reason) => some3(onError5(reason)), "catch")
  }), ({
    done: done12,
    value: value6
  }) => done12 ? fail10(none2()) : succeed11(value6)))));
}, "fromReadableStream");
var fromReadableStreamByob = /* @__PURE__ */ __name((...args2) => {
  const evaluate3 = args2.length === 1 ? args2[0].evaluate : args2[0];
  const onError5 = args2.length === 1 ? args2[0].onError : args2[1];
  const allocSize = (args2.length === 1 ? args2[0].bufferSize : args2[2]) ?? 4096;
  const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
  return unwrapScoped4(map22(acquireRelease2(sync7(() => evaluate3().getReader({
    mode: "byob"
  })), (reader) => releaseLockOnEnd ? sync7(() => reader.releaseLock()) : promise2(() => reader.cancel())), (reader) => catchAll7(forever5(readChunkStreamByobReader(reader, onError5, allocSize)), (error5) => error5 === EOF ? empty36 : fail18(error5))));
}, "fromReadableStreamByob");
var EOF = /* @__PURE__ */ Symbol.for("effect/Stream/EOF");
var readChunkStreamByobReader = /* @__PURE__ */ __name((reader, onError5, size22) => {
  const buffer4 = new ArrayBuffer(size22);
  return paginateEffect(0, (offset) => flatMap15(tryPromise2({
    try: /* @__PURE__ */ __name(() => reader.read(new Uint8Array(buffer4, offset, buffer4.byteLength - offset)), "try"),
    catch: /* @__PURE__ */ __name((reason) => onError5(reason), "catch")
  }), ({
    done: done12,
    value: value6
  }) => {
    if (done12) {
      return fail10(EOF);
    }
    const newOffset = offset + value6.byteLength;
    return succeed11([value6, newOffset >= buffer4.byteLength ? none2() : some3(newOffset)]);
  }));
}, "readChunkStreamByobReader");
var groupAdjacentBy = /* @__PURE__ */ dual(2, (self2, f) => {
  const groupAdjacentByChunk = /* @__PURE__ */ __name((state2, chunk4) => {
    if (isEmpty(chunk4)) {
      return [state2, empty4()];
    }
    const builder = [];
    let from = 0;
    let until = 0;
    let key = void 0;
    let previousChunk = empty4();
    switch (state2._tag) {
      case "Some": {
        const tuple5 = state2.value;
        key = tuple5[0];
        let loop5 = true;
        while (loop5 && until < chunk4.length) {
          const input = unsafeGet2(chunk4, until);
          const updatedKey = f(input);
          if (!equals(key, updatedKey)) {
            const previousChunk2 = tuple5[1];
            const additionalChunk = unsafeFromArray(Array.from(chunk4).slice(from, until));
            const group5 = appendAll2(previousChunk2, additionalChunk);
            builder.push([key, group5]);
            key = updatedKey;
            from = until;
            loop5 = false;
          }
          until = until + 1;
        }
        if (loop5) {
          previousChunk = tuple5[1];
        }
        break;
      }
      case "None": {
        key = f(unsafeGet2(chunk4, until));
        until = until + 1;
        break;
      }
    }
    while (until < chunk4.length) {
      const input = unsafeGet2(chunk4, until);
      const updatedKey = f(input);
      if (!equals(key, updatedKey)) {
        builder.push([key, unsafeFromArray(Array.from(chunk4).slice(from, until))]);
        key = updatedKey;
        from = until;
      }
      until = until + 1;
    }
    const nonEmptyChunk = appendAll2(previousChunk, unsafeFromArray(Array.from(chunk4).slice(from, until)));
    const output = unsafeFromArray(builder);
    return [some3([key, nonEmptyChunk]), output];
  }, "groupAdjacentByChunk");
  const groupAdjacent = /* @__PURE__ */ __name((state2) => readWithCause({
    onInput: /* @__PURE__ */ __name((input) => {
      const [updatedState, output] = groupAdjacentByChunk(state2, input);
      return isEmpty(output) ? groupAdjacent(updatedState) : flatMap18(write(output), () => groupAdjacent(updatedState));
    }, "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => match2(state2, {
      onNone: /* @__PURE__ */ __name(() => failCause11(cause3), "onNone"),
      onSome: /* @__PURE__ */ __name((output) => flatMap18(write(of2(output)), () => failCause11(cause3)), "onSome")
    }), "onFailure"),
    onDone: /* @__PURE__ */ __name((done12) => match2(state2, {
      onNone: /* @__PURE__ */ __name(() => succeedNow(done12), "onNone"),
      onSome: /* @__PURE__ */ __name((output) => flatMap18(write(of2(output)), () => succeedNow(done12)), "onSome")
    }), "onDone")
  }), "groupAdjacent");
  return new StreamImpl(pipeToOrFail(toChannel2(self2), groupAdjacent(none2())));
});
var grouped = /* @__PURE__ */ dual(2, (self2, chunkSize) => pipe(self2, rechunk(chunkSize), chunks));
var groupedWithin = /* @__PURE__ */ dual(3, (self2, chunkSize, duration4) => aggregateWithin(self2, collectAllN(chunkSize), spaced2(duration4)));
var haltWhen = /* @__PURE__ */ dual(2, (self2, effect4) => {
  const writer = /* @__PURE__ */ __name((fiber) => pipe(poll2(fiber), map22(match2({
    onNone: /* @__PURE__ */ __name(() => readWith({
      onInput: /* @__PURE__ */ __name((input) => flatMap18(write(input), () => writer(fiber)), "onInput"),
      onFailure: fail14,
      onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
    }), "onNone"),
    onSome: match9({
      onFailure: failCause11,
      onSuccess: /* @__PURE__ */ __name(() => void_8, "onSuccess")
    })
  })), unwrap3), "writer");
  return new StreamImpl(unwrapScopedWith((scope5) => effect4.pipe(forkIn2(scope5), map22((fiber) => toChannel2(self2).pipe(pipeTo(writer(fiber)))))));
});
var haltAfter = /* @__PURE__ */ dual(2, (self2, duration4) => pipe(self2, haltWhen(sleep2(duration4))));
var haltWhenDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => {
  const writer = pipe(poll3(deferred), map22(match2({
    onNone: /* @__PURE__ */ __name(() => readWith({
      onInput: /* @__PURE__ */ __name((input) => pipe(write(input), flatMap18(() => writer)), "onInput"),
      onFailure: fail14,
      onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
    }), "onNone"),
    onSome: /* @__PURE__ */ __name((effect4) => unwrap3(match15(effect4, {
      onFailure: fail14,
      onSuccess: /* @__PURE__ */ __name(() => void_8, "onSuccess")
    })), "onSome")
  })), unwrap3);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
});
var identityStream = /* @__PURE__ */ __name(() => new StreamImpl(identityChannel()), "identityStream");
var interleave = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, interleaveWith(that, forever5(make63(true, false)))));
var interleaveWith = /* @__PURE__ */ dual(3, (self2, that, decider) => {
  const producer = /* @__PURE__ */ __name((handoff) => readWithCause({
    onInput: /* @__PURE__ */ __name((value6) => flatMap18(fromEffect5(offer6(handoff, of5(value6))), () => producer(handoff)), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(offer6(handoff, failCause12(cause3))), "onFailure"),
    onDone: /* @__PURE__ */ __name(() => fromEffect5(offer6(handoff, end4)), "onDone")
  }), "producer");
  return new StreamImpl(unwrapScopedWith((scope5) => pipe(make62(), zip8(make62()), tap4(([left3]) => toChannel2(self2).pipe(concatMap(writeChunk), pipeTo(producer(left3)), runIn(scope5), forkIn2(scope5))), tap4(([_, right3]) => toChannel2(that).pipe(concatMap(writeChunk), pipeTo(producer(right3)), runIn(scope5), forkIn2(scope5))), map22(([left3, right3]) => {
    const process2 = /* @__PURE__ */ __name((leftDone, rightDone) => readWithCause({
      onInput: /* @__PURE__ */ __name((bool) => {
        if (bool && !leftDone) {
          return pipe(fromEffect5(take7(left3)), flatMap18(match22({
            onEnd: /* @__PURE__ */ __name(() => rightDone ? void_8 : process2(true, rightDone), "onEnd"),
            onFailure: failCause11,
            onSuccess: /* @__PURE__ */ __name((chunk4) => pipe(write(chunk4), flatMap18(() => process2(leftDone, rightDone))), "onSuccess")
          })));
        }
        if (!bool && !rightDone) {
          return pipe(fromEffect5(take7(right3)), flatMap18(match22({
            onEnd: /* @__PURE__ */ __name(() => leftDone ? void_8 : process2(leftDone, true), "onEnd"),
            onFailure: failCause11,
            onSuccess: /* @__PURE__ */ __name((chunk4) => pipe(write(chunk4), flatMap18(() => process2(leftDone, rightDone))), "onSuccess")
          })));
        }
        return process2(leftDone, rightDone);
      }, "onInput"),
      onFailure: failCause11,
      onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
    }), "process");
    return pipe(toChannel2(decider), concatMap(writeChunk), pipeTo(process2(false, false)));
  }))));
});
var intersperse2 = /* @__PURE__ */ dual(2, (self2, element2) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(suspend8(() => {
  const writer = /* @__PURE__ */ __name((isFirst) => readWithCause({
    onInput: /* @__PURE__ */ __name((chunk4) => {
      const builder = [];
      let flagResult = isFirst;
      for (const output of chunk4) {
        if (flagResult) {
          flagResult = false;
          builder.push(output);
        } else {
          builder.push(element2);
          builder.push(output);
        }
      }
      return pipe(write(unsafeFromArray(builder)), flatMap18(() => writer(flagResult)));
    }, "onInput"),
    onFailure: failCause11,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  }), "writer");
  return writer(true);
})))));
var intersperseAffixes = /* @__PURE__ */ dual(2, (self2, {
  end: end6,
  middle,
  start: start3
}) => pipe(make63(start3), concat2(pipe(self2, intersperse2(middle))), concat2(make63(end6))));
var interruptAfter = /* @__PURE__ */ dual(2, (self2, duration4) => pipe(self2, interruptWhen2(sleep2(duration4))));
var interruptWhen2 = /* @__PURE__ */ dual(2, (self2, effect4) => new StreamImpl(pipe(toChannel2(self2), interruptWhen(effect4))));
var interruptWhenDeferred2 = /* @__PURE__ */ dual(2, (self2, deferred) => new StreamImpl(pipe(toChannel2(self2), interruptWhenDeferred(deferred))));
var iterate4 = /* @__PURE__ */ __name((value6, next4) => unfold4(value6, (a) => some3([a, next4(a)])), "iterate");
var make63 = /* @__PURE__ */ __name((...as16) => fromIterable14(as16), "make");
var map32 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(map6(f)))));
var mapAccum5 = /* @__PURE__ */ dual(3, (self2, s, f) => {
  const accumulator = /* @__PURE__ */ __name((s2) => readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      const [nextS, chunk4] = mapAccum2(input, s2, f);
      return flatMap18(write(chunk4), () => accumulator(nextS));
    }, "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  }), "accumulator");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(accumulator(s))));
});
var mapAccumEffect = /* @__PURE__ */ dual(3, (self2, s, f) => suspend12(() => {
  const accumulator = /* @__PURE__ */ __name((s2) => readWith({
    onInput: /* @__PURE__ */ __name((input) => pipe(suspend4(() => {
      const outputs = [];
      const emit3 = /* @__PURE__ */ __name((output) => sync7(() => {
        outputs.push(output);
      }), "emit");
      return pipe(input, reduce13(s2, (s3, a) => pipe(f(s3, a), flatMap15(([s4, a2]) => pipe(emit3(a2), as8(s4))))), match15({
        onFailure: /* @__PURE__ */ __name((error5) => {
          if (outputs.length !== 0) {
            return zipRight8(write(unsafeFromArray(outputs)), fail14(error5));
          }
          return fail14(error5);
        }, "onFailure"),
        onSuccess: /* @__PURE__ */ __name((s3) => flatMap18(write(unsafeFromArray(outputs)), () => accumulator(s3)), "onSuccess")
      }));
    }), unwrap3), "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  }), "accumulator");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(accumulator(s))));
}));
var mapBoth9 = /* @__PURE__ */ dual(2, (self2, options4) => pipe(self2, mapError9(options4.onFailure), map32(options4.onSuccess)));
var mapChunks = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOut(f))));
var mapChunksEffect = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapOutEffect(f))));
var mapConcat = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapConcatChunk((a) => fromIterable3(f(a)))));
var mapConcatChunk = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapChunks(flatMap4(f))));
var mapConcatChunkEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential(f), mapConcatChunk(identity)));
var mapConcatEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapEffectSequential((a) => pipe(f(a), map22(fromIterable3))), mapConcatChunk(identity)));
var mapEffectSequential = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop5 = /* @__PURE__ */ __name((iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: /* @__PURE__ */ __name((elem) => loop5(elem[Symbol.iterator]()), "onInput"),
        onFailure: failCause11,
        onDone: succeed15
      });
    } else {
      const value6 = next4.value;
      return unwrap3(map22(f(value6), (a2) => flatMap18(write(of2(a2)), () => loop5(iterator))));
    }
  }, "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(suspend8(() => loop5(empty4()[Symbol.iterator]())))));
});
var mapEffectPar = /* @__PURE__ */ dual(3, (self2, n, f) => new StreamImpl(pipe(toChannel2(self2), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of2))));
var mapError9 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapError7(f))));
var mapErrorCause5 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), mapErrorCause4(f))));
var merge11 = /* @__PURE__ */ dual((args2) => isStream(args2[1]), (self2, that, options4) => mergeWith3(self2, that, {
  onSelf: identity,
  onOther: identity,
  haltStrategy: options4?.haltStrategy
}));
var mergeAll9 = /* @__PURE__ */ dual((args2) => Symbol.iterator in args2[0], (streams, options4) => flatten15(fromIterable14(streams), options4));
var mergeWithTag = /* @__PURE__ */ dual(2, (streams, options4) => {
  const keys6 = Object.keys(streams);
  const values6 = keys6.map((key) => streams[key].pipe(map32((value6) => ({
    _tag: key,
    value: value6
  }))));
  return mergeAll9(values6, options4);
});
var mergeEither = /* @__PURE__ */ dual(2, (self2, that) => mergeWith3(self2, that, {
  onSelf: left2,
  onOther: right2
}));
var mergeLeft = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, merge11(drain3(right3))));
var mergeRight = /* @__PURE__ */ dual(2, (left3, right3) => pipe(drain3(left3), merge11(right3)));
var mergeWith3 = /* @__PURE__ */ dual(3, (self2, other, options4) => {
  const strategy = options4.haltStrategy ? fromInput4(options4.haltStrategy) : Both2;
  const handler = /* @__PURE__ */ __name((terminate) => (exit5) => terminate || !isSuccess2(exit5) ? (
    // TODO: remove
    Done4(suspend4(() => exit5))
  ) : Await2((exit6) => suspend4(() => exit6)), "handler");
  return new StreamImpl(mergeWith2(toChannel2(map32(self2, options4.onSelf)), {
    other: toChannel2(map32(other, options4.onOther)),
    onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
    onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
  }));
});
var mkString2 = /* @__PURE__ */ __name((self2) => run4(self2, mkString), "mkString");
var never5 = /* @__PURE__ */ fromEffect8(never4);
var onEnd = /* @__PURE__ */ dual(2, (self2, effect4) => concat2(self2, drain3(fromEffect8(effect4))));
var onError3 = /* @__PURE__ */ dual(2, (self2, cleanup) => pipe(self2, catchAllCause6((cause3) => fromEffect8(pipe(cleanup(cause3), zipRight7(failCause9(cause3)))))));
var onDone = /* @__PURE__ */ dual(2, (self2, cleanup) => new StreamImpl(pipe(toChannel2(self2), ensuringWith((exit5) => isSuccess2(exit5) ? cleanup() : _void))));
var onStart = /* @__PURE__ */ dual(2, (self2, effect4) => unwrap4(as8(effect4, self2)));
var orDie6 = /* @__PURE__ */ __name((self2) => pipe(self2, orDieWith5(identity)), "orDie");
var orDieWith5 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel2(self2), orDieWith3(f))));
var orElse13 = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel2(self2), orElse11(() => toChannel2(that())))));
var orElseEither6 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, map32(left2), orElse13(() => pipe(that(), map32(right2)))));
var orElseFail4 = /* @__PURE__ */ dual(2, (self2, error5) => pipe(self2, orElse13(() => failSync8(error5))));
var orElseIfEmpty = /* @__PURE__ */ dual(2, (self2, element2) => pipe(self2, orElseIfEmptyChunk(() => of2(element2()))));
var orElseIfEmptyChunk = /* @__PURE__ */ dual(2, (self2, chunk4) => pipe(self2, orElseIfEmptyStream(() => new StreamImpl(write(chunk4())))));
var orElseIfEmptyStream = /* @__PURE__ */ dual(2, (self2, stream6) => {
  const writer = readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      if (isEmpty(input)) {
        return suspend8(() => writer);
      }
      return pipe(write(input), zipRight8(identityChannel()));
    }, "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => suspend8(() => toChannel2(stream6())), "onDone")
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(writer)));
});
var orElseSucceed4 = /* @__PURE__ */ dual(2, (self2, value6) => pipe(self2, orElse13(() => sync13(value6))));
var paginate = /* @__PURE__ */ __name((s, f) => paginateChunk(s, (s2) => {
  const page = f(s2);
  return [of2(page[0]), page[1]];
}), "paginate");
var paginateChunk = /* @__PURE__ */ __name((s, f) => {
  const loop5 = /* @__PURE__ */ __name((s2) => {
    const page = f(s2);
    return match2(page[1], {
      onNone: /* @__PURE__ */ __name(() => zipRight8(write(page[0]), void_8), "onNone"),
      onSome: /* @__PURE__ */ __name((s3) => flatMap18(write(page[0]), () => loop5(s3)), "onSome")
    });
  }, "loop");
  return new StreamImpl(suspend8(() => loop5(s)));
}, "paginateChunk");
var paginateChunkEffect = /* @__PURE__ */ __name((s, f) => {
  const loop5 = /* @__PURE__ */ __name((s2) => unwrap3(map22(f(s2), ([chunk4, option9]) => match2(option9, {
    onNone: /* @__PURE__ */ __name(() => zipRight8(write(chunk4), void_8), "onNone"),
    onSome: /* @__PURE__ */ __name((s3) => flatMap18(write(chunk4), () => loop5(s3)), "onSome")
  }))), "loop");
  return new StreamImpl(suspend8(() => loop5(s)));
}, "paginateChunkEffect");
var paginateEffect = /* @__PURE__ */ __name((s, f) => paginateChunkEffect(s, (s2) => pipe(f(s2), map22(([a, s3]) => [of2(a), s3]))), "paginateEffect");
var peel = /* @__PURE__ */ dual(2, (self2, sink) => {
  const OP_EMIT5 = "Emit";
  const OP_HALT2 = "Halt";
  const OP_END2 = "End";
  return pipe(make43(), flatMap15((deferred) => pipe(make62(), map22((handoff) => {
    const consumer = foldSink(collectLeftover(sink), {
      onFailure: /* @__PURE__ */ __name((error5) => zipRight10(fromEffect7(fail8(deferred, error5)), fail15(error5)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name(([z, leftovers]) => {
        const loop5 = readWithCause({
          onInput: /* @__PURE__ */ __name((elements) => flatMap18(fromEffect5(offer6(handoff, {
            _tag: OP_EMIT5,
            elements
          })), () => loop5), "onInput"),
          onFailure: /* @__PURE__ */ __name((cause3) => zipRight8(fromEffect5(offer6(handoff, {
            _tag: OP_HALT2,
            cause: cause3
          })), failCause11(cause3)), "onFailure"),
          onDone: /* @__PURE__ */ __name((_) => zipRight8(fromEffect5(offer6(handoff, {
            _tag: OP_END2
          })), void_8), "onDone")
        });
        return fromChannel(pipe(fromEffect5(succeed9(deferred, z)), zipRight8(fromEffect5(pipe(handoff, offer6({
          _tag: OP_EMIT5,
          elements: leftovers
        })))), zipRight8(loop5)));
      }, "onSuccess")
    });
    const producer = pipe(take7(handoff), map22((signal) => {
      switch (signal._tag) {
        case OP_EMIT5: {
          return pipe(write(signal.elements), flatMap18(() => producer));
        }
        case OP_HALT2: {
          return failCause11(signal.cause);
        }
        case OP_END2: {
          return void_8;
        }
      }
    }), unwrap3);
    return pipe(self2, tapErrorCause5((cause3) => failCause7(deferred, cause3)), run4(consumer), forkScoped2, zipRight7(_await3(deferred)), map22((z) => [z, new StreamImpl(producer)]));
  }))), flatten10);
});
var partition8 = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options4) => partitionEither(self2, (a) => succeed11(predicate(a) ? right2(a) : left2(a)), options4));
var partitionEither = /* @__PURE__ */ dual((args2) => typeof args2[1] === "function", (self2, predicate, options4) => pipe(mapEffectSequential(self2, predicate), distributedWith({
  size: 2,
  maximumLag: options4?.bufferSize ?? 16,
  decide: match({
    onLeft: /* @__PURE__ */ __name(() => succeed11((n) => n === 0), "onLeft"),
    onRight: /* @__PURE__ */ __name(() => succeed11((n) => n === 1), "onRight")
  })
}), flatMap15(([queue1, queue2]) => succeed11([filterMap8(flattenExitOption(fromQueue2(queue1, {
  shutdown: true
})), (_) => match(_, {
  onLeft: some3,
  onRight: none2
})), filterMap8(flattenExitOption(fromQueue2(queue2, {
  shutdown: true
})), (_) => match(_, {
  onLeft: none2,
  onRight: some3
}))]))));
var pipeThrough = /* @__PURE__ */ dual(2, (self2, sink) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)))));
var pipeThroughChannel = /* @__PURE__ */ dual(2, (self2, channel2) => new StreamImpl(pipeTo(toChannel2(self2), channel2)));
var pipeThroughChannelOrFail = /* @__PURE__ */ dual(2, (self2, chan) => new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(chan))));
var prepend4 = /* @__PURE__ */ dual(2, (self2, values6) => new StreamImpl(zipRight8(write(values6), toChannel2(self2))));
var provideContext7 = /* @__PURE__ */ dual(2, (self2, context17) => new StreamImpl(pipe(toChannel2(self2), provideContext4(context17))));
var provideSomeContext3 = /* @__PURE__ */ dual(2, (self2, context17) => mapInputContext6(self2, merge3(context17)));
var provideLayer = /* @__PURE__ */ dual(2, (self2, layer14) => new StreamImpl(unwrapScopedWith((scope5) => buildWithScope2(layer14, scope5).pipe(map22((env3) => pipe(toChannel2(self2), provideContext4(env3)))))));
var provideService8 = /* @__PURE__ */ dual(3, (self2, tag8, resource) => provideServiceEffect3(self2, tag8, succeed11(resource)));
var provideServiceEffect3 = /* @__PURE__ */ dual(3, (self2, tag8, effect4) => provideServiceStream(self2, tag8, fromEffect8(effect4)));
var provideServiceStream = /* @__PURE__ */ dual(3, (self2, tag8, stream6) => contextWithStream((env3) => flatMap21(stream6, (service3) => pipe(self2, provideContext7(add4(env3, tag8, service3))))));
var mapInputContext6 = /* @__PURE__ */ dual(2, (self2, f) => contextWithStream((env3) => pipe(self2, provideContext7(f(env3)))));
var provideSomeLayer2 = /* @__PURE__ */ dual(2, (self2, layer14) => (
  // @ts-expect-error
  // @effect-diagnostics-next-line missingEffectContext:off
  pipe(self2, provideLayer(pipe(context5(), merge8(layer14))))
));
var range3 = /* @__PURE__ */ __name((min6, max9, chunkSize = DefaultChunkSize) => suspend12(() => {
  if (min6 > max9) {
    return empty36;
  }
  const go3 = /* @__PURE__ */ __name((min7, max10, chunkSize2) => {
    const remaining = max10 - min7 + 1;
    if (remaining > chunkSize2) {
      return pipe(write(range2(min7, min7 + chunkSize2 - 1)), flatMap18(() => go3(min7 + chunkSize2, max10, chunkSize2)));
    }
    return write(range2(min7, min7 + remaining - 1));
  }, "go");
  return new StreamImpl(go3(min6, max9, chunkSize));
}), "range");
var race3 = /* @__PURE__ */ dual(2, (left3, right3) => raceAll3(left3, right3));
var raceAll3 = /* @__PURE__ */ __name((...streams) => make43().pipe(map22((halt2) => {
  let winner = null;
  return mergeAll9(streams.map((stream6, index2) => stream6.pipe(takeWhile5(() => {
    if (winner === null) {
      winner = index2;
      unsafeDone(halt2, void_5);
      return true;
    }
    return winner === index2;
  }), interruptWhen2(_await3(halt2).pipe(flatMap15(() => winner === index2 ? never4 : _void))))), {
    concurrency: streams.length
  });
}), unwrap4), "raceAll");
var rechunk = /* @__PURE__ */ dual(2, (self2, n) => suspend12(() => {
  const target3 = Math.max(n, 1);
  const process2 = rechunkProcess(new StreamRechunker(target3), target3);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(process2)));
}));
var rechunkProcess = /* @__PURE__ */ __name((rechunker, target3) => readWithCause({
  onInput: /* @__PURE__ */ __name((chunk4) => {
    if (chunk4.length === target3 && rechunker.isEmpty()) {
      return flatMap18(write(chunk4), () => rechunkProcess(rechunker, target3));
    }
    if (chunk4.length > 0) {
      const chunks3 = [];
      let result = void 0;
      let index2 = 0;
      while (index2 < chunk4.length) {
        while (index2 < chunk4.length && result === void 0) {
          result = rechunker.write(pipe(chunk4, unsafeGet2(index2)));
          index2 = index2 + 1;
        }
        if (result !== void 0) {
          chunks3.push(result);
          result = void 0;
        }
      }
      return flatMap18(writeAll(...chunks3), () => rechunkProcess(rechunker, target3));
    }
    return suspend8(() => rechunkProcess(rechunker, target3));
  }, "onInput"),
  onFailure: /* @__PURE__ */ __name((cause3) => zipRight8(rechunker.emitIfNotEmpty(), failCause11(cause3)), "onFailure"),
  onDone: /* @__PURE__ */ __name(() => rechunker.emitIfNotEmpty(), "onDone")
}), "rechunkProcess");
var StreamRechunker = class {
  static {
    __name(this, "StreamRechunker");
  }
  n;
  builder = [];
  pos = 0;
  constructor(n) {
    this.n = n;
  }
  isEmpty() {
    return this.pos === 0;
  }
  write(elem) {
    this.builder.push(elem);
    this.pos += 1;
    if (this.pos === this.n) {
      const result = unsafeFromArray(this.builder);
      this.builder = [];
      this.pos = 0;
      return result;
    }
    return void 0;
  }
  emitIfNotEmpty() {
    if (this.pos !== 0) {
      return write(unsafeFromArray(this.builder));
    }
    return void_8;
  }
};
var refineOrDie2 = /* @__PURE__ */ dual(2, (self2, pf) => pipe(self2, refineOrDieWith2(pf, identity)));
var refineOrDieWith2 = /* @__PURE__ */ dual(3, (self2, pf, f) => new StreamImpl(catchAll5(toChannel2(self2), (error5) => match2(pf(error5), {
  onNone: /* @__PURE__ */ __name(() => failCause11(die4(f(error5))), "onNone"),
  onSome: fail14
}))));
var repeat3 = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap8(repeatEither(self2, schedule4), (_) => match(_, {
  onLeft: none2,
  onRight: some3
})));
var repeatEffect = /* @__PURE__ */ __name((effect4) => repeatEffectOption(pipe(effect4, mapError4(some3))), "repeatEffect");
var repeatEffectChunk = /* @__PURE__ */ __name((effect4) => repeatEffectChunkOption(pipe(effect4, mapError4(some3))), "repeatEffectChunk");
var repeatEffectChunkOption = /* @__PURE__ */ __name((effect4) => unfoldChunkEffect(effect4, (effect5) => pipe(map22(effect5, (chunk4) => some3([chunk4, effect5])), catchAll3(match2({
  onNone: /* @__PURE__ */ __name(() => succeed11(none2()), "onNone"),
  onSome: fail10
})))), "repeatEffectChunkOption");
var repeatEffectOption = /* @__PURE__ */ __name((effect4) => repeatEffectChunkOption(pipe(effect4, map22(of2))), "repeatEffectOption");
var repeatEither = /* @__PURE__ */ dual(2, (self2, schedule4) => repeatWith(self2, schedule4, {
  onElement: /* @__PURE__ */ __name((a) => right2(a), "onElement"),
  onSchedule: left2
}));
var repeatElements = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap8(repeatElementsWith(self2, schedule4, {
  onElement: /* @__PURE__ */ __name((a) => some3(a), "onElement"),
  onSchedule: none2
}), identity));
var repeatElementsWith = /* @__PURE__ */ dual(3, (self2, schedule4, options4) => {
  const driver3 = pipe(driver2(schedule4), map22((driver4) => {
    const feed = /* @__PURE__ */ __name((input) => match2(head3(input), {
      onNone: /* @__PURE__ */ __name(() => loop5, "onNone"),
      onSome: /* @__PURE__ */ __name((a) => zipRight8(write(of2(options4.onElement(a))), step4(pipe(input, drop2(1)), a)), "onSome")
    }), "feed");
    const step4 = /* @__PURE__ */ __name((input, a) => {
      const advance = pipe(driver4.next(a), as8(pipe(write(of2(options4.onElement(a))), flatMap18(() => step4(input, a)))));
      const reset2 = pipe(driver4.last, orDie3, flatMap15((b) => pipe(driver4.reset, map22(() => pipe(write(of2(options4.onSchedule(b))), zipRight8(feed(input)))))));
      return pipe(advance, orElse7(() => reset2), unwrap3);
    }, "step");
    const loop5 = readWith({
      onInput: feed,
      onFailure: fail14,
      onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
    });
    return loop5;
  }), unwrap3);
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(driver3)));
});
var repeatValue = /* @__PURE__ */ __name((value6) => new StreamImpl(repeated(write(of2(value6)))), "repeatValue");
var repeatWith = /* @__PURE__ */ dual(3, (self2, schedule4, options4) => {
  return pipe(driver2(schedule4), map22((driver3) => {
    const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
    const process2 = pipe(self2, provideLastIterationInfo, map32(options4.onElement), toChannel2);
    const loop5 = unwrap3(match15(driver3.next(void 0), {
      onFailure: /* @__PURE__ */ __name(() => void_8, "onFailure"),
      onSuccess: /* @__PURE__ */ __name((output) => flatMap18(process2, () => zipRight8(write(of2(options4.onSchedule(output))), loop5)), "onSuccess")
    }));
    return new StreamImpl(zipRight8(process2, loop5));
  }), unwrap4);
});
var repeatWithSchedule = /* @__PURE__ */ __name((value6, schedule4) => repeatEffectWithSchedule(succeed11(value6), schedule4), "repeatWithSchedule");
var repeatEffectWithSchedule = /* @__PURE__ */ __name((effect4, schedule4) => flatMap21(fromEffect8(zip8(effect4, driver2(schedule4))), ([a, driver3]) => {
  const provideLastIterationInfo = provideServiceEffect2(CurrentIterationMetadata2, get12(driver3.iterationMeta));
  return concat2(succeed19(a), unfoldEffect(a, (s) => matchEffect3(driver3.next(s), {
    onFailure: succeed11,
    onSuccess: /* @__PURE__ */ __name(() => map22(provideLastIterationInfo(effect4), (nextA) => some3([nextA, nextA])), "onSuccess")
  })));
}), "repeatEffectWithSchedule");
var retry6 = /* @__PURE__ */ dual(2, (self2, policy2) => driver2(policy2).pipe(map22((driver3) => {
  const provideLastIterationInfo = provideServiceEffect3(CurrentIterationMetadata2, get12(driver3.iterationMeta));
  const loop5 = toChannel2(provideLastIterationInfo(self2)).pipe(mapOutEffect((out) => as8(driver3.reset, out)), catchAll5((error5) => driver3.next(error5).pipe(match15({
    onFailure: /* @__PURE__ */ __name(() => fail14(error5), "onFailure"),
    onSuccess: /* @__PURE__ */ __name(() => loop5, "onSuccess")
  }), unwrap3)));
  return loop5;
}), unwrap3, fromChannel2));
var withExecutionPlan3 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, policy2, options4) => suspend12(() => {
  const preventFallbackOnPartialStream = options4?.preventFallbackOnPartialStream ?? false;
  let i = 0;
  let lastError = none2();
  const loop5 = suspend12(() => {
    const step4 = policy2.steps[i++];
    if (!step4) {
      return fail18(getOrThrow2(lastError));
    }
    let nextStream = isContext2(step4.provide) ? provideSomeContext3(self2, step4.provide) : provideSomeLayer2(self2, step4.provide);
    let receivedElements = false;
    if (isSome2(lastError)) {
      const error5 = lastError.value;
      let attempted = false;
      const wrapped = nextStream;
      nextStream = suspend12(() => {
        if (attempted) return wrapped;
        attempted = true;
        return fail18(error5);
      });
      nextStream = scheduleDefectRefail2(retry6(nextStream, scheduleFromStep(step4, false)));
    } else {
      const schedule4 = scheduleFromStep(step4, true);
      nextStream = schedule4 ? scheduleDefectRefail2(retry6(nextStream, schedule4)) : nextStream;
    }
    return catchAll7(preventFallbackOnPartialStream ? mapChunks(nextStream, (chunk4) => {
      receivedElements = true;
      return chunk4;
    }) : nextStream, (error5) => {
      if (preventFallbackOnPartialStream && receivedElements) {
        return fail18(error5);
      }
      lastError = some3(error5);
      return loop5;
    });
  });
  return loop5;
}));
var scheduleDefectRefail2 = /* @__PURE__ */ __name((self2) => catchAllCause6(self2, (cause3) => failCause14(scheduleDefectRefailCause(cause3))), "scheduleDefectRefail");
var run4 = /* @__PURE__ */ dual(2, (self2, sink) => toChannel2(self2).pipe(pipeToOrFail(toChannel(sink)), runDrain));
var runCollect = /* @__PURE__ */ __name((self2) => run4(self2, collectAll()), "runCollect");
var runCount = /* @__PURE__ */ __name((self2) => run4(self2, count5), "runCount");
var runDrain2 = /* @__PURE__ */ __name((self2) => run4(self2, drain2), "runDrain");
var runFold = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhile(self2, s, constTrue, f));
var runFoldEffect = /* @__PURE__ */ dual(3, (self2, s, f) => runFoldWhileEffect(self2, s, constTrue, f));
var runFoldScoped = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScoped(s, constTrue, f)));
var runFoldScopedEffect = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, runFoldWhileScopedEffect(s, constTrue, f)));
var runFoldWhile = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run4(self2, fold(s, cont, f)));
var runFoldWhileEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => run4(self2, foldEffect(s, cont, f)));
var runFoldWhileScoped = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(fold(s, cont, f))));
var runFoldWhileScopedEffect = /* @__PURE__ */ dual(4, (self2, s, cont, f) => pipe(self2, runScoped2(foldEffect(s, cont, f))));
var runForEach = /* @__PURE__ */ dual(2, (self2, f) => run4(self2, forEach12(f)));
var runForEachChunk = /* @__PURE__ */ dual(2, (self2, f) => run4(self2, forEachChunk(f)));
var runForEachChunkScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachChunk(f))));
var runForEachScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEach12(f))));
var runForEachWhile = /* @__PURE__ */ dual(2, (self2, f) => run4(self2, forEachWhile(f)));
var runForEachWhileScoped = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, runScoped2(forEachWhile(f))));
var runHead = /* @__PURE__ */ __name((self2) => run4(self2, head7()), "runHead");
var runIntoPubSub = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueue(pubsub)));
var runIntoPubSubScoped = /* @__PURE__ */ dual(2, (self2, pubsub) => pipe(self2, runIntoQueueScoped(pubsub)));
var runIntoQueue = /* @__PURE__ */ dual(2, (self2, queue) => pipe(self2, runIntoQueueScoped(queue), scoped3));
var runIntoQueueElementsScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
  const writer = readWithCause({
    onInput: /* @__PURE__ */ __name((input) => flatMap18(fromEffect5(offerAll3(queue, map6(input, succeed3))), () => writer), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(offer3(queue, failCause3(map18(cause3, some3)))), "onFailure"),
    onDone: /* @__PURE__ */ __name(() => fromEffect5(offer3(queue, fail3(none2()))), "onDone")
  });
  return pipe(pipeTo(toChannel2(self2), writer), drain, runScoped, asVoid5);
});
var runIntoQueueScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
  const writer = readWithCause({
    onInput: /* @__PURE__ */ __name((input) => flatMap18(write(chunk3(input)), () => writer), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => write(failCause12(cause3)), "onFailure"),
    onDone: /* @__PURE__ */ __name(() => write(end4), "onDone")
  });
  return pipe(pipeTo(toChannel2(self2), writer), mapOutEffect((take11) => offer3(queue, take11)), drain, runScoped, asVoid5);
});
var runLast = /* @__PURE__ */ __name((self2) => run4(self2, last4()), "runLast");
var runScoped2 = /* @__PURE__ */ dual(2, (self2, sink) => pipe(toChannel2(self2), pipeToOrFail(toChannel(sink)), drain, runScoped));
var runSum = /* @__PURE__ */ __name((self2) => run4(self2, sum2), "runSum");
var scan2 = /* @__PURE__ */ dual(3, (self2, s, f) => pipe(self2, scanEffect(s, (s2, a) => succeed11(f(s2, a)))));
var scanReduce = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, scanReduceEffect((a2, a) => succeed11(f(a2, a)))));
var scanReduceEffect = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, mapAccumEffect(none2(), (option9, a) => {
  switch (option9._tag) {
    case "None": {
      return succeed11([some3(a), a]);
    }
    case "Some": {
      return pipe(f(option9.value, a), map22((b) => [some3(b), b]));
    }
  }
})));
var schedule2 = /* @__PURE__ */ dual(2, (self2, schedule4) => filterMap8(scheduleWith(self2, schedule4, {
  onElement: some3,
  onSchedule: none2
}), identity));
var scheduleWith = /* @__PURE__ */ dual(3, (self2, schedule4, options4) => {
  const loop5 = /* @__PURE__ */ __name((driver3, iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: /* @__PURE__ */ __name((chunk4) => loop5(driver3, chunk4[Symbol.iterator]()), "onInput"),
        onFailure: failCause11,
        onDone: succeedNow
      });
    }
    return unwrap3(matchEffect3(driver3.next(next4.value), {
      onFailure: /* @__PURE__ */ __name(() => pipe(driver3.last, orDie3, map22((b) => pipe(write(make5(options4.onElement(next4.value), options4.onSchedule(b))), flatMap18(() => loop5(driver3, iterator)))), zipLeft7(driver3.reset)), "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => succeed11(pipe(write(of2(options4.onElement(next4.value))), flatMap18(() => loop5(driver3, iterator)))), "onSuccess")
    }));
  }, "loop");
  return new StreamImpl(pipe(fromEffect5(driver2(schedule4)), flatMap18((driver3) => pipe(toChannel2(self2), pipeTo(loop5(driver3, empty4()[Symbol.iterator]()))))));
});
var scanEffect = /* @__PURE__ */ dual(3, (self2, s, f) => new StreamImpl(pipe(write(of2(s)), flatMap18(() => toChannel2(pipe(self2, mapAccumEffect(s, (s2, a) => pipe(f(s2, a), map22((s3) => [s3, s3])))))))));
var scoped6 = /* @__PURE__ */ __name((effect4) => new StreamImpl(ensuring4(scoped5(pipe(effect4, map22(of2))), _void)), "scoped");
var scopedWith4 = /* @__PURE__ */ __name((f) => new StreamImpl(scopedWith3((scope5) => f(scope5).pipe(map22(of2)))), "scopedWith");
var some11 = /* @__PURE__ */ __name((self2) => pipe(self2, mapError9(some3), someOrFail(() => none2())), "some");
var someOrElse = /* @__PURE__ */ dual(2, (self2, fallback) => pipe(self2, map32(getOrElse2(fallback))));
var someOrFail = /* @__PURE__ */ dual(2, (self2, error5) => mapEffectSequential(self2, match2({
  onNone: /* @__PURE__ */ __name(() => failSync4(error5), "onNone"),
  onSome: succeed11
})));
var sliding8 = /* @__PURE__ */ dual(2, (self2, chunkSize) => slidingSize(self2, chunkSize, 1));
var slidingSize = /* @__PURE__ */ dual(3, (self2, chunkSize, stepSize) => {
  if (chunkSize <= 0 || stepSize <= 0) {
    return die11(new IllegalArgumentException2("Invalid bounds - `chunkSize` and `stepSize` must be greater than zero"));
  }
  return new StreamImpl(suspend8(() => {
    const queue = new RingBuffer(chunkSize);
    const emitOnStreamEnd = /* @__PURE__ */ __name((queueSize, channelEnd) => {
      if (queueSize < chunkSize) {
        const items = queue.toChunk();
        const result2 = isEmpty(items) ? empty4() : of2(items);
        return pipe(write(result2), flatMap18(() => channelEnd));
      }
      const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize;
      if (lastEmitIndex === queueSize) {
        return channelEnd;
      }
      const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize);
      const lastItems = pipe(queue.toChunk(), takeRight2(leftovers));
      const result = isEmpty(lastItems) ? empty4() : of2(lastItems);
      return pipe(write(result), flatMap18(() => channelEnd));
    }, "emitOnStreamEnd");
    const reader = /* @__PURE__ */ __name((queueSize) => readWithCause({
      onInput: /* @__PURE__ */ __name((input) => flatMap18(write(filterMap3(input, (element2, index2) => {
        queue.put(element2);
        const currentIndex = queueSize + index2 + 1;
        if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {
          return none2();
        }
        return some3(queue.toChunk());
      })), () => reader(queueSize + input.length)), "onInput"),
      onFailure: /* @__PURE__ */ __name((cause3) => emitOnStreamEnd(queueSize, failCause11(cause3)), "onFailure"),
      onDone: /* @__PURE__ */ __name(() => emitOnStreamEnd(queueSize, void_8), "onDone")
    }), "reader");
    return pipe(toChannel2(self2), pipeTo(reader(0)));
  }));
});
var split4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const split6 = /* @__PURE__ */ __name((leftovers, input) => {
    const [chunk4, remaining] = pipe(leftovers, appendAll2(input), splitWhere2(predicate));
    if (isEmpty(chunk4) || isEmpty(remaining)) {
      return loop5(pipe(chunk4, appendAll2(pipe(remaining, drop2(1)))));
    }
    return pipe(write(of2(chunk4)), flatMap18(() => split6(empty4(), pipe(remaining, drop2(1)))));
  }, "split");
  const loop5 = /* @__PURE__ */ __name((leftovers) => readWith({
    onInput: /* @__PURE__ */ __name((input) => split6(leftovers, input), "onInput"),
    onFailure: fail14,
    onDone: /* @__PURE__ */ __name(() => {
      if (isEmpty(leftovers)) {
        return void_8;
      }
      if (isNone2(pipe(leftovers, findFirst3(predicate)))) {
        return zipRight8(write(of2(leftovers)), void_8);
      }
      return zipRight8(split6(empty4(), leftovers), void_8);
    }, "onDone")
  }), "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop5(empty4()))));
});
var splitOnChunk = /* @__PURE__ */ dual(2, (self2, delimiter) => {
  const next4 = /* @__PURE__ */ __name((leftover2, delimiterIndex) => readWithCause({
    onInput: /* @__PURE__ */ __name((inputChunk) => {
      let buffer4;
      const [carry, delimiterCursor] = pipe(inputChunk, reduce2([pipe(leftover2, getOrElse2(() => empty4())), delimiterIndex], ([carry2, delimiterCursor2], a) => {
        const concatenated = pipe(carry2, append2(a));
        if (delimiterCursor2 < delimiter.length && equals(a, pipe(delimiter, unsafeGet2(delimiterCursor2)))) {
          if (delimiterCursor2 + 1 === delimiter.length) {
            if (buffer4 === void 0) {
              buffer4 = [];
            }
            buffer4.push(pipe(concatenated, take2(concatenated.length - delimiter.length)));
            return [empty4(), 0];
          }
          return [concatenated, delimiterCursor2 + 1];
        }
        return [concatenated, equals(a, pipe(delimiter, unsafeGet2(0))) ? 1 : 0];
      }));
      const output = buffer4 === void 0 ? empty4() : unsafeFromArray(buffer4);
      return flatMap18(write(output), () => next4(isNonEmpty(carry) ? some3(carry) : none2(), delimiterCursor));
    }, "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => match2(leftover2, {
      onNone: /* @__PURE__ */ __name(() => failCause11(cause3), "onNone"),
      onSome: /* @__PURE__ */ __name((chunk4) => zipRight8(write(of2(chunk4)), failCause11(cause3)), "onSome")
    }), "onFailure"),
    onDone: /* @__PURE__ */ __name((done12) => match2(leftover2, {
      onNone: /* @__PURE__ */ __name(() => succeed15(done12), "onNone"),
      onSome: /* @__PURE__ */ __name((chunk4) => zipRight8(write(of2(chunk4)), succeed15(done12)), "onSome")
    }), "onDone")
  }), "next");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(next4(none2(), 0))));
});
var splitLines2 = /* @__PURE__ */ __name((self2) => pipeThroughChannel(self2, splitLines()), "splitLines");
var succeed19 = /* @__PURE__ */ __name((value6) => fromChunk(of2(value6)), "succeed");
var sync13 = /* @__PURE__ */ __name((evaluate3) => suspend12(() => fromChunk(of2(evaluate3()))), "sync");
var suspend12 = /* @__PURE__ */ __name((stream6) => new StreamImpl(suspend8(() => toChannel2(stream6()))), "suspend");
var take8 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (!Number.isInteger(n)) {
    return die11(new IllegalArgumentException2(`${n} must be an integer`));
  }
  const loop5 = /* @__PURE__ */ __name((n2) => readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      const taken = pipe(input, take2(Math.min(n2, Number.POSITIVE_INFINITY)));
      const leftover2 = Math.max(0, n2 - taken.length);
      const more = leftover2 > 0;
      if (more) {
        return pipe(write(taken), flatMap18(() => loop5(leftover2)));
      }
      return write(taken);
    }, "onInput"),
    onFailure: fail14,
    onDone: succeed15
  }), "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(0 < n ? loop5(n) : void_8)));
});
var takeRight3 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return empty36;
  }
  return new StreamImpl(pipe(succeed11(new RingBuffer(n)), map22((queue) => {
    const reader = readWith({
      onInput: /* @__PURE__ */ __name((input) => {
        for (const element2 of input) {
          queue.put(element2);
        }
        return reader;
      }, "onInput"),
      onFailure: fail14,
      onDone: /* @__PURE__ */ __name(() => pipe(write(queue.toChunk()), zipRight8(void_8)), "onDone")
    });
    return pipe(toChannel2(self2), pipeTo(reader));
  }), unwrap3));
});
var takeUntil3 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop5 = readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      const taken = pipe(input, takeWhile2((a) => !predicate(a)));
      const last5 = pipe(input, drop2(taken.length), take2(1));
      if (isEmpty(last5)) {
        return pipe(write(taken), flatMap18(() => loop5));
      }
      return write(pipe(taken, appendAll2(last5)));
    }, "onInput"),
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop5)));
});
var takeUntilEffect = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop5 = /* @__PURE__ */ __name((iterator) => {
    const next4 = iterator.next();
    if (next4.done) {
      return readWithCause({
        onInput: /* @__PURE__ */ __name((elem) => loop5(elem[Symbol.iterator]()), "onInput"),
        onFailure: failCause11,
        onDone: succeed15
      });
    }
    return pipe(predicate(next4.value), map22((bool) => bool ? write(of2(next4.value)) : pipe(write(of2(next4.value)), flatMap18(() => loop5(iterator)))), unwrap3);
  }, "loop");
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop5(empty4()[Symbol.iterator]()))));
});
var takeWhile5 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  const loop5 = readWith({
    onInput: /* @__PURE__ */ __name((input) => {
      const taken = pipe(input, takeWhile2(predicate));
      const more = taken.length === input.length;
      if (more) {
        return pipe(write(taken), flatMap18(() => loop5));
      }
      return write(taken);
    }, "onInput"),
    onFailure: fail14,
    onDone: succeed15
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(loop5)));
});
var tap7 = /* @__PURE__ */ dual(2, (self2, f) => mapEffectSequential(self2, (a) => as8(f(a), a)));
var tapBoth4 = /* @__PURE__ */ dual(2, (self2, options4) => pipe(self2, tapError6(options4.onFailure), tap7(options4.onSuccess)));
var tapError6 = /* @__PURE__ */ dual(2, (self2, f) => catchAll7(self2, (error5) => fromEffect8(zipRight7(f(error5), fail10(error5)))));
var tapErrorCause5 = /* @__PURE__ */ dual(2, (self2, f) => {
  const loop5 = readWithCause({
    onInput: /* @__PURE__ */ __name((chunk4) => flatMap18(write(chunk4), () => loop5), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(zipRight7(f(cause3), failCause9(cause3))), "onFailure"),
    onDone: succeedNow
  });
  return new StreamImpl(pipe(toChannel2(self2), pipeTo(loop5)));
});
var tapSink = /* @__PURE__ */ dual(2, (self2, sink) => pipe(fromEffect8(all8([bounded3(1), make43()])), flatMap21(([queue, deferred]) => {
  const right3 = flattenTake(fromQueue2(queue, {
    maxChunkSize: 1
  }));
  const loop5 = readWithCause({
    onInput: /* @__PURE__ */ __name((chunk4) => pipe(fromEffect5(offer3(queue, chunk3(chunk4))), foldCauseChannel({
      onFailure: /* @__PURE__ */ __name(() => flatMap18(write(chunk4), () => identityChannel()), "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => flatMap18(write(chunk4), () => loop5), "onSuccess")
    })), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => pipe(fromEffect5(offer3(queue, failCause12(cause3))), foldCauseChannel({
      onFailure: /* @__PURE__ */ __name(() => failCause11(cause3), "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => failCause11(cause3), "onSuccess")
    })), "onFailure"),
    onDone: /* @__PURE__ */ __name(() => pipe(fromEffect5(offer3(queue, end4)), foldCauseChannel({
      onFailure: /* @__PURE__ */ __name(() => void_8, "onFailure"),
      onSuccess: /* @__PURE__ */ __name(() => void_8, "onSuccess")
    })), "onDone")
  });
  return pipe(new StreamImpl(pipe(pipeTo(toChannel2(self2), loop5), ensuring4(zipRight7(forkDaemon2(offer3(queue, end4)), _await3(deferred))))), merge11(execute(pipe(run4(right3, sink), ensuring3(zipRight7(shutdown2(queue), succeed9(deferred, void 0)))))));
})));
var throttle = /* @__PURE__ */ dual(2, (self2, options4) => throttleEffect(self2, {
  ...options4,
  cost: /* @__PURE__ */ __name((chunk4) => succeed11(options4.cost(chunk4)), "cost")
}));
var throttleEffect = /* @__PURE__ */ dual(2, (self2, options4) => {
  if (options4.strategy === "enforce") {
    return throttleEnforceEffect(self2, options4.cost, options4.units, options4.duration, options4.burst ?? 0);
  }
  return throttleShapeEffect(self2, options4.cost, options4.units, options4.duration, options4.burst ?? 0);
});
var throttleEnforceEffect = /* @__PURE__ */ __name((self2, cost, units, duration4, burst) => {
  const loop5 = /* @__PURE__ */ __name((tokens, timestampMillis) => readWithCause({
    onInput: /* @__PURE__ */ __name((input) => pipe(cost(input), zip8(currentTimeMillis2), map22(([weight, currentTimeMillis3]) => {
      const elapsed3 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration4);
      const sum3 = tokens + cycles * units;
      const max9 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max9 : Math.min(sum3, max9);
      if (weight <= available) {
        return pipe(write(input), flatMap18(() => loop5(available - weight, currentTimeMillis3)));
      }
      return loop5(tokens, timestampMillis);
    }), unwrap3), "onInput"),
    onFailure: failCause11,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  }), "loop");
  const throttled = pipe(currentTimeMillis2, map22((currentTimeMillis3) => loop5(units, currentTimeMillis3)), unwrap3);
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
}, "throttleEnforceEffect");
var throttleShapeEffect = /* @__PURE__ */ __name((self2, costFn, units, duration4, burst) => {
  const loop5 = /* @__PURE__ */ __name((tokens, timestampMillis) => readWithCause({
    onInput: /* @__PURE__ */ __name((input) => pipe(costFn(input), zip8(currentTimeMillis2), map22(([weight, currentTimeMillis3]) => {
      const elapsed3 = currentTimeMillis3 - timestampMillis;
      const cycles = elapsed3 / toMillis(duration4);
      const sum3 = tokens + cycles * units;
      const max9 = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst;
      const available = sum3 < 0 ? max9 : Math.min(sum3, max9);
      const remaining = available - weight;
      const waitCycles = remaining >= 0 ? 0 : -remaining / units;
      const delay3 = millis(Math.max(0, waitCycles * toMillis(duration4)));
      if (greaterThan2(delay3, zero)) {
        return pipe(fromEffect5(sleep2(delay3)), zipRight8(write(input)), flatMap18(() => loop5(remaining, currentTimeMillis3)));
      }
      return flatMap18(write(input), () => loop5(remaining, currentTimeMillis3));
    }), unwrap3), "onInput"),
    onFailure: failCause11,
    onDone: /* @__PURE__ */ __name(() => void_8, "onDone")
  }), "loop");
  const throttled = pipe(currentTimeMillis2, map22((currentTimeMillis3) => loop5(units, currentTimeMillis3)), unwrap3);
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(throttled)));
}, "throttleShapeEffect");
var tick = /* @__PURE__ */ __name((interval) => repeatWithSchedule(void 0, spaced2(interval)), "tick");
var timeout3 = /* @__PURE__ */ dual(2, (self2, duration4) => pipe(toPull2(self2), map22(timeoutFail2({
  onTimeout: /* @__PURE__ */ __name(() => none2(), "onTimeout"),
  duration: duration4
})), fromPull2));
var timeoutFail3 = /* @__PURE__ */ dual(3, (self2, error5, duration4) => pipe(self2, timeoutTo3(duration4, failSync8(error5))));
var timeoutFailCause3 = /* @__PURE__ */ dual(3, (self2, cause3, duration4) => pipe(toPull2(self2), map22(timeoutFailCause2({
  onTimeout: /* @__PURE__ */ __name(() => map18(cause3(), some3), "onTimeout"),
  duration: duration4
})), fromPull2));
var timeoutTo3 = /* @__PURE__ */ dual(3, (self2, duration4, that) => {
  const StreamTimeout = new RuntimeException2("Stream Timeout");
  return pipe(self2, timeoutFailCause3(() => die4(StreamTimeout), duration4), catchSomeCause3((cause3) => isDieType2(cause3) && isRuntimeException2(cause3.defect) && cause3.defect.message !== void 0 && cause3.defect.message === "Stream Timeout" ? some3(that) : none2()));
});
var pubsubFromOptions = /* @__PURE__ */ __name((options4) => {
  if (typeof options4 === "number") {
    return bounded5(options4);
  } else if (options4.capacity === "unbounded") {
    return unbounded5({
      replay: options4.replay
    });
  }
  switch (options4.strategy) {
    case "dropping":
      return dropping4(options4);
    case "sliding":
      return sliding4(options4);
    default:
      return bounded5(options4);
  }
}, "pubsubFromOptions");
var toPubSub2 = /* @__PURE__ */ dual(2, (self2, capacity9) => pipe(acquireRelease2(pubsubFromOptions(capacity9), (pubsub) => shutdown4(pubsub)), tap4((pubsub) => pipe(self2, runIntoPubSubScoped(pubsub), forkScoped2))));
var toPull2 = /* @__PURE__ */ __name((self2) => map22(toPull(toChannel2(self2)), (pull) => pipe(pull, mapError4(some3), flatMap15(match({
  onLeft: /* @__PURE__ */ __name(() => fail10(none2()), "onLeft"),
  onRight: succeed11
})))), "toPull");
var toQueue2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => tap4(acquireRelease2(options4?.strategy === "unbounded" ? unbounded3() : options4?.strategy === "dropping" ? dropping2(options4.capacity ?? 2) : options4?.strategy === "sliding" ? sliding2(options4.capacity ?? 2) : bounded3(options4?.capacity ?? 2), (queue) => shutdown2(queue)), (queue) => forkScoped2(runIntoQueueScoped(self2, queue))));
var toQueueOfElements = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => tap4(acquireRelease2(bounded3(options4?.capacity ?? 2), (queue) => shutdown2(queue)), (queue) => forkScoped2(runIntoQueueElementsScoped(self2, queue))));
var toReadableStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => toReadableStreamRuntime(self2, defaultRuntime2, options4));
var toReadableStreamEffect = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => map22(runtime4(), (runtime8) => toReadableStreamRuntime(self2, runtime8, options4)));
var toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime8, options4) => {
  const runFork4 = runFork3(runtime8);
  let currentResolve = void 0;
  let fiber = void 0;
  const latch = unsafeMakeLatch2(false);
  return new ReadableStream({
    start(controller) {
      fiber = runFork4(runForEachChunk(self2, (chunk4) => {
        if (chunk4.length === 0) return _void;
        return latch.whenOpen(sync7(() => {
          latch.unsafeClose();
          for (const item of chunk4) {
            controller.enqueue(item);
          }
          currentResolve();
          currentResolve = void 0;
        }));
      }));
      fiber.addObserver((exit5) => {
        try {
          if (exit5._tag === "Failure") {
            controller.error(squash(exit5.cause));
          } else {
            controller.close();
          }
        } catch {
        }
      });
    },
    pull() {
      return new Promise((resolve3) => {
        currentResolve = resolve3;
        runSync(latch.open);
      });
    },
    cancel() {
      if (!fiber) return;
      return runPromise(asVoid5(interrupt5(fiber)));
    }
  }, options4?.strategy);
});
var transduce = /* @__PURE__ */ dual(2, (self2, sink) => {
  const newChannel = suspend8(() => {
    const leftovers = {
      ref: empty4()
    };
    const upstreamDone = {
      ref: false
    };
    const buffer4 = suspend8(() => {
      const leftover2 = leftovers.ref;
      if (isEmpty(leftover2)) {
        return readWith({
          onInput: /* @__PURE__ */ __name((input) => pipe(write(input), flatMap18(() => buffer4)), "onInput"),
          onFailure: fail14,
          onDone: succeedNow
        });
      }
      leftovers.ref = empty4();
      return pipe(writeChunk(leftover2), flatMap18(() => buffer4));
    });
    const concatAndGet = /* @__PURE__ */ __name((chunk4) => {
      const leftover2 = leftovers.ref;
      const concatenated = appendAll2(leftover2, filter4(chunk4, (chunk5) => chunk5.length !== 0));
      leftovers.ref = concatenated;
      return concatenated;
    }, "concatAndGet");
    const upstreamMarker = readWith({
      onInput: /* @__PURE__ */ __name((input) => flatMap18(write(input), () => upstreamMarker), "onInput"),
      onFailure: fail14,
      onDone: /* @__PURE__ */ __name((done12) => zipRight8(sync10(() => {
        upstreamDone.ref = true;
      }), succeedNow(done12)), "onDone")
    });
    const transducer = pipe(sink, toChannel, collectElements, flatMap18(([leftover2, z]) => pipe(succeed15([upstreamDone.ref, concatAndGet(leftover2)]), flatMap18(([done12, newLeftovers]) => {
      const nextChannel = done12 && isEmpty(newLeftovers) ? void_8 : transducer;
      return pipe(write(of2(z)), flatMap18(() => nextChannel));
    }))));
    return pipe(toChannel2(self2), pipeTo(upstreamMarker), pipeTo(buffer4), pipeToOrFail(transducer));
  });
  return new StreamImpl(newChannel);
});
var toAsyncIterableRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime8) => {
  const runFork4 = runFork3(runtime8);
  return {
    [Symbol.asyncIterator]() {
      let currentResolve = void 0;
      let currentReject = void 0;
      let fiber = void 0;
      const latch = unsafeMakeLatch2(false);
      let returned = false;
      return {
        next() {
          if (!fiber) {
            fiber = runFork4(runForEach(self2, (value6) => latch.whenOpen(sync7(() => {
              latch.unsafeClose();
              currentResolve({
                done: false,
                value: value6
              });
              currentResolve = currentReject = void 0;
            }))));
            fiber.addObserver((exit5) => {
              if (returned) return;
              fiber = runFork2(latch.whenOpen(sync7(() => {
                if (exit5._tag === "Failure") {
                  currentReject(squash(exit5.cause));
                } else {
                  currentResolve({
                    done: true,
                    value: void 0
                  });
                }
                currentResolve = currentReject = void 0;
              })));
            });
          }
          return new Promise((resolve3, reject3) => {
            currentResolve = resolve3;
            currentReject = reject3;
            latch.unsafeOpen();
          });
        },
        return() {
          returned = true;
          if (!fiber) return Promise.resolve({
            done: true,
            value: void 0
          });
          return runPromise(as8(interrupt5(fiber), {
            done: true,
            value: void 0
          }));
        }
      };
    }
  };
});
var toAsyncIterable = /* @__PURE__ */ __name((self2) => toAsyncIterableRuntime(self2, defaultRuntime2), "toAsyncIterable");
var toAsyncIterableEffect = /* @__PURE__ */ __name((self2) => map22(runtime4(), (runtime8) => toAsyncIterableRuntime(self2, runtime8)), "toAsyncIterableEffect");
var unfold4 = /* @__PURE__ */ __name((s, f) => unfoldChunk(s, (s2) => pipe(f(s2), map2(([a, s3]) => [of2(a), s3]))), "unfold");
var unfoldChunk = /* @__PURE__ */ __name((s, f) => {
  const loop5 = /* @__PURE__ */ __name((s2) => match2(f(s2), {
    onNone: /* @__PURE__ */ __name(() => void_8, "onNone"),
    onSome: /* @__PURE__ */ __name(([chunk4, s3]) => flatMap18(write(chunk4), () => loop5(s3)), "onSome")
  }), "loop");
  return new StreamImpl(suspend8(() => loop5(s)));
}, "unfoldChunk");
var unfoldChunkEffect = /* @__PURE__ */ __name((s, f) => suspend12(() => {
  const loop5 = /* @__PURE__ */ __name((s2) => unwrap3(map22(f(s2), match2({
    onNone: /* @__PURE__ */ __name(() => void_8, "onNone"),
    onSome: /* @__PURE__ */ __name(([chunk4, s3]) => flatMap18(write(chunk4), () => loop5(s3)), "onSome")
  }))), "loop");
  return new StreamImpl(loop5(s));
}), "unfoldChunkEffect");
var unfoldEffect = /* @__PURE__ */ __name((s, f) => unfoldChunkEffect(s, (s2) => pipe(f(s2), map22(map2(([a, s3]) => [of2(a), s3])))), "unfoldEffect");
var void_10 = /* @__PURE__ */ succeed19(void 0);
var unwrap4 = /* @__PURE__ */ __name((effect4) => flatten15(fromEffect8(effect4)), "unwrap");
var unwrapScoped4 = /* @__PURE__ */ __name((effect4) => flatten15(scoped6(effect4)), "unwrapScoped");
var unwrapScopedWith3 = /* @__PURE__ */ __name((f) => flatten15(scopedWith4((scope5) => f(scope5))), "unwrapScopedWith");
var updateService4 = /* @__PURE__ */ dual(3, (self2, tag8, f) => pipe(self2, mapInputContext6((context17) => pipe(context17, add4(tag8, f(pipe(context17, unsafeGet5(tag8))))))));
var when4 = /* @__PURE__ */ dual(2, (self2, test3) => pipe(self2, whenEffect3(sync7(test3))));
var whenCase = /* @__PURE__ */ __name((evaluate3, pf) => whenCaseEffect(pf)(sync7(evaluate3)), "whenCase");
var whenCaseEffect = /* @__PURE__ */ dual(2, (self2, pf) => pipe(fromEffect8(self2), flatMap21((a) => pipe(pf(a), getOrElse2(() => empty36)))));
var whenEffect3 = /* @__PURE__ */ dual(2, (self2, effect4) => pipe(fromEffect8(effect4), flatMap21((bool) => bool ? self2 : empty36)));
var withSpan6 = /* @__PURE__ */ __name(function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options4 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return new StreamImpl(withSpan5(toChannel2(self2), name, options4));
  }
  return (self2) => new StreamImpl(withSpan5(toChannel2(self2), name, options4));
}, "withSpan");
var zip12 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith16(that, (a, a2) => [a, a2])));
var zipFlatten = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, zipWith16(that, (a, a2) => [...a, a2])));
var zipAll = /* @__PURE__ */ dual(2, (self2, options4) => zipAllWith(self2, {
  other: options4.other,
  onSelf: /* @__PURE__ */ __name((a) => [a, options4.defaultOther], "onSelf"),
  onOther: /* @__PURE__ */ __name((a2) => [options4.defaultSelf, a2], "onOther"),
  onBoth: /* @__PURE__ */ __name((a, a2) => [a, a2], "onBoth")
}));
var zipAllLeft = /* @__PURE__ */ dual(3, (self2, other, defaultSelf) => zipAllWith(self2, {
  other,
  onSelf: identity,
  onOther: /* @__PURE__ */ __name(() => defaultSelf, "onOther"),
  onBoth: /* @__PURE__ */ __name((a) => a, "onBoth")
}));
var zipAllRight = /* @__PURE__ */ dual(3, (self2, other, defaultRight) => zipAllWith(self2, {
  other,
  onSelf: /* @__PURE__ */ __name(() => defaultRight, "onSelf"),
  onOther: identity,
  onBoth: /* @__PURE__ */ __name((_, a2) => a2, "onBoth")
}));
var zipAllSortedByKey = /* @__PURE__ */ dual(2, (self2, options4) => zipAllSortedByKeyWith(self2, {
  other: options4.other,
  onSelf: /* @__PURE__ */ __name((a) => [a, options4.defaultOther], "onSelf"),
  onOther: /* @__PURE__ */ __name((a2) => [options4.defaultSelf, a2], "onOther"),
  onBoth: /* @__PURE__ */ __name((a, a2) => [a, a2], "onBoth"),
  order: options4.order
}));
var zipAllSortedByKeyLeft = /* @__PURE__ */ dual(2, (self2, options4) => zipAllSortedByKeyWith(self2, {
  other: options4.other,
  onSelf: identity,
  onOther: /* @__PURE__ */ __name(() => options4.defaultSelf, "onOther"),
  onBoth: /* @__PURE__ */ __name((a) => a, "onBoth"),
  order: options4.order
}));
var zipAllSortedByKeyRight = /* @__PURE__ */ dual(2, (self2, options4) => zipAllSortedByKeyWith(self2, {
  other: options4.other,
  onSelf: /* @__PURE__ */ __name(() => options4.defaultOther, "onSelf"),
  onOther: identity,
  onBoth: /* @__PURE__ */ __name((_, a2) => a2, "onBoth"),
  order: options4.order
}));
var zipAllSortedByKeyWith = /* @__PURE__ */ dual(2, (self2, options4) => {
  const pull = /* @__PURE__ */ __name((state2, pullLeft, pullRight) => {
    switch (state2._tag) {
      case OP_DRAIN_LEFT: {
        return pipe(pullLeft, match15({
          onFailure: fail3,
          onSuccess: /* @__PURE__ */ __name((leftChunk) => succeed3([map6(leftChunk, ([k, a]) => [k, options4.onSelf(a)]), DrainLeft]), "onSuccess")
        }));
      }
      case OP_DRAIN_RIGHT: {
        return pipe(pullRight, match15({
          onFailure: fail3,
          onSuccess: /* @__PURE__ */ __name((rightChunk) => succeed3([map6(rightChunk, ([k, a2]) => [k, options4.onOther(a2)]), DrainRight]), "onSuccess")
        }));
      }
      case OP_PULL_BOTH: {
        return pipe(unsome2(pullLeft), zip8(unsome2(pullRight), {
          concurrent: true
        }), matchEffect3({
          onFailure: /* @__PURE__ */ __name((error5) => succeed11(fail3(some3(error5))), "onFailure"),
          onSuccess: /* @__PURE__ */ __name(([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed11(succeed3(merge16(leftOption.value, rightOption.value)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              if (isEmpty(leftOption.value)) {
                return pull(DrainLeft, pullLeft, pullRight);
              }
              return succeed11(succeed3([pipe(leftOption.value, map6(([k, a]) => [k, options4.onSelf(a)])), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(rightOption.value)) {
                return pull(DrainRight, pullLeft, pullRight);
              }
              return succeed11(succeed3([pipe(rightOption.value, map6(([k, a2]) => [k, options4.onOther(a2)])), DrainRight]));
            }
            return succeed11(fail3(none2()));
          }, "onSuccess")
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect3(pullLeft, {
          onFailure: match2({
            onNone: /* @__PURE__ */ __name(() => succeed11(succeed3([pipe(state2.rightChunk, map6(([k, a2]) => [k, options4.onOther(a2)])), DrainRight])), "onNone"),
            onSome: /* @__PURE__ */ __name((error5) => succeed11(fail3(some3(error5))), "onSome")
          }),
          onSuccess: /* @__PURE__ */ __name((leftChunk) => isEmpty(leftChunk) ? pull(PullLeft(state2.rightChunk), pullLeft, pullRight) : succeed11(succeed3(merge16(leftChunk, state2.rightChunk))), "onSuccess")
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect3(pullRight, {
          onFailure: match2({
            onNone: /* @__PURE__ */ __name(() => succeed11(succeed3([map6(state2.leftChunk, ([k, a]) => [k, options4.onSelf(a)]), DrainLeft])), "onNone"),
            onSome: /* @__PURE__ */ __name((error5) => succeed11(fail3(some3(error5))), "onSome")
          }),
          onSuccess: /* @__PURE__ */ __name((rightChunk) => isEmpty(rightChunk) ? pull(PullRight(state2.leftChunk), pullLeft, pullRight) : succeed11(succeed3(merge16(state2.leftChunk, rightChunk))), "onSuccess")
        });
      }
    }
  }, "pull");
  const merge16 = /* @__PURE__ */ __name((leftChunk, rightChunk) => {
    const hasNext = /* @__PURE__ */ __name((chunk4, index2) => index2 < chunk4.length - 1, "hasNext");
    const builder = [];
    let state2 = void 0;
    let leftIndex = 0;
    let rightIndex = 0;
    let leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
    let rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
    let k1 = leftTuple[0];
    let a = leftTuple[1];
    let k2 = rightTuple[0];
    let a2 = rightTuple[1];
    let loop5 = true;
    while (loop5) {
      const compare3 = options4.order(k1, k2);
      if (compare3 === 0) {
        builder.push([k1, options4.onBoth(a, a2)]);
        if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {
          leftIndex = leftIndex + 1;
          rightIndex = rightIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
          rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else if (hasNext(leftChunk, leftIndex)) {
          state2 = PullRight(pipe(leftChunk, drop2(leftIndex + 1)));
          loop5 = false;
        } else if (hasNext(rightChunk, rightIndex)) {
          state2 = PullLeft(pipe(rightChunk, drop2(rightIndex + 1)));
          loop5 = false;
        } else {
          state2 = PullBoth;
          loop5 = false;
        }
      } else if (compare3 < 0) {
        builder.push([k1, options4.onSelf(a)]);
        if (hasNext(leftChunk, leftIndex)) {
          leftIndex = leftIndex + 1;
          leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
          k1 = leftTuple[0];
          a = leftTuple[1];
        } else {
          const rightBuilder = [];
          rightBuilder.push(rightTuple);
          while (hasNext(rightChunk, rightIndex)) {
            rightIndex = rightIndex + 1;
            rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
            rightBuilder.push(rightTuple);
          }
          state2 = PullLeft(unsafeFromArray(rightBuilder));
          loop5 = false;
        }
      } else {
        builder.push([k2, options4.onOther(a2)]);
        if (hasNext(rightChunk, rightIndex)) {
          rightIndex = rightIndex + 1;
          rightTuple = pipe(rightChunk, unsafeGet2(rightIndex));
          k2 = rightTuple[0];
          a2 = rightTuple[1];
        } else {
          const leftBuilder = [];
          leftBuilder.push(leftTuple);
          while (hasNext(leftChunk, leftIndex)) {
            leftIndex = leftIndex + 1;
            leftTuple = pipe(leftChunk, unsafeGet2(leftIndex));
            leftBuilder.push(leftTuple);
          }
          state2 = PullRight(unsafeFromArray(leftBuilder));
          loop5 = false;
        }
      }
    }
    return [unsafeFromArray(builder), state2];
  }, "merge");
  return combineChunks(self2, options4.other, PullBoth, pull);
});
var zipAllWith = /* @__PURE__ */ dual(2, (self2, options4) => {
  const pull = /* @__PURE__ */ __name((state2, pullLeft, pullRight) => {
    switch (state2._tag) {
      case OP_DRAIN_LEFT: {
        return matchEffect3(pullLeft, {
          onFailure: /* @__PURE__ */ __name((error5) => succeed11(fail3(error5)), "onFailure"),
          onSuccess: /* @__PURE__ */ __name((leftChunk) => succeed11(succeed3([map6(leftChunk, options4.onSelf), DrainLeft])), "onSuccess")
        });
      }
      case OP_DRAIN_RIGHT: {
        return matchEffect3(pullRight, {
          onFailure: /* @__PURE__ */ __name((error5) => succeed11(fail3(error5)), "onFailure"),
          onSuccess: /* @__PURE__ */ __name((rightChunk) => succeed11(succeed3([map6(rightChunk, options4.onOther), DrainRight])), "onSuccess")
        });
      }
      case OP_PULL_BOTH: {
        return pipe(unsome2(pullLeft), zip8(unsome2(pullRight), {
          concurrent: true
        }), matchEffect3({
          onFailure: /* @__PURE__ */ __name((error5) => succeed11(fail3(some3(error5))), "onFailure"),
          onSuccess: /* @__PURE__ */ __name(([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight(leftOption.value), pullLeft, pullRight);
              }
              return succeed11(succeed3(zip18(leftOption.value, rightOption.value, options4.onBoth)));
            }
            if (isSome2(leftOption) && isNone2(rightOption)) {
              return succeed11(succeed3([map6(leftOption.value, options4.onSelf), DrainLeft]));
            }
            if (isNone2(leftOption) && isSome2(rightOption)) {
              return succeed11(succeed3([map6(rightOption.value, options4.onOther), DrainRight]));
            }
            return succeed11(fail3(none2()));
          }, "onSuccess")
        }));
      }
      case OP_PULL_LEFT: {
        return matchEffect3(pullLeft, {
          onFailure: match2({
            onNone: /* @__PURE__ */ __name(() => succeed11(succeed3([map6(state2.rightChunk, options4.onOther), DrainRight])), "onNone"),
            onSome: /* @__PURE__ */ __name((error5) => succeed11(fail3(some3(error5))), "onSome")
          }),
          onSuccess: /* @__PURE__ */ __name((leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft(state2.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state2.rightChunk)) {
              return pull(PullRight(leftChunk), pullLeft, pullRight);
            }
            return succeed11(succeed3(zip18(leftChunk, state2.rightChunk, options4.onBoth)));
          }, "onSuccess")
        });
      }
      case OP_PULL_RIGHT: {
        return matchEffect3(pullRight, {
          onFailure: match2({
            onNone: /* @__PURE__ */ __name(() => succeed11(succeed3([map6(state2.leftChunk, options4.onSelf), DrainLeft])), "onNone"),
            onSome: /* @__PURE__ */ __name((error5) => succeed11(fail3(some3(error5))), "onSome")
          }),
          onSuccess: /* @__PURE__ */ __name((rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight(state2.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state2.leftChunk)) {
              return pull(PullLeft(rightChunk), pullLeft, pullRight);
            }
            return succeed11(succeed3(zip18(state2.leftChunk, rightChunk, options4.onBoth)));
          }, "onSuccess")
        });
      }
    }
  }, "pull");
  const zip18 = /* @__PURE__ */ __name((leftChunk, rightChunk, f) => {
    const [output, either12] = zipChunks(leftChunk, rightChunk, f);
    switch (either12._tag) {
      case "Left": {
        if (isEmpty(either12.left)) {
          return [output, PullBoth];
        }
        return [output, PullRight(either12.left)];
      }
      case "Right": {
        if (isEmpty(either12.right)) {
          return [output, PullBoth];
        }
        return [output, PullLeft(either12.right)];
      }
    }
  }, "zip");
  return combineChunks(self2, options4.other, PullBoth, pull);
});
var zipLatest = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipLatestWith(right3, (a, a2) => [a, a2])));
var zipLatestAll = /* @__PURE__ */ __name((...streams) => {
  if (streams.length === 0) {
    return empty36;
  } else if (streams.length === 1) {
    return map32(streams[0], (x) => [x]);
  }
  const [head13, ...tail3] = streams;
  return zipLatestWith(head13, zipLatestAll(...tail3), (first2, second) => [first2, ...second]);
}, "zipLatestAll");
var zipLatestWith = /* @__PURE__ */ dual(3, (left3, right3, f) => {
  const pullNonEmpty = /* @__PURE__ */ __name((pull) => pipe(pull, flatMap15((chunk4) => isEmpty(chunk4) ? pullNonEmpty(pull) : succeed11(chunk4))), "pullNonEmpty");
  return pipe(toPull2(left3), map22(pullNonEmpty), zip8(pipe(toPull2(right3), map22(pullNonEmpty))), flatMap15(([left4, right4]) => pipe(fromEffectOption(raceWith2(left4, right4, {
    onSelfDone: /* @__PURE__ */ __name((leftDone, rightFiber) => pipe(suspend4(() => leftDone), zipWith10(join4(rightFiber), (l, r) => [l, r, true])), "onSelfDone"),
    onOtherDone: /* @__PURE__ */ __name((rightDone, leftFiber) => pipe(suspend4(() => rightDone), zipWith10(join4(leftFiber), (l, r) => [r, l, false])), "onOtherDone")
  })), flatMap21(([l, r, leftFirst]) => pipe(fromEffect8(make26([unsafeLast(l), unsafeLast(r)])), flatMap21((latest) => pipe(fromChunk(leftFirst ? pipe(r, map6((a2) => f(unsafeLast(l), a2))) : pipe(l, map6((a) => f(a, unsafeLast(r))))), concat2(pipe(repeatEffectOption(left4), mergeEither(repeatEffectOption(right4)), mapEffectSequential(match({
    onLeft: /* @__PURE__ */ __name((leftChunk) => modify6(latest, ([_, rightLatest]) => [pipe(leftChunk, map6((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]]), "onLeft"),
    onRight: /* @__PURE__ */ __name((rightChunk) => modify6(latest, ([leftLatest, _]) => [pipe(rightChunk, map6((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]]), "onRight")
  })), flatMap21(fromChunk))))))), toPull2)), fromPull2);
});
var zipLeft11 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [pipe(left4, take2(right4.length)), left2(pipe(left4, take2(right4.length)))];
  }
  return [left4, right2(pipe(right4, drop2(left4.length)))];
})));
var zipRight12 = /* @__PURE__ */ dual(2, (left3, right3) => pipe(left3, zipWithChunks(right3, (left4, right4) => {
  if (left4.length > right4.length) {
    return [right4, left2(pipe(left4, take2(right4.length)))];
  }
  return [pipe(right4, take2(left4.length)), right2(pipe(right4, drop2(left4.length)))];
})));
var zipWith16 = /* @__PURE__ */ dual(3, (left3, right3, f) => pipe(left3, zipWithChunks(right3, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f))));
var zipWithChunks = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const pull = /* @__PURE__ */ __name((state2, pullLeft, pullRight) => {
    switch (state2._tag) {
      case OP_PULL_BOTH2: {
        return pipe(unsome2(pullLeft), zip8(unsome2(pullRight), {
          concurrent: true
        }), matchEffect3({
          onFailure: /* @__PURE__ */ __name((error5) => succeed11(fail3(some3(error5))), "onFailure"),
          onSuccess: /* @__PURE__ */ __name(([leftOption, rightOption]) => {
            if (isSome2(leftOption) && isSome2(rightOption)) {
              if (isEmpty(leftOption.value) && isEmpty(rightOption.value)) {
                return pull(PullBoth2, pullLeft, pullRight);
              }
              if (isEmpty(leftOption.value)) {
                return pull(PullLeft2(rightOption.value), pullLeft, pullRight);
              }
              if (isEmpty(rightOption.value)) {
                return pull(PullRight2(leftOption.value), pullLeft, pullRight);
              }
              return succeed11(succeed3(zip18(leftOption.value, rightOption.value)));
            }
            return succeed11(fail3(none2()));
          }, "onSuccess")
        }));
      }
      case OP_PULL_LEFT2: {
        return matchEffect3(pullLeft, {
          onFailure: /* @__PURE__ */ __name((error5) => succeed11(fail3(error5)), "onFailure"),
          onSuccess: /* @__PURE__ */ __name((leftChunk) => {
            if (isEmpty(leftChunk)) {
              return pull(PullLeft2(state2.rightChunk), pullLeft, pullRight);
            }
            if (isEmpty(state2.rightChunk)) {
              return pull(PullRight2(leftChunk), pullLeft, pullRight);
            }
            return succeed11(succeed3(zip18(leftChunk, state2.rightChunk)));
          }, "onSuccess")
        });
      }
      case OP_PULL_RIGHT2: {
        return matchEffect3(pullRight, {
          onFailure: /* @__PURE__ */ __name((error5) => succeed11(fail3(error5)), "onFailure"),
          onSuccess: /* @__PURE__ */ __name((rightChunk) => {
            if (isEmpty(rightChunk)) {
              return pull(PullRight2(state2.leftChunk), pullLeft, pullRight);
            }
            if (isEmpty(state2.leftChunk)) {
              return pull(PullLeft2(rightChunk), pullLeft, pullRight);
            }
            return succeed11(succeed3(zip18(state2.leftChunk, rightChunk)));
          }, "onSuccess")
        });
      }
    }
  }, "pull");
  const zip18 = /* @__PURE__ */ __name((leftChunk, rightChunk) => {
    const [output, either12] = f(leftChunk, rightChunk);
    switch (either12._tag) {
      case "Left": {
        if (isEmpty(either12.left)) {
          return [output, PullBoth2];
        }
        return [output, PullRight2(either12.left)];
      }
      case "Right": {
        if (isEmpty(either12.right)) {
          return [output, PullBoth2];
        }
        return [output, PullLeft2(either12.right)];
      }
    }
  }, "zip");
  return pipe(self2, combineChunks(that, PullBoth2, pull));
});
var zipWithIndex = /* @__PURE__ */ __name((self2) => pipe(self2, mapAccum5(0, (index2, a) => [index2 + 1, [a, index2]])), "zipWithIndex");
var zipWithNext = /* @__PURE__ */ __name((self2) => {
  const process2 = /* @__PURE__ */ __name((last5) => readWithCause({
    onInput: /* @__PURE__ */ __name((input) => {
      const [newLast, chunk4] = mapAccum2(input, last5, (prev, curr) => [some3(curr), pipe(prev, map2((a) => [a, curr]))]);
      const output = filterMap3(chunk4, (option9) => isSome2(option9) ? some3([option9.value[0], some3(option9.value[1])]) : none2());
      return flatMap18(write(output), () => process2(newLast));
    }, "onInput"),
    onFailure: failCause11,
    onDone: /* @__PURE__ */ __name(() => match2(last5, {
      onNone: /* @__PURE__ */ __name(() => void_8, "onNone"),
      onSome: /* @__PURE__ */ __name((value6) => zipRight8(write(of2([value6, none2()])), void_8), "onSome")
    }), "onDone")
  }), "process");
  return new StreamImpl(pipe(toChannel2(self2), pipeToOrFail(process2(none2()))));
}, "zipWithNext");
var zipWithPrevious = /* @__PURE__ */ __name((self2) => pipe(self2, mapAccum5(none2(), (prev, curr) => [some3(curr), [prev, curr]])), "zipWithPrevious");
var zipWithPreviousAndNext = /* @__PURE__ */ __name((self2) => pipe(zipWithNext(zipWithPrevious(self2)), map32(([[prev, curr], next4]) => [prev, curr, pipe(next4, map2((tuple5) => tuple5[1]))])), "zipWithPreviousAndNext");
var zipChunks = /* @__PURE__ */ __name((left3, right3, f) => {
  if (left3.length > right3.length) {
    return [pipe(left3, take2(right3.length), zipWith4(right3, f)), left2(pipe(left3, drop2(right3.length)))];
  }
  return [pipe(left3, zipWith4(pipe(right3, take2(left3.length)), f)), right2(pipe(right3, drop2(left3.length)))];
}, "zipChunks");
var Do6 = /* @__PURE__ */ succeed19({});
var bind8 = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag8, f, options4) => flatMap21(self2, (k) => map32(f(k), (a) => ({
  ...k,
  [tag8]: a
})), options4));
var bindTo8 = /* @__PURE__ */ bindTo(map32);
var let_8 = /* @__PURE__ */ let_(map32);
var decodeText = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, encoding = "utf-8") => suspend12(() => {
  const decoder4 = new TextDecoder(encoding);
  return map32(self2, (s) => decoder4.decode(s));
}));
var encodeText = /* @__PURE__ */ __name((self2) => suspend12(() => {
  const encoder3 = new TextEncoder();
  return map32(self2, (s) => encoder3.encode(s));
}), "encodeText");
var fromEventListener = /* @__PURE__ */ __name((target3, type3, options4) => asyncPush((emit3) => acquireRelease2(sync7(() => target3.addEventListener(type3, emit3.single, options4)), () => sync7(() => target3.removeEventListener(type3, emit3.single, options4))), {
  bufferSize: typeof options4 === "object" ? options4.bufferSize : void 0
}), "fromEventListener");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/groupBy.js
var GroupBySymbolKey = "effect/GroupBy";
var GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
var groupByVariance = {
  /* c8 ignore next */
  _R: /* @__PURE__ */ __name((_) => _, "_R"),
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _K: /* @__PURE__ */ __name((_) => _, "_K"),
  /* c8 ignore next */
  _V: /* @__PURE__ */ __name((_) => _, "_V")
};
var isGroupBy = /* @__PURE__ */ __name((u) => hasProperty(u, GroupByTypeId), "isGroupBy");
var evaluate2 = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self2, f, options4) => flatMap21(self2.grouped, ([key, queue]) => f(key, flattenTake(fromQueue2(queue, {
  shutdown: true
}))), {
  concurrency: "unbounded",
  bufferSize: options4?.bufferSize ?? 16
}));
var make64 = /* @__PURE__ */ __name((grouped3) => ({
  [GroupByTypeId]: groupByVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  grouped: grouped3
}), "make");
var groupBy2 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options4) => make64(unwrapScoped4(gen4(function* () {
  const decider = yield* make43();
  const output = yield* acquireRelease2(bounded3(options4?.bufferSize ?? 16), (queue) => shutdown2(queue));
  const ref2 = yield* make26(/* @__PURE__ */ new Map());
  const add8 = yield* pipe(mapEffectSequential(self2, f), distributedWithDynamicCallback(options4?.bufferSize ?? 16, ([key, value6]) => flatMap15(_await3(decider), (f2) => f2(key, value6)), (exit5) => offer3(output, exit5)));
  yield* succeed9(decider, (key, _) => pipe(get12(ref2), map22((map38) => fromNullable2(map38.get(key))), flatMap15(match2({
    onNone: /* @__PURE__ */ __name(() => flatMap15(add8, ([index2, queue]) => zipRight7(update3(ref2, (map38) => map38.set(key, index2)), pipe(offer3(output, succeed3([key, mapDequeue(queue, (exit5) => new TakeImpl(pipe(exit5, map15((tuple5) => of2(tuple5[1])))))])), as8((n) => n === index2)))), "onNone"),
    onSome: /* @__PURE__ */ __name((index2) => succeed11((n) => n === index2), "onSome")
  }))));
  return flattenExitOption(fromQueue2(output, {
    shutdown: true
  }));
}))));
var mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options4) => {
  if (options4?.key) {
    return evaluate2(groupByKey(self2, options4.key, {
      bufferSize: options4.bufferSize
    }), (_, s) => mapEffectSequential(s, f));
  }
  return matchConcurrency(options4?.concurrency, () => mapEffectSequential(self2, f), (n) => options4?.unordered ? flatMap21(self2, (a) => fromEffect8(f(a)), {
    concurrency: n
  }) : mapEffectPar(self2, n, f));
});
var bindEffect = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "string", (self2, tag8, f, options4) => mapEffectOptions(self2, (k) => map22(f(k), (a) => ({
  ...k,
  [tag8]: a
})), options4));
var mapDequeue = /* @__PURE__ */ __name((dequeue, f) => new MapDequeue(dequeue, f), "mapDequeue");
var MapDequeue = class extends Class2 {
  static {
    __name(this, "MapDequeue");
  }
  dequeue;
  f;
  [DequeueTypeId2] = {
    _Out: /* @__PURE__ */ __name((_) => _, "_Out")
  };
  constructor(dequeue, f) {
    super();
    this.dequeue = dequeue;
    this.f = f;
  }
  capacity() {
    return capacity3(this.dequeue);
  }
  get size() {
    return size14(this.dequeue);
  }
  unsafeSize() {
    return this.dequeue.unsafeSize();
  }
  get awaitShutdown() {
    return awaitShutdown2(this.dequeue);
  }
  isActive() {
    return this.dequeue.isActive();
  }
  get isShutdown() {
    return isShutdown2(this.dequeue);
  }
  get shutdown() {
    return shutdown2(this.dequeue);
  }
  get isFull() {
    return isFull2(this.dequeue);
  }
  get isEmpty() {
    return isEmpty12(this.dequeue);
  }
  get take() {
    return pipe(take4(this.dequeue), map22((a) => this.f(a)));
  }
  get takeAll() {
    return pipe(takeAll2(this.dequeue), map22(map6((a) => this.f(a))));
  }
  takeUpTo(max9) {
    return pipe(takeUpTo2(this.dequeue, max9), map22(map6((a) => this.f(a))));
  }
  takeBetween(min6, max9) {
    return pipe(takeBetween2(this.dequeue, min6, max9), map22(map6((a) => this.f(a))));
  }
  takeN(n) {
    return pipe(takeN2(this.dequeue, n), map22(map6((a) => this.f(a))));
  }
  poll() {
    return pipe(poll6(this.dequeue), map22(map2((a) => this.f(a))));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  commit() {
    return this.take;
  }
};
var groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options4) => {
  const loop5 = /* @__PURE__ */ __name((map38, outerQueue) => readWithCause({
    onInput: /* @__PURE__ */ __name((input) => flatMap18(fromEffect5(forEach11(groupByIterable(input, f), ([key, values6]) => {
      const innerQueue = map38.get(key);
      if (innerQueue === void 0) {
        return pipe(bounded3(options4?.bufferSize ?? 16), flatMap15((innerQueue2) => pipe(sync7(() => {
          map38.set(key, innerQueue2);
        }), zipRight7(offer3(outerQueue, of5([key, innerQueue2]))), zipRight7(pipe(offer3(innerQueue2, chunk3(values6)), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2()))))));
      }
      return catchSomeCause2(offer3(innerQueue, chunk3(values6)), (cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2());
    }, {
      discard: true
    })), () => loop5(map38, outerQueue)), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => fromEffect5(offer3(outerQueue, failCause12(cause3))), "onFailure"),
    onDone: /* @__PURE__ */ __name(() => fromEffect5(pipe(forEach11(map38.entries(), ([_, innerQueue]) => pipe(offer3(innerQueue, end4), catchSomeCause2((cause3) => isInterruptedOnly2(cause3) ? some3(_void) : none2())), {
      discard: true
    }), zipRight7(offer3(outerQueue, end4)))), "onDone")
  }), "loop");
  return make64(unwrapScopedWith3((scope5) => gen4(function* () {
    const map38 = /* @__PURE__ */ new Map();
    const queue = yield* unbounded3();
    yield* addFinalizer2(scope5, shutdown2(queue));
    return yield* toChannel2(self2).pipe(pipeTo(loop5(map38, queue)), drain, runIn(scope5), forkIn2(scope5), as8(flattenTake(fromQueue2(queue, {
      shutdown: true
    }))));
  })));
});
var groupByIterable = /* @__PURE__ */ dual(2, (iterable, f) => {
  const builder = [];
  const iterator = iterable[Symbol.iterator]();
  const map38 = /* @__PURE__ */ new Map();
  let next4;
  while ((next4 = iterator.next()) && !next4.done) {
    const value6 = next4.value;
    const key = f(value6);
    if (map38.has(key)) {
      const innerBuilder = map38.get(key);
      innerBuilder.push(value6);
    } else {
      const innerBuilder = [value6];
      builder.push([key, innerBuilder]);
      map38.set(key, innerBuilder);
    }
  }
  return unsafeFromArray(builder.map((tuple5) => [tuple5[0], unsafeFromArray(tuple5[1])]));
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Stream.js
var StreamTypeId4 = StreamTypeId3;
var DefaultChunkSize2 = DefaultChunkSize;
var accumulate2 = accumulate;
var accumulateChunks2 = accumulateChunks;
var acquireRelease4 = acquireRelease3;
var aggregate2 = aggregate;
var aggregateWithin2 = aggregateWithin;
var aggregateWithinEither2 = aggregateWithinEither;
var as13 = as12;
var _async2 = _async;
var asyncEffect4 = asyncEffect3;
var asyncPush2 = asyncPush;
var asyncScoped2 = asyncScoped;
var branchAfter2 = branchAfter;
var broadcast2 = broadcast;
var share2 = share;
var broadcastDynamic2 = broadcastDynamic;
var broadcastedQueues2 = broadcastedQueues;
var broadcastedQueuesDynamic2 = broadcastedQueuesDynamic;
var buffer2 = buffer;
var bufferChunks2 = bufferChunks;
var catchAll8 = catchAll7;
var catchAllCause7 = catchAllCause6;
var catchSome5 = catchSome4;
var catchTag5 = catchTag4;
var catchTags5 = catchTags4;
var catchSomeCause4 = catchSomeCause3;
var changes2 = changes;
var changesWith2 = changesWith;
var changesWithEffect2 = changesWithEffect;
var chunks2 = chunks;
var chunksWith2 = chunksWith;
var combine10 = combine9;
var combineChunks2 = combineChunks;
var concat3 = concat2;
var concatAll3 = concatAll2;
var cross2 = cross;
var crossLeft2 = crossLeft;
var crossRight2 = crossRight;
var crossWith2 = crossWith;
var debounce2 = debounce;
var die12 = die11;
var dieSync8 = dieSync7;
var dieMessage5 = dieMessage4;
var distributedWith2 = distributedWith;
var distributedWithDynamic2 = distributedWithDynamic;
var drain4 = drain3;
var drainFork2 = drainFork;
var drop4 = drop3;
var dropRight4 = dropRight3;
var dropUntil4 = dropUntil3;
var dropUntilEffect2 = dropUntilEffect;
var dropWhile6 = dropWhile5;
var dropWhileEffect2 = dropWhileEffect;
var either8 = either7;
var empty37 = empty36;
var ensuring8 = ensuring7;
var ensuringWith3 = ensuringWith2;
var context9 = context8;
var contextWith5 = contextWith4;
var contextWithEffect4 = contextWithEffect3;
var contextWithStream2 = contextWithStream;
var execute2 = execute;
var fail19 = fail18;
var failSync9 = failSync8;
var failCause15 = failCause14;
var failCauseSync8 = failCauseSync7;
var filter16 = filter15;
var filterEffect3 = filterEffect2;
var filterMap9 = filterMap8;
var filterMapEffect2 = filterMapEffect;
var filterMapWhile4 = filterMapWhile3;
var filterMapWhileEffect2 = filterMapWhileEffect;
var finalizer2 = finalizer;
var find4 = find3;
var findEffect2 = findEffect;
var flatMap22 = flatMap21;
var flatten16 = flatten15;
var flattenChunks2 = flattenChunks;
var flattenEffect2 = flattenEffect;
var flattenExitOption2 = flattenExitOption;
var flattenIterables2 = flattenIterables;
var flattenTake2 = flattenTake;
var forever6 = forever5;
var fromAsyncIterable2 = fromAsyncIterable;
var fromChannel3 = fromChannel2;
var toChannel3 = toChannel2;
var fromChunk2 = fromChunk;
var fromChunkPubSub2 = fromChunkPubSub;
var fromChunkQueue2 = fromChunkQueue;
var fromChunks2 = fromChunks;
var fromEffect9 = fromEffect8;
var fromEffectOption2 = fromEffectOption;
var fromPubSub2 = fromPubSub;
var fromTPubSub2 = fromTPubSub;
var fromIterable15 = fromIterable14;
var fromIterableEffect2 = fromIterableEffect;
var fromIteratorSucceed2 = fromIteratorSucceed;
var fromPull3 = fromPull2;
var fromQueue3 = fromQueue2;
var fromTQueue2 = fromTQueue;
var fromReadableStream2 = fromReadableStream;
var fromReadableStreamByob2 = fromReadableStreamByob;
var fromSchedule2 = fromSchedule;
var groupAdjacentBy2 = groupAdjacentBy;
var groupBy3 = groupBy2;
var groupByKey2 = groupByKey;
var grouped2 = grouped;
var groupedWithin2 = groupedWithin;
var haltAfter2 = haltAfter;
var haltWhen2 = haltWhen;
var haltWhenDeferred2 = haltWhenDeferred;
var identity5 = identityStream;
var interleave2 = interleave;
var interleaveWith2 = interleaveWith;
var intersperse3 = intersperse2;
var intersperseAffixes2 = intersperseAffixes;
var interruptAfter2 = interruptAfter;
var interruptWhen3 = interruptWhen2;
var interruptWhenDeferred3 = interruptWhenDeferred2;
var iterate5 = iterate4;
var make65 = make63;
var map33 = map32;
var mapAccum6 = mapAccum5;
var mapAccumEffect2 = mapAccumEffect;
var mapBoth10 = mapBoth9;
var mapChunks2 = mapChunks;
var mapChunksEffect2 = mapChunksEffect;
var mapConcat2 = mapConcat;
var mapConcatChunk2 = mapConcatChunk;
var mapConcatChunkEffect2 = mapConcatChunkEffect;
var mapConcatEffect2 = mapConcatEffect;
var mapEffect7 = mapEffectOptions;
var mapError10 = mapError9;
var mapErrorCause6 = mapErrorCause5;
var merge12 = merge11;
var mergeAll10 = mergeAll9;
var mergeWithTag2 = mergeWithTag;
var mergeWith4 = mergeWith3;
var mergeEither2 = mergeEither;
var mergeLeft2 = mergeLeft;
var mergeRight2 = mergeRight;
var mkString3 = mkString2;
var never6 = never5;
var onEnd2 = onEnd;
var onError4 = onError3;
var onDone2 = onDone;
var onStart2 = onStart;
var orDie7 = orDie6;
var orDieWith6 = orDieWith5;
var orElse14 = orElse13;
var orElseEither7 = orElseEither6;
var orElseFail5 = orElseFail4;
var orElseIfEmpty2 = orElseIfEmpty;
var orElseIfEmptyChunk2 = orElseIfEmptyChunk;
var orElseIfEmptyStream2 = orElseIfEmptyStream;
var orElseSucceed5 = orElseSucceed4;
var paginate2 = paginate;
var paginateChunk2 = paginateChunk;
var paginateChunkEffect2 = paginateChunkEffect;
var paginateEffect2 = paginateEffect;
var partition9 = partition8;
var partitionEither2 = partitionEither;
var peel2 = peel;
var pipeThrough2 = pipeThrough;
var pipeThroughChannel2 = pipeThroughChannel;
var pipeThroughChannelOrFail2 = pipeThroughChannelOrFail;
var prepend5 = prepend4;
var provideContext8 = provideContext7;
var provideSomeContext4 = provideSomeContext3;
var provideLayer2 = provideLayer;
var provideService9 = provideService8;
var provideServiceEffect4 = provideServiceEffect3;
var provideServiceStream2 = provideServiceStream;
var mapInputContext7 = mapInputContext6;
var provideSomeLayer3 = provideSomeLayer2;
var race4 = race3;
var raceAll4 = raceAll3;
var range4 = range3;
var rechunk2 = rechunk;
var refineOrDie3 = refineOrDie2;
var refineOrDieWith3 = refineOrDieWith2;
var repeat4 = repeat3;
var repeatEffect2 = repeatEffect;
var repeatEffectChunk2 = repeatEffectChunk;
var repeatEffectChunkOption2 = repeatEffectChunkOption;
var repeatEffectOption2 = repeatEffectOption;
var repeatEffectWithSchedule2 = repeatEffectWithSchedule;
var repeatEither2 = repeatEither;
var repeatElements2 = repeatElements;
var repeatElementsWith2 = repeatElementsWith;
var repeatValue2 = repeatValue;
var repeatWith2 = repeatWith;
var retry7 = retry6;
var withExecutionPlan4 = withExecutionPlan3;
var run5 = run4;
var runCollect2 = runCollect;
var runCount2 = runCount;
var runDrain3 = runDrain2;
var runFold2 = runFold;
var runFoldEffect2 = runFoldEffect;
var runFoldScoped2 = runFoldScoped;
var runFoldScopedEffect2 = runFoldScopedEffect;
var runFoldWhile2 = runFoldWhile;
var runFoldWhileEffect2 = runFoldWhileEffect;
var runFoldWhileScoped2 = runFoldWhileScoped;
var runFoldWhileScopedEffect2 = runFoldWhileScopedEffect;
var runForEach2 = runForEach;
var runForEachChunk2 = runForEachChunk;
var runForEachChunkScoped2 = runForEachChunkScoped;
var runForEachScoped2 = runForEachScoped;
var runForEachWhile2 = runForEachWhile;
var runForEachWhileScoped2 = runForEachWhileScoped;
var runHead2 = runHead;
var runIntoPubSub2 = runIntoPubSub;
var runIntoPubSubScoped2 = runIntoPubSubScoped;
var runIntoQueue2 = runIntoQueue;
var runIntoQueueElementsScoped2 = runIntoQueueElementsScoped;
var runIntoQueueScoped2 = runIntoQueueScoped;
var runLast2 = runLast;
var runScoped3 = runScoped2;
var runSum2 = runSum;
var scan3 = scan2;
var scanEffect2 = scanEffect;
var scanReduce2 = scanReduce;
var scanReduceEffect2 = scanReduceEffect;
var schedule3 = schedule2;
var scheduleWith2 = scheduleWith;
var scoped7 = scoped6;
var scopedWith5 = scopedWith4;
var sliding9 = sliding8;
var slidingSize2 = slidingSize;
var some12 = some11;
var someOrElse2 = someOrElse;
var someOrFail2 = someOrFail;
var split5 = split4;
var splitOnChunk2 = splitOnChunk;
var splitLines3 = splitLines2;
var succeed20 = succeed19;
var sync14 = sync13;
var suspend13 = suspend12;
var take9 = take8;
var takeRight4 = takeRight3;
var takeUntil4 = takeUntil3;
var takeUntilEffect2 = takeUntilEffect;
var takeWhile6 = takeWhile5;
var tap8 = tap7;
var tapBoth5 = tapBoth4;
var tapError7 = tapError6;
var tapErrorCause6 = tapErrorCause5;
var tapSink2 = tapSink;
var throttle2 = throttle;
var throttleEffect2 = throttleEffect;
var tick2 = tick;
var timeout4 = timeout3;
var timeoutFail4 = timeoutFail3;
var timeoutFailCause4 = timeoutFailCause3;
var timeoutTo4 = timeoutTo3;
var toPubSub3 = toPubSub2;
var toPull3 = toPull2;
var toQueue3 = toQueue2;
var toQueueOfElements2 = toQueueOfElements;
var toReadableStream2 = toReadableStream;
var toReadableStreamEffect2 = toReadableStreamEffect;
var toReadableStreamRuntime2 = toReadableStreamRuntime;
var toAsyncIterableRuntime2 = toAsyncIterableRuntime;
var toAsyncIterableEffect2 = toAsyncIterableEffect;
var toAsyncIterable2 = toAsyncIterable;
var transduce2 = transduce;
var unfold5 = unfold4;
var unfoldChunk2 = unfoldChunk;
var unfoldChunkEffect2 = unfoldChunkEffect;
var unfoldEffect2 = unfoldEffect;
var void_11 = void_10;
var unwrap5 = unwrap4;
var unwrapScoped5 = unwrapScoped4;
var unwrapScopedWith4 = unwrapScopedWith3;
var updateService5 = updateService4;
var when5 = when4;
var whenCase2 = whenCase;
var whenCaseEffect2 = whenCaseEffect;
var whenEffect4 = whenEffect3;
var withSpan7 = withSpan6;
var zip13 = zip12;
var zipFlatten2 = zipFlatten;
var zipAll2 = zipAll;
var zipAllLeft2 = zipAllLeft;
var zipAllRight2 = zipAllRight;
var zipAllSortedByKey2 = zipAllSortedByKey;
var zipAllSortedByKeyLeft2 = zipAllSortedByKeyLeft;
var zipAllSortedByKeyRight2 = zipAllSortedByKeyRight;
var zipAllSortedByKeyWith2 = zipAllSortedByKeyWith;
var zipAllWith2 = zipAllWith;
var zipLatest2 = zipLatest;
var zipLatestAll2 = zipLatestAll;
var zipLatestWith2 = zipLatestWith;
var zipLeft12 = zipLeft11;
var zipRight13 = zipRight12;
var zipWith17 = zipWith16;
var zipWithChunks2 = zipWithChunks;
var zipWithNext2 = zipWithNext;
var zipWithPrevious2 = zipWithPrevious;
var zipWithPreviousAndNext2 = zipWithPreviousAndNext;
var zipWithIndex2 = zipWithIndex;
var Do7 = Do6;
var bind9 = bind8;
var bindEffect2 = bindEffect;
var bindTo9 = bindTo8;
var let_9 = let_8;
var decodeText2 = decodeText;
var encodeText2 = encodeText;
var fromEventListener2 = fromEventListener;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/FileSystem.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Brand.js
var Brand_exports = {};
__export(Brand_exports, {
  BrandTypeId: () => BrandTypeId,
  RefinedConstructorsTypeId: () => RefinedConstructorsTypeId,
  all: () => all11,
  error: () => error3,
  errors: () => errors,
  nominal: () => nominal,
  refined: () => refined,
  unbranded: () => unbranded
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BrandTypeId = /* @__PURE__ */ Symbol.for("effect/Brand");
var RefinedConstructorsTypeId = /* @__PURE__ */ Symbol.for("effect/Brand/Refined");
var error3 = /* @__PURE__ */ __name((message, meta) => [{
  message,
  meta
}], "error");
var errors = /* @__PURE__ */ __name((...errors4) => flatten2(errors4), "errors");
function refined(...args2) {
  const either12 = args2.length === 2 ? (unbranded2) => args2[0](unbranded2) ? right2(unbranded2) : left2(args2[1](unbranded2)) : (unbranded2) => {
    return match2(args2[0](unbranded2), {
      onNone: /* @__PURE__ */ __name(() => right2(unbranded2), "onNone"),
      onSome: left2
    });
  };
  return Object.assign((unbranded2) => getOrThrowWith(either12(unbranded2), identity), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: /* @__PURE__ */ __name((args3) => getRight3(either12(args3)), "option"),
    either: either12,
    is: /* @__PURE__ */ __name((args3) => isRight2(either12(args3)), "is")
  });
}
__name(refined, "refined");
var nominal = /* @__PURE__ */ __name(() => {
  return Object.assign((args2) => args2, {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: /* @__PURE__ */ __name((args2) => some3(args2), "option"),
    either: /* @__PURE__ */ __name((args2) => right2(args2), "either"),
    is: /* @__PURE__ */ __name((_args) => true, "is")
  });
}, "nominal");
var all11 = /* @__PURE__ */ __name((...brands) => {
  const either12 = /* @__PURE__ */ __name((args2) => {
    let result = right2(args2);
    for (const brand2 of brands) {
      const nextResult = brand2.either(args2);
      if (isLeft2(result) && isLeft2(nextResult)) {
        result = left2([...result.left, ...nextResult.left]);
      } else {
        result = isLeft2(result) ? result : nextResult;
      }
    }
    return result;
  }, "either");
  return Object.assign((args2) => match(either12(args2), {
    onLeft: /* @__PURE__ */ __name((e) => {
      throw e;
    }, "onLeft"),
    onRight: identity
  }), {
    [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
    option: /* @__PURE__ */ __name((args2) => getRight3(either12(args2)), "option"),
    either: either12,
    is: /* @__PURE__ */ __name((args2) => isRight2(either12(args2)), "is")
  });
}, "all");
var unbranded = unsafeCoerce;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/fileSystem.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Channel.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var acquireUseRelease5 = acquireUseRelease3;
var embedInput2 = embedInput;
var failCause16 = failCause11;
var flatMap23 = flatMap18;
var pipeTo2 = pipeTo;
var readWithCause2 = readWithCause;
var run6 = run2;
var succeed21 = succeed15;
var suspend14 = suspend8;
var sync15 = sync10;
var void_12 = void_8;
var unwrap6 = unwrap3;
var unwrapScoped6 = unwrapScoped3;
var write2 = write;
var zipRight14 = zipRight8;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Sink.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var fail20 = fail15;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Error.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId23 = /* @__PURE__ */ Symbol.for("@effect/platform/Error");
var TypeIdError = /* @__PURE__ */ __name((typeId, tag8) => {
  class Base4 extends Error3 {
    static {
      __name(this, "Base");
    }
    _tag = tag8;
  }
  ;
  Base4.prototype[typeId] = typeId;
  Base4.prototype.name = tag8;
  return Base4;
}, "TypeIdError");
var Module = /* @__PURE__ */ Literal2("Clipboard", "Command", "FileSystem", "KeyValueStore", "Path", "Stream", "Terminal");
var BadArgument = class extends (/* @__PURE__ */ TaggedError2("@effect/platform/Error/BadArgument")("BadArgument", {
  module: Module,
  method: String$,
  description: /* @__PURE__ */ optional(String$),
  cause: /* @__PURE__ */ optional(Defect)
})) {
  static {
    __name(this, "BadArgument");
  }
  /**
   * @since 1.0.0
   */
  [TypeId23] = TypeId23;
  /**
   * @since 1.0.0
   */
  get message() {
    return `${this.module}.${this.method}${this.description ? `: ${this.description}` : ""}`;
  }
};
var SystemErrorReason = /* @__PURE__ */ Literal2("AlreadyExists", "BadResource", "Busy", "InvalidData", "NotFound", "PermissionDenied", "TimedOut", "UnexpectedEof", "Unknown", "WouldBlock", "WriteZero");
var SystemError = class extends (/* @__PURE__ */ TaggedError2("@effect/platform/Error/SystemError")("SystemError", {
  reason: SystemErrorReason,
  module: Module,
  method: String$,
  description: /* @__PURE__ */ optional(String$),
  syscall: /* @__PURE__ */ optional(String$),
  pathOrDescriptor: /* @__PURE__ */ optional(/* @__PURE__ */ Union2(String$, Number$)),
  cause: /* @__PURE__ */ optional(Defect)
})) {
  static {
    __name(this, "SystemError");
  }
  /**
   * @since 1.0.0
   */
  [TypeId23] = TypeId23;
  /**
   * @since 1.0.0
   */
  get message() {
    return `${this.reason}: ${this.module}.${this.method}${this.pathOrDescriptor !== void 0 ? ` (${this.pathOrDescriptor})` : ""}${this.description ? `: ${this.description}` : ""}`;
  }
};

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/fileSystem.js
var tag2 = /* @__PURE__ */ GenericTag("@effect/platform/FileSystem");
var Size = /* @__PURE__ */ __name((bytes) => typeof bytes === "bigint" ? bytes : BigInt(bytes), "Size");
var bigint1024 = /* @__PURE__ */ BigInt(1024);
var bigintPiB = bigint1024 * bigint1024 * bigint1024 * bigint1024 * bigint1024;
var notFound = /* @__PURE__ */ __name((method, path) => new SystemError({
  module: "FileSystem",
  method,
  reason: "NotFound",
  description: "No such file or directory",
  pathOrDescriptor: path
}), "notFound");
var makeNoop = /* @__PURE__ */ __name((fileSystem) => {
  return {
    access(path) {
      return fail10(notFound("access", path));
    },
    chmod(path) {
      return fail10(notFound("chmod", path));
    },
    chown(path) {
      return fail10(notFound("chown", path));
    },
    copy(path) {
      return fail10(notFound("copy", path));
    },
    copyFile(path) {
      return fail10(notFound("copyFile", path));
    },
    exists() {
      return succeed11(false);
    },
    link(path) {
      return fail10(notFound("link", path));
    },
    makeDirectory() {
      return die7("not implemented");
    },
    makeTempDirectory() {
      return die7("not implemented");
    },
    makeTempDirectoryScoped() {
      return die7("not implemented");
    },
    makeTempFile() {
      return die7("not implemented");
    },
    makeTempFileScoped() {
      return die7("not implemented");
    },
    open(path) {
      return fail10(notFound("open", path));
    },
    readDirectory(path) {
      return fail10(notFound("readDirectory", path));
    },
    readFile(path) {
      return fail10(notFound("readFile", path));
    },
    readFileString(path) {
      return fail10(notFound("readFileString", path));
    },
    readLink(path) {
      return fail10(notFound("readLink", path));
    },
    realPath(path) {
      return fail10(notFound("realPath", path));
    },
    remove() {
      return _void;
    },
    rename(oldPath) {
      return fail10(notFound("rename", oldPath));
    },
    sink(path) {
      return fail20(notFound("sink", path));
    },
    stat(path) {
      return fail10(notFound("stat", path));
    },
    stream(path) {
      return fail19(notFound("stream", path));
    },
    symlink(fromPath) {
      return fail10(notFound("symlink", fromPath));
    },
    truncate(path) {
      return fail10(notFound("truncate", path));
    },
    utimes(path) {
      return fail10(notFound("utimes", path));
    },
    watch(path) {
      return fail19(notFound("watch", path));
    },
    writeFile(path) {
      return fail10(notFound("writeFile", path));
    },
    writeFileString(path) {
      return fail10(notFound("writeFileString", path));
    },
    ...fileSystem
  };
}, "makeNoop");
var layerNoop = /* @__PURE__ */ __name((fileSystem) => succeed13(tag2, makeNoop(fileSystem)), "layerNoop");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/FileSystem.js
var Size2 = Size;
var FileSystem = tag2;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpBody.js
var TypeId24 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpBody");
var BodyBase = class {
  static {
    __name(this, "BodyBase");
  }
  [TypeId24];
  constructor() {
    this[TypeId24] = TypeId24;
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  toString() {
    return format(this);
  }
};
var EmptyImpl = class extends BodyBase {
  static {
    __name(this, "EmptyImpl");
  }
  _tag = "Empty";
  toJSON() {
    return {
      _id: "@effect/platform/HttpBody",
      _tag: "Empty"
    };
  }
};
var empty38 = /* @__PURE__ */ new EmptyImpl();
var Uint8ArrayImpl = class extends BodyBase {
  static {
    __name(this, "Uint8ArrayImpl");
  }
  body;
  contentType;
  _tag = "Uint8Array";
  constructor(body, contentType) {
    super();
    this.body = body;
    this.contentType = contentType;
  }
  get contentLength() {
    return this.body.length;
  }
  toJSON() {
    const toString5 = this.contentType.startsWith("text/") || this.contentType.endsWith("json");
    return {
      _id: "@effect/platform/HttpBody",
      _tag: "Uint8Array",
      body: toString5 ? new TextDecoder().decode(this.body) : `Uint8Array(${this.body.length})`,
      contentType: this.contentType,
      contentLength: this.contentLength
    };
  }
};
var uint8Array2 = /* @__PURE__ */ __name((body, contentType) => new Uint8ArrayImpl(body, contentType ?? "application/octet-stream"), "uint8Array");
var encoder2 = /* @__PURE__ */ new TextEncoder();
var text = /* @__PURE__ */ __name((body, contentType) => uint8Array2(encoder2.encode(body), contentType ?? "text/plain"), "text");
var unsafeJson = /* @__PURE__ */ __name((body) => text(JSON.stringify(body), "application/json"), "unsafeJson");
var StreamImpl2 = class extends BodyBase {
  static {
    __name(this, "StreamImpl");
  }
  stream;
  contentType;
  contentLength;
  _tag = "Stream";
  constructor(stream6, contentType, contentLength) {
    super();
    this.stream = stream6;
    this.contentType = contentType;
    this.contentLength = contentLength;
  }
  toJSON() {
    return {
      _id: "@effect/platform/HttpBody",
      _tag: "Stream",
      contentType: this.contentType,
      contentLength: this.contentLength
    };
  }
};
var stream2 = /* @__PURE__ */ __name((body, contentType, contentLength) => new StreamImpl2(body, contentType ?? "application/octet-stream", contentLength), "stream");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpClientRequest.js
var TypeId25 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClientRequest");
var Proto4 = {
  [TypeId25]: TypeId25,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/HttpClientRequest",
      method: this.method,
      url: this.url,
      urlParams: this.urlParams,
      hash: this.hash,
      headers: redact(this.headers),
      body: this.body.toJSON()
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeInternal(method, url2, urlParams3, hash5, headers, body) {
  const self2 = Object.create(Proto4);
  self2.method = method;
  self2.url = url2;
  self2.urlParams = urlParams3;
  self2.hash = hash5;
  self2.headers = headers;
  self2.body = body;
  return self2;
}
__name(makeInternal, "makeInternal");
var empty39 = /* @__PURE__ */ makeInternal("GET", "", empty35, /* @__PURE__ */ none2(), empty34, empty38);
var make67 = /* @__PURE__ */ __name((method) => (url2, options4) => modify9(empty39, {
  method,
  url: url2,
  ...options4 ?? void 0
}), "make");
var get19 = /* @__PURE__ */ make67("GET");
var post = /* @__PURE__ */ make67("POST");
var put = /* @__PURE__ */ make67("PUT");
var patch9 = /* @__PURE__ */ make67("PATCH");
var del = /* @__PURE__ */ make67("DELETE");
var head9 = /* @__PURE__ */ make67("HEAD");
var options = /* @__PURE__ */ make67("OPTIONS");
var modify9 = /* @__PURE__ */ dual(2, (self2, options4) => {
  let result = self2;
  if (options4.method) {
    result = setMethod(result, options4.method);
  }
  if (options4.url) {
    result = setUrl(result, options4.url);
  }
  if (options4.headers) {
    result = setHeaders(result, options4.headers);
  }
  if (options4.urlParams) {
    result = setUrlParams(result, options4.urlParams);
  }
  if (options4.hash) {
    result = setHash(result, options4.hash);
  }
  if (options4.body) {
    result = setBody(result, options4.body);
  }
  if (options4.accept) {
    result = accept(result, options4.accept);
  }
  if (options4.acceptJson) {
    result = acceptJson(result);
  }
  return result;
});
var setHeader = /* @__PURE__ */ dual(3, (self2, key, value6) => makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, set9(self2.headers, key, value6), self2.body));
var setHeaders = /* @__PURE__ */ dual(2, (self2, input) => makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, setAll3(self2.headers, input), self2.body));
var accept = /* @__PURE__ */ dual(2, (self2, mediaType) => setHeader(self2, "Accept", mediaType));
var acceptJson = /* @__PURE__ */ accept("application/json");
var setMethod = /* @__PURE__ */ dual(2, (self2, method) => makeInternal(method, self2.url, self2.urlParams, self2.hash, self2.headers, self2.body));
var setUrl = /* @__PURE__ */ dual(2, (self2, url2) => {
  if (typeof url2 === "string") {
    return makeInternal(self2.method, url2, self2.urlParams, self2.hash, self2.headers, self2.body);
  }
  const clone3 = new URL(url2.toString());
  const urlParams3 = fromInput2(clone3.searchParams);
  const hash5 = clone3.hash ? some3(clone3.hash.slice(1)) : none2();
  clone3.search = "";
  clone3.hash = "";
  return makeInternal(self2.method, clone3.toString(), urlParams3, hash5, self2.headers, self2.body);
});
var appendUrl = /* @__PURE__ */ dual(2, (self2, url2) => makeInternal(self2.method, self2.url.endsWith("/") && url2.startsWith("/") ? self2.url + url2.slice(1) : self2.url + url2, self2.urlParams, self2.hash, self2.headers, self2.body));
var prependUrl = /* @__PURE__ */ dual(2, (self2, url2) => makeInternal(self2.method, url2.endsWith("/") && self2.url.startsWith("/") ? url2 + self2.url.slice(1) : url2 + self2.url, self2.urlParams, self2.hash, self2.headers, self2.body));
var setUrlParams = /* @__PURE__ */ dual(2, (self2, input) => makeInternal(self2.method, self2.url, setAll4(self2.urlParams, input), self2.hash, self2.headers, self2.body));
var setHash = /* @__PURE__ */ dual(2, (self2, hash5) => makeInternal(self2.method, self2.url, self2.urlParams, some3(hash5), self2.headers, self2.body));
var setBody = /* @__PURE__ */ dual(2, (self2, body) => {
  let headers = self2.headers;
  if (body._tag === "Empty" || body._tag === "FormData") {
    headers = remove10(headers, ["Content-type", "Content-length"]);
  } else {
    const contentType = body.contentType;
    if (contentType) {
      headers = set9(headers, "content-type", contentType);
    }
    const contentLength = body.contentLength;
    if (contentLength) {
      headers = set9(headers, "content-length", contentLength.toString());
    }
  }
  return makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, headers, body);
});
var bodyUnsafeJson = /* @__PURE__ */ dual(2, (self2, body) => setBody(self2, unsafeJson(body)));

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpClientRequest.js
var get20 = get19;
var post2 = post;
var prependUrl2 = prependUrl;
var appendUrl2 = appendUrl;
var bodyUnsafeJson2 = bodyUnsafeJson;

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/OtlpLogger.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Logger.js
var Logger_exports = {};
__export(Logger_exports, {
  LoggerTypeId: () => LoggerTypeId2,
  add: () => add7,
  addEffect: () => addEffect,
  addScoped: () => addScoped,
  batched: () => batched,
  defaultLogger: () => defaultLogger2,
  filterLogLevel: () => filterLogLevel2,
  isLogger: () => isLogger2,
  json: () => json3,
  jsonLogger: () => jsonLogger3,
  logFmt: () => logFmt,
  logfmtLogger: () => logfmtLogger2,
  make: () => make68,
  map: () => map34,
  mapInput: () => mapInput9,
  mapInputOptions: () => mapInputOptions2,
  minimumLogLevel: () => minimumLogLevel2,
  none: () => none11,
  pretty: () => pretty5,
  prettyLogger: () => prettyLogger3,
  prettyLoggerDefault: () => prettyLoggerDefault2,
  remove: () => remove12,
  replace: () => replace3,
  replaceEffect: () => replaceEffect,
  replaceScoped: () => replaceScoped,
  simple: () => simple2,
  stringLogger: () => stringLogger2,
  structured: () => structured,
  structuredLogger: () => structuredLogger3,
  succeed: () => succeed23,
  sync: () => sync17,
  test: () => test2,
  tracerLogger: () => tracerLogger2,
  withConsoleError: () => withConsoleError,
  withConsoleLog: () => withConsoleLog,
  withLeveledConsole: () => withLeveledConsole,
  withMinimumLogLevel: () => withMinimumLogLevel2,
  withSpanAnnotations: () => withSpanAnnotations,
  zip: () => zip15,
  zipLeft: () => zipLeft14,
  zipRight: () => zipRight15
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/logger-circular.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var test = /* @__PURE__ */ dual(2, (self2, input) => self2.log({
  fiberId: none3,
  logLevel: logLevelInfo,
  message: input,
  cause: empty27,
  context: empty20(),
  spans: empty12(),
  annotations: empty11(),
  date: /* @__PURE__ */ new Date()
}));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Logger.js
var LoggerTypeId2 = LoggerTypeId;
var make68 = makeLogger;
var add7 = addLogger;
var addEffect = addLoggerEffect;
var addScoped = addLoggerScoped;
var mapInput9 = mapInput4;
var mapInputOptions2 = mapInputOptions;
var filterLogLevel2 = filterLogLevel;
var map34 = map17;
var batched = batchedLogger;
var withConsoleLog = loggerWithConsoleLog;
var withLeveledConsole = loggerWithLeveledLog;
var withConsoleError = loggerWithConsoleError;
var none11 = none7;
var remove12 = removeLogger;
var replace3 = replaceLogger;
var replaceEffect = replaceLoggerEffect;
var replaceScoped = replaceLoggerScoped;
var simple2 = simple;
var succeed23 = succeed5;
var sync17 = sync3;
var test2 = test;
var withMinimumLogLevel2 = withMinimumLogLevel;
var withSpanAnnotations = loggerWithSpanAnnotations;
var zip15 = zip5;
var zipLeft14 = zipLeft4;
var zipRight15 = zipRight4;
var defaultLogger2 = defaultLogger;
var jsonLogger3 = jsonLogger;
var logfmtLogger2 = logfmtLogger;
var stringLogger2 = stringLogger;
var prettyLogger3 = prettyLogger;
var prettyLoggerDefault2 = prettyLoggerDefault;
var structuredLogger3 = structuredLogger;
var tracerLogger2 = tracerLogger;
var json3 = /* @__PURE__ */ replace3(defaultLogger, jsonLogger2);
var logFmt = /* @__PURE__ */ replace3(defaultLogger, logFmtLogger);
var pretty5 = /* @__PURE__ */ replace3(defaultLogger, prettyLogger2);
var structured = /* @__PURE__ */ replace3(defaultLogger, structuredLogger2);
var minimumLogLevel2 = minimumLogLevel;
var isLogger2 = isLogger;

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/internal/otlpExporter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpClient.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpClient.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Cookies.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId26 = /* @__PURE__ */ Symbol.for("@effect/platform/Cookies");
var CookieTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Cookies/Cookie");
var Proto5 = {
  [TypeId26]: TypeId26,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/Cookies",
      cookies: map4(this.cookies, (cookie) => cookie.toJSON())
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromReadonlyRecord = /* @__PURE__ */ __name((cookies) => {
  const self2 = Object.create(Proto5);
  self2.cookies = cookies;
  return self2;
}, "fromReadonlyRecord");
var fromIterable16 = /* @__PURE__ */ __name((cookies) => {
  const record4 = {};
  for (const cookie of cookies) {
    record4[cookie.name] = cookie;
  }
  return fromReadonlyRecord(record4);
}, "fromIterable");
var fromSetCookie = /* @__PURE__ */ __name((headers) => {
  const arrayHeaders = typeof headers === "string" ? [headers] : headers;
  const cookies = [];
  for (const header of arrayHeaders) {
    const cookie = parseSetCookie(header.trim());
    if (isSome2(cookie)) {
      cookies.push(cookie.value);
    }
  }
  return fromIterable16(cookies);
}, "fromSetCookie");
function parseSetCookie(header) {
  const parts2 = header.split(";").map((_) => _.trim()).filter((_) => _ !== "");
  if (parts2.length === 0) {
    return none2();
  }
  const firstEqual = parts2[0].indexOf("=");
  if (firstEqual === -1) {
    return none2();
  }
  const name = parts2[0].slice(0, firstEqual);
  if (!fieldContentRegExp.test(name)) {
    return none2();
  }
  const valueEncoded = parts2[0].slice(firstEqual + 1);
  const value6 = tryDecodeURIComponent(valueEncoded);
  if (parts2.length === 1) {
    return some3(Object.assign(Object.create(CookieProto), {
      name,
      value: value6,
      valueEncoded
    }));
  }
  const options4 = {};
  for (let i = 1; i < parts2.length; i++) {
    const part = parts2[i];
    const equalIndex = part.indexOf("=");
    const key = equalIndex === -1 ? part : part.slice(0, equalIndex).trim();
    const value7 = equalIndex === -1 ? void 0 : part.slice(equalIndex + 1).trim();
    switch (key.toLowerCase()) {
      case "domain": {
        if (value7 === void 0) {
          break;
        }
        const domain3 = value7.trim().replace(/^\./, "");
        if (domain3) {
          options4.domain = domain3;
        }
        break;
      }
      case "expires": {
        if (value7 === void 0) {
          break;
        }
        const date4 = new Date(value7);
        if (!isNaN(date4.getTime())) {
          options4.expires = date4;
        }
        break;
      }
      case "max-age": {
        if (value7 === void 0) {
          break;
        }
        const maxAge = parseInt(value7, 10);
        if (!isNaN(maxAge)) {
          options4.maxAge = seconds(maxAge);
        }
        break;
      }
      case "path": {
        if (value7 === void 0) {
          break;
        }
        if (value7[0] === "/") {
          options4.path = value7;
        }
        break;
      }
      case "priority": {
        if (value7 === void 0) {
          break;
        }
        switch (value7.toLowerCase()) {
          case "low":
            options4.priority = "low";
            break;
          case "medium":
            options4.priority = "medium";
            break;
          case "high":
            options4.priority = "high";
            break;
        }
        break;
      }
      case "httponly": {
        options4.httpOnly = true;
        break;
      }
      case "secure": {
        options4.secure = true;
        break;
      }
      case "partitioned": {
        options4.partitioned = true;
        break;
      }
      case "samesite": {
        if (value7 === void 0) {
          break;
        }
        switch (value7.toLowerCase()) {
          case "lax":
            options4.sameSite = "lax";
            break;
          case "strict":
            options4.sameSite = "strict";
            break;
          case "none":
            options4.sameSite = "none";
            break;
        }
        break;
      }
    }
  }
  return some3(Object.assign(Object.create(CookieProto), {
    name,
    value: value6,
    valueEncoded,
    options: Object.keys(options4).length > 0 ? options4 : void 0
  }));
}
__name(parseSetCookie, "parseSetCookie");
var empty40 = /* @__PURE__ */ fromIterable16([]);
var isEmpty18 = /* @__PURE__ */ __name((self2) => isEmptyRecord(self2.cookies), "isEmpty");
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var CookieProto = {
  [CookieTypeId]: CookieTypeId,
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/Cookies/Cookie",
      name: this.name,
      value: this.value,
      options: this.options
    };
  }
};
function serializeCookie(self2) {
  let str = self2.name + "=" + self2.valueEncoded;
  if (self2.options === void 0) {
    return str;
  }
  const options4 = self2.options;
  if (options4.maxAge !== void 0) {
    const maxAge = toSeconds(options4.maxAge);
    str += "; Max-Age=" + Math.trunc(maxAge);
  }
  if (options4.domain !== void 0) {
    str += "; Domain=" + options4.domain;
  }
  if (options4.path !== void 0) {
    str += "; Path=" + options4.path;
  }
  if (options4.priority !== void 0) {
    switch (options4.priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
    }
  }
  if (options4.expires !== void 0) {
    str += "; Expires=" + options4.expires.toUTCString();
  }
  if (options4.httpOnly) {
    str += "; HttpOnly";
  }
  if (options4.secure) {
    str += "; Secure";
  }
  if (options4.partitioned) {
    str += "; Partitioned";
  }
  if (options4.sameSite !== void 0) {
    switch (options4.sameSite) {
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
    }
  }
  return str;
}
__name(serializeCookie, "serializeCookie");
var toSetCookieHeaders = /* @__PURE__ */ __name((self2) => Object.values(self2.cookies).map(serializeCookie), "toSetCookieHeaders");
function parseHeader(header) {
  const result = {};
  const strLen = header.length;
  let pos = 0;
  let terminatorPos = 0;
  while (true) {
    if (terminatorPos === strLen) break;
    terminatorPos = header.indexOf(";", pos);
    if (terminatorPos === -1) terminatorPos = strLen;
    let eqIdx = header.indexOf("=", pos);
    if (eqIdx === -1) break;
    if (eqIdx > terminatorPos) {
      pos = terminatorPos + 1;
      continue;
    }
    const key = header.substring(pos, eqIdx++).trim();
    if (result[key] === void 0) {
      const val = header.charCodeAt(eqIdx) === 34 ? header.substring(eqIdx + 1, terminatorPos - 1).trim() : header.substring(eqIdx, terminatorPos).trim();
      result[key] = !(val.indexOf("%") === -1) ? tryDecodeURIComponent(val) : val;
    }
    pos = terminatorPos + 1;
  }
  return result;
}
__name(parseHeader, "parseHeader");
var tryDecodeURIComponent = /* @__PURE__ */ __name((str) => {
  try {
    return decodeURIComponent(str);
  } catch {
    return str;
  }
}, "tryDecodeURIComponent");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpClientError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpClientError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId27 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClientError");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpClientError.js
var TypeId28 = TypeId27;
var isHttpClientError = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId28), "isHttpClientError");
var RequestError = class extends (/* @__PURE__ */ TypeIdError(TypeId28, "RequestError")) {
  static {
    __name(this, "RequestError");
  }
  get methodAndUrl() {
    return `${this.request.method} ${this.request.url}`;
  }
  get message() {
    return this.description ? `${this.reason}: ${this.description} (${this.methodAndUrl})` : `${this.reason} error (${this.methodAndUrl})`;
  }
};
var ResponseError = class extends (/* @__PURE__ */ TypeIdError(TypeId28, "ResponseError")) {
  static {
    __name(this, "ResponseError");
  }
  get methodAndUrl() {
    return `${this.request.method} ${this.request.url}`;
  }
  get message() {
    const info4 = `${this.response.status} ${this.methodAndUrl}`;
    return this.description ? `${this.reason}: ${this.description} (${info4})` : `${this.reason} error (${info4})`;
  }
};

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpIncomingMessage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId29 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpIncomingMessage");
var MaxBodySize = class extends (/* @__PURE__ */ Reference2()("@effect/platform/HttpIncomingMessage/MaxBodySize", {
  defaultValue: none2
})) {
  static {
    __name(this, "MaxBodySize");
  }
};
var inspect = /* @__PURE__ */ __name((self2, that) => {
  const contentType = self2.headers["content-type"] ?? "";
  let body;
  if (contentType.includes("application/json")) {
    try {
      body = runSync(self2.json);
    } catch {
    }
  } else if (contentType.includes("text/") || contentType.includes("urlencoded")) {
    try {
      body = runSync(self2.text);
    } catch {
    }
  }
  const obj = {
    ...that,
    headers: redact(self2.headers),
    remoteAddress: self2.remoteAddress.toJSON()
  };
  if (body !== void 0) {
    obj.body = body;
  }
  return obj;
}, "inspect");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpTraceContext.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var toHeaders = /* @__PURE__ */ __name((span4) => unsafeFromRecord({
  b3: `${span4.traceId}-${span4.spanId}-${span4.sampled ? "1" : "0"}${span4.parent._tag === "Some" ? `-${span4.parent.value.spanId}` : ""}`,
  traceparent: `00-${span4.traceId}-${span4.spanId}-${span4.sampled ? "01" : "00"}`
}), "toHeaders");
var fromHeaders = /* @__PURE__ */ __name((headers) => {
  let span4 = w3c(headers);
  if (span4._tag === "Some") {
    return span4;
  }
  span4 = b3(headers);
  if (span4._tag === "Some") {
    return span4;
  }
  return xb3(headers);
}, "fromHeaders");
var b3 = /* @__PURE__ */ __name((headers) => {
  if (!("b3" in headers)) {
    return none2();
  }
  const parts2 = headers["b3"].split("-");
  if (parts2.length < 2) {
    return none2();
  }
  return some3(externalSpan2({
    traceId: parts2[0],
    spanId: parts2[1],
    sampled: parts2[2] ? parts2[2] === "1" : true
  }));
}, "b3");
var xb3 = /* @__PURE__ */ __name((headers) => {
  if (!headers["x-b3-traceid"] || !headers["x-b3-spanid"]) {
    return none2();
  }
  return some3(externalSpan2({
    traceId: headers["x-b3-traceid"],
    spanId: headers["x-b3-spanid"],
    sampled: headers["x-b3-sampled"] ? headers["x-b3-sampled"] === "1" : true
  }));
}, "xb3");
var w3cTraceId = /^[0-9a-f]{32}$/i;
var w3cSpanId = /^[0-9a-f]{16}$/i;
var w3c = /* @__PURE__ */ __name((headers) => {
  if (!headers["traceparent"]) {
    return none2();
  }
  const parts2 = headers["traceparent"].split("-");
  if (parts2.length !== 4) {
    return none2();
  }
  const [version2, traceId, spanId, flags] = parts2;
  switch (version2) {
    case "00": {
      if (w3cTraceId.test(traceId) === false || w3cSpanId.test(spanId) === false) {
        return none2();
      }
      return some3(externalSpan2({
        traceId,
        spanId,
        sampled: (parseInt(flags, 16) & 1) === 1
      }));
    }
    default: {
      return none2();
    }
  }
}, "w3c");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpClientResponse.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId30 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClientResponse");
var fromWeb = /* @__PURE__ */ __name((request2, source) => new ClientResponseImpl(request2, source), "fromWeb");
var ClientResponseImpl = class extends Class {
  static {
    __name(this, "ClientResponseImpl");
  }
  request;
  source;
  [TypeId29];
  [TypeId30];
  constructor(request2, source) {
    super();
    this.request = request2;
    this.source = source;
    this[TypeId29] = TypeId29;
    this[TypeId30] = TypeId30;
  }
  toJSON() {
    return inspect(this, {
      _id: "@effect/platform/HttpClientResponse",
      request: this.request.toJSON(),
      status: this.status
    });
  }
  get status() {
    return this.source.status;
  }
  get headers() {
    return fromInput(this.source.headers);
  }
  cachedCookies;
  get cookies() {
    if (this.cachedCookies) {
      return this.cachedCookies;
    }
    return this.cachedCookies = fromSetCookie(this.source.headers.getSetCookie());
  }
  get remoteAddress() {
    return none2();
  }
  get stream() {
    return this.source.body ? fromReadableStream2(() => this.source.body, (cause3) => new ResponseError({
      request: this.request,
      response: this,
      reason: "Decode",
      cause: cause3
    })) : fail19(new ResponseError({
      request: this.request,
      response: this,
      reason: "EmptyBody",
      description: "can not create stream from empty body"
    }));
  }
  get json() {
    return tryMap2(this.text, {
      try: /* @__PURE__ */ __name((text7) => text7 === "" ? null : JSON.parse(text7), "try"),
      catch: /* @__PURE__ */ __name((cause3) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause: cause3
      }), "catch")
    });
  }
  textBody;
  get text() {
    return this.textBody ??= tryPromise2({
      try: /* @__PURE__ */ __name(() => this.source.text(), "try"),
      catch: /* @__PURE__ */ __name((cause3) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause: cause3
      }), "catch")
    }).pipe(cached3, runSync);
  }
  get urlParamsBody() {
    return flatMap15(this.text, (_) => try_3({
      try: /* @__PURE__ */ __name(() => fromInput2(new URLSearchParams(_)), "try"),
      catch: /* @__PURE__ */ __name((cause3) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause: cause3
      }), "catch")
    }));
  }
  formDataBody;
  get formData() {
    return this.formDataBody ??= tryPromise2({
      try: /* @__PURE__ */ __name(() => this.source.formData(), "try"),
      catch: /* @__PURE__ */ __name((cause3) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause: cause3
      }), "catch")
    }).pipe(cached3, runSync);
  }
  arrayBufferBody;
  get arrayBuffer() {
    return this.arrayBufferBody ??= tryPromise2({
      try: /* @__PURE__ */ __name(() => this.source.arrayBuffer(), "try"),
      catch: /* @__PURE__ */ __name((cause3) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause: cause3
      }), "catch")
    }).pipe(cached3, runSync);
  }
};
var filterStatusOk = /* @__PURE__ */ __name((self2) => self2.status >= 200 && self2.status < 300 ? succeed11(self2) : fail10(new ResponseError({
  response: self2,
  request: self2.request,
  reason: "StatusCode",
  description: "non 2xx status code"
})), "filterStatusOk");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpClient.js
var ATTR_HTTP_REQUEST_HEADER = /* @__PURE__ */ __name((key) => `http.request.header.${key}`, "ATTR_HTTP_REQUEST_HEADER");
var ATTR_HTTP_REQUEST_METHOD = "http.request.method";
var ATTR_HTTP_RESPONSE_HEADER = /* @__PURE__ */ __name((key) => `http.response.header.${key}`, "ATTR_HTTP_RESPONSE_HEADER");
var ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
var ATTR_SERVER_ADDRESS = "server.address";
var ATTR_SERVER_PORT = "server.port";
var ATTR_URL_FULL = "url.full";
var ATTR_URL_PATH = "url.path";
var ATTR_URL_SCHEME = "url.scheme";
var ATTR_URL_QUERY = "url.query";
var TypeId31 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClient");
var tag3 = /* @__PURE__ */ GenericTag("@effect/platform/HttpClient");
var currentTracerDisabledWhen = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpClient/tracerDisabledWhen"), () => unsafeMake11(constFalse));
var currentTracerPropagation = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpClient/currentTracerPropagation"), () => unsafeMake11(true));
var SpanNameGenerator = /* @__PURE__ */ Reference2()("@effect/platform/HttpClient/SpanNameGenerator", {
  defaultValue: /* @__PURE__ */ __name(() => (request2) => `http.client ${request2.method}`, "defaultValue")
});
var ClientProto = {
  [TypeId31]: TypeId31,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...BaseProto,
  toJSON() {
    return {
      _id: "@effect/platform/HttpClient"
    };
  },
  get(url2, options4) {
    return this.execute(get19(url2, options4));
  },
  head(url2, options4) {
    return this.execute(head9(url2, options4));
  },
  post(url2, options4) {
    return this.execute(post(url2, options4));
  },
  put(url2, options4) {
    return this.execute(put(url2, options4));
  },
  patch(url2, options4) {
    return this.execute(patch9(url2, options4));
  },
  del(url2, options4) {
    return this.execute(del(url2, options4));
  },
  options(url2, options4) {
    return this.execute(options(url2, options4));
  }
};
var makeWith2 = /* @__PURE__ */ __name((postprocess, preprocess) => {
  const self2 = Object.create(ClientProto);
  self2.preprocess = preprocess;
  self2.postprocess = postprocess;
  self2.execute = function(request2) {
    return postprocess(preprocess(request2));
  };
  return self2;
}, "makeWith");
var responseRegistry = /* @__PURE__ */ globalValue("@effect/platform/HttpClient/responseRegistry", () => {
  if ("FinalizationRegistry" in globalThis && globalThis.FinalizationRegistry) {
    const registry = new FinalizationRegistry((controller) => {
      controller.abort();
    });
    return {
      register(response, controller) {
        registry.register(response, controller, response);
      },
      unregister(response) {
        registry.unregister(response);
      }
    };
  }
  const timers = /* @__PURE__ */ new Map();
  return {
    register(response, controller) {
      timers.set(response, setTimeout(() => controller.abort(), 5e3));
    },
    unregister(response) {
      const timer2 = timers.get(response);
      if (timer2 === void 0) return;
      clearTimeout(timer2);
      timers.delete(response);
    }
  };
});
var scopedRequests = /* @__PURE__ */ globalValue("@effect/platform/HttpClient/scopedRequests", () => /* @__PURE__ */ new WeakMap());
var make69 = /* @__PURE__ */ __name((f) => makeWith2((effect4) => flatMap15(effect4, (request2) => withFiberRuntime2((fiber) => {
  const scopedController = scopedRequests.get(request2);
  const controller = scopedController ?? new AbortController();
  const urlResult = makeUrl(request2.url, request2.urlParams, request2.hash);
  if (urlResult._tag === "Left") {
    return fail10(new RequestError({
      request: request2,
      reason: "InvalidUrl",
      cause: urlResult.left
    }));
  }
  const url2 = urlResult.right;
  const tracerDisabled = !fiber.getFiberRef(currentTracerEnabled2) || fiber.getFiberRef(currentTracerDisabledWhen)(request2);
  if (tracerDisabled) {
    const effect5 = f(request2, url2, controller.signal, fiber);
    if (scopedController) return effect5;
    return uninterruptibleMask3((restore) => matchCauseEffect3(restore(effect5), {
      onSuccess(response) {
        responseRegistry.register(response, controller);
        return succeed11(new InterruptibleResponse(response, controller));
      },
      onFailure(cause3) {
        if (isInterrupted3(cause3)) {
          controller.abort();
        }
        return failCause9(cause3);
      }
    }));
  }
  const nameGenerator = get6(fiber.currentContext, SpanNameGenerator);
  return useSpan2(nameGenerator(request2), {
    kind: "client",
    captureStackTrace: false
  }, (span4) => {
    span4.attribute(ATTR_HTTP_REQUEST_METHOD, request2.method);
    span4.attribute(ATTR_SERVER_ADDRESS, url2.origin);
    if (url2.port !== "") {
      span4.attribute(ATTR_SERVER_PORT, +url2.port);
    }
    span4.attribute(ATTR_URL_FULL, url2.toString());
    span4.attribute(ATTR_URL_PATH, url2.pathname);
    span4.attribute(ATTR_URL_SCHEME, url2.protocol.slice(0, -1));
    const query = url2.search.slice(1);
    if (query !== "") {
      span4.attribute(ATTR_URL_QUERY, query);
    }
    const redactedHeaderNames = fiber.getFiberRef(currentRedactedNames);
    const redactedHeaders = redact2(request2.headers, redactedHeaderNames);
    for (const name in redactedHeaders) {
      span4.attribute(ATTR_HTTP_REQUEST_HEADER(name), String(redactedHeaders[name]));
    }
    request2 = fiber.getFiberRef(currentTracerPropagation) ? setHeaders(request2, toHeaders(span4)) : request2;
    return uninterruptibleMask3((restore) => restore(f(request2, url2, controller.signal, fiber)).pipe(withParentSpan3(span4), matchCauseEffect3({
      onSuccess: /* @__PURE__ */ __name((response) => {
        span4.attribute(ATTR_HTTP_RESPONSE_STATUS_CODE, response.status);
        const redactedHeaders2 = redact2(response.headers, redactedHeaderNames);
        for (const name in redactedHeaders2) {
          span4.attribute(ATTR_HTTP_RESPONSE_HEADER(name), String(redactedHeaders2[name]));
        }
        if (scopedController) return succeed11(response);
        responseRegistry.register(response, controller);
        return succeed11(new InterruptibleResponse(response, controller));
      }, "onSuccess"),
      onFailure(cause3) {
        if (!scopedController && isInterrupted3(cause3)) {
          controller.abort();
        }
        return failCause9(cause3);
      }
    })));
  });
})), succeed11), "make");
var InterruptibleResponse = class {
  static {
    __name(this, "InterruptibleResponse");
  }
  original;
  controller;
  constructor(original, controller) {
    this.original = original;
    this.controller = controller;
  }
  [TypeId30] = TypeId30;
  [TypeId29] = TypeId29;
  applyInterrupt(effect4) {
    return suspend4(() => {
      responseRegistry.unregister(this.original);
      return onInterrupt2(effect4, () => sync7(() => {
        this.controller.abort();
      }));
    });
  }
  get request() {
    return this.original.request;
  }
  get status() {
    return this.original.status;
  }
  get headers() {
    return this.original.headers;
  }
  get cookies() {
    return this.original.cookies;
  }
  get remoteAddress() {
    return this.original.remoteAddress;
  }
  get formData() {
    return this.applyInterrupt(this.original.formData);
  }
  get text() {
    return this.applyInterrupt(this.original.text);
  }
  get json() {
    return this.applyInterrupt(this.original.json);
  }
  get urlParamsBody() {
    return this.applyInterrupt(this.original.urlParamsBody);
  }
  get arrayBuffer() {
    return this.applyInterrupt(this.original.arrayBuffer);
  }
  get stream() {
    return suspend13(() => {
      responseRegistry.unregister(this.original);
      return ensuring8(this.original.stream, sync7(() => {
        this.controller.abort();
      }));
    });
  }
  toJSON() {
    return this.original.toJSON();
  }
  [NodeInspectSymbol]() {
    return this.original[NodeInspectSymbol]();
  }
};
var {
  /** @internal */
  del: del2,
  /** @internal */
  execute: execute3,
  /** @internal */
  get: get21,
  /** @internal */
  head: head10,
  /** @internal */
  options: options2,
  /** @internal */
  patch: patch10,
  /** @internal */
  post: post3,
  /** @internal */
  put: put2
} = /* @__PURE__ */ serviceFunctions2(tag3);
var filterStatusOk2 = /* @__PURE__ */ __name((self2) => transformResponse(self2, flatMap15(filterStatusOk)), "filterStatusOk");
var transformResponse = /* @__PURE__ */ dual(2, (self2, f) => {
  const client = self2;
  return makeWith2((request2) => f(client.postprocess(request2)), client.preprocess);
});
var mapRequest = /* @__PURE__ */ dual(2, (self2, f) => {
  const client = self2;
  return makeWith2(client.postprocess, (request2) => map22(client.preprocess(request2), f));
});
var retryTransient = /* @__PURE__ */ dual(2, (self2, options4) => transformResponse(self2, retry2({
  while: ScheduleTypeId2 in options4 || options4.while === void 0 ? isTransientError : or(isTransientError, options4.while),
  schedule: ScheduleTypeId2 in options4 ? options4 : options4.schedule,
  times: ScheduleTypeId2 in options4 ? void 0 : options4.times
})));
var isTransientError = /* @__PURE__ */ __name((error5) => hasProperty(error5, TimeoutExceptionTypeId2) || isTransientHttpError(error5), "isTransientError");
var isTransientHttpError = /* @__PURE__ */ __name((error5) => isHttpClientError(error5) && (error5._tag === "RequestError" && error5.reason === "Transport" || error5._tag === "ResponseError" && error5.response.status >= 429), "isTransientHttpError");
var layerMergedContext = /* @__PURE__ */ __name((effect4) => effect(tag3, flatMap15(context4(), (context17) => map22(effect4, (client) => transformResponse(client, mapInputContext3((input) => merge3(context17, input)))))), "layerMergedContext");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpClient.js
var HttpClient = tag3;
var filterStatusOk3 = filterStatusOk2;
var mapRequest2 = mapRequest;
var retryTransient2 = retryTransient;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberSet.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId32 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
var isFiberSet = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId32), "isFiberSet");
var Proto6 = {
  [TypeId32]: TypeId32,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty2();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake14 = /* @__PURE__ */ __name((backing, deferred) => {
  const self2 = Object.create(Proto6);
  self2.state = {
    _tag: "Open",
    backing
  };
  self2.deferred = deferred;
  return self2;
}, "unsafeMake");
var make70 = /* @__PURE__ */ __name(() => acquireRelease2(map22(make43(), (deferred) => unsafeMake14(/* @__PURE__ */ new Set(), deferred)), (set20) => withFiberRuntime2((parent) => {
  const state2 = set20.state;
  if (state2._tag === "Closed") return _void;
  set20.state = {
    _tag: "Closed"
  };
  const fibers = state2.backing;
  return interruptAllAs2(fibers, combine3(parent.id(), internalFiberId)).pipe(intoDeferred2(set20.deferred));
})), "make");
var makeRuntime = /* @__PURE__ */ __name(() => flatMap15(make70(), (self2) => runtime5(self2)()), "makeRuntime");
var internalFiberIdId = -1;
var internalFiberId = /* @__PURE__ */ make15(internalFiberIdId, 0);
var isInternalInterruption = /* @__PURE__ */ reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: /* @__PURE__ */ __name((_, fiberId5) => has4(ids2(fiberId5), internalFiberIdId), "interruptCase"),
  sequentialCase: /* @__PURE__ */ __name((_, left3, right3) => left3 || right3, "sequentialCase"),
  parallelCase: /* @__PURE__ */ __name((_, left3, right3) => left3 || right3, "parallelCase")
});
var unsafeAdd = /* @__PURE__ */ dual((args2) => isFiberSet(args2[0]), (self2, fiber, options4) => {
  if (self2.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine3(options4?.interruptAs ?? none4, internalFiberId));
    return;
  } else if (self2.state.backing.has(fiber)) {
    return;
  }
  self2.state.backing.add(fiber);
  fiber.addObserver((exit5) => {
    if (self2.state._tag === "Closed") {
      return;
    }
    self2.state.backing.delete(fiber);
    if (isFailure3(exit5) && (options4?.propagateInterruption === true ? !isInternalInterruption(exit5.cause) : !isInterruptedOnly2(exit5.cause))) {
      unsafeDone(self2.deferred, exit5);
    }
  });
});
var constInterruptedFiber = /* @__PURE__ */ (function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork2(interrupt7);
    }
    return fiber;
  };
})();
var run7 = /* @__PURE__ */ __name(function() {
  const self2 = arguments[0];
  if (!isEffect2(arguments[1])) {
    const options4 = arguments[1];
    return (effect4) => runImpl(self2, effect4, options4);
  }
  return runImpl(self2, arguments[1], arguments[2]);
}, "run");
var runImpl = /* @__PURE__ */ __name((self2, effect4, options4) => fiberIdWith2((fiberId5) => {
  if (self2.state._tag === "Closed") {
    return sync7(constInterruptedFiber);
  }
  return tap4(forkDaemon2(effect4), (fiber) => unsafeAdd(self2, fiber, {
    ...options4,
    interruptAs: fiberId5
  }));
}), "runImpl");
var runtime5 = /* @__PURE__ */ __name((self2) => () => map22(runtime4(), (runtime8) => {
  const runFork4 = runFork3(runtime8);
  return (effect4, options4) => {
    if (self2.state._tag === "Closed") {
      return constInterruptedFiber();
    }
    const fiber = runFork4(effect4, options4);
    unsafeAdd(self2, fiber);
    return fiber;
  };
}), "runtime");
var join5 = /* @__PURE__ */ __name((self2) => _await3(self2.deferred), "join");

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/internal/otlpExporter.js
var policy = /* @__PURE__ */ forever4.pipe(passthrough4, /* @__PURE__ */ addDelay2((error5) => {
  if (isHttpClientError(error5) && error5._tag === "ResponseError" && error5.response.status === 429) {
    const retryAfter = fromNullable2(error5.response.headers["retry-after"]).pipe(flatMap2(parse), getOrElse2(() => 5));
    return seconds(retryAfter);
  }
  return seconds(1);
}));
var make71 = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const clock3 = yield* clock2;
  const scope5 = yield* scope3;
  const exportInterval = decode(options4.exportInterval);
  let disabledUntil = void 0;
  const client = filterStatusOk3(yield* HttpClient).pipe(retryTransient2({
    schedule: policy,
    times: 3
  }));
  let headers = unsafeFromRecord({
    "user-agent": `effect-opentelemetry-${options4.label}/0.0.0`
  });
  if (options4.headers) {
    headers = merge9(fromInput(options4.headers), headers);
  }
  const request2 = post2(options4.url, {
    headers
  });
  let buffer4 = [];
  const runExport = suspend4(() => {
    if (disabledUntil !== void 0 && clock3.unsafeCurrentTimeMillis() < disabledUntil) {
      return _void;
    } else if (disabledUntil !== void 0) {
      disabledUntil = void 0;
    }
    const items = buffer4;
    if (options4.maxBatchSize !== "disabled") {
      if (buffer4.length === 0) {
        return _void;
      }
      buffer4 = [];
    }
    return client.execute(bodyUnsafeJson2(request2, options4.body(items))).pipe(asVoid5, withTracerEnabled2(false));
  }).pipe(catchAllCause3((cause3) => {
    if (disabledUntil !== void 0) return _void;
    disabledUntil = clock3.unsafeCurrentTimeMillis() + toMillis("1 minute");
    return logDebug2(`Disabling ${options4.label} for 60 seconds`, cause3);
  }));
  yield* addFinalizer2(scope5, runExport.pipe(ignore2, interruptible4, timeoutOption2(options4.shutdownTimeout)));
  yield* sleep4(exportInterval).pipe(zipRight7(runExport), forever3, annotateLogs3({
    package: "@effect/opentelemetry",
    module: options4.label
  }), forkIn2(scope5), interruptible4);
  const runFork4 = yield* makeRuntime().pipe(interruptible4);
  return {
    push(data) {
      if (disabledUntil !== void 0) return;
      buffer4.push(data);
      if (options4.maxBatchSize !== "disabled" && buffer4.length >= options4.maxBatchSize) {
        runFork4(runExport);
      }
    }
  };
});

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/OtlpResource.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ATTR_SERVICE_NAME = "service.name";
var ATTR_SERVICE_VERSION = "service.version";
var make72 = /* @__PURE__ */ __name((options4) => {
  const resourceAttributes = options4.attributes ? entriesToAttributes(Object.entries(options4.attributes)) : [];
  resourceAttributes.push({
    key: ATTR_SERVICE_NAME,
    value: {
      stringValue: options4.serviceName
    }
  });
  if (options4.serviceVersion) {
    resourceAttributes.push({
      key: ATTR_SERVICE_VERSION,
      value: {
        stringValue: options4.serviceVersion
      }
    });
  }
  return {
    attributes: resourceAttributes,
    droppedAttributesCount: 0
  };
}, "make");
var fromConfig = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const attributes = yield* string4("OTEL_RESOURCE_ATTRIBUTES").pipe(map24((s) => {
    const attrs = s.split(",");
    return reduce(attrs, {}, (acc, attr) => {
      const parts2 = attr.split("=");
      if (parts2.length !== 2) {
        return acc;
      }
      acc[parts2[0].trim()] = parts2[1].trim();
      return acc;
    });
  }), withDefault2({}), map22((envAttrs) => ({
    ...envAttrs,
    ...options4?.attributes
  })));
  const serviceName = options4?.serviceName ?? attributes[ATTR_SERVICE_NAME] ?? (yield* string4("OTEL_SERVICE_NAME"));
  const serviceVersion = options4?.serviceVersion ?? attributes[ATTR_SERVICE_VERSION] ?? (yield* string4("OTEL_SERVICE_VERSION").pipe(withDefault2(void 0)));
  return make72({
    serviceName,
    serviceVersion,
    attributes
  });
}, orDie3);
var unsafeServiceName = /* @__PURE__ */ __name((resource) => {
  const serviceNameAttribute = resource.attributes.find((attr) => attr.key === ATTR_SERVICE_NAME);
  if (!serviceNameAttribute || !serviceNameAttribute.value.stringValue) {
    throw new Error("Resource does not contain a service name");
  }
  return serviceNameAttribute.value.stringValue;
}, "unsafeServiceName");
var entriesToAttributes = /* @__PURE__ */ __name((entries3) => {
  const attributes = [];
  for (const [key, value6] of entries3) {
    attributes.push({
      key,
      value: unknownToAttributeValue(value6)
    });
  }
  return attributes;
}, "entriesToAttributes");
var unknownToAttributeValue = /* @__PURE__ */ __name((value6) => {
  if (Array.isArray(value6)) {
    return {
      arrayValue: {
        values: value6.map(unknownToAttributeValue)
      }
    };
  }
  switch (typeof value6) {
    case "string":
      return {
        stringValue: value6
      };
    case "bigint":
      return {
        intValue: Number(value6)
      };
    case "number":
      return Number.isInteger(value6) ? {
        intValue: value6
      } : {
        doubleValue: value6
      };
    case "boolean":
      return {
        boolValue: value6
      };
    default:
      return {
        stringValue: toStringUnknown(value6)
      };
  }
}, "unknownToAttributeValue");

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/OtlpLogger.js
var make73 = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const otelResource = yield* fromConfig(options4.resource);
  const scope5 = {
    name: unsafeServiceName(otelResource)
  };
  const exporter = yield* make71({
    label: "OtlpLogger",
    url: options4.url,
    headers: options4.headers,
    maxBatchSize: options4.maxBatchSize ?? 1e3,
    exportInterval: options4.exportInterval ?? seconds(1),
    body: /* @__PURE__ */ __name((data) => ({
      resourceLogs: [{
        resource: otelResource,
        scopeLogs: [{
          scope: scope5,
          logRecords: data
        }]
      }]
    }), "body"),
    shutdownTimeout: options4.shutdownTimeout ?? seconds(3)
  });
  const opts = {
    excludeLogSpans: options4.excludeLogSpans ?? false
  };
  return make68((options5) => {
    exporter.push(makeLogRecord(options5, opts));
  });
});
var layer = /* @__PURE__ */ __name((options4) => options4.replaceLogger ? replaceScoped(options4.replaceLogger, make73(options4)) : addScoped(make73(options4)), "layer");
var makeLogRecord = /* @__PURE__ */ __name((options4, opts) => {
  const now2 = options4.date.getTime();
  const nanosString = `${now2}000000`;
  const attributes = entriesToAttributes(options4.annotations);
  attributes.push({
    key: "fiberId",
    value: {
      stringValue: threadName2(options4.fiberId)
    }
  });
  if (!opts.excludeLogSpans) {
    for (const span4 of options4.spans) {
      attributes.push({
        key: `logSpan.${span4.label}`,
        value: {
          stringValue: `${now2 - span4.startTime}ms`
        }
      });
    }
  }
  if (!isEmpty6(options4.cause)) {
    attributes.push({
      key: "log.error",
      value: {
        stringValue: pretty3(options4.cause, {
          renderErrorCause: true
        })
      }
    });
  }
  const message = ensure(options4.message);
  const maybeSpan = getOption2(getOrDefault2(options4.context, currentContext2), ParentSpan);
  const logRecord = {
    severityNumber: logLevelToSeverityNumber(options4.logLevel),
    severityText: options4.logLevel.label,
    timeUnixNano: nanosString,
    observedTimeUnixNano: nanosString,
    attributes,
    body: unknownToAttributeValue(message.length === 1 ? message[0] : message),
    droppedAttributesCount: 0
  };
  if (isSome2(maybeSpan)) {
    logRecord.traceId = maybeSpan.value.traceId;
    logRecord.spanId = maybeSpan.value.spanId;
  }
  return logRecord;
}, "makeLogRecord");
var logLevelToSeverityNumber = /* @__PURE__ */ __name((logLevel2) => {
  switch (logLevel2._tag) {
    case "Trace":
      return ESeverityNumber.SEVERITY_NUMBER_TRACE;
    case "Debug":
      return ESeverityNumber.SEVERITY_NUMBER_DEBUG;
    case "Info":
      return ESeverityNumber.SEVERITY_NUMBER_INFO;
    case "Warning":
      return ESeverityNumber.SEVERITY_NUMBER_WARN;
    case "Error":
      return ESeverityNumber.SEVERITY_NUMBER_ERROR;
    case "Fatal":
      return ESeverityNumber.SEVERITY_NUMBER_FATAL;
    default:
      return ESeverityNumber.SEVERITY_NUMBER_UNSPECIFIED;
  }
}, "logLevelToSeverityNumber");
var ESeverityNumber;
(function(ESeverityNumber2) {
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_UNSPECIFIED"] = 0] = "SEVERITY_NUMBER_UNSPECIFIED";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_TRACE"] = 1] = "SEVERITY_NUMBER_TRACE";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_TRACE2"] = 2] = "SEVERITY_NUMBER_TRACE2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_TRACE3"] = 3] = "SEVERITY_NUMBER_TRACE3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_TRACE4"] = 4] = "SEVERITY_NUMBER_TRACE4";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_DEBUG"] = 5] = "SEVERITY_NUMBER_DEBUG";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_DEBUG2"] = 6] = "SEVERITY_NUMBER_DEBUG2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_DEBUG3"] = 7] = "SEVERITY_NUMBER_DEBUG3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_DEBUG4"] = 8] = "SEVERITY_NUMBER_DEBUG4";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_INFO"] = 9] = "SEVERITY_NUMBER_INFO";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_INFO2"] = 10] = "SEVERITY_NUMBER_INFO2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_INFO3"] = 11] = "SEVERITY_NUMBER_INFO3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_INFO4"] = 12] = "SEVERITY_NUMBER_INFO4";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_WARN"] = 13] = "SEVERITY_NUMBER_WARN";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_WARN2"] = 14] = "SEVERITY_NUMBER_WARN2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_WARN3"] = 15] = "SEVERITY_NUMBER_WARN3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_WARN4"] = 16] = "SEVERITY_NUMBER_WARN4";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_ERROR"] = 17] = "SEVERITY_NUMBER_ERROR";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_ERROR2"] = 18] = "SEVERITY_NUMBER_ERROR2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_ERROR3"] = 19] = "SEVERITY_NUMBER_ERROR3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_ERROR4"] = 20] = "SEVERITY_NUMBER_ERROR4";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_FATAL"] = 21] = "SEVERITY_NUMBER_FATAL";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_FATAL2"] = 22] = "SEVERITY_NUMBER_FATAL2";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_FATAL3"] = 23] = "SEVERITY_NUMBER_FATAL3";
  ESeverityNumber2[ESeverityNumber2["SEVERITY_NUMBER_FATAL4"] = 24] = "SEVERITY_NUMBER_FATAL4";
})(ESeverityNumber || (ESeverityNumber = {}));

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/OtlpMetrics.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Metric.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var unsafeSnapshot2 = unsafeSnapshot;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/MetricState.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isCounterState2 = isCounterState;
var isFrequencyState2 = isFrequencyState;
var isGaugeState2 = isGaugeState;
var isHistogramState2 = isHistogramState;
var isSummaryState2 = isSummaryState;

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/OtlpMetrics.js
var make74 = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const clock3 = yield* clock2;
  const startTime = String(clock3.unsafeCurrentTimeNanos());
  const resource = yield* fromConfig(options4.resource);
  const metricsScope = {
    name: unsafeServiceName(resource)
  };
  const snapshot2 = /* @__PURE__ */ __name(() => {
    const snapshot3 = unsafeSnapshot2();
    const nowNanos = clock3.unsafeCurrentTimeNanos();
    const nowTime = String(nowNanos);
    const metricData = [];
    const metricDataByName = /* @__PURE__ */ new Map();
    const addMetricData = /* @__PURE__ */ __name((data) => {
      metricData.push(data);
      metricDataByName.set(data.name, data);
    }, "addMetricData");
    for (let i = 0, len = snapshot3.length; i < len; i++) {
      const {
        metricKey,
        metricState
      } = snapshot3[i];
      let unit = "1";
      const attributes = reduce(metricKey.tags, [], (acc, label) => {
        if (label.key === "unit" || label.key === "time_unit") {
          unit = label.value;
        }
        acc.push({
          key: label.key,
          value: {
            stringValue: label.value
          }
        });
        return acc;
      });
      if (isCounterState2(metricState)) {
        const dataPoint = {
          attributes,
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime
        };
        if (typeof metricState.count === "bigint") {
          dataPoint.asInt = Number(metricState.count);
        } else {
          dataPoint.asDouble = metricState.count;
        }
        if (metricDataByName.has(metricKey.name)) {
          metricDataByName.get(metricKey.name).sum.dataPoints.push(dataPoint);
        } else {
          const key = metricKey;
          addMetricData({
            name: metricKey.name,
            description: getOrEmpty(key.description),
            unit,
            sum: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              isMonotonic: key.keyType.incremental,
              dataPoints: [dataPoint]
            }
          });
        }
      } else if (isGaugeState2(metricState)) {
        const dataPoint = {
          attributes,
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime
        };
        if (typeof metricState.value === "bigint") {
          dataPoint.asInt = Number(metricState.value);
        } else {
          dataPoint.asDouble = metricState.value;
        }
        if (metricDataByName.has(metricKey.name)) {
          metricDataByName.get(metricKey.name).gauge.dataPoints.push(dataPoint);
        } else {
          addMetricData({
            name: metricKey.name,
            description: getOrEmpty(metricKey.description),
            unit,
            gauge: {
              dataPoints: [dataPoint]
            }
          });
        }
      } else if (isHistogramState2(metricState)) {
        const size22 = metricState.buckets.length;
        const buckets = {
          boundaries: allocate(size22 - 1),
          counts: allocate(size22)
        };
        let i2 = 0;
        let prev = 0;
        for (const [boundary, value6] of metricState.buckets) {
          if (i2 < size22 - 1) {
            buckets.boundaries[i2] = boundary;
          }
          buckets.counts[i2] = value6 - prev;
          prev = value6;
          i2++;
        }
        const dataPoint = {
          attributes,
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime,
          count: metricState.count,
          min: metricState.min,
          max: metricState.max,
          sum: metricState.sum,
          bucketCounts: buckets.counts,
          explicitBounds: buckets.boundaries
        };
        if (metricDataByName.has(metricKey.name)) {
          metricDataByName.get(metricKey.name).histogram.dataPoints.push(dataPoint);
        } else {
          addMetricData({
            name: metricKey.name,
            description: getOrEmpty(metricKey.description),
            unit,
            histogram: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              dataPoints: [dataPoint]
            }
          });
        }
      } else if (isFrequencyState2(metricState)) {
        const dataPoints = [];
        for (const [freqKey, value6] of metricState.occurrences) {
          dataPoints.push({
            attributes: [...attributes, {
              key: "key",
              value: {
                stringValue: freqKey
              }
            }],
            startTimeUnixNano: startTime,
            timeUnixNano: nowTime,
            asInt: value6
          });
        }
        if (metricDataByName.has(metricKey.name)) {
          metricDataByName.get(metricKey.name).sum.dataPoints.push(...dataPoints);
        } else {
          addMetricData({
            name: metricKey.name,
            description: getOrEmpty(metricKey.description),
            unit,
            sum: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              isMonotonic: true,
              dataPoints
            }
          });
        }
      } else if (isSummaryState2(metricState)) {
        const dataPoints = [{
          attributes: [...attributes, {
            key: "quantile",
            value: {
              stringValue: "min"
            }
          }],
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime,
          asDouble: metricState.min
        }];
        for (const [quantile, value6] of metricState.quantiles) {
          dataPoints.push({
            attributes: [...attributes, {
              key: "quantile",
              value: {
                stringValue: quantile.toString()
              }
            }],
            startTimeUnixNano: startTime,
            timeUnixNano: nowTime,
            asDouble: value6._tag === "Some" ? value6.value : 0
          });
        }
        dataPoints.push({
          attributes: [...attributes, {
            key: "quantile",
            value: {
              stringValue: "max"
            }
          }],
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime,
          asDouble: metricState.max
        });
        const countDataPoint = {
          attributes,
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime,
          asInt: metricState.count
        };
        const sumDataPoint = {
          attributes,
          startTimeUnixNano: startTime,
          timeUnixNano: nowTime,
          asDouble: metricState.sum
        };
        if (metricDataByName.has(`${metricKey.name}_quantiles`)) {
          metricDataByName.get(`${metricKey.name}_quantiles`).sum.dataPoints.push(...dataPoints);
          metricDataByName.get(`${metricKey.name}_count`).sum.dataPoints.push(countDataPoint);
          metricDataByName.get(`${metricKey.name}_sum`).sum.dataPoints.push(sumDataPoint);
        } else {
          addMetricData({
            name: `${metricKey.name}_quantiles`,
            description: getOrEmpty(metricKey.description),
            unit,
            sum: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              isMonotonic: false,
              dataPoints
            }
          });
          addMetricData({
            name: `${metricKey.name}_count`,
            description: getOrEmpty(metricKey.description),
            unit: "1",
            sum: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              isMonotonic: true,
              dataPoints: [countDataPoint]
            }
          });
          addMetricData({
            name: `${metricKey.name}_sum`,
            description: getOrEmpty(metricKey.description),
            unit: "1",
            sum: {
              aggregationTemporality: EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE,
              isMonotonic: true,
              dataPoints: [sumDataPoint]
            }
          });
        }
      }
    }
    return {
      resourceMetrics: [{
        resource,
        scopeMetrics: [{
          scope: metricsScope,
          metrics: metricData
        }]
      }]
    };
  }, "snapshot");
  yield* make71({
    label: "OtlpMetrics",
    url: options4.url,
    headers: options4.headers,
    maxBatchSize: "disabled",
    exportInterval: options4.exportInterval ?? seconds(10),
    body: snapshot2,
    shutdownTimeout: options4.shutdownTimeout ?? seconds(3)
  });
});
var layer2 = /* @__PURE__ */ __name((options4) => scopedDiscard2(make74(options4)), "layer");
var getOrEmpty = /* @__PURE__ */ getOrElse2(() => "");
var EAggregationTemporality;
(function(EAggregationTemporality2) {
  EAggregationTemporality2[EAggregationTemporality2["AGGREGATION_TEMPORALITY_UNSPECIFIED"] = 0] = "AGGREGATION_TEMPORALITY_UNSPECIFIED";
  EAggregationTemporality2[EAggregationTemporality2["AGGREGATION_TEMPORALITY_DELTA"] = 1] = "AGGREGATION_TEMPORALITY_DELTA";
  EAggregationTemporality2[EAggregationTemporality2["AGGREGATION_TEMPORALITY_CUMULATIVE"] = 2] = "AGGREGATION_TEMPORALITY_CUMULATIVE";
})(EAggregationTemporality || (EAggregationTemporality = {}));

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/OtlpTracer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ATTR_EXCEPTION_TYPE = "exception.type";
var ATTR_EXCEPTION_MESSAGE = "exception.message";
var ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
var make75 = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const otelResource = yield* fromConfig(options4.resource);
  const scope5 = {
    name: unsafeServiceName(otelResource)
  };
  const exporter = yield* make71({
    label: "OtlpTracer",
    url: options4.url,
    headers: options4.headers,
    exportInterval: options4.exportInterval ?? seconds(5),
    maxBatchSize: options4.maxBatchSize ?? 1e3,
    body(spans) {
      const data = {
        resourceSpans: [{
          resource: otelResource,
          scopeSpans: [{
            scope: scope5,
            spans
          }]
        }]
      };
      return data;
    },
    shutdownTimeout: options4.shutdownTimeout ?? seconds(3)
  });
  const exportFn = /* @__PURE__ */ __name((span4) => {
    exporter.push(makeOtlpSpan(span4));
  }, "exportFn");
  return make29({
    span(name, parent, context17, links, startTime, kind) {
      return makeSpan3({
        name,
        parent,
        context: context17,
        status: {
          _tag: "Started",
          startTime
        },
        attributes: /* @__PURE__ */ new Map(),
        links,
        sampled: true,
        kind,
        export: exportFn
      });
    },
    context: options4.context ? function(f, fiber) {
      if (fiber.currentSpan === void 0) {
        return f();
      }
      return options4.context(f, fiber.currentSpan);
    } : defaultContext
  });
});
var layer3 = /* @__PURE__ */ __name((options4) => unwrapScoped2(map22(make75(options4), setTracer2)), "layer");
function defaultContext(f, _) {
  return f();
}
__name(defaultContext, "defaultContext");
var SpanProto = {
  _tag: "Span",
  end(endTime, exit5) {
    this.status = {
      _tag: "Ended",
      startTime: this.status.startTime,
      endTime,
      exit: exit5
    };
    this.export(this);
  },
  attribute(key, value6) {
    this.attributes.set(key, value6);
  },
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes]);
  },
  addLinks(links) {
    this.links.push(...links);
  }
};
var makeSpan3 = /* @__PURE__ */ __name((options4) => {
  const self2 = Object.assign(Object.create(SpanProto), options4);
  if (isSome2(self2.parent)) {
    self2.traceId = self2.parent.value.traceId;
  } else {
    self2.traceId = generateId(32);
  }
  self2.spanId = generateId(16);
  self2.events = [];
  return self2;
}, "makeSpan");
var generateId = /* @__PURE__ */ __name((len) => {
  const chars = "0123456789abcdef";
  let result = "";
  for (let i = 0; i < len; i++) {
    result += chars[Math.floor(Math.random() * chars.length)];
  }
  return result;
}, "generateId");
var makeOtlpSpan = /* @__PURE__ */ __name((self2) => {
  const status3 = self2.status;
  const attributes = entriesToAttributes(self2.attributes.entries());
  const events2 = self2.events.map(([name, startTime, attributes2]) => ({
    name,
    timeUnixNano: String(startTime),
    attributes: attributes2 ? entriesToAttributes(Object.entries(attributes2)) : [],
    droppedAttributesCount: 0
  }));
  let otelStatus;
  if (status3.exit._tag === "Success") {
    otelStatus = constOtelStatusSuccess;
  } else if (isInterruptedOnly2(status3.exit.cause)) {
    otelStatus = {
      code: StatusCode.Ok,
      message: pretty3(status3.exit.cause)
    };
  } else {
    const errors4 = prettyErrors2(status3.exit.cause);
    const firstError = errors4[0];
    otelStatus = {
      code: StatusCode.Error
    };
    attributes.push({
      key: "span.label",
      value: {
        stringValue: "\u26A0\uFE0E Interrupted"
      }
    }, {
      key: "status.interrupted",
      value: {
        boolValue: true
      }
    });
    if (firstError) {
      otelStatus.message = firstError.message;
      events2.push({
        name: "exception",
        timeUnixNano: String(status3.endTime),
        droppedAttributesCount: 0,
        attributes: [{
          "key": ATTR_EXCEPTION_TYPE,
          "value": {
            "stringValue": firstError.name
          }
        }, {
          "key": ATTR_EXCEPTION_MESSAGE,
          "value": {
            "stringValue": firstError.message
          }
        }, {
          "key": ATTR_EXCEPTION_STACKTRACE,
          "value": {
            "stringValue": pretty3(status3.exit.cause, {
              renderErrorCause: true
            })
          }
        }]
      });
    }
  }
  return {
    traceId: self2.traceId,
    spanId: self2.spanId,
    parentSpanId: isSome2(self2.parent) ? self2.parent.value.spanId : void 0,
    name: self2.name,
    kind: SpanKind[self2.kind],
    startTimeUnixNano: String(status3.startTime),
    endTimeUnixNano: String(status3.endTime),
    attributes,
    droppedAttributesCount: 0,
    events: events2,
    droppedEventsCount: 0,
    status: otelStatus,
    links: self2.links.map((link) => ({
      traceId: link.span.traceId,
      spanId: link.span.spanId,
      attributes: entriesToAttributes(Object.entries(link.attributes)),
      droppedAttributesCount: 0
    })),
    droppedLinksCount: 0
  };
}, "makeOtlpSpan");
var StatusCode;
(function(StatusCode2) {
  StatusCode2[StatusCode2["Unset"] = 0] = "Unset";
  StatusCode2[StatusCode2["Ok"] = 1] = "Ok";
  StatusCode2[StatusCode2["Error"] = 2] = "Error";
})(StatusCode || (StatusCode = {}));
var SpanKind;
(function(SpanKind3) {
  SpanKind3[SpanKind3["unspecified"] = 0] = "unspecified";
  SpanKind3[SpanKind3["internal"] = 1] = "internal";
  SpanKind3[SpanKind3["server"] = 2] = "server";
  SpanKind3[SpanKind3["client"] = 3] = "client";
  SpanKind3[SpanKind3["producer"] = 4] = "producer";
  SpanKind3[SpanKind3["consumer"] = 5] = "consumer";
})(SpanKind || (SpanKind = {}));
var constOtelStatusSuccess = {
  code: StatusCode.Ok
};

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/Otlp.js
var layer4 = /* @__PURE__ */ __name((options4) => {
  const baseReq = get20(options4.baseUrl);
  const url2 = /* @__PURE__ */ __name((path) => appendUrl2(baseReq, path).url, "url");
  return mergeAll6(layer({
    replaceLogger: options4.replaceLogger,
    url: url2("/v1/logs"),
    resource: options4.resource,
    headers: options4.headers,
    exportInterval: options4.loggerExportInterval,
    maxBatchSize: options4.maxBatchSize,
    shutdownTimeout: options4.shutdownTimeout,
    excludeLogSpans: options4.loggerExcludeLogSpans
  }), layer2({
    url: url2("/v1/metrics"),
    resource: options4.resource,
    headers: options4.headers,
    exportInterval: options4.metricsExportInterval,
    shutdownTimeout: options4.shutdownTimeout
  }), layer3({
    url: url2("/v1/traces"),
    resource: options4.resource,
    headers: options4.headers,
    exportInterval: options4.tracerExportInterval,
    maxBatchSize: options4.maxBatchSize,
    context: options4.tracerContext,
    shutdownTimeout: options4.shutdownTimeout
  }));
}, "layer");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Etag.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/etag.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var GeneratorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Etag/Generator");
var tag4 = /* @__PURE__ */ GenericTag("@effect/platform/Etag/Generator");
var toString2 = /* @__PURE__ */ __name((self2) => {
  switch (self2._tag) {
    case "Weak":
      return `W/"${self2.value}"`;
    case "Strong":
      return `"${self2.value}"`;
  }
}, "toString");
var fromFileInfo = /* @__PURE__ */ __name((info4) => {
  const mtime = info4.mtime._tag === "Some" ? info4.mtime.value.getTime().toString(16) : "0";
  return `${info4.size.toString(16)}-${mtime}`;
}, "fromFileInfo");
var fromFileWeb = /* @__PURE__ */ __name((file3) => {
  return `${file3.size.toString(16)}-${file3.lastModified.toString(16)}`;
}, "fromFileWeb");
var layer5 = /* @__PURE__ */ succeed13(tag4, /* @__PURE__ */ tag4.of({
  [GeneratorTypeId]: GeneratorTypeId,
  fromFileInfo(info4) {
    return sync7(() => ({
      _tag: "Strong",
      value: fromFileInfo(info4)
    }));
  },
  fromFileWeb(file3) {
    return sync7(() => ({
      _tag: "Strong",
      value: fromFileWeb(file3)
    }));
  }
}));
var layerWeak = /* @__PURE__ */ succeed13(tag4, /* @__PURE__ */ tag4.of({
  [GeneratorTypeId]: GeneratorTypeId,
  fromFileInfo(info4) {
    return sync7(() => ({
      _tag: "Weak",
      value: fromFileInfo(info4)
    }));
  },
  fromFileWeb(file3) {
    return sync7(() => ({
      _tag: "Weak",
      value: fromFileWeb(file3)
    }));
  }
}));

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Etag.js
var toString3 = toString2;
var Generator = tag4;
var layerWeak2 = layerWeak;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/FetchHttpClient.js
var FetchHttpClient_exports = {};
__export(FetchHttpClient_exports, {
  Fetch: () => Fetch,
  RequestInit: () => RequestInit,
  layer: () => layer7
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/fetchHttpClient.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var fetchTagKey = "@effect/platform/FetchHttpClient/Fetch";
var requestInitTagKey = "@effect/platform/FetchHttpClient/FetchOptions";
var fetch2 = /* @__PURE__ */ make69((request2, url2, signal, fiber) => {
  const context17 = fiber.getFiberRef(currentContext2);
  const fetch3 = context17.unsafeMap.get(fetchTagKey) ?? globalThis.fetch;
  const options4 = context17.unsafeMap.get(requestInitTagKey) ?? {};
  const headers = options4.headers ? merge9(fromInput(options4.headers), request2.headers) : request2.headers;
  const send2 = /* @__PURE__ */ __name((body) => map22(tryPromise2({
    try: /* @__PURE__ */ __name(() => fetch3(url2, {
      ...options4,
      method: request2.method,
      headers,
      body,
      duplex: request2.body._tag === "Stream" ? "half" : void 0,
      signal
    }), "try"),
    catch: /* @__PURE__ */ __name((cause3) => new RequestError({
      request: request2,
      reason: "Transport",
      cause: cause3
    }), "catch")
  }), (response) => fromWeb(request2, response)), "send");
  switch (request2.body._tag) {
    case "Raw":
    case "Uint8Array":
      return send2(request2.body.body);
    case "FormData":
      return send2(request2.body.formData);
    case "Stream":
      return flatMap15(toReadableStreamEffect2(request2.body.stream), send2);
  }
  return send2(void 0);
});
var layer6 = /* @__PURE__ */ layerMergedContext(/* @__PURE__ */ succeed11(fetch2));

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/FetchHttpClient.js
var Fetch = class extends (/* @__PURE__ */ Tag2(fetchTagKey)()) {
  static {
    __name(this, "Fetch");
  }
};
var RequestInit = class extends (/* @__PURE__ */ Tag2(requestInitTagKey)()) {
  static {
    __name(this, "RequestInit");
  }
};
var layer7 = layer6;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Unify.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var unify2 = identity;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpApp.js
var HttpApp_exports = {};
__export(HttpApp_exports, {
  appendPreResponseHandler: () => appendPreResponseHandler2,
  currentPreResponseHandlers: () => currentPreResponseHandlers2,
  ejectDefaultScopeClose: () => ejectDefaultScopeClose,
  toHandled: () => toHandled,
  toWebHandler: () => toWebHandler,
  toWebHandlerLayer: () => toWebHandlerLayer,
  toWebHandlerLayerWith: () => toWebHandlerLayerWith,
  toWebHandlerRuntime: () => toWebHandlerRuntime,
  unsafeEjectStreamScope: () => unsafeEjectStreamScope,
  withPreResponseHandler: () => withPreResponseHandler2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpBody.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var uint8Array3 = uint8Array2;
var text2 = text;
var stream3 = stream2;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpServerError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpServerRespondable.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpServerResponse.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpServerResponse.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId33 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServerResponse");
var respondableSymbol = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServerRespondable");
var ServerResponseImpl = class extends StructuralClass {
  static {
    __name(this, "ServerResponseImpl");
  }
  status;
  statusText;
  cookies;
  body;
  [TypeId33];
  headers;
  constructor(status3, statusText, headers, cookies, body) {
    super();
    this.status = status3;
    this.statusText = statusText;
    this.cookies = cookies;
    this.body = body;
    this[TypeId33] = TypeId33;
    if (body.contentType || body.contentLength) {
      const newHeaders = {
        ...headers
      };
      if (body.contentType) {
        newHeaders["content-type"] = body.contentType;
      }
      if (body.contentLength) {
        newHeaders["content-length"] = body.contentLength.toString();
      }
      this.headers = newHeaders;
    } else {
      this.headers = headers;
    }
  }
  commit() {
    return succeed11(this);
  }
  [respondableSymbol]() {
    return succeed11(this);
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  toString() {
    return format(this);
  }
  toJSON() {
    return {
      _id: "@effect/platform/HttpServerResponse",
      status: this.status,
      statusText: this.statusText,
      headers: redact(this.headers),
      cookies: this.cookies.toJSON(),
      body: this.body.toJSON()
    };
  }
};
var isServerResponse = /* @__PURE__ */ __name((u) => typeof u === "object" && u !== null && TypeId33 in u, "isServerResponse");
var empty41 = /* @__PURE__ */ __name((options4) => new ServerResponseImpl(options4?.status ?? 204, options4?.statusText, options4?.headers ? fromInput(options4.headers) : empty34, options4?.cookies ?? empty40, empty38), "empty");
var text3 = /* @__PURE__ */ __name((body, options4) => {
  const headers = options4?.headers ? fromInput(options4.headers) : empty34;
  return new ServerResponseImpl(options4?.status ?? 200, options4?.statusText, headers, options4?.cookies ?? empty40, text(body, getContentType(options4, headers)));
}, "text");
var stream4 = /* @__PURE__ */ __name((body, options4) => {
  const headers = options4?.headers ? fromInput(options4.headers) : empty34;
  return new ServerResponseImpl(options4?.status ?? 200, options4?.statusText, headers, options4?.cookies ?? empty40, stream2(body, getContentType(options4, headers), options4?.contentLength));
}, "stream");
var getContentType = /* @__PURE__ */ __name((options4, headers) => {
  if (options4?.contentType) {
    return options4.contentType;
  } else if (options4?.headers) {
    return headers["content-type"];
  } else {
    return;
  }
}, "getContentType");
var setBody2 = /* @__PURE__ */ dual(2, (self2, body) => {
  let headers = self2.headers;
  if (body._tag === "Empty") {
    headers = remove10(remove10(headers, "Content-Type"), "Content-length");
  }
  return new ServerResponseImpl(self2.status, self2.statusText, headers, self2.cookies, body);
});
var toWeb = /* @__PURE__ */ __name((response, options4) => {
  const headers = new globalThis.Headers(response.headers);
  if (!isEmpty18(response.cookies)) {
    const toAdd = toSetCookieHeaders(response.cookies);
    for (const header of toAdd) {
      headers.append("set-cookie", header);
    }
  }
  if (options4?.withoutBody) {
    return new Response(void 0, {
      status: response.status,
      statusText: response.statusText,
      headers
    });
  }
  const body = response.body;
  switch (body._tag) {
    case "Empty": {
      return new Response(void 0, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    }
    case "Uint8Array":
    case "Raw": {
      if (body.body instanceof Response) {
        for (const [key, value6] of headers) {
          body.body.headers.set(key, value6);
        }
        return body.body;
      }
      return new Response(body.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    }
    case "FormData": {
      return new Response(body.formData, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    }
    case "Stream": {
      return new Response(toReadableStreamRuntime2(body.stream, options4?.runtime ?? defaultRuntime2), {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    }
  }
}, "toWeb");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpServerResponse.js
var isServerResponse2 = isServerResponse;
var empty42 = empty41;
var text4 = text3;
var stream5 = stream4;
var setBody3 = setBody2;
var toWeb2 = toWeb;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpServerRespondable.js
var symbol3 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServerRespondable");
var isRespondable = /* @__PURE__ */ __name((u) => hasProperty(u, symbol3), "isRespondable");
var badRequest = /* @__PURE__ */ empty42({
  status: 400
});
var notFound2 = /* @__PURE__ */ empty42({
  status: 404
});
var toResponse = /* @__PURE__ */ __name((self2) => {
  if (isServerResponse2(self2)) {
    return succeed11(self2);
  }
  return orDie3(self2[symbol3]());
}, "toResponse");
var toResponseOrElse = /* @__PURE__ */ __name((u, orElse19) => {
  if (isServerResponse2(u)) {
    return succeed11(u);
  } else if (isRespondable(u)) {
    return catchAllCause3(u[symbol3](), () => succeed11(orElse19));
  } else if (isParseError(u)) {
    return succeed11(badRequest);
  } else if (isNoSuchElementException2(u)) {
    return succeed11(notFound2);
  }
  return succeed11(orElse19);
}, "toResponseOrElse");
var toResponseOrElseDefect = /* @__PURE__ */ __name((u, orElse19) => {
  if (isServerResponse2(u)) {
    return succeed11(u);
  } else if (isRespondable(u)) {
    return catchAllCause3(u[symbol3](), () => succeed11(orElse19));
  }
  return succeed11(orElse19);
}, "toResponseOrElseDefect");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpServerError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId34 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServerError");
var clientAbortFiberId = /* @__PURE__ */ globalValue("@effect/platform/HttpServerError/clientAbortFiberId", () => runtime2(-499, 0));
var causeResponse = /* @__PURE__ */ __name((cause3) => {
  const [effect4, stripped] = reduce11(cause3, [succeed11(internalServerError), empty27], (acc, cause4) => {
    switch (cause4._tag) {
      case "Empty": {
        return some3(acc);
      }
      case "Fail": {
        return some3([toResponseOrElse(cause4.error, internalServerError), cause4]);
      }
      case "Die": {
        return some3([toResponseOrElseDefect(cause4.defect, internalServerError), cause4]);
      }
      case "Interrupt": {
        if (acc[1]._tag !== "Empty") {
          return none2();
        }
        const response = cause4.fiberId === clientAbortFiberId ? clientAbortError : serverAbortError;
        return some3([succeed11(response), cause4]);
      }
      default: {
        return none2();
      }
    }
  });
  return map22(effect4, (response) => {
    if (isEmptyType2(stripped)) {
      return [response, die4(response)];
    }
    return [response, sequential4(stripped, die4(response))];
  });
}, "causeResponse");
var causeResponseStripped = /* @__PURE__ */ __name((cause3) => {
  let response;
  const stripped = stripSomeDefects2(cause3, (defect) => {
    if (isServerResponse(defect)) {
      response = defect;
      return some3(empty27);
    }
    return none2();
  });
  return [response ?? internalServerError, stripped];
}, "causeResponseStripped");
var internalServerError = /* @__PURE__ */ empty41({
  status: 500
});
var clientAbortError = /* @__PURE__ */ empty41({
  status: 499
});
var serverAbortError = /* @__PURE__ */ empty41({
  status: 503
});
var exitResponse = /* @__PURE__ */ __name((exit5) => {
  if (exit5._tag === "Success") {
    return exit5.value;
  }
  return causeResponseStripped(exit5.cause)[0];
}, "exitResponse");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpServerError.js
var TypeId35 = TypeId34;
var RequestError2 = class extends (/* @__PURE__ */ TypeIdError(TypeId35, "RequestError")) {
  static {
    __name(this, "RequestError");
  }
  /**
   * @since 1.0.0
   */
  [symbol3]() {
    return empty42({
      status: 400
    });
  }
  get methodAndUrl() {
    return `${this.request.method} ${this.request.url}`;
  }
  get message() {
    return this.description ? `${this.reason}: ${this.description} (${this.methodAndUrl})` : `${this.reason} error (${this.methodAndUrl})`;
  }
};
var RouteNotFound = class extends (/* @__PURE__ */ TypeIdError(TypeId35, "RouteNotFound")) {
  static {
    __name(this, "RouteNotFound");
  }
  constructor(options4) {
    super(options4);
    this.stack = `${this.name}: ${this.message}`;
  }
  /**
   * @since 1.0.0
   */
  [symbol3]() {
    return empty42({
      status: 404
    });
  }
  get message() {
    return `${this.request.method} ${this.request.url} not found`;
  }
};
var ResponseError2 = class extends (/* @__PURE__ */ TypeIdError(TypeId35, "ResponseError")) {
  static {
    __name(this, "ResponseError");
  }
  /**
   * @since 1.0.0
   */
  [symbol3]() {
    return empty42({
      status: 500
    });
  }
  get methodAndUrl() {
    return `${this.request.method} ${this.request.url}`;
  }
  get message() {
    const info4 = `${this.response.status} ${this.methodAndUrl}`;
    return this.description ? `${this.description} (${info4})` : `${this.reason} error (${info4})`;
  }
};
var clientAbortFiberId2 = clientAbortFiberId;
var causeResponse2 = causeResponse;
var exitResponse2 = exitResponse;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpServerRequest.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpServerRequest.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Multipart.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Mailbox.js
var Mailbox_exports = {};
__export(Mailbox_exports, {
  ReadonlyTypeId: () => ReadonlyTypeId2,
  TypeId: () => TypeId37,
  fromStream: () => fromStream2,
  into: () => into2,
  isMailbox: () => isMailbox,
  isReadonlyMailbox: () => isReadonlyMailbox,
  make: () => make77,
  toChannel: () => toChannel5,
  toStream: () => toStream2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/mailbox.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId36 = /* @__PURE__ */ Symbol.for("effect/Mailbox");
var ReadonlyTypeId = /* @__PURE__ */ Symbol.for("effect/Mailbox/ReadonlyMailbox");
var empty43 = /* @__PURE__ */ empty4();
var exitEmpty = /* @__PURE__ */ exitSucceed(empty43);
var exitFalse = /* @__PURE__ */ exitSucceed(false);
var exitTrue = /* @__PURE__ */ exitSucceed(true);
var constDone = [empty43, true];
var MailboxImpl = class extends Class2 {
  static {
    __name(this, "MailboxImpl");
  }
  scheduler;
  capacity;
  strategy;
  [TypeId36] = TypeId36;
  [ReadonlyTypeId] = ReadonlyTypeId;
  state = {
    _tag: "Open",
    takers: /* @__PURE__ */ new Set(),
    offers: /* @__PURE__ */ new Set(),
    awaiters: /* @__PURE__ */ new Set()
  };
  messages = [];
  messagesChunk = /* @__PURE__ */ empty4();
  constructor(scheduler2, capacity9, strategy) {
    super();
    this.scheduler = scheduler2;
    this.capacity = capacity9;
    this.strategy = strategy;
  }
  offer(message) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return exitFalse;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        switch (this.strategy) {
          case "dropping":
            return exitFalse;
          case "suspend":
            if (this.capacity <= 0 && this.state.takers.size > 0) {
              this.messages.push(message);
              this.releaseTaker();
              return exitTrue;
            }
            return this.offerRemainingSingle(message);
          case "sliding":
            this.unsafeTake();
            this.messages.push(message);
            return exitTrue;
        }
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return exitTrue;
    });
  }
  unsafeOffer(message) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
      if (this.strategy === "sliding") {
        this.unsafeTake();
        this.messages.push(message);
        return true;
      } else if (this.capacity <= 0 && this.state.takers.size > 0) {
        this.messages.push(message);
        this.releaseTaker();
        return true;
      }
      return false;
    }
    this.messages.push(message);
    this.scheduleReleaseTaker();
    return true;
  }
  offerAll(messages) {
    return suspend(() => {
      if (this.state._tag !== "Open") {
        return succeed(fromIterable3(messages));
      }
      const remaining = this.unsafeOfferAllArray(messages);
      if (remaining.length === 0) {
        return exitEmpty;
      } else if (this.strategy === "dropping") {
        return succeed(unsafeFromArray(remaining));
      }
      return this.offerRemainingArray(remaining);
    });
  }
  unsafeOfferAll(messages) {
    return unsafeFromArray(this.unsafeOfferAllArray(messages));
  }
  unsafeOfferAllArray(messages) {
    if (this.state._tag !== "Open") {
      return fromIterable2(messages);
    } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
      if (this.messages.length > 0) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
      }
      if (this.strategy === "sliding") {
        this.messagesChunk = this.messagesChunk.pipe(appendAll2(fromIterable3(messages)), takeRight2(this.capacity));
      } else if (isChunk(messages)) {
        this.messagesChunk = appendAll2(this.messagesChunk, messages);
      } else {
        this.messages = fromIterable2(messages);
      }
      this.scheduleReleaseTaker();
      return [];
    }
    const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
    if (free === 0) {
      return fromIterable2(messages);
    }
    const remaining = [];
    let i = 0;
    for (const message of messages) {
      if (i < free) {
        this.messages.push(message);
      } else {
        remaining.push(message);
      }
      i++;
    }
    this.scheduleReleaseTaker();
    return remaining;
  }
  fail(error5) {
    return this.done(exitFail(error5));
  }
  failCause(cause3) {
    return this.done(exitFailCause(cause3));
  }
  unsafeDone(exit5) {
    if (this.state._tag !== "Open") {
      return false;
    } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
      this.finalize(exit5);
      return true;
    }
    this.state = {
      ...this.state,
      _tag: "Closing",
      exit: exit5
    };
    return true;
  }
  shutdown = /* @__PURE__ */ sync(() => {
    if (this.state._tag === "Done") {
      return true;
    }
    this.messages = [];
    this.messagesChunk = empty43;
    const offers = this.state.offers;
    this.finalize(this.state._tag === "Open" ? exitVoid : this.state.exit);
    if (offers.size > 0) {
      for (const entry of offers) {
        if (entry._tag === "Single") {
          entry.resume(exitFalse);
        } else {
          entry.resume(exitSucceed(unsafeFromArray(entry.remaining.slice(entry.offset))));
        }
      }
      offers.clear();
    }
    return true;
  });
  done(exit5) {
    return sync(() => this.unsafeDone(exit5));
  }
  end = /* @__PURE__ */ this.done(exitVoid);
  clear = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, empty43);
    }
    const messages = this.unsafeTakeAll();
    this.releaseCapacity();
    return succeed(messages);
  });
  takeAll = /* @__PURE__ */ suspend(() => {
    if (this.state._tag === "Done") {
      return exitAs(this.state.exit, constDone);
    }
    const messages = this.unsafeTakeAll();
    if (messages.length === 0) {
      return zipRight2(this.awaitTake, this.takeAll);
    }
    return succeed([messages, this.releaseCapacity()]);
  });
  takeN(n) {
    return suspend(() => {
      if (this.state._tag === "Done") {
        return exitAs(this.state.exit, constDone);
      } else if (n <= 0) {
        return succeed([empty43, false]);
      }
      n = Math.min(n, this.capacity);
      let messages;
      if (n <= this.messagesChunk.length) {
        messages = take2(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else if (n <= this.messages.length + this.messagesChunk.length) {
        this.messagesChunk = appendAll2(this.messagesChunk, unsafeFromArray(this.messages));
        this.messages = [];
        messages = take2(this.messagesChunk, n);
        this.messagesChunk = drop2(this.messagesChunk, n);
      } else {
        return zipRight2(this.awaitTake, this.takeN(n));
      }
      return succeed([messages, this.releaseCapacity()]);
    });
  }
  unsafeTake() {
    if (this.state._tag === "Done") {
      return exitZipRight(this.state.exit, exitFail(new NoSuchElementException2()));
    }
    let message;
    if (this.messagesChunk.length > 0) {
      message = unsafeHead2(this.messagesChunk);
      this.messagesChunk = drop2(this.messagesChunk, 1);
    } else if (this.messages.length > 0) {
      message = this.messages[0];
      this.messagesChunk = drop2(unsafeFromArray(this.messages), 1);
      this.messages = [];
    } else if (this.capacity <= 0 && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return this.messages.length > 0 ? exitSucceed(this.messages.pop()) : void 0;
    } else {
      return void 0;
    }
    this.releaseCapacity();
    return exitSucceed(message);
  }
  take = /* @__PURE__ */ suspend(() => this.unsafeTake() ?? zipRight2(this.awaitTake, this.take));
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.awaiters.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.awaiters.delete(resume2);
      }
    });
  });
  unsafeSize() {
    const size22 = this.messages.length + this.messagesChunk.length;
    return this.state._tag === "Done" ? none2() : some3(size22);
  }
  size = /* @__PURE__ */ sync(() => this.unsafeSize());
  commit() {
    return this.takeAll;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "effect/Mailbox",
      state: this.state._tag,
      size: this.unsafeSize().toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return format(this);
  }
  offerRemainingSingle(message) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitFalse);
      }
      const entry = {
        _tag: "Single",
        message,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  offerRemainingArray(remaining) {
    return asyncInterrupt((resume2) => {
      if (this.state._tag !== "Open") {
        return resume2(exitSucceed(unsafeFromArray(remaining)));
      }
      const entry = {
        _tag: "Array",
        remaining,
        offset: 0,
        resume: resume2
      };
      this.state.offers.add(entry);
      return sync(() => {
        if (this.state._tag === "Open") {
          this.state.offers.delete(entry);
        }
      });
    });
  }
  releaseCapacity() {
    if (this.state._tag === "Done") {
      return this.state.exit._tag === "Success";
    } else if (this.state.offers.size === 0) {
      if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(this.state.exit);
        return this.state.exit._tag === "Success";
      }
      return false;
    }
    let n = this.capacity - this.messages.length - this.messagesChunk.length;
    for (const entry of this.state.offers) {
      if (n === 0) return false;
      else if (entry._tag === "Single") {
        this.messages.push(entry.message);
        n--;
        entry.resume(exitTrue);
        this.state.offers.delete(entry);
      } else {
        for (; entry.offset < entry.remaining.length; entry.offset++) {
          if (n === 0) return false;
          this.messages.push(entry.remaining[entry.offset]);
          n--;
        }
        entry.resume(exitEmpty);
        this.state.offers.delete(entry);
      }
    }
    return false;
  }
  awaitTake = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.state._tag === "Done") {
      return resume2(this.state.exit);
    }
    this.state.takers.add(resume2);
    return sync(() => {
      if (this.state._tag !== "Done") {
        this.state.takers.delete(resume2);
      }
    });
  });
  scheduleRunning = false;
  scheduleReleaseTaker() {
    if (this.scheduleRunning) {
      return;
    }
    this.scheduleRunning = true;
    this.scheduler.scheduleTask(this.releaseTaker, 0);
  }
  releaseTaker = /* @__PURE__ */ __name(() => {
    this.scheduleRunning = false;
    if (this.state._tag === "Done") {
      return;
    } else if (this.state.takers.size === 0) {
      return;
    }
    for (const taker of this.state.takers) {
      this.state.takers.delete(taker);
      taker(exitVoid);
      if (this.messages.length + this.messagesChunk.length === 0) {
        break;
      }
    }
  }, "releaseTaker");
  unsafeTakeAll() {
    if (this.messagesChunk.length > 0) {
      const messages = this.messages.length > 0 ? appendAll2(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
      this.messagesChunk = empty43;
      this.messages = [];
      return messages;
    } else if (this.messages.length > 0) {
      const messages = unsafeFromArray(this.messages);
      this.messages = [];
      return messages;
    } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
      this.capacity = 1;
      this.releaseCapacity();
      this.capacity = 0;
      return of2(this.messages.pop());
    }
    return empty43;
  }
  finalize(exit5) {
    if (this.state._tag === "Done") {
      return;
    }
    const openState = this.state;
    this.state = {
      _tag: "Done",
      exit: exit5
    };
    for (const taker of openState.takers) {
      taker(exit5);
    }
    openState.takers.clear();
    for (const awaiter of openState.awaiters) {
      awaiter(exit5);
    }
    openState.awaiters.clear();
  }
};
var make76 = /* @__PURE__ */ __name((capacity9) => withFiberRuntime((fiber) => succeed(new MailboxImpl(fiber.currentScheduler, typeof capacity9 === "number" ? capacity9 : capacity9?.capacity ?? Number.POSITIVE_INFINITY, typeof capacity9 === "number" ? "suspend" : capacity9?.strategy ?? "suspend"))), "make");
var into = /* @__PURE__ */ dual(2, (effect4, self2) => uninterruptibleMask((restore) => matchCauseEffect(restore(effect4), {
  onFailure: /* @__PURE__ */ __name((cause3) => self2.failCause(cause3), "onFailure"),
  onSuccess: /* @__PURE__ */ __name((_) => self2.end, "onSuccess")
})));
var toChannel4 = /* @__PURE__ */ __name((self2) => {
  const loop5 = flatMap18(self2.takeAll, ([messages, done12]) => done12 ? messages.length === 0 ? void_8 : write(messages) : zipRight8(write(messages), loop5));
  return loop5;
}, "toChannel");
var toStream = /* @__PURE__ */ __name((self2) => fromChannel2(toChannel4(self2)), "toStream");
var fromStream = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options4) => tap2(acquireRelease(make76(options4), (mailbox) => mailbox.shutdown), (mailbox) => {
  const writer = readWithCause({
    onInput: /* @__PURE__ */ __name((input) => flatMap18(mailbox.offerAll(input), () => writer), "onInput"),
    onFailure: /* @__PURE__ */ __name((cause3) => mailbox.failCause(cause3), "onFailure"),
    onDone: /* @__PURE__ */ __name(() => mailbox.end, "onDone")
  });
  return scopeWith((scope5) => toChannel2(self2).pipe(pipeTo(writer), runIn(scope5), forkIn(scope5)));
}));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Mailbox.js
var TypeId37 = TypeId36;
var ReadonlyTypeId2 = ReadonlyTypeId;
var isMailbox = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId37), "isMailbox");
var isReadonlyMailbox = /* @__PURE__ */ __name((u) => hasProperty(u, ReadonlyTypeId2), "isReadonlyMailbox");
var make77 = make76;
var into2 = into;
var toChannel5 = toChannel4;
var toStream2 = toStream;
var fromStream2 = fromStream;

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/internal/multipart.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/internal/contentType.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var paramRE = /; *([!#$%&'*+.^\w`|~-]+)=("(?:[\v\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\v\u0020-\u00ff])*"|[!#$%&'*+.^\w`|~-]+) */gu;
var quotedPairRE = /\\([\v\u0020-\u00ff])/gu;
var mediaTypeRE = /^[!#$%&'*+.^\w|~-]+\/[!#$%&'*+.^\w|~-]+$/u;
var mediaTypeRENoSlash = /^[!#$%&'*+.^\w|~-]+$/u;
var defaultContentType = {
  value: "",
  parameters: /* @__PURE__ */ Object.create(null)
};
function parse3(header, withoutSlash = false) {
  if (typeof header !== "string") {
    return defaultContentType;
  }
  let index2 = header.indexOf(";");
  const type3 = index2 !== -1 ? header.slice(0, index2).trim() : header.trim();
  const mediaRE = withoutSlash ? mediaTypeRENoSlash : mediaTypeRE;
  if (mediaRE.test(type3) === false) {
    return defaultContentType;
  }
  const result = {
    value: type3.toLowerCase(),
    parameters: /* @__PURE__ */ Object.create(null)
  };
  if (index2 === -1) {
    return result;
  }
  let key;
  let match24;
  let value6;
  paramRE.lastIndex = index2;
  while (match24 = paramRE.exec(header)) {
    if (match24.index !== index2) {
      return defaultContentType;
    }
    index2 += match24[0].length;
    key = match24[1].toLowerCase();
    value6 = match24[2];
    if (value6[0] === '"') {
      value6 = value6.slice(1, value6.length - 1);
      !withoutSlash && quotedPairRE.test(value6) && (value6 = value6.replace(quotedPairRE, "$1"));
    }
    result.parameters[key] = value6;
  }
  if (index2 !== header.length) {
    return defaultContentType;
  }
  return result;
}
__name(parse3, "parse");

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/internal/headers.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var constMaxPairs = 100;
var constMaxSize = 16 * 1024;
var State;
(function(State3) {
  State3[State3["key"] = 0] = "key";
  State3[State3["whitespace"] = 1] = "whitespace";
  State3[State3["value"] = 2] = "value";
})(State || (State = {}));
var constContinue = {
  _tag: "Continue"
};
var constNameChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1];
var constValueChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
function make78() {
  const decoder4 = new TextDecoder();
  const state2 = {
    state: State.key,
    headers: /* @__PURE__ */ Object.create(null),
    key: "",
    value: void 0,
    crlf: 0,
    previousChunk: void 0,
    pairs: 0,
    size: 0
  };
  function reset2(value6) {
    state2.state = State.key;
    state2.headers = /* @__PURE__ */ Object.create(null);
    state2.key = "";
    state2.value = void 0;
    state2.crlf = 0;
    state2.previousChunk = void 0;
    state2.pairs = 0;
    state2.size = 0;
    return value6;
  }
  __name(reset2, "reset");
  function concatUint8Array(a, b) {
    const newUint8Array = new Uint8Array(a.length + b.length);
    newUint8Array.set(a);
    newUint8Array.set(b, a.length);
    return newUint8Array;
  }
  __name(concatUint8Array, "concatUint8Array");
  function error5(reason) {
    return reset2({
      _tag: "Failure",
      reason,
      headers: state2.headers
    });
  }
  __name(error5, "error");
  return /* @__PURE__ */ __name(function write3(chunk4, start3) {
    let endOffset = 0;
    let previousCursor;
    if (state2.previousChunk !== void 0) {
      endOffset = state2.previousChunk.length;
      previousCursor = endOffset;
      const newChunk = new Uint8Array(chunk4.length + endOffset);
      newChunk.set(state2.previousChunk);
      newChunk.set(chunk4, endOffset);
      state2.previousChunk = void 0;
      chunk4 = newChunk;
    }
    const end6 = chunk4.length;
    outer: while (start3 < end6) {
      if (state2.state === State.key) {
        let i = start3;
        for (; i < end6; i++) {
          if (state2.size++ > constMaxSize) {
            return error5("HeaderTooLarge");
          }
          if (chunk4[i] === 58) {
            state2.key += decoder4.decode(chunk4.subarray(start3, i)).toLowerCase();
            if (state2.key.length === 0) {
              return error5("InvalidHeaderName");
            }
            if (chunk4[i + 1] === 32 && chunk4[i + 2] !== 32 && chunk4[i + 2] !== 9) {
              start3 = i + 2;
              state2.state = State.value;
              state2.size++;
            } else if (chunk4[i + 1] !== 32 && chunk4[i + 1] !== 9) {
              start3 = i + 1;
              state2.state = State.value;
            } else {
              start3 = i + 1;
              state2.state = State.whitespace;
            }
            break;
          } else if (constNameChars[chunk4[i]] !== 1) {
            return error5("InvalidHeaderName");
          }
        }
        if (i === end6) {
          state2.key += decoder4.decode(chunk4.subarray(start3, end6)).toLowerCase();
          return constContinue;
        }
      }
      if (state2.state === State.whitespace) {
        for (; start3 < end6; start3++) {
          if (state2.size++ > constMaxSize) {
            return error5("HeaderTooLarge");
          }
          if (chunk4[start3] !== 32 && chunk4[start3] !== 9) {
            state2.state = State.value;
            break;
          }
        }
        if (start3 === end6) {
          return constContinue;
        }
      }
      if (state2.state === State.value) {
        let i = start3;
        if (previousCursor !== void 0) {
          i = previousCursor;
          previousCursor = void 0;
        }
        for (; i < end6; i++) {
          if (state2.size++ > constMaxSize) {
            return error5("HeaderTooLarge");
          }
          if (chunk4[i] === 13 || state2.crlf > 0) {
            let byte = chunk4[i];
            if (byte === 13 && state2.crlf === 0) {
              state2.crlf = 1;
              i++;
              state2.size++;
              byte = chunk4[i];
            }
            if (byte === 10 && state2.crlf === 1) {
              state2.crlf = 2;
              i++;
              state2.size++;
              byte = chunk4[i];
            }
            if (byte === 13 && state2.crlf === 2) {
              state2.crlf = 3;
              i++;
              state2.size++;
              byte = chunk4[i];
            }
            if (byte === 10 && state2.crlf === 3) {
              state2.crlf = 4;
              i++;
              state2.size++;
            }
            if (state2.crlf < 4 && i >= end6) {
              state2.previousChunk = chunk4.subarray(start3);
              return constContinue;
            } else if (state2.crlf >= 2) {
              state2.value = state2.value === void 0 ? chunk4.subarray(start3, i - state2.crlf) : concatUint8Array(state2.value, chunk4.subarray(start3, i - state2.crlf));
              const value6 = decoder4.decode(state2.value);
              if (state2.headers[state2.key] === void 0) {
                state2.headers[state2.key] = value6;
              } else if (typeof state2.headers[state2.key] === "string") {
                state2.headers[state2.key] = [state2.headers[state2.key], value6];
              } else {
                ;
                state2.headers[state2.key].push(value6);
              }
              start3 = i;
              state2.size--;
              if (state2.crlf !== 4 && state2.pairs === constMaxPairs) {
                return error5("TooManyHeaders");
              } else if (state2.crlf === 3) {
                return error5("InvalidHeaderValue");
              } else if (state2.crlf === 4) {
                return reset2({
                  _tag: "Headers",
                  headers: state2.headers,
                  endPosition: start3 - endOffset
                });
              }
              state2.pairs++;
              state2.key = "";
              state2.value = void 0;
              state2.crlf = 0;
              state2.state = State.key;
              continue outer;
            }
          } else if (constValueChars[chunk4[i]] !== 1) {
            return error5("InvalidHeaderValue");
          }
        }
        if (i === end6) {
          state2.value = state2.value === void 0 ? chunk4.subarray(start3, end6) : concatUint8Array(state2.value, chunk4.subarray(start3, end6));
          return constContinue;
        }
      }
    }
    if (start3 > end6) {
      state2.size += end6 - start3;
    }
    return constContinue;
  }, "write");
}
__name(make78, "make");

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/internal/search.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function makeState(needle_) {
  const needle = new TextEncoder().encode(needle_);
  const needleLength = needle.length;
  const indexes = {};
  for (let i = 0; i < needleLength; i++) {
    const b = needle[i];
    if (indexes[b] === void 0) indexes[b] = [];
    indexes[b].push(i);
  }
  return {
    needle,
    needleLength,
    indexes,
    firstByte: needle[0],
    previousChunk: void 0,
    previousChunkLength: 0,
    matchIndex: 0
  };
}
__name(makeState, "makeState");
function make79(needle, callback, seed) {
  const state2 = makeState(needle);
  if (seed !== void 0) {
    state2.previousChunk = seed;
    state2.previousChunkLength = seed.length;
  }
  function makeIndexOf() {
    if ("Buffer" in globalThis && !("Bun" in globalThis || "Deno" in globalThis)) {
      return function(chunk4, needle2, fromIndex) {
        return Buffer.prototype.indexOf.call(chunk4, needle2, fromIndex);
      };
    }
    const skipTable = new Uint8Array(256).fill(state2.needle.length);
    for (let i = 0, lastIndex = state2.needle.length - 1; i < lastIndex; ++i) {
      skipTable[state2.needle[i]] = lastIndex - i;
    }
    return function(chunk4, needle2, fromIndex) {
      const lengthTotal = chunk4.length;
      let i = fromIndex + state2.needleLength - 1;
      while (i < lengthTotal) {
        for (let j = state2.needleLength - 1, k = i; j >= 0 && chunk4[k] === needle2[j]; j--, k--) {
          if (j === 0) return k;
        }
        i += skipTable[chunk4[i]];
      }
      return -1;
    };
  }
  __name(makeIndexOf, "makeIndexOf");
  const indexOf = makeIndexOf();
  function write3(chunk4) {
    let chunkLength = chunk4.length;
    if (state2.previousChunk !== void 0) {
      const newChunk = new Uint8Array(state2.previousChunkLength + chunkLength);
      newChunk.set(state2.previousChunk);
      newChunk.set(chunk4, state2.previousChunkLength);
      chunk4 = newChunk;
      chunkLength = state2.previousChunkLength + chunkLength;
      state2.previousChunk = void 0;
    }
    if (chunkLength < state2.needleLength) {
      state2.previousChunk = chunk4;
      state2.previousChunkLength = chunkLength;
      return;
    }
    let pos = 0;
    while (pos < chunkLength) {
      const match24 = indexOf(chunk4, state2.needle, pos);
      if (match24 > -1) {
        if (match24 > pos) {
          callback(state2.matchIndex, chunk4.subarray(pos, match24));
        }
        state2.matchIndex += 1;
        pos = match24 + state2.needleLength;
        continue;
      } else if (chunk4[chunkLength - 1] in state2.indexes) {
        const indexes = state2.indexes[chunk4[chunkLength - 1]];
        let earliestIndex = -1;
        for (let i = 0, len = indexes.length; i < len; i++) {
          const index2 = indexes[i];
          if (chunk4[chunkLength - 1 - index2] === state2.firstByte && i > earliestIndex) {
            earliestIndex = index2;
          }
        }
        if (earliestIndex === -1) {
          if (pos === 0) {
            callback(state2.matchIndex, chunk4);
          } else {
            callback(state2.matchIndex, chunk4.subarray(pos));
          }
        } else {
          if (chunkLength - 1 - earliestIndex > pos) {
            callback(state2.matchIndex, chunk4.subarray(pos, chunkLength - 1 - earliestIndex));
          }
          state2.previousChunk = chunk4.subarray(chunkLength - 1 - earliestIndex);
          state2.previousChunkLength = earliestIndex + 1;
        }
      } else if (pos === 0) {
        callback(state2.matchIndex, chunk4);
      } else {
        callback(state2.matchIndex, chunk4.subarray(pos));
      }
      break;
    }
  }
  __name(write3, "write");
  function end6() {
    if (state2.previousChunk !== void 0 && state2.previousChunk !== seed) {
      callback(state2.matchIndex, state2.previousChunk);
    }
    state2.previousChunk = seed;
    state2.previousChunkLength = seed?.length ?? 0;
    state2.matchIndex = 0;
  }
  __name(end6, "end");
  return {
    write: write3,
    end: end6
  };
}
__name(make79, "make");

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/internal/multipart.js
var State2;
(function(State3) {
  State3[State3["headers"] = 0] = "headers";
  State3[State3["body"] = 1] = "body";
})(State2 || (State2 = {}));
var errInvalidDisposition = {
  _tag: "InvalidDisposition"
};
var errEndNotReached = {
  _tag: "EndNotReached"
};
var errMaxParts = {
  _tag: "ReachedLimit",
  limit: "MaxParts"
};
var errMaxTotalSize = {
  _tag: "ReachedLimit",
  limit: "MaxTotalSize"
};
var errMaxPartSize = {
  _tag: "ReachedLimit",
  limit: "MaxPartSize"
};
var errMaxFieldSize = {
  _tag: "ReachedLimit",
  limit: "MaxFieldSize"
};
var constCR = /* @__PURE__ */ new TextEncoder().encode("\r\n");
function defaultIsFile(info4) {
  return info4.filename !== void 0 || info4.contentType === "application/octet-stream";
}
__name(defaultIsFile, "defaultIsFile");
function parseBoundary(headers) {
  const contentType = parse3(headers["content-type"]);
  return contentType.parameters.boundary;
}
__name(parseBoundary, "parseBoundary");
function noopOnChunk(_chunk) {
}
__name(noopOnChunk, "noopOnChunk");
function make80({
  headers,
  onFile: onPart,
  onField,
  onError: onError5,
  onDone: onDone3,
  isFile = defaultIsFile,
  maxParts = Infinity,
  maxTotalSize = Infinity,
  maxPartSize = Infinity,
  maxFieldSize = 1024 * 1024
}) {
  const boundary = parseBoundary(headers);
  if (boundary === void 0) {
    onError5({
      _tag: "InvalidBoundary"
    });
    return {
      write: noopOnChunk,
      end() {
      }
    };
  }
  const state2 = {
    state: State2.headers,
    index: 0,
    parts: 0,
    onChunk: noopOnChunk,
    info: void 0,
    headerSkip: 0,
    partSize: 0,
    totalSize: 0,
    isFile: false,
    fieldChunks: [],
    fieldSize: 0
  };
  function skipBody() {
    state2.state = State2.body;
    state2.isFile = true;
    state2.onChunk = noopOnChunk;
  }
  __name(skipBody, "skipBody");
  const headerParser = make78();
  const split6 = make79(`\r
--${boundary}`, function(index2, chunk4) {
    if (index2 === 0) {
      skipBody();
      return;
    } else if (index2 !== state2.index) {
      if (state2.index > 0) {
        if (state2.isFile) {
          state2.onChunk(null);
          state2.partSize = 0;
        } else {
          if (state2.fieldChunks.length === 1) {
            onField(state2.info, state2.fieldChunks[0]);
          } else {
            const buf = new Uint8Array(state2.fieldSize);
            let offset = 0;
            for (let i = 0; i < state2.fieldChunks.length; i++) {
              const chunk5 = state2.fieldChunks[i];
              buf.set(chunk5, offset);
              offset += chunk5.length;
            }
            onField(state2.info, buf);
          }
          state2.fieldSize = 0;
          state2.fieldChunks = [];
        }
      }
      state2.state = State2.headers;
      state2.index = index2;
      state2.headerSkip = 2;
      if (chunk4[0] === 45 && chunk4[1] === 45) {
        return onDone3();
      }
      state2.parts++;
      if (state2.parts > maxParts) {
        onError5(errMaxParts);
      }
    }
    if ((state2.partSize += chunk4.length) > maxPartSize) {
      onError5(errMaxPartSize);
    }
    if (state2.state === State2.headers) {
      const result = headerParser(chunk4, state2.headerSkip);
      state2.headerSkip = 0;
      if (result._tag === "Continue") {
        return;
      } else if (result._tag === "Failure") {
        skipBody();
        return onError5({
          _tag: "BadHeaders",
          error: result
        });
      }
      const contentType = parse3(result.headers["content-type"]);
      const contentDisposition = parse3(result.headers["content-disposition"], true);
      if ("form-data" === contentDisposition.value && !("name" in contentDisposition.parameters)) {
        skipBody();
        return onError5(errInvalidDisposition);
      }
      let encodedFilename;
      if ("filename*" in contentDisposition.parameters) {
        const parts2 = contentDisposition.parameters["filename*"].split("''");
        if (parts2.length === 2) {
          encodedFilename = decodeURIComponent(parts2[1]);
        }
      }
      state2.info = {
        name: contentDisposition.parameters.name ?? "",
        filename: encodedFilename ?? contentDisposition.parameters.filename,
        contentType: contentType.value === "" ? contentDisposition.parameters.filename !== void 0 ? "application/octet-stream" : "text/plain" : contentType.value,
        contentTypeParameters: contentType.parameters,
        contentDisposition: contentDisposition.value,
        contentDispositionParameters: contentDisposition.parameters,
        headers: result.headers
      };
      state2.state = State2.body;
      state2.isFile = isFile(state2.info);
      if (state2.isFile) {
        state2.onChunk = onPart(state2.info);
      }
      if (result.endPosition < chunk4.length) {
        if (state2.isFile) {
          state2.onChunk(chunk4.subarray(result.endPosition));
        } else {
          const buf = chunk4.subarray(result.endPosition);
          if ((state2.fieldSize += buf.length) > maxFieldSize) {
            onError5(errMaxFieldSize);
          }
          state2.fieldChunks.push(buf);
        }
      }
    } else if (state2.isFile) {
      state2.onChunk(chunk4);
    } else {
      if ((state2.fieldSize += chunk4.length) > maxFieldSize) {
        onError5(errMaxFieldSize);
      }
      state2.fieldChunks.push(chunk4);
    }
  }, constCR);
  return {
    write(chunk4) {
      if ((state2.totalSize += chunk4.length) > maxTotalSize) {
        return onError5(errMaxTotalSize);
      }
      return split6.write(chunk4);
    },
    end() {
      split6.end();
      if (state2.state === State2.body) {
        onError5(errEndNotReached);
      }
      state2.state = State2.headers;
      state2.index = 0;
      state2.parts = 0;
      state2.onChunk = noopOnChunk;
      state2.info = void 0;
      state2.totalSize = 0;
      state2.partSize = 0;
      state2.fieldChunks = [];
      state2.fieldSize = 0;
    }
  };
}
__name(make80, "make");
var utf8Decoder = /* @__PURE__ */ new TextDecoder("utf-8");
function getDecoder(charset) {
  if (charset === "utf-8" || charset === "utf8" || charset === "") {
    return utf8Decoder;
  }
  try {
    return new TextDecoder(charset);
  } catch (error5) {
    return utf8Decoder;
  }
}
__name(getDecoder, "getDecoder");
function decodeField(info4, value6) {
  return getDecoder(info4.contentTypeParameters.charset ?? "utf-8").decode(value6);
}
__name(decodeField, "decodeField");

// node_modules/.pnpm/multipasta@0.2.7/node_modules/multipasta/dist/esm/index.js
var make81 = make80;
var defaultIsFile2 = defaultIsFile;
var decodeField2 = decodeField;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Path.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/path.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId38 = /* @__PURE__ */ Symbol.for("@effect/platform/Path");
var Path = /* @__PURE__ */ GenericTag("@effect/platform/Path");
function normalizeStringPosix(path, allowAboveRoot) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code;
  for (let i = 0; i <= path.length; ++i) {
    if (i < path.length) {
      code = path.charCodeAt(i);
    } else if (code === 47) {
      break;
    } else {
      code = 47;
    }
    if (code === 47) {
      if (lastSlash === i - 1 || dots === 1) {
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf("/");
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = "";
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) {
            res += "/..";
          } else {
            res = "..";
          }
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) {
          res += "/" + path.slice(lastSlash + 1, i);
        } else {
          res = path.slice(lastSlash + 1, i);
        }
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
__name(normalizeStringPosix, "normalizeStringPosix");
function _format(sep, pathObject) {
  const dir4 = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir4) {
    return base;
  }
  if (dir4 === pathObject.root) {
    return dir4 + base;
  }
  return dir4 + sep + base;
}
__name(_format, "_format");
function fromFileUrl(url2) {
  if (url2.protocol !== "file:") {
    return fail10(new BadArgument({
      module: "Path",
      method: "fromFileUrl",
      description: "URL must be of scheme file"
    }));
  } else if (url2.hostname !== "") {
    return fail10(new BadArgument({
      module: "Path",
      method: "fromFileUrl",
      description: "Invalid file URL host"
    }));
  }
  const pathname = url2.pathname;
  for (let n = 0; n < pathname.length; n++) {
    if (pathname[n] === "%") {
      const third = pathname.codePointAt(n + 2) | 32;
      if (pathname[n + 1] === "2" && third === 102) {
        return fail10(new BadArgument({
          module: "Path",
          method: "fromFileUrl",
          description: "must not include encoded / characters"
        }));
      }
    }
  }
  return succeed11(decodeURIComponent(pathname));
}
__name(fromFileUrl, "fromFileUrl");
var resolve = /* @__PURE__ */ __name(function resolve2() {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  let cwd2 = void 0;
  for (let i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    let path;
    if (i >= 0) {
      path = arguments[i];
    } else {
      const process2 = globalThis.process;
      if (cwd2 === void 0 && "process" in globalThis && typeof process2 === "object" && process2 !== null && typeof process2.cwd === "function") {
        cwd2 = process2.cwd();
      }
      path = cwd2;
    }
    if (path.length === 0) {
      continue;
    }
    resolvedPath = path + "/" + resolvedPath;
    resolvedAbsolute = path.charCodeAt(0) === 47;
  }
  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0) {
      return "/" + resolvedPath;
    } else {
      return "/";
    }
  } else if (resolvedPath.length > 0) {
    return resolvedPath;
  } else {
    return ".";
  }
}, "resolve");
var CHAR_FORWARD_SLASH = 47;
function toFileUrl(filepath) {
  const outURL = new URL("file://");
  let resolved = resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if (filePathLast === CHAR_FORWARD_SLASH && resolved[resolved.length - 1] !== "/") {
    resolved += "/";
  }
  outURL.pathname = encodePathChars(resolved);
  return succeed11(outURL);
}
__name(toFileUrl, "toFileUrl");
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
function encodePathChars(filepath) {
  if (filepath.includes("%")) {
    filepath = filepath.replace(percentRegEx, "%25");
  }
  if (filepath.includes("\\")) {
    filepath = filepath.replace(backslashRegEx, "%5C");
  }
  if (filepath.includes("\n")) {
    filepath = filepath.replace(newlineRegEx, "%0A");
  }
  if (filepath.includes("\r")) {
    filepath = filepath.replace(carriageReturnRegEx, "%0D");
  }
  if (filepath.includes("	")) {
    filepath = filepath.replace(tabRegEx, "%09");
  }
  return filepath;
}
__name(encodePathChars, "encodePathChars");
var posixImpl = /* @__PURE__ */ Path.of({
  [TypeId38]: TypeId38,
  resolve,
  normalize(path) {
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeStringPosix(path, !isAbsolute);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return "/" + path;
    return path;
  },
  isAbsolute(path) {
    return path.length > 0 && path.charCodeAt(0) === 47;
  },
  join() {
    if (arguments.length === 0) {
      return ".";
    }
    let joined;
    for (let i = 0; i < arguments.length; ++i) {
      const arg = arguments[i];
      if (arg.length > 0) {
        if (joined === void 0) {
          joined = arg;
        } else {
          joined += "/" + arg;
        }
      }
    }
    if (joined === void 0) {
      return ".";
    }
    return posixImpl.normalize(joined);
  },
  relative(from, to) {
    if (from === to) return "";
    from = posixImpl.resolve(from);
    to = posixImpl.resolve(to);
    if (from === to) return "";
    let fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47) {
        break;
      }
    }
    const fromEnd = from.length;
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47) {
        break;
      }
    }
    const toEnd = to.length;
    const toLen = toEnd - toStart;
    const length5 = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for (; i <= length5; ++i) {
      if (i === length5) {
        if (toLen > length5) {
          if (to.charCodeAt(toStart + i) === 47) {
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            return to.slice(toStart + i);
          }
        } else if (fromLen > length5) {
          if (from.charCodeAt(fromStart + i) === 47) {
            lastCommonSep = i;
          } else if (i === 0) {
            lastCommonSep = 0;
          }
        }
        break;
      }
      const fromCode = from.charCodeAt(fromStart + i);
      const toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode) {
        break;
      } else if (fromCode === 47) {
        lastCommonSep = i;
      }
    }
    let out = "";
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47) {
        if (out.length === 0) {
          out += "..";
        } else {
          out += "/..";
        }
      }
    }
    if (out.length > 0) {
      return out + to.slice(toStart + lastCommonSep);
    } else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47) {
        ++toStart;
      }
      return to.slice(toStart);
    }
  },
  dirname(path) {
    if (path.length === 0) return ".";
    let code = path.charCodeAt(0);
    const hasRoot = code === 47;
    let end6 = -1;
    let matchedSlash = true;
    for (let i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          end6 = i;
          break;
        }
      } else {
        matchedSlash = false;
      }
    }
    if (end6 === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end6 === 1) return "//";
    return path.slice(0, end6);
  },
  basename(path, ext) {
    let start3 = 0;
    let end6 = -1;
    let matchedSlash = true;
    let i;
    if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return "";
      let extIdx = ext.length - 1;
      let firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        const code = path.charCodeAt(i);
        if (code === 47) {
          if (!matchedSlash) {
            start3 = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                end6 = i;
              }
            } else {
              extIdx = -1;
              end6 = firstNonSlashEnd;
            }
          }
        }
      }
      if (start3 === end6) end6 = firstNonSlashEnd;
      else if (end6 === -1) end6 = path.length;
      return path.slice(start3, end6);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47) {
          if (!matchedSlash) {
            start3 = i + 1;
            break;
          }
        } else if (end6 === -1) {
          matchedSlash = false;
          end6 = i + 1;
        }
      }
      if (end6 === -1) return "";
      return path.slice(start3, end6);
    }
  },
  extname(path) {
    let startDot = -1;
    let startPart = 0;
    let end6 = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for (let i = path.length - 1; i >= 0; --i) {
      const code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end6 === -1) {
        matchedSlash = false;
        end6 = i + 1;
      }
      if (code === 46) {
        if (startDot === -1) {
          startDot = i;
        } else if (preDotState !== 1) {
          preDotState = 1;
        }
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end6 === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      return "";
    }
    return path.slice(startDot, end6);
  },
  format: /* @__PURE__ */ __name(function format7(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format("/", pathObject);
  }, "format"),
  parse(path) {
    const ret = {
      root: "",
      dir: "",
      base: "",
      ext: "",
      name: ""
    };
    if (path.length === 0) return ret;
    let code = path.charCodeAt(0);
    const isAbsolute = code === 47;
    let start3;
    if (isAbsolute) {
      ret.root = "/";
      start3 = 1;
    } else {
      start3 = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end6 = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for (; i >= start3; --i) {
      code = path.charCodeAt(i);
      if (code === 47) {
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end6 === -1) {
        matchedSlash = false;
        end6 = i + 1;
      }
      if (code === 46) {
        if (startDot === -1) startDot = i;
        else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        preDotState = -1;
      }
    }
    if (startDot === -1 || end6 === -1 || // We saw a non-dot character immediately before the dot
    preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end6 - 1 && startDot === startPart + 1) {
      if (end6 !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end6);
        else ret.base = ret.name = path.slice(startPart, end6);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end6);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end6);
      }
      ret.ext = path.slice(startDot, end6);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
  },
  sep: "/",
  fromFileUrl,
  toFileUrl,
  toNamespacedPath: identity
});
var layer8 = /* @__PURE__ */ succeed13(Path, posixImpl);

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Path.js
var Path2 = Path;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Multipart.js
var TypeId39 = /* @__PURE__ */ Symbol.for("@effect/platform/Multipart");
var ErrorTypeId2 = /* @__PURE__ */ Symbol.for("@effect/platform/Multipart/MultipartError");
var MultipartError = class extends (/* @__PURE__ */ TaggedError2()("MultipartError", {
  reason: /* @__PURE__ */ Literal2("FileTooLarge", "FieldTooLarge", "BodyTooLarge", "TooManyParts", "InternalError", "Parse"),
  cause: Defect
})) {
  static {
    __name(this, "MultipartError");
  }
  /**
   * @since 1.0.0
   */
  [ErrorTypeId2] = ErrorTypeId2;
  /**
   * @since 1.0.0
   */
  get message() {
    return this.reason;
  }
};
var makeConfig = /* @__PURE__ */ __name((headers) => withFiberRuntime2((fiber) => {
  const mimeTypes = get6(fiber.currentContext, FieldMimeTypes);
  return succeed11({
    headers,
    maxParts: getOrUndefined2(get6(fiber.currentContext, MaxParts)),
    maxFieldSize: Number(get6(fiber.currentContext, MaxFieldSize)),
    maxPartSize: get6(fiber.currentContext, MaxFileSize).pipe(map2(Number), getOrUndefined2),
    maxTotalSize: get6(fiber.currentContext, MaxBodySize).pipe(map2(Number), getOrUndefined2),
    isFile: mimeTypes.length === 0 ? void 0 : (info4) => !some5(mimeTypes, (_) => info4.contentType.includes(_)) && defaultIsFile2(info4)
  });
}), "makeConfig");
var makeChannel = /* @__PURE__ */ __name((headers, bufferSize = 16) => acquireUseRelease5(all8([makeConfig(headers), make77(bufferSize)]), ([config3, mailbox]) => {
  let partsBuffer = [];
  let exit5 = none2();
  const input = {
    awaitRead: /* @__PURE__ */ __name(() => _void, "awaitRead"),
    emit(element2) {
      return mailbox.offer(element2);
    },
    error(cause3) {
      exit5 = some3(failCause3(cause3));
      return mailbox.end;
    },
    done(_value) {
      return mailbox.end;
    }
  };
  const parser = make81({
    ...config3,
    onField(info4, value6) {
      partsBuffer.push(new FieldImpl(info4.name, info4.contentType, decodeField2(info4, value6)));
    },
    onFile(info4) {
      let chunks3 = [];
      let finished = false;
      const take11 = suspend14(() => {
        if (chunks3.length === 0) {
          return finished ? void_12 : zipRight14(pump, take11);
        }
        const chunk4 = unsafeFromArray(chunks3);
        chunks3 = [];
        return finished ? write2(chunk4) : zipRight14(write2(chunk4), zipRight14(pump, take11));
      });
      partsBuffer.push(new FileImpl(info4, take11));
      return function(chunk4) {
        if (chunk4 === null) {
          finished = true;
        } else {
          chunks3.push(chunk4);
        }
      };
    },
    onError(error_) {
      exit5 = some3(fail3(convertError(error_)));
    },
    onDone() {
      exit5 = some3(void_5);
    }
  });
  const pump = flatMap23(mailbox.takeAll, ([chunks3, done12]) => sync15(() => {
    forEach2(chunks3, forEach2(parser.write));
    if (done12) {
      parser.end();
    }
  }));
  const partsChannel = flatMap23(pump, () => {
    if (partsBuffer.length === 0) {
      return exit5._tag === "None" ? partsChannel : writeExit(exit5.value);
    }
    const chunk4 = unsafeFromArray(partsBuffer);
    partsBuffer = [];
    return zipRight14(write2(chunk4), exit5._tag === "None" ? partsChannel : writeExit(exit5.value));
  });
  return embedInput2(partsChannel, input);
}, ([, mailbox]) => mailbox.shutdown), "makeChannel");
var writeExit = /* @__PURE__ */ __name((self2) => self2._tag === "Success" ? void_12 : failCause16(self2.cause), "writeExit");
function convertError(cause3) {
  switch (cause3._tag) {
    case "ReachedLimit": {
      switch (cause3.limit) {
        case "MaxParts": {
          return new MultipartError({
            reason: "TooManyParts",
            cause: cause3
          });
        }
        case "MaxFieldSize": {
          return new MultipartError({
            reason: "FieldTooLarge",
            cause: cause3
          });
        }
        case "MaxPartSize": {
          return new MultipartError({
            reason: "FileTooLarge",
            cause: cause3
          });
        }
        case "MaxTotalSize": {
          return new MultipartError({
            reason: "BodyTooLarge",
            cause: cause3
          });
        }
      }
    }
    default: {
      return new MultipartError({
        reason: "Parse",
        cause: cause3
      });
    }
  }
}
__name(convertError, "convertError");
var PartBase = class extends Class {
  static {
    __name(this, "PartBase");
  }
  [TypeId39];
  constructor() {
    super();
    this[TypeId39] = TypeId39;
  }
};
var FieldImpl = class extends PartBase {
  static {
    __name(this, "FieldImpl");
  }
  key;
  contentType;
  value;
  _tag = "Field";
  constructor(key, contentType, value6) {
    super();
    this.key = key;
    this.contentType = contentType;
    this.value = value6;
  }
  toJSON() {
    return {
      _id: "@effect/platform/Multipart/Part",
      _tag: "Field",
      key: this.key,
      contentType: this.contentType,
      value: this.value
    };
  }
};
var FileImpl = class extends PartBase {
  static {
    __name(this, "FileImpl");
  }
  _tag = "File";
  key;
  name;
  contentType;
  content;
  contentEffect;
  constructor(info4, channel2) {
    super();
    this.key = info4.name;
    this.name = info4.filename ?? info4.name;
    this.contentType = info4.contentType;
    this.content = fromChannel3(channel2);
    this.contentEffect = channel2.pipe(pipeTo2(collectUint8Array), run6, mapError4((cause3) => new MultipartError({
      reason: "InternalError",
      cause: cause3
    })));
  }
  toJSON() {
    return {
      _id: "@effect/platform/Multipart/Part",
      _tag: "File",
      key: this.key,
      name: this.name,
      contentType: this.contentType
    };
  }
};
var defaultWriteFile = /* @__PURE__ */ __name((path, file3) => flatMap15(FileSystem, (fs) => mapError4(run5(file3.content, fs.sink(path)), (cause3) => new MultipartError({
  reason: "InternalError",
  cause: cause3
}))), "defaultWriteFile");
var collectUint8Array = /* @__PURE__ */ suspend14(() => {
  let accumulator = new Uint8Array(0);
  const loop5 = readWithCause2({
    onInput(chunk4) {
      for (const element2 of chunk4) {
        const newAccumulator = new Uint8Array(accumulator.length + element2.length);
        newAccumulator.set(accumulator, 0);
        newAccumulator.set(element2, accumulator.length);
        accumulator = newAccumulator;
      }
      return loop5;
    },
    onFailure: /* @__PURE__ */ __name((cause3) => failCause16(cause3), "onFailure"),
    onDone: /* @__PURE__ */ __name(() => succeed21(accumulator), "onDone")
  });
  return loop5;
});
var toPersisted = /* @__PURE__ */ __name((stream6, writeFile = defaultWriteFile) => gen4(function* () {
  const fs = yield* FileSystem;
  const path_ = yield* Path2;
  const dir4 = yield* fs.makeTempDirectoryScoped();
  const persisted = /* @__PURE__ */ Object.create(null);
  yield* runForEach2(stream6, (part) => {
    if (part._tag === "Field") {
      if (!(part.key in persisted)) {
        persisted[part.key] = part.value;
      } else if (typeof persisted[part.key] === "string") {
        persisted[part.key] = [persisted[part.key], part.value];
      } else {
        ;
        persisted[part.key].push(part.value);
      }
      return _void;
    } else if (part.name === "") {
      return _void;
    }
    const file3 = part;
    const path = path_.join(dir4, path_.basename(file3.name).slice(-128));
    const filePart = new PersistedFileImpl(file3.key, file3.name, file3.contentType, path);
    if (Array.isArray(persisted[part.key])) {
      ;
      persisted[part.key].push(filePart);
    } else {
      persisted[part.key] = [filePart];
    }
    return writeFile(path, file3);
  });
  return persisted;
}).pipe(catchTags2({
  SystemError: /* @__PURE__ */ __name((cause3) => fail10(new MultipartError({
    reason: "InternalError",
    cause: cause3
  })), "SystemError"),
  BadArgument: /* @__PURE__ */ __name((cause3) => fail10(new MultipartError({
    reason: "InternalError",
    cause: cause3
  })), "BadArgument")
})), "toPersisted");
var PersistedFileImpl = class extends PartBase {
  static {
    __name(this, "PersistedFileImpl");
  }
  key;
  name;
  contentType;
  path;
  _tag = "PersistedFile";
  constructor(key, name, contentType, path) {
    super();
    this.key = key;
    this.name = name;
    this.contentType = contentType;
    this.path = path;
  }
  toJSON() {
    return {
      _id: "@effect/platform/Multipart/Part",
      _tag: "PersistedFile",
      key: this.key,
      name: this.name,
      contentType: this.contentType,
      path: this.path
    };
  }
};
var MaxParts = class extends (/* @__PURE__ */ Reference2()("@effect/platform/Multipart/MaxParts", {
  defaultValue: none2
})) {
  static {
    __name(this, "MaxParts");
  }
};
var MaxFieldSize = class extends (/* @__PURE__ */ Reference2()("@effect/platform/Multipart/MaxFieldSize", {
  defaultValue: /* @__PURE__ */ constant(/* @__PURE__ */ Size2(10 * 1024 * 1024))
})) {
  static {
    __name(this, "MaxFieldSize");
  }
};
var MaxFileSize = class extends (/* @__PURE__ */ Reference2()("@effect/platform/Multipart/MaxFileSize", {
  defaultValue: none2
})) {
  static {
    __name(this, "MaxFileSize");
  }
};
var FieldMimeTypes = class extends (/* @__PURE__ */ Reference2()("@effect/platform/Multipart/FieldMimeTypes", {
  defaultValue: /* @__PURE__ */ constant(/* @__PURE__ */ make5("application/json"))
})) {
  static {
    __name(this, "FieldMimeTypes");
  }
};

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Socket.js
var Socket_exports = {};
__export(Socket_exports, {
  CloseEvent: () => CloseEvent,
  CloseEventTypeId: () => CloseEventTypeId,
  Socket: () => Socket,
  SocketCloseError: () => SocketCloseError,
  SocketErrorTypeId: () => SocketErrorTypeId,
  SocketGenericError: () => SocketGenericError,
  TypeId: () => TypeId40,
  WebSocket: () => WebSocket,
  WebSocketConstructor: () => WebSocketConstructor,
  currentSendQueueCapacity: () => currentSendQueueCapacity,
  defaultCloseCodeIsError: () => defaultCloseCodeIsError,
  fromTransformStream: () => fromTransformStream,
  fromWebSocket: () => fromWebSocket,
  isCloseEvent: () => isCloseEvent,
  isSocket: () => isSocket,
  isSocketError: () => isSocketError,
  layerWebSocket: () => layerWebSocket,
  layerWebSocketConstructorGlobal: () => layerWebSocketConstructorGlobal,
  makeChannel: () => makeChannel2,
  makeWebSocket: () => makeWebSocket,
  makeWebSocketChannel: () => makeWebSocketChannel,
  toChannel: () => toChannel6,
  toChannelMap: () => toChannelMap,
  toChannelString: () => toChannelString,
  toChannelWith: () => toChannelWith
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId40 = /* @__PURE__ */ Symbol.for("@effect/platform/Socket");
var isSocket = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId40), "isSocket");
var Socket = /* @__PURE__ */ GenericTag("@effect/platform/Socket");
var CloseEventTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Socket/CloseEvent");
var CloseEvent = class {
  static {
    __name(this, "CloseEvent");
  }
  code;
  reason;
  /**
   * @since 1.0.0
   */
  [CloseEventTypeId];
  constructor(code = 1e3, reason) {
    this.code = code;
    this.reason = reason;
    this[CloseEventTypeId] = CloseEventTypeId;
  }
  /**
   * @since 1.0.0
   */
  toString() {
    return this.reason ? `${this.code}: ${this.reason}` : `${this.code}`;
  }
};
var isCloseEvent = /* @__PURE__ */ __name((u) => hasProperty(u, CloseEventTypeId), "isCloseEvent");
var SocketErrorTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Socket/SocketError");
var isSocketError = /* @__PURE__ */ __name((u) => hasProperty(u, SocketErrorTypeId), "isSocketError");
var SocketGenericError = class extends (/* @__PURE__ */ TypeIdError(SocketErrorTypeId, "SocketError")) {
  static {
    __name(this, "SocketGenericError");
  }
  get message() {
    return `An error occurred during ${this.reason}`;
  }
};
var SocketCloseError = class _SocketCloseError extends (/* @__PURE__ */ TypeIdError(SocketErrorTypeId, "SocketError")) {
  static {
    __name(this, "SocketCloseError");
  }
  /**
   * @since 1.0.0
   */
  static is(u) {
    return isSocketError(u) && u.reason === "Close";
  }
  /**
   * @since 1.0.0
   */
  static isClean(isClean) {
    return function(u) {
      return _SocketCloseError.is(u) && isClean(u.code);
    };
  }
  get message() {
    if (this.closeReason) {
      return `${this.reason}: ${this.code}: ${this.closeReason}`;
    }
    return `${this.reason}: ${this.code}`;
  }
};
var toChannelMap = /* @__PURE__ */ __name((self2, f) => gen4(function* () {
  const scope5 = yield* scope3;
  const mailbox = yield* make77();
  const writeScope = yield* fork2(scope5, sequential3);
  const write3 = yield* extend3(self2.writer, writeScope);
  function* emit3(chunk4) {
    for (const data of chunk4) {
      yield* write3(data);
    }
  }
  __name(emit3, "emit");
  const input = {
    awaitRead: /* @__PURE__ */ __name(() => _void, "awaitRead"),
    emit(chunk4) {
      return catchAllCause3(gen4(() => emit3(chunk4)), (cause3) => mailbox.failCause(cause3));
    },
    error(error5) {
      return zipRight7(close(writeScope, void_5), mailbox.failCause(error5));
    },
    done() {
      return close(writeScope, void_5);
    }
  };
  yield* self2.runRaw((data) => {
    mailbox.unsafeOffer(f(data));
  }).pipe(into2(mailbox), forkIn2(scope5), interruptible4);
  return embedInput2(toChannel5(mailbox), input);
}).pipe(unwrapScoped6), "toChannelMap");
var toChannel6 = /* @__PURE__ */ __name((self2) => {
  const encoder3 = new TextEncoder();
  return toChannelMap(self2, (data) => typeof data === "string" ? encoder3.encode(data) : data);
}, "toChannel");
var toChannelString = /* @__PURE__ */ dual((args2) => isSocket(args2[0]), (self2, encoding) => {
  const decoder4 = new TextDecoder(encoding);
  return toChannelMap(self2, (data) => typeof data === "string" ? data : decoder4.decode(data));
});
var toChannelWith = /* @__PURE__ */ __name(() => (self2) => toChannel6(self2), "toChannelWith");
var makeChannel2 = /* @__PURE__ */ __name(() => unwrap6(map22(Socket, toChannelWith())), "makeChannel");
var defaultCloseCodeIsError = /* @__PURE__ */ __name((code) => code !== 1e3 && code !== 1006, "defaultCloseCodeIsError");
var WebSocket = /* @__PURE__ */ GenericTag("@effect/platform/Socket/WebSocket");
var WebSocketConstructor = /* @__PURE__ */ GenericTag("@effect/platform/Socket/WebSocketConstructor");
var layerWebSocketConstructorGlobal = /* @__PURE__ */ succeed13(WebSocketConstructor, (url2, protocols) => new globalThis.WebSocket(url2, protocols));
var makeWebSocket = /* @__PURE__ */ __name((url2, options4) => fromWebSocket(acquireRelease2((typeof url2 === "string" ? succeed11(url2) : url2).pipe(flatMap15((url3) => map22(WebSocketConstructor, (f) => f(url3, options4?.protocols)))), (ws) => sync7(() => ws.close(1e3))), options4), "makeWebSocket");
var fromWebSocket = /* @__PURE__ */ __name((acquire, options4) => withFiberRuntime2((fiber) => {
  let currentWS;
  const latch = unsafeMakeLatch2(false);
  const acquireContext = fiber.currentContext;
  const closeCodeIsError = options4?.closeCodeIsError ?? defaultCloseCodeIsError;
  const runRaw = /* @__PURE__ */ __name((handler, opts) => scopedWith2(fnUntraced2(function* (scope5) {
    const fiberSet = yield* make70().pipe(extend3(scope5));
    const ws = yield* extend3(acquire, scope5);
    const run11 = yield* provideService4(runtime5(fiberSet)(), WebSocket, ws);
    let open = false;
    function onMessage(event) {
      if (event.data instanceof Blob) {
        return promise2(() => event.data.arrayBuffer()).pipe(andThen8((buffer4) => handler(new Uint8Array(buffer4))), run11);
      }
      const result = handler(event.data);
      if (isEffect2(result)) {
        run11(result);
      }
    }
    __name(onMessage, "onMessage");
    function onError5(cause3) {
      ws.removeEventListener("message", onMessage);
      ws.removeEventListener("close", onClose);
      unsafeDone(fiberSet.deferred, fail10(new SocketGenericError({
        reason: open ? "Read" : "Open",
        cause: cause3
      })));
    }
    __name(onError5, "onError");
    function onClose(event) {
      ws.removeEventListener("message", onMessage);
      ws.removeEventListener("error", onError5);
      unsafeDone(fiberSet.deferred, fail10(new SocketCloseError({
        reason: "Close",
        code: event.code,
        closeReason: event.reason
      })));
    }
    __name(onClose, "onClose");
    ws.addEventListener("close", onClose, {
      once: true
    });
    ws.addEventListener("error", onError5, {
      once: true
    });
    ws.addEventListener("message", onMessage);
    if (ws.readyState !== 1) {
      const openDeferred = unsafeMake10(fiber.id());
      ws.addEventListener("open", () => {
        open = true;
        unsafeDone(openDeferred, _void);
      }, {
        once: true
      });
      yield* _await3(openDeferred).pipe(timeoutFail2({
        duration: options4?.openTimeout ?? 1e4,
        onTimeout: /* @__PURE__ */ __name(() => new SocketGenericError({
          reason: "OpenTimeout",
          cause: 'timeout waiting for "open"'
        }), "onTimeout")
      }), raceFirst2(join5(fiberSet)));
    }
    open = true;
    currentWS = ws;
    yield* latch.open;
    if (opts?.onOpen) yield* opts.onOpen;
    return yield* join5(fiberSet).pipe(catchIf2(SocketCloseError.isClean((_) => !closeCodeIsError(_)), (_) => _void));
  })).pipe(mapInputContext3((input) => merge3(acquireContext, input)), ensuring3(sync7(() => {
    latch.unsafeClose();
    currentWS = void 0;
  })), interruptible4), "runRaw");
  const encoder3 = new TextEncoder();
  const run10 = /* @__PURE__ */ __name((handler, opts) => runRaw((data) => typeof data === "string" ? handler(encoder3.encode(data)) : data instanceof Uint8Array ? handler(data) : handler(new Uint8Array(data)), opts), "run");
  const write3 = /* @__PURE__ */ __name((chunk4) => latch.whenOpen(sync7(() => {
    const ws = currentWS;
    if (isCloseEvent(chunk4)) {
      ws.close(chunk4.code, chunk4.reason);
    } else {
      ws.send(chunk4);
    }
  })), "write");
  const writer = succeed11(write3);
  return succeed11(Socket.of({
    [TypeId40]: TypeId40,
    run: run10,
    runRaw,
    writer
  }));
}), "fromWebSocket");
var makeWebSocketChannel = /* @__PURE__ */ __name((url2, options4) => unwrapScoped6(map22(makeWebSocket(url2, options4), toChannelWith())), "makeWebSocketChannel");
var layerWebSocket = /* @__PURE__ */ __name((url2, options4) => effect(Socket, makeWebSocket(url2, options4)), "layerWebSocket");
var currentSendQueueCapacity = /* @__PURE__ */ globalValue("@effect/platform/Socket/currentSendQueueCapacity", () => unsafeMake11(16));
var fromTransformStream = /* @__PURE__ */ __name((acquire, options4) => withFiberRuntime2((fiber) => {
  const latch = unsafeMakeLatch2(false);
  let currentStream;
  const acquireContext = fiber.currentContext;
  const closeCodeIsError = options4?.closeCodeIsError ?? defaultCloseCodeIsError;
  const runRaw = /* @__PURE__ */ __name((handler, opts) => scopedWith2(fnUntraced2(function* (scope5) {
    const stream6 = yield* extend3(acquire, scope5);
    const reader = stream6.readable.getReader();
    yield* addFinalizer2(scope5, promise2(() => reader.cancel()));
    const fiberSet = yield* make70().pipe(extend3(scope5));
    const runFork4 = yield* runtime5(fiberSet)();
    yield* tryPromise2({
      try: /* @__PURE__ */ __name(async () => {
        while (true) {
          const {
            done: done12,
            value: value6
          } = await reader.read();
          if (done12) {
            throw new SocketCloseError({
              reason: "Close",
              code: 1e3
            });
          }
          const result = handler(value6);
          if (isEffect2(result)) {
            runFork4(result);
          }
        }
      }, "try"),
      catch: /* @__PURE__ */ __name((cause3) => isSocketError(cause3) ? cause3 : new SocketGenericError({
        reason: "Read",
        cause: cause3
      }), "catch")
    }).pipe(run7(fiberSet));
    currentStream = {
      stream: stream6,
      fiberSet
    };
    yield* latch.open;
    if (opts?.onOpen) yield* opts.onOpen;
    return yield* join5(fiberSet).pipe(catchIf2(SocketCloseError.isClean((_) => !closeCodeIsError(_)), (_) => _void));
  })).pipe((_) => _, mapInputContext3((input) => merge3(acquireContext, input)), ensuring3(sync7(() => {
    latch.unsafeClose();
    currentStream = void 0;
  })), interruptible4), "runRaw");
  const encoder3 = new TextEncoder();
  const run10 = /* @__PURE__ */ __name((handler, opts) => runRaw((data) => typeof data === "string" ? handler(encoder3.encode(data)) : handler(data), opts), "run");
  const writers = /* @__PURE__ */ new WeakMap();
  const getWriter = /* @__PURE__ */ __name((stream6) => {
    let writer2 = writers.get(stream6);
    if (!writer2) {
      writer2 = stream6.writable.getWriter();
      writers.set(stream6, writer2);
    }
    return writer2;
  }, "getWriter");
  const write3 = /* @__PURE__ */ __name((chunk4) => latch.whenOpen(suspend4(() => {
    const {
      fiberSet,
      stream: stream6
    } = currentStream;
    if (isCloseEvent(chunk4)) {
      return fail8(fiberSet.deferred, new SocketCloseError({
        reason: "Close",
        code: chunk4.code,
        closeReason: chunk4.reason
      }));
    }
    return promise2(() => getWriter(stream6).write(typeof chunk4 === "string" ? encoder3.encode(chunk4) : chunk4));
  })), "write");
  const writer = acquireRelease2(succeed11(write3), () => promise2(async () => {
    if (!currentStream) return;
    await getWriter(currentStream.stream).close();
  }));
  return succeed11(Socket.of({
    [TypeId40]: TypeId40,
    run: run10,
    runRaw,
    writer
  }));
}), "fromTransformStream");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpServerRequest.js
var TypeId41 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServerRequest");
var serverRequestTag = /* @__PURE__ */ GenericTag("@effect/platform/HttpServerRequest");
var parsedSearchParamsTag = /* @__PURE__ */ GenericTag("@effect/platform/HttpServerRequest/ParsedSearchParams");
var fromWeb2 = /* @__PURE__ */ __name((request2) => new ServerRequestImpl(request2, removeHost(request2.url)), "fromWeb");
var removeHost = /* @__PURE__ */ __name((url2) => {
  if (url2[0] === "/") {
    return url2;
  }
  const index2 = url2.indexOf("/", url2.indexOf("//") + 2);
  return index2 === -1 ? "/" : url2.slice(index2);
}, "removeHost");
var ServerRequestImpl = class _ServerRequestImpl extends Class {
  static {
    __name(this, "ServerRequestImpl");
  }
  source;
  url;
  headersOverride;
  remoteAddressOverride;
  [TypeId41];
  [TypeId29];
  constructor(source, url2, headersOverride, remoteAddressOverride) {
    super();
    this.source = source;
    this.url = url2;
    this.headersOverride = headersOverride;
    this.remoteAddressOverride = remoteAddressOverride;
    this[TypeId41] = TypeId41;
    this[TypeId29] = TypeId29;
  }
  toJSON() {
    return inspect(this, {
      _id: "@effect/platform/HttpServerRequest",
      method: this.method,
      url: this.originalUrl
    });
  }
  modify(options4) {
    return new _ServerRequestImpl(this.source, options4.url ?? this.url, options4.headers ?? this.headersOverride, options4.remoteAddress ?? this.remoteAddressOverride);
  }
  get method() {
    return this.source.method.toUpperCase();
  }
  get originalUrl() {
    return this.source.url;
  }
  get remoteAddress() {
    return this.remoteAddressOverride ? some3(this.remoteAddressOverride) : none2();
  }
  get headers() {
    this.headersOverride ??= fromInput(this.source.headers);
    return this.headersOverride;
  }
  cachedCookies;
  get cookies() {
    if (this.cachedCookies) {
      return this.cachedCookies;
    }
    return this.cachedCookies = parseHeader(this.headers.cookie ?? "");
  }
  get stream() {
    return this.source.body ? fromReadableStream2(() => this.source.body, (cause3) => new RequestError2({
      request: this,
      reason: "Decode",
      cause: cause3
    })) : fail19(new RequestError2({
      request: this,
      reason: "Decode",
      description: "can not create stream from empty body"
    }));
  }
  textEffect;
  get text() {
    if (this.textEffect) {
      return this.textEffect;
    }
    this.textEffect = runSync(cached3(tryPromise2({
      try: /* @__PURE__ */ __name(() => this.source.text(), "try"),
      catch: /* @__PURE__ */ __name((cause3) => new RequestError2({
        request: this,
        reason: "Decode",
        cause: cause3
      }), "catch")
    })));
    return this.textEffect;
  }
  get json() {
    return tryMap2(this.text, {
      try: /* @__PURE__ */ __name((_) => JSON.parse(_), "try"),
      catch: /* @__PURE__ */ __name((cause3) => new RequestError2({
        request: this,
        reason: "Decode",
        cause: cause3
      }), "catch")
    });
  }
  get urlParamsBody() {
    return flatMap15(this.text, (_) => try_3({
      try: /* @__PURE__ */ __name(() => fromInput2(new URLSearchParams(_)), "try"),
      catch: /* @__PURE__ */ __name((cause3) => new RequestError2({
        request: this,
        reason: "Decode",
        cause: cause3
      }), "catch")
    }));
  }
  multipartEffect;
  get multipart() {
    if (this.multipartEffect) {
      return this.multipartEffect;
    }
    this.multipartEffect = runSync(cached3(toPersisted(this.multipartStream)));
    return this.multipartEffect;
  }
  get multipartStream() {
    return pipeThroughChannel2(mapError10(this.stream, (cause3) => new MultipartError({
      reason: "InternalError",
      cause: cause3
    })), makeChannel(this.headers));
  }
  arrayBufferEffect;
  get arrayBuffer() {
    if (this.arrayBufferEffect) {
      return this.arrayBufferEffect;
    }
    this.arrayBufferEffect = runSync(cached3(tryPromise2({
      try: /* @__PURE__ */ __name(() => this.source.arrayBuffer(), "try"),
      catch: /* @__PURE__ */ __name((cause3) => new RequestError2({
        request: this,
        reason: "Decode",
        cause: cause3
      }), "catch")
    })));
    return this.arrayBufferEffect;
  }
  get upgrade() {
    return fail10(new RequestError2({
      request: this,
      reason: "Decode",
      description: "Not an upgradeable ServerRequest"
    }));
  }
};
var toURL = /* @__PURE__ */ __name((self2) => {
  const host = self2.headers.host ?? "localhost";
  const protocol = self2.headers["x-forwarded-proto"] === "https" ? "https" : "http";
  try {
    return some3(new URL(self2.url, `${protocol}://${host}`));
  } catch {
    return none2();
  }
}, "toURL");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpServerRequest.js
var HttpServerRequest = serverRequestTag;
var ParsedSearchParams = parsedSearchParamsTag;
var fromWeb3 = fromWeb2;
var toURL2 = toURL;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpApp.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var currentPreResponseHandlers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpApp/preResponseHandlers"), () => unsafeMake11(none2()));
var appendPreResponseHandler = /* @__PURE__ */ __name((handler) => update5(currentPreResponseHandlers, match2({
  onNone: /* @__PURE__ */ __name(() => some3(handler), "onNone"),
  onSome: /* @__PURE__ */ __name((prev) => some3((request2, response) => flatMap15(prev(request2, response), (response2) => handler(request2, response2))), "onSome")
})), "appendPreResponseHandler");
var withPreResponseHandler = /* @__PURE__ */ dual(2, (self2, handler) => locallyWith(self2, currentPreResponseHandlers, match2({
  onNone: /* @__PURE__ */ __name(() => some3(handler), "onNone"),
  onSome: /* @__PURE__ */ __name((prev) => some3((request2, response) => flatMap15(prev(request2, response), (response2) => handler(request2, response2))), "onSome")
})));

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpMiddleware.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var make82 = /* @__PURE__ */ __name((middleware2) => middleware2, "make");
var loggerDisabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpMiddleware/loggerDisabled"), () => unsafeMake11(false));
var withLoggerDisabled = /* @__PURE__ */ __name((self2) => zipRight7(set7(loggerDisabled, true), self2), "withLoggerDisabled");
var currentTracerDisabledWhen2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpMiddleware/tracerDisabledWhen"), () => unsafeMake11(constFalse));
var SpanNameGenerator2 = /* @__PURE__ */ Reference2()("@effect/platform/HttpMiddleware/SpanNameGenerator", {
  defaultValue: /* @__PURE__ */ __name(() => (request2) => `http.server ${request2.method}`, "defaultValue")
});
var tracer3 = /* @__PURE__ */ make82((httpApp) => withFiberRuntime2((fiber) => {
  const request2 = unsafeGet5(fiber.currentContext, HttpServerRequest);
  const disabled = fiber.getFiberRef(currentTracerDisabledWhen2)(request2);
  if (disabled) {
    return httpApp;
  }
  const url2 = getOrUndefined2(toURL2(request2));
  if (url2 !== void 0 && (url2.username !== "" || url2.password !== "")) {
    url2.username = "REDACTED";
    url2.password = "REDACTED";
  }
  const redactedHeaderNames = fiber.getFiberRef(currentRedactedNames);
  const redactedHeaders = redact2(request2.headers, redactedHeaderNames);
  const nameGenerator = get6(fiber.currentContext, SpanNameGenerator2);
  return useSpan2(nameGenerator(request2), {
    parent: getOrUndefined2(fromHeaders(request2.headers)),
    kind: "server",
    captureStackTrace: false
  }, (span4) => {
    span4.attribute("http.request.method", request2.method);
    if (url2 !== void 0) {
      span4.attribute("url.full", url2.toString());
      span4.attribute("url.path", url2.pathname);
      const query = url2.search.slice(1);
      if (query !== "") {
        span4.attribute("url.query", url2.search.slice(1));
      }
      span4.attribute("url.scheme", url2.protocol.slice(0, -1));
    }
    if (request2.headers["user-agent"] !== void 0) {
      span4.attribute("user_agent.original", request2.headers["user-agent"]);
    }
    for (const name in redactedHeaders) {
      span4.attribute(`http.request.header.${name}`, String(redactedHeaders[name]));
    }
    if (request2.remoteAddress._tag === "Some") {
      span4.attribute("client.address", request2.remoteAddress.value);
    }
    return flatMap15(exit4(withParentSpan3(httpApp, span4)), (exit5) => {
      const response = exitResponse2(exit5);
      span4.attribute("http.response.status_code", response.status);
      const redactedHeaders2 = redact2(response.headers, redactedHeaderNames);
      for (const name in redactedHeaders2) {
        span4.attribute(`http.response.header.${name}`, String(redactedHeaders2[name]));
      }
      return exit5;
    });
  });
}));

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpApp.js
var handledSymbol = /* @__PURE__ */ Symbol.for("@effect/platform/HttpApp/handled");
var toHandled = /* @__PURE__ */ __name((self2, handleResponse, middleware2) => {
  const responded = withFiberRuntime2((fiber) => flatMap15(self2, (response) => {
    const request2 = unsafeGet5(fiber.currentContext, HttpServerRequest);
    const handler = fiber.getFiberRef(currentPreResponseHandlers2);
    if (handler._tag === "None") {
      ;
      request2[handledSymbol] = true;
      return as8(handleResponse(request2, response), response);
    }
    return tap4(handler.value(request2, response), (response2) => {
      ;
      request2[handledSymbol] = true;
      return handleResponse(request2, response2);
    });
  }));
  const withErrorHandling = catchAllCause3(responded, (cause3) => withFiberRuntime2((fiber) => flatMap15(causeResponse2(cause3), ([response, cause4]) => {
    const request2 = unsafeGet5(fiber.currentContext, HttpServerRequest);
    const handler = fiber.getFiberRef(currentPreResponseHandlers2);
    if (handler._tag === "None") {
      ;
      request2[handledSymbol] = true;
      return zipRight7(handleResponse(request2, response), failCause9(cause4));
    }
    return zipRight7(tap4(handler.value(request2, response), (response2) => {
      ;
      request2[handledSymbol] = true;
      return handleResponse(request2, response2);
    }), failCause9(cause4));
  })));
  const withMiddleware = unify2(middleware2 === void 0 ? tracer3(withErrorHandling) : matchCauseEffect3(tracer3(middleware2(withErrorHandling)), {
    onFailure: /* @__PURE__ */ __name((cause3) => withFiberRuntime2((fiber) => {
      const request2 = unsafeGet5(fiber.currentContext, HttpServerRequest);
      if (handledSymbol in request2) {
        return _void;
      }
      return matchCauseEffect3(causeResponse2(cause3), {
        onFailure: /* @__PURE__ */ __name((_cause) => handleResponse(request2, empty42({
          status: 500
        })), "onFailure"),
        onSuccess: /* @__PURE__ */ __name(([response]) => handleResponse(request2, response), "onSuccess")
      });
    }), "onFailure"),
    onSuccess: /* @__PURE__ */ __name((response) => withFiberRuntime2((fiber) => {
      const request2 = unsafeGet5(fiber.currentContext, HttpServerRequest);
      return handledSymbol in request2 ? _void : handleResponse(request2, response);
    }), "onSuccess")
  }));
  return uninterruptible2(scoped8(withMiddleware));
}, "toHandled");
var ejectDefaultScopeClose = /* @__PURE__ */ __name((scope5) => {
  ejectedScopes.add(scope5);
}, "ejectDefaultScopeClose");
var unsafeEjectStreamScope = /* @__PURE__ */ __name((response) => {
  if (response.body._tag !== "Stream") {
    return response;
  }
  const fiber = getOrThrow2(getCurrentFiber2());
  const scope5 = unsafeGet5(fiber.currentContext, Scope);
  ejectDefaultScopeClose(scope5);
  return setBody3(response, stream3(ensuring8(response.body.stream, close(scope5, void_5)), response.body.contentType, response.body.contentLength));
}, "unsafeEjectStreamScope");
var ejectedScopes = /* @__PURE__ */ globalValue("@effect/platform/HttpApp/ejectedScopes", () => /* @__PURE__ */ new WeakSet());
var scoped8 = /* @__PURE__ */ __name((effect4) => flatMap15(make40(), (scope5) => onExit3(extend3(effect4, scope5), (exit5) => {
  if (ejectedScopes.has(scope5)) {
    return _void;
  }
  return close(scope5, exit5);
})), "scoped");
var currentPreResponseHandlers2 = currentPreResponseHandlers;
var appendPreResponseHandler2 = appendPreResponseHandler;
var withPreResponseHandler2 = withPreResponseHandler;
var toWebHandlerRuntime = /* @__PURE__ */ __name((runtime8) => {
  const httpRuntime = make57(runtime8);
  const run10 = runFork3(httpRuntime);
  return (self2, middleware2) => {
    const resolveSymbol = Symbol.for("@effect/platform/HttpApp/resolve");
    const httpApp = toHandled(self2, (request2, response) => {
      response = unsafeEjectStreamScope(response);
      request2[resolveSymbol](toWeb2(response, {
        withoutBody: request2.method === "HEAD",
        runtime: runtime8
      }));
      return _void;
    }, middleware2);
    return (request2, context17) => new Promise((resolve3) => {
      const contextMap = new Map(runtime8.context.unsafeMap);
      if (isContext2(context17)) {
        for (const [key, value6] of context17.unsafeMap) {
          contextMap.set(key, value6);
        }
      }
      const httpServerRequest = fromWeb3(request2);
      contextMap.set(HttpServerRequest.key, httpServerRequest);
      httpServerRequest[resolveSymbol] = resolve3;
      httpRuntime.context = unsafeMake(contextMap);
      const fiber = run10(httpApp);
      request2.signal?.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(clientAbortFiberId2);
      }, {
        once: true
      });
    });
  };
}, "toWebHandlerRuntime");
var toWebHandler = /* @__PURE__ */ toWebHandlerRuntime(defaultRuntime2);
var toWebHandlerLayerWith = /* @__PURE__ */ __name((layer14, options4) => {
  const scope5 = runSync(make40());
  const dispose = /* @__PURE__ */ __name(() => runPromise(close(scope5, void_5)), "dispose");
  let handlerCache;
  let handlerPromise;
  function handler(request2, context17) {
    if (handlerCache) {
      return handlerCache(request2, context17);
    }
    handlerPromise ??= gen4(function* () {
      const runtime8 = yield* options4.memoMap ? toRuntimeWithMemoMap2(layer14, options4.memoMap) : toRuntime2(layer14);
      return handlerCache = toWebHandlerRuntime(runtime8)(yield* options4.toHandler(runtime8), options4.middleware);
    }).pipe(extend3(scope5), runPromise);
    return handlerPromise.then((f) => f(request2, context17));
  }
  __name(handler, "handler");
  return {
    dispose,
    handler
  };
}, "toWebHandlerLayerWith");
var toWebHandlerLayer = /* @__PURE__ */ __name((self2, layer14, options4) => toWebHandlerLayerWith(layer14, {
  ...options4,
  toHandler: /* @__PURE__ */ __name(() => succeed11(self2), "toHandler")
}), "toWebHandlerLayer");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpMiddleware.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var withLoggerDisabled2 = withLoggerDisabled;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpRouter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpRouter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/find-my-way-ts@0.1.6/node_modules/find-my-way-ts/dist/esm/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/find-my-way-ts@0.1.6/node_modules/find-my-way-ts/dist/esm/internal/router.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/find-my-way-ts@0.1.6/node_modules/find-my-way-ts/dist/esm/QueryString.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var plusRegex = /\+/g;
var Empty = /* @__PURE__ */ __name(function() {
}, "Empty");
Empty.prototype = /* @__PURE__ */ Object.create(null);
function parse4(input) {
  const result = new Empty();
  if (typeof input !== "string") {
    return result;
  }
  const inputLength = input.length;
  let key = "";
  let value6 = "";
  let startingIndex = -1;
  let equalityIndex = -1;
  let shouldDecodeKey = false;
  let shouldDecodeValue = false;
  let keyHasPlus = false;
  let valueHasPlus = false;
  let hasBothKeyValuePair = false;
  let c = 0;
  for (let i = 0; i < inputLength + 1; i++) {
    c = i !== inputLength ? input.charCodeAt(i) : 38;
    if (c === 38) {
      hasBothKeyValuePair = equalityIndex > startingIndex;
      if (!hasBothKeyValuePair) {
        equalityIndex = i;
      }
      key = input.slice(startingIndex + 1, equalityIndex);
      if (hasBothKeyValuePair || key.length > 0) {
        if (keyHasPlus) {
          key = key.replace(plusRegex, " ");
        }
        if (shouldDecodeKey) {
          try {
            key = decodeURIComponent(key) || key;
          } catch {
          }
        }
        if (hasBothKeyValuePair) {
          value6 = input.slice(equalityIndex + 1, i);
          if (valueHasPlus) {
            value6 = value6.replace(plusRegex, " ");
          }
          if (shouldDecodeValue) {
            try {
              value6 = decodeURIComponent(value6) || value6;
            } catch {
            }
          }
        }
        const currentValue = result[key];
        if (currentValue === void 0) {
          result[key] = value6;
        } else {
          if (currentValue.pop) {
            currentValue.push(value6);
          } else {
            result[key] = [currentValue, value6];
          }
        }
      }
      value6 = "";
      startingIndex = i;
      equalityIndex = i;
      shouldDecodeKey = false;
      shouldDecodeValue = false;
      keyHasPlus = false;
      valueHasPlus = false;
    } else if (c === 61) {
      if (equalityIndex <= startingIndex) {
        equalityIndex = i;
      } else {
        shouldDecodeValue = true;
      }
    } else if (c === 43) {
      if (equalityIndex > startingIndex) {
        valueHasPlus = true;
      } else {
        keyHasPlus = true;
      }
    } else if (c === 37) {
      if (equalityIndex > startingIndex) {
        shouldDecodeValue = true;
      } else {
        shouldDecodeKey = true;
      }
    }
  }
  return result;
}
__name(parse4, "parse");

// node_modules/.pnpm/find-my-way-ts@0.1.6/node_modules/find-my-way-ts/dist/esm/internal/router.js
var FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
var OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
var make83 = /* @__PURE__ */ __name((options4 = {}) => new RouterImpl(options4), "make");
var RouterImpl = class {
  static {
    __name(this, "RouterImpl");
  }
  constructor(options4 = {}) {
    this.options = {
      ignoreTrailingSlash: true,
      ignoreDuplicateSlashes: true,
      caseSensitive: false,
      maxParamLength: 100,
      ...options4
    };
  }
  options;
  routes = [];
  trees = {};
  on(method, path, handler) {
    const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
    if (optionalParamMatch && optionalParamMatch.index !== void 0) {
      assert4(path.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
      const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
      const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, "$2");
      this.on(method, pathFull, handler);
      this.on(method, pathOptional, handler);
      return;
    }
    if (this.options.ignoreDuplicateSlashes) {
      path = removeDuplicateSlashes(path);
    }
    if (this.options.ignoreTrailingSlash) {
      path = trimLastSlash(path);
    }
    const methods = typeof method === "string" ? [method] : method;
    for (const method2 of methods) {
      this._on(method2, path, handler);
    }
  }
  all(path, handler) {
    this.on(httpMethods, path, handler);
  }
  _on(method, path, handler) {
    if (this.trees[method] === void 0) {
      this.trees[method] = new StaticNode("/");
    }
    let pattern2 = path;
    if (pattern2 === "*" && this.trees[method].prefix.length !== 0) {
      const currentRoot = this.trees[method];
      this.trees[method] = new StaticNode("");
      this.trees[method].staticChildren["/"] = currentRoot;
    }
    let parentNodePathIndex = this.trees[method].prefix.length;
    let currentNode = this.trees[method];
    const params2 = [];
    for (let i = 0; i <= pattern2.length; i++) {
      if (pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) === 58) {
        i++;
        continue;
      }
      const isParametricNode = pattern2.charCodeAt(i) === 58 && pattern2.charCodeAt(i + 1) !== 58;
      const isWildcardNode = pattern2.charCodeAt(i) === 42;
      if (isParametricNode || isWildcardNode || i === pattern2.length && i !== parentNodePathIndex) {
        let staticNodePath = pattern2.slice(parentNodePathIndex, i);
        if (!this.options.caseSensitive) {
          staticNodePath = staticNodePath.toLowerCase();
        }
        staticNodePath = staticNodePath.split("::").join(":");
        staticNodePath = staticNodePath.split("%").join("%25");
        currentNode = currentNode.createStaticChild(staticNodePath);
      }
      if (isParametricNode) {
        let isRegexNode = false;
        const regexps = [];
        let lastParamStartIndex = i + 1;
        for (let j = lastParamStartIndex; ; j++) {
          const charCode = pattern2.charCodeAt(j);
          const isRegexParam = charCode === 40;
          const isStaticPart = charCode === 45 || charCode === 46;
          const isEndOfNode = charCode === 47 || j === pattern2.length;
          if (isRegexParam || isStaticPart || isEndOfNode) {
            const paramName = pattern2.slice(lastParamStartIndex, j);
            params2.push(paramName);
            isRegexNode = isRegexNode || isRegexParam || isStaticPart;
            if (isRegexParam) {
              const endOfRegexIndex = getClosingParenthensePosition(pattern2, j);
              const regexString = pattern2.slice(j, endOfRegexIndex + 1);
              regexps.push(trimRegExpStartAndEnd(regexString));
              j = endOfRegexIndex + 1;
            } else {
              regexps.push("(.*?)");
            }
            const staticPartStartIndex = j;
            for (; j < pattern2.length; j++) {
              const charCode2 = pattern2.charCodeAt(j);
              if (charCode2 === 47) break;
              if (charCode2 === 58) {
                const nextCharCode = pattern2.charCodeAt(j + 1);
                if (nextCharCode === 58) j++;
                else break;
              }
            }
            let staticPart = pattern2.slice(staticPartStartIndex, j);
            if (staticPart) {
              staticPart = staticPart.split("::").join(":");
              staticPart = staticPart.split("%").join("%25");
              regexps.push(escapeRegExp(staticPart));
            }
            lastParamStartIndex = j + 1;
            if (isEndOfNode || pattern2.charCodeAt(j) === 47 || j === pattern2.length) {
              const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
              const nodePath = pattern2.slice(i, j);
              pattern2 = pattern2.slice(0, i + 1) + nodePattern + pattern2.slice(j);
              i += nodePattern.length;
              const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : void 0;
              currentNode = currentNode.createParametricChild(regex, staticPart, nodePath);
              parentNodePathIndex = i + 1;
              break;
            }
          }
        }
      } else if (isWildcardNode) {
        params2.push("*");
        currentNode = currentNode.createWildcardChild();
        parentNodePathIndex = i + 1;
        if (i !== pattern2.length - 1) {
          throw new Error("Wildcard must be the last character in the route");
        }
      }
    }
    if (!this.options.caseSensitive) {
      pattern2 = pattern2.toLowerCase();
    }
    if (pattern2 === "*") {
      pattern2 = "/*";
    }
    for (const existRoute of this.routes) {
      if (existRoute.method === method && existRoute.pattern === pattern2) {
        throw new Error(`Method '${method}' already declared for route '${pattern2}'`);
      }
    }
    const route2 = {
      method,
      path,
      pattern: pattern2,
      params: params2,
      handler
    };
    this.routes.push(route2);
    currentNode.addRoute(route2);
  }
  has(method, path) {
    const node = this.trees[method];
    if (node === void 0) {
      return false;
    }
    const staticNode = node.getStaticChild(path);
    if (staticNode === void 0) {
      return false;
    }
    return staticNode.isLeafNode;
  }
  find(method, path) {
    let currentNode = this.trees[method];
    if (currentNode === void 0) return void 0;
    if (path.charCodeAt(0) !== 47) {
      path = path.replace(FULL_PATH_REGEXP, "/");
    }
    if (this.options.ignoreDuplicateSlashes) {
      path = removeDuplicateSlashes(path);
    }
    let sanitizedUrl;
    let querystring;
    let shouldDecodeParam;
    try {
      sanitizedUrl = safeDecodeURI(path);
      path = sanitizedUrl.path;
      querystring = sanitizedUrl.querystring;
      shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
    } catch (error5) {
      return void 0;
    }
    if (this.options.ignoreTrailingSlash) {
      path = trimLastSlash(path);
    }
    const originPath = path;
    if (this.options.caseSensitive === false) {
      path = path.toLowerCase();
    }
    const maxParamLength = this.options.maxParamLength;
    let pathIndex = currentNode.prefix.length;
    const params2 = [];
    const pathLen = path.length;
    const brothersNodesStack = [];
    while (true) {
      if (pathIndex === pathLen && currentNode.isLeafNode) {
        const handle = currentNode.handlerStorage?.find();
        if (handle !== void 0) {
          return {
            handler: handle.handler,
            params: handle.createParams(params2),
            searchParams: parse4(querystring)
          };
        }
      }
      let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params2.length);
      if (node === void 0) {
        if (brothersNodesStack.length === 0) {
          return void 0;
        }
        const brotherNodeState = brothersNodesStack.pop();
        pathIndex = brotherNodeState.brotherPathIndex;
        params2.splice(brotherNodeState.paramsCount);
        node = brotherNodeState.brotherNode;
      }
      currentNode = node;
      if (currentNode._tag === "StaticNode") {
        pathIndex += currentNode.prefix.length;
        continue;
      }
      if (currentNode._tag === "WildcardNode") {
        let param = originPath.slice(pathIndex);
        if (shouldDecodeParam) {
          param = safeDecodeURIComponent(param);
        }
        params2.push(param);
        pathIndex = pathLen;
        continue;
      }
      if (currentNode._tag === "ParametricNode") {
        let paramEndIndex = originPath.indexOf("/", pathIndex);
        if (paramEndIndex === -1) {
          paramEndIndex = pathLen;
        }
        let param = originPath.slice(pathIndex, paramEndIndex);
        if (shouldDecodeParam) {
          param = safeDecodeURIComponent(param);
        }
        if (currentNode.regex !== void 0) {
          const matchedParameters = currentNode.regex.exec(param);
          if (matchedParameters === null) continue;
          for (let i = 1; i < matchedParameters.length; i++) {
            const matchedParam = matchedParameters[i];
            if (matchedParam.length > maxParamLength) {
              return void 0;
            }
            params2.push(matchedParam);
          }
        } else {
          if (param.length > maxParamLength) {
            return void 0;
          }
          params2.push(param);
        }
        pathIndex = paramEndIndex;
      }
    }
  }
};
var HandlerStorage = class {
  static {
    __name(this, "HandlerStorage");
  }
  handlers = [];
  unconstrainedHandler;
  find() {
    return this.unconstrainedHandler;
  }
  add(route2) {
    const handler = {
      params: route2.params,
      handler: route2.handler,
      createParams: compileCreateParams(route2.params)
    };
    this.handlers.push(handler);
    this.unconstrainedHandler = this.handlers[0];
  }
};
var NodeBase = class {
  static {
    __name(this, "NodeBase");
  }
  isLeafNode = false;
  routes;
  handlerStorage;
  addRoute(route2) {
    if (this.routes === void 0) {
      this.routes = [route2];
    } else {
      this.routes.push(route2);
    }
    if (this.handlerStorage === void 0) {
      this.handlerStorage = new HandlerStorage();
    }
    this.isLeafNode = true;
    this.handlerStorage.add(route2);
  }
};
var ParentNode = class extends NodeBase {
  static {
    __name(this, "ParentNode");
  }
  staticChildren = {};
  findStaticMatchingChild(path, pathIndex) {
    const staticChild = this.staticChildren[path.charAt(pathIndex)];
    if (staticChild === void 0 || !staticChild.matchPrefix(path, pathIndex)) {
      return void 0;
    }
    return staticChild;
  }
  getStaticChild(path, pathIndex = 0) {
    if (path.length === pathIndex) {
      return this;
    }
    const staticChild = this.findStaticMatchingChild(path, pathIndex);
    if (staticChild === void 0) {
      return void 0;
    }
    return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length);
  }
  createStaticChild(path) {
    if (path.length === 0) {
      return this;
    }
    let staticChild = this.staticChildren[path.charAt(0)];
    if (staticChild) {
      let i = 1;
      for (; i < staticChild.prefix.length; i++) {
        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
          staticChild = staticChild.split(this, i);
          break;
        }
      }
      return staticChild.createStaticChild(path.slice(i));
    }
    const label = path.charAt(0);
    this.staticChildren[label] = new StaticNode(path);
    return this.staticChildren[label];
  }
};
var StaticNode = class _StaticNode extends ParentNode {
  static {
    __name(this, "StaticNode");
  }
  _tag = "StaticNode";
  constructor(prefix) {
    super();
    this.setPrefix(prefix);
  }
  prefix;
  matchPrefix;
  parametricChildren = [];
  wildcardChild;
  setPrefix(prefix) {
    this.prefix = prefix;
    if (prefix.length === 1) {
      this.matchPrefix = (_path, _pathIndex) => true;
    } else {
      const len = prefix.length;
      this.matchPrefix = function(path, pathIndex) {
        for (let i = 1; i < len; i++) {
          if (path.charCodeAt(pathIndex + i) !== this.prefix.charCodeAt(i)) {
            return false;
          }
        }
        return true;
      };
    }
  }
  getParametricChild(regex) {
    if (regex === void 0) {
      return this.parametricChildren.find((child) => child.isRegex === false);
    }
    const source = regex.source;
    return this.parametricChildren.find((child) => {
      if (child.regex === void 0) {
        return false;
      }
      return child.regex.source === source;
    });
  }
  createParametricChild(regex, staticSuffix, nodePath) {
    let child = this.getParametricChild(regex);
    if (child !== void 0) {
      child.nodePaths.add(nodePath);
      return child;
    }
    child = new ParametricNode(regex, staticSuffix, nodePath);
    this.parametricChildren.push(child);
    this.parametricChildren.sort((child1, child2) => {
      if (!child1.isRegex) return 1;
      if (!child2.isRegex) return -1;
      if (child1.staticSuffix === void 0) return 1;
      if (child2.staticSuffix === void 0) return -1;
      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1;
      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1;
      return 0;
    });
    return child;
  }
  createWildcardChild() {
    if (this.wildcardChild === void 0) {
      this.wildcardChild = new WildcardNode();
    }
    return this.wildcardChild;
  }
  split(parentNode, length5) {
    const parentPrefix = this.prefix.slice(0, length5);
    const childPrefix = this.prefix.slice(length5);
    this.setPrefix(childPrefix);
    const staticNode = new _StaticNode(parentPrefix);
    staticNode.staticChildren[childPrefix.charAt(0)] = this;
    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;
    return staticNode;
  }
  getNextNode(path, pathIndex, nodeStack, paramsCount) {
    let node = this.findStaticMatchingChild(path, pathIndex);
    let parametricBrotherNodeIndex = 0;
    if (node === void 0) {
      if (this.parametricChildren.length === 0) {
        return this.wildcardChild;
      }
      node = this.parametricChildren[0];
      parametricBrotherNodeIndex = 1;
    }
    if (this.wildcardChild !== void 0) {
      nodeStack.push({
        paramsCount,
        brotherPathIndex: pathIndex,
        brotherNode: this.wildcardChild
      });
    }
    for (let i = this.parametricChildren.length - 1; i >= parametricBrotherNodeIndex; i--) {
      nodeStack.push({
        paramsCount,
        brotherPathIndex: pathIndex,
        brotherNode: this.parametricChildren[i]
      });
    }
    return node;
  }
};
var ParametricNode = class extends ParentNode {
  static {
    __name(this, "ParametricNode");
  }
  regex;
  staticSuffix;
  _tag = "ParametricNode";
  constructor(regex, staticSuffix, nodePath) {
    super();
    this.regex = regex;
    this.staticSuffix = staticSuffix;
    this.isRegex = !!regex;
    this.nodePaths = /* @__PURE__ */ new Set([nodePath]);
  }
  isRegex;
  nodePaths;
  getNextNode(path, pathIndex) {
    return this.findStaticMatchingChild(path, pathIndex);
  }
};
var WildcardNode = class extends NodeBase {
  static {
    __name(this, "WildcardNode");
  }
  _tag = "WildcardNode";
  getNextNode(_path, _pathIndex, _nodeStack, _paramsCount) {
    return void 0;
  }
};
var assert4 = /* @__PURE__ */ __name((condition, message) => {
  if (!condition) {
    throw new Error(message);
  }
}, "assert");
function removeDuplicateSlashes(path) {
  return path.replace(/\/\/+/g, "/");
}
__name(removeDuplicateSlashes, "removeDuplicateSlashes");
function trimLastSlash(path) {
  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {
    return path.slice(0, -1);
  }
  return path;
}
__name(trimLastSlash, "trimLastSlash");
function compileCreateParams(params2) {
  const len = params2.length;
  return function(paramsArray) {
    const paramsObject = {};
    for (let i = 0; i < len; i++) {
      paramsObject[params2[i]] = paramsArray[i];
    }
    return paramsObject;
  };
}
__name(compileCreateParams, "compileCreateParams");
function getClosingParenthensePosition(path, idx) {
  let parentheses = 1;
  while (idx < path.length) {
    idx++;
    if (path[idx] === "\\") {
      idx++;
      continue;
    }
    if (path[idx] === ")") {
      parentheses--;
    } else if (path[idx] === "(") {
      parentheses++;
    }
    if (!parentheses) return idx;
  }
  throw new TypeError('Invalid regexp expression in "' + path + '"');
}
__name(getClosingParenthensePosition, "getClosingParenthensePosition");
function trimRegExpStartAndEnd(regexString) {
  if (regexString.charCodeAt(1) === 94) {
    regexString = regexString.slice(0, 1) + regexString.slice(2);
  }
  if (regexString.charCodeAt(regexString.length - 2) === 36) {
    regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
  }
  return regexString;
}
__name(trimRegExpStartAndEnd, "trimRegExpStartAndEnd");
function escapeRegExp(string7) {
  return string7.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
__name(escapeRegExp, "escapeRegExp");
function decodeComponentChar(highCharCode, lowCharCode) {
  if (highCharCode === 50) {
    if (lowCharCode === 53) return "%";
    if (lowCharCode === 51) return "#";
    if (lowCharCode === 52) return "$";
    if (lowCharCode === 54) return "&";
    if (lowCharCode === 66) return "+";
    if (lowCharCode === 98) return "+";
    if (lowCharCode === 67) return ",";
    if (lowCharCode === 99) return ",";
    if (lowCharCode === 70) return "/";
    if (lowCharCode === 102) return "/";
    return void 0;
  }
  if (highCharCode === 51) {
    if (lowCharCode === 65) return ":";
    if (lowCharCode === 97) return ":";
    if (lowCharCode === 66) return ";";
    if (lowCharCode === 98) return ";";
    if (lowCharCode === 68) return "=";
    if (lowCharCode === 100) return "=";
    if (lowCharCode === 70) return "?";
    if (lowCharCode === 102) return "?";
    return void 0;
  }
  if (highCharCode === 52 && lowCharCode === 48) {
    return "@";
  }
  return void 0;
}
__name(decodeComponentChar, "decodeComponentChar");
function safeDecodeURI(path) {
  let shouldDecode = false;
  let shouldDecodeParam = false;
  let querystring = "";
  for (let i = 1; i < path.length; i++) {
    const charCode = path.charCodeAt(i);
    if (charCode === 37) {
      const highCharCode = path.charCodeAt(i + 1);
      const lowCharCode = path.charCodeAt(i + 2);
      if (decodeComponentChar(highCharCode, lowCharCode) === void 0) {
        shouldDecode = true;
      } else {
        shouldDecodeParam = true;
        if (highCharCode === 50 && lowCharCode === 53) {
          shouldDecode = true;
          path = path.slice(0, i + 1) + "25" + path.slice(i + 1);
          i += 2;
        }
        i += 2;
      }
    } else if (charCode === 63 || charCode === 59 || charCode === 35) {
      querystring = path.slice(i + 1);
      path = path.slice(0, i);
      break;
    }
  }
  const decodedPath = shouldDecode ? decodeURI(path) : path;
  return {
    path: decodedPath,
    querystring,
    shouldDecodeParam
  };
}
__name(safeDecodeURI, "safeDecodeURI");
function safeDecodeURIComponent(uriComponent) {
  const startIndex = uriComponent.indexOf("%");
  if (startIndex === -1) return uriComponent;
  let decoded = "";
  let lastIndex = startIndex;
  for (let i = startIndex; i < uriComponent.length; i++) {
    if (uriComponent.charCodeAt(i) === 37) {
      const highCharCode = uriComponent.charCodeAt(i + 1);
      const lowCharCode = uriComponent.charCodeAt(i + 2);
      const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
      decoded += uriComponent.slice(lastIndex, i) + decodedChar;
      lastIndex = i + 3;
    }
  }
  return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);
}
__name(safeDecodeURIComponent, "safeDecodeURIComponent");
var httpMethods = ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE"];

// node_modules/.pnpm/find-my-way-ts@0.1.6/node_modules/find-my-way-ts/dist/esm/index.js
var make84 = make83;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpServer.js
var HttpServer_exports = {};
__export(HttpServer_exports, {
  HttpServer: () => HttpServer,
  TypeId: () => TypeId44,
  addressFormattedWith: () => addressFormattedWith2,
  addressWith: () => addressWith2,
  formatAddress: () => formatAddress2,
  layerContext: () => layerContext2,
  layerTestClient: () => layerTestClient2,
  logAddress: () => logAddress2,
  make: () => make87,
  serve: () => serve2,
  serveEffect: () => serveEffect2,
  withLogAddress: () => withLogAddress2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpServer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpPlatform.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId42 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpPlatform");
var tag5 = /* @__PURE__ */ GenericTag("@effect/platform/HttpPlatform");
var make85 = /* @__PURE__ */ __name((impl) => gen4(function* () {
  const fs = yield* FileSystem;
  const etagGen = yield* Generator;
  return tag5.of({
    [TypeId42]: TypeId42,
    fileResponse(path, options4) {
      return pipe(bindTo6(fs.stat(path), "info"), bind6("etag", ({
        info: info4
      }) => etagGen.fromFileInfo(info4)), map22(({
        etag,
        info: info4
      }) => {
        const start3 = Number(options4?.offset ?? 0);
        const end6 = options4?.bytesToRead !== void 0 ? start3 + Number(options4.bytesToRead) : void 0;
        const headers = set9(options4?.headers ? fromInput(options4.headers) : empty34, "etag", toString3(etag));
        if (info4.mtime._tag === "Some") {
          ;
          headers["last-modified"] = info4.mtime.value.toUTCString();
        }
        const contentLength = end6 !== void 0 ? end6 - start3 : Number(info4.size) - start3;
        return impl.fileResponse(path, options4?.status ?? 200, options4?.statusText, headers, start3, end6, contentLength);
      }));
    },
    fileWebResponse(file3, options4) {
      return map22(etagGen.fromFileWeb(file3), (etag) => {
        const headers = merge9(options4?.headers ? fromInput(options4.headers) : empty34, unsafeFromRecord({
          etag: toString3(etag),
          "last-modified": new Date(file3.lastModified).toUTCString()
        }));
        return impl.fileWebResponse(file3, options4?.status ?? 200, options4?.statusText, headers, options4);
      });
    }
  });
}), "make");
var layer9 = /* @__PURE__ */ effect(tag5, flatMap15(FileSystem, (fs) => make85({
  fileResponse(path, status3, statusText, headers, start3, end6, contentLength) {
    return stream4(fs.stream(path, {
      offset: start3,
      bytesToRead: end6 !== void 0 ? end6 - start3 : void 0
    }), {
      contentLength,
      headers,
      status: status3,
      statusText
    });
  },
  fileWebResponse(file3, status3, statusText, headers, _options) {
    return stream4(fromReadableStream2(() => file3.stream(), identity), {
      headers,
      status: status3,
      statusText
    });
  }
}))).pipe(/* @__PURE__ */ provide3(layerWeak2));

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpServer.js
var TypeId43 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpServer");
var serverTag = /* @__PURE__ */ GenericTag("@effect/platform/HttpServer");
var serverProto = {
  [TypeId43]: TypeId43
};
var make86 = /* @__PURE__ */ __name((options4) => Object.assign(Object.create(serverProto), options4), "make");
var serve = /* @__PURE__ */ dual((args2) => isEffect2(args2[0]), (httpApp, middleware2) => scopedDiscard2(flatMap15(serverTag, (server) => server.serve(httpApp, middleware2))));
var serveEffect = /* @__PURE__ */ dual((args2) => isEffect2(args2[0]), (httpApp, middleware2) => flatMap15(serverTag, (server) => server.serve(httpApp, middleware2)));
var formatAddress = /* @__PURE__ */ __name((address) => {
  switch (address._tag) {
    case "UnixAddress":
      return `unix://${address.path}`;
    case "TcpAddress":
      return `http://${address.hostname}:${address.port}`;
  }
}, "formatAddress");
var addressWith = /* @__PURE__ */ __name((effect4) => flatMap15(serverTag, (server) => effect4(server.address)), "addressWith");
var addressFormattedWith = /* @__PURE__ */ __name((effect4) => flatMap15(serverTag, (server) => effect4(formatAddress(server.address))), "addressFormattedWith");
var logAddress = /* @__PURE__ */ addressFormattedWith((_) => log5(`Listening on ${_}`));
var withLogAddress = /* @__PURE__ */ __name((layer14) => effectDiscard(logAddress).pipe(provideMerge2(layer14)), "withLogAddress");
var makeTestClient = /* @__PURE__ */ addressWith((address) => flatMap15(HttpClient, (client) => {
  if (address._tag === "UnixAddress") {
    return die7(new Error("HttpServer.layerTestClient: UnixAddress not supported"));
  }
  const host = address.hostname === "0.0.0.0" ? "127.0.0.1" : address.hostname;
  const url2 = `http://${host}:${address.port}`;
  return succeed11(mapRequest2(client, prependUrl2(url2)));
}));
var layerTestClient = /* @__PURE__ */ effect(HttpClient, makeTestClient);
var layerContext = /* @__PURE__ */ mergeAll6(layer9, layer8, layerWeak).pipe(/* @__PURE__ */ provideMerge2(/* @__PURE__ */ layerNoop({})));

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpServer.js
var TypeId44 = TypeId43;
var HttpServer = serverTag;
var make87 = make86;
var serve2 = serve;
var serveEffect2 = serveEffect;
var formatAddress2 = formatAddress;
var addressWith2 = addressWith;
var addressFormattedWith2 = addressFormattedWith;
var logAddress2 = logAddress;
var withLogAddress2 = withLogAddress;
var layerTestClient2 = layerTestClient;
var layerContext2 = layerContext;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/httpRouter.js
var TypeId45 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpRouter");
var RouteTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/HttpRouter/Route");
var RouteContextTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/HttpRouter/RouteContext");
var RouteContext = /* @__PURE__ */ GenericTag("@effect/platform/HttpRouter/RouteContext");
var isRouter = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId45), "isRouter");
var currentRouterConfig = /* @__PURE__ */ globalValue("@effect/platform/HttpRouter/currentRouterConfig", () => unsafeMake11({}));
var RouterImpl2 = class extends StructuralClass {
  static {
    __name(this, "RouterImpl");
  }
  routes;
  mounts;
  [TypeId45];
  constructor(routes, mounts) {
    super();
    this.routes = routes;
    this.mounts = mounts;
    this[TypeId45] = TypeId45;
    this.httpApp = toHttpApp(this).pipe(flatMap15((app) => this.httpApp = app));
  }
  httpApp;
  commit() {
    return this.httpApp;
  }
  toJSON() {
    return {
      _id: "Router",
      routes: this.routes.toJSON(),
      mounts: this.mounts.toJSON()
    };
  }
  toString() {
    return format(this);
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var toHttpApp = /* @__PURE__ */ __name((self2) => map22(get14(currentRouterConfig), (config3) => {
  const router = make84(config3);
  const mounts = toReadonlyArray(self2.mounts).map(([path, app, options4]) => [path, new RouteContextImpl(new RouteImpl("*", options4?.includePrefix ? `${path}/*` : "/*", app, options4?.includePrefix ? none2() : some3(path), false), {}), options4]);
  const mountsLen = mounts.length;
  forEach2(self2.routes, (route2) => {
    if (route2.method === "*") {
      router.all(route2.path, route2);
    } else {
      router.on(route2.method, route2.path, route2);
    }
  });
  return withFiberRuntime2((fiber) => {
    const context17 = unsafeMake(new Map(fiber.getFiberRef(currentContext2).unsafeMap));
    const request2 = unsafeGet5(context17, HttpServerRequest);
    if (mountsLen > 0) {
      const searchIndex = request2.url.indexOf("?");
      const pathname = searchIndex === -1 ? request2.url : request2.url.slice(0, searchIndex);
      for (let i = 0; i < mountsLen; i++) {
        const [path, routeContext, options4] = mounts[i];
        if (pathname === path || pathname.startsWith(path + "/")) {
          context17.unsafeMap.set(RouteContext.key, routeContext);
          if (options4?.includePrefix !== true) {
            context17.unsafeMap.set(HttpServerRequest.key, sliceRequestUrl(request2, path));
          }
          return locally2(flatMap15(routeContext.route.handler, toResponse), currentContext2, context17);
        }
      }
    }
    let result = router.find(request2.method, request2.url);
    if (result === void 0 && request2.method === "HEAD") {
      result = router.find("GET", request2.url);
    }
    if (result === void 0) {
      return fail10(new RouteNotFound({
        request: request2
      }));
    }
    const route2 = result.handler;
    if (route2.prefix._tag === "Some") {
      context17.unsafeMap.set(HttpServerRequest.key, sliceRequestUrl(request2, route2.prefix.value));
    }
    context17.unsafeMap.set(ParsedSearchParams.key, result.searchParams);
    context17.unsafeMap.set(RouteContext.key, new RouteContextImpl(route2, result.params));
    const span4 = getOption2(context17, ParentSpan);
    if (span4._tag === "Some" && span4.value._tag === "Span") {
      span4.value.attribute("http.route", route2.path);
    }
    const handlerResponse = flatMap15(route2.handler, toResponse);
    return locally2(route2.uninterruptible ? handlerResponse : interruptible4(handlerResponse), currentContext2, context17);
  });
}), "toHttpApp");
function sliceRequestUrl(request2, prefix) {
  const prefexLen = prefix.length;
  return request2.modify({
    url: request2.url.length <= prefexLen ? "/" : request2.url.slice(prefexLen)
  });
}
__name(sliceRequestUrl, "sliceRequestUrl");
var RouteImpl = class extends Class {
  static {
    __name(this, "RouteImpl");
  }
  method;
  path;
  handler;
  prefix;
  uninterruptible;
  [RouteTypeId];
  constructor(method, path, handler, prefix = none2(), uninterruptible3 = false) {
    super();
    this.method = method;
    this.path = path;
    this.handler = handler;
    this.prefix = prefix;
    this.uninterruptible = uninterruptible3;
    this[RouteTypeId] = RouteTypeId;
  }
  toJSON() {
    return {
      _id: "@effect/platform/HttpRouter/Route",
      method: this.method,
      path: this.path,
      prefix: this.prefix.toJSON()
    };
  }
};
var RouteContextImpl = class {
  static {
    __name(this, "RouteContextImpl");
  }
  route;
  params;
  [RouteContextTypeId];
  constructor(route2, params2) {
    this.route = route2;
    this.params = params2;
    this[RouteContextTypeId] = RouteContextTypeId;
  }
};
var empty44 = /* @__PURE__ */ new RouterImpl2(/* @__PURE__ */ empty4(), /* @__PURE__ */ empty4());
var append5 = /* @__PURE__ */ dual(2, (self2, route2) => new RouterImpl2(append2(self2.routes, route2), self2.mounts));
var concat4 = /* @__PURE__ */ dual(2, (self2, that) => concatAll4(self2, that));
var concatAll4 = /* @__PURE__ */ __name((...routers) => new RouterImpl2(routers.reduce((cur, acc) => appendAll2(cur, acc.routes), empty4()), routers.reduce((cur, acc) => appendAll2(cur, acc.mounts), empty4())), "concatAll");
var removeTrailingSlash = /* @__PURE__ */ __name((path) => path.endsWith("/") ? path.slice(0, -1) : path, "removeTrailingSlash");
var prefixAll = /* @__PURE__ */ dual(2, (self2, prefix) => {
  prefix = removeTrailingSlash(prefix);
  return new RouterImpl2(map6(self2.routes, (route2) => new RouteImpl(route2.method, route2.path === "/" ? prefix : prefix + route2.path, route2.handler, orElse2(map2(route2.prefix, (_) => prefix + _), () => some3(prefix)), route2.uninterruptible)), map6(self2.mounts, ([path, app]) => [path === "/" ? prefix : prefix + path, app]));
});
var mount = /* @__PURE__ */ dual(3, (self2, path, that) => concat4(self2, prefixAll(that, path)));
var mountApp = /* @__PURE__ */ dual((args2) => hasProperty(args2[0], TypeId45), (self2, path, that, options4) => new RouterImpl2(self2.routes, append2(self2.mounts, [removeTrailingSlash(path), that, options4])));
var route = /* @__PURE__ */ __name((method) => dual((args2) => isRouter(args2[0]), (self2, path, handler, options4) => new RouterImpl2(append2(self2.routes, new RouteImpl(method, path, handler, none2(), options4?.uninterruptible ?? false)), self2.mounts)), "route");
var all12 = /* @__PURE__ */ route("*");
var get22 = /* @__PURE__ */ route("GET");
var post4 = /* @__PURE__ */ route("POST");
var put3 = /* @__PURE__ */ route("PUT");
var patch11 = /* @__PURE__ */ route("PATCH");
var del3 = /* @__PURE__ */ route("DELETE");
var head11 = /* @__PURE__ */ route("HEAD");
var options3 = /* @__PURE__ */ route("OPTIONS");
var makeService = /* @__PURE__ */ __name(() => {
  let router = empty44;
  return {
    addRoute(route2) {
      return sync7(() => {
        router = append5(router, route2);
      });
    },
    all(path, handler, options4) {
      return sync7(() => {
        router = all12(router, path, handler, options4);
      });
    },
    get(path, handler, options4) {
      return sync7(() => {
        router = get22(router, path, handler, options4);
      });
    },
    post(path, handler, options4) {
      return sync7(() => {
        router = post4(router, path, handler, options4);
      });
    },
    put(path, handler, options4) {
      return sync7(() => {
        router = put3(router, path, handler, options4);
      });
    },
    patch(path, handler, options4) {
      return sync7(() => {
        router = patch11(router, path, handler, options4);
      });
    },
    del(path, handler, options4) {
      return sync7(() => {
        router = del3(router, path, handler, options4);
      });
    },
    head(path, handler, options4) {
      return sync7(() => {
        router = head11(router, path, handler, options4);
      });
    },
    options(path, handler, opts) {
      return sync7(() => {
        router = options3(router, path, handler, opts);
      });
    },
    router: sync7(() => router),
    mount(path, that) {
      return sync7(() => {
        router = mount(router, path, that);
      });
    },
    mountApp(path, app, options4) {
      return sync7(() => {
        router = mountApp(router, path, app, options4);
      });
    },
    concat(that) {
      return sync7(() => {
        router = concat4(router, that);
      });
    }
  };
}, "makeService");
var Tag4 = /* @__PURE__ */ __name((id4) => () => {
  const Err = globalThis.Error;
  const limit = Err.stackTraceLimit;
  Err.stackTraceLimit = 2;
  const creationError = new Err();
  Err.stackTraceLimit = limit;
  function TagClass() {
  }
  __name(TagClass, "TagClass");
  const TagClass_ = TagClass;
  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(GenericTag(id4)));
  TagClass.key = id4;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  TagClass_.Live = sync9(TagClass_, makeService);
  TagClass_.router = flatMap15(TagClass_, (_) => _.router);
  TagClass_.use = (f) => TagClass_.pipe(flatMap15(f), scopedDiscard2, provide3(TagClass_.Live));
  TagClass_.unwrap = (f) => TagClass_.pipe(flatMap15((_) => _.router), map22(f), unwrapEffect2, provide3(TagClass_.Live));
  TagClass_.serve = (middleware2) => TagClass_.unwrap(serve2(middleware2));
  return TagClass;
}, "Tag");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpRouter.js
var Tag5 = Tag4;
var Default = class extends (/* @__PURE__ */ Tag5("@effect/platform/HttpRouter/Default")()) {
  static {
    __name(this, "Default");
  }
};

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/HttpLayerRouter.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var HttpRouter = /* @__PURE__ */ GenericTag("@effect/platform/HttpLayerRouter");
var MiddlewareTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/HttpLayerRouter/Middleware");
var middleware = /* @__PURE__ */ __name(function() {
  if (arguments.length === 0) {
    return makeMiddleware;
  }
  return makeMiddleware(arguments[0], arguments[1]);
}, "middleware");
var makeMiddleware = /* @__PURE__ */ __name((middleware2, options4) => options4?.global ? scopedDiscard2(gen4(function* () {
  const router = yield* HttpRouter;
  const fn2 = isEffect2(middleware2) ? yield* middleware2 : middleware2;
  yield* router.addGlobalMiddleware(fn2);
})) : new MiddlewareImpl(isEffect2(middleware2) ? scopedContext2(map22(middleware2, (fn2) => unsafeMake(/* @__PURE__ */ new Map([[fnContextKey, fn2]])))) : succeedContext2(unsafeMake(/* @__PURE__ */ new Map([[fnContextKey, middleware2]])))), "makeMiddleware");
var middlewareId = 0;
var fnContextKey = "@effect/platform/HttpLayerRouter/MiddlewareFn";
var MiddlewareImpl = class _MiddlewareImpl {
  static {
    __name(this, "MiddlewareImpl");
  }
  layerFn;
  dependencies;
  [MiddlewareTypeId] = {};
  constructor(layerFn, dependencies) {
    this.layerFn = layerFn;
    this.dependencies = dependencies;
    const contextKey = `@effect/platform/HttpLayerRouter/Middleware-${++middlewareId}`;
    this.layer = scopedContext2(gen4(this, function* () {
      const context17 = yield* context4();
      const stack = [context17.unsafeMap.get(fnContextKey)];
      if (this.dependencies) {
        const memoMap = yield* CurrentMemoMap2;
        const scope5 = get6(context17, Scope);
        const depsContext = yield* buildWithMemoMap2(this.dependencies, memoMap, scope5);
        stack.push(...getMiddleware(depsContext));
      }
      return unsafeMake(/* @__PURE__ */ new Map([[contextKey, stack]]));
    })).pipe(provide3(this.layerFn));
  }
  layer;
  combine(other) {
    return new _MiddlewareImpl(this.layerFn, this.dependencies ? provideMerge2(this.dependencies, other.layer) : other.layer);
  }
};
var middlewareCache = /* @__PURE__ */ new WeakMap();
var getMiddleware = /* @__PURE__ */ __name((context17) => {
  let arr = middlewareCache.get(context17);
  if (arr) return arr;
  const topLevel = empty3();
  let maxLength2 = 0;
  for (const [key, value6] of context17.unsafeMap) {
    if (key.startsWith("@effect/platform/HttpLayerRouter/Middleware-")) {
      topLevel.push(value6);
      if (value6.length > maxLength2) {
        maxLength2 = value6.length;
      }
    }
  }
  if (topLevel.length === 0) {
    arr = [];
  } else {
    const middleware2 = /* @__PURE__ */ new Set();
    for (let i = maxLength2 - 1; i >= 0; i--) {
      for (const arr2 of topLevel) {
        if (i < arr2.length) {
          middleware2.add(arr2[i]);
        }
      }
    }
    arr = fromIterable2(middleware2).reverse();
  }
  middlewareCache.set(context17, arr);
  return arr;
}, "getMiddleware");
var disableLogger = middleware(withLoggerDisabled2).layer;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/MsgPack.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/msgpackr@1.11.8/node_modules/msgpackr/index.js
var msgpackr_exports = {};
__export(msgpackr_exports, {
  ALWAYS: () => ALWAYS,
  C1: () => C1,
  DECIMAL_FIT: () => DECIMAL_FIT,
  DECIMAL_ROUND: () => DECIMAL_ROUND,
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  FLOAT32_OPTIONS: () => FLOAT32_OPTIONS,
  NEVER: () => NEVER,
  Packr: () => Packr,
  RESERVE_START_SPACE: () => RESERVE_START_SPACE,
  RESET_BUFFER_MODE: () => RESET_BUFFER_MODE,
  REUSE_BUFFER_MODE: () => REUSE_BUFFER_MODE,
  Unpackr: () => Unpackr,
  addExtension: () => addExtension2,
  clearSource: () => clearSource,
  decode: () => decode7,
  decodeIter: () => decodeIter,
  encode: () => encode6,
  encodeIter: () => encodeIter,
  isNativeAccelerationEnabled: () => isNativeAccelerationEnabled,
  mapsAsObjects: () => mapsAsObjects,
  pack: () => pack2,
  roundFloat32: () => roundFloat32,
  unpack: () => unpack,
  unpackMultiple: () => unpackMultiple,
  useRecords: () => useRecords
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/msgpackr@1.11.8/node_modules/msgpackr/pack.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/msgpackr@1.11.8/node_modules/msgpackr/unpack.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var decoder2;
try {
  decoder2 = new TextDecoder();
} catch (error5) {
}
var src;
var srcEnd;
var position = 0;
var EMPTY_ARRAY = [];
var strings = EMPTY_ARRAY;
var stringPosition = 0;
var currentUnpackr = {};
var currentStructures;
var srcString;
var srcStringStart = 0;
var srcStringEnd = 0;
var bundledStrings;
var referenceMap;
var currentExtensions = [];
var dataView;
var defaultOptions = {
  useRecords: false,
  mapsAsObjects: true
};
var C1Type = class {
  static {
    __name(this, "C1Type");
  }
};
var C1 = new C1Type();
C1.name = "MessagePack 0xC1";
var sequentialMode = false;
var inlineObjectReadThreshold = 2;
var readStruct;
var onLoadedStructures;
var onSaveState;
try {
  new Function("");
} catch (error5) {
  inlineObjectReadThreshold = Infinity;
}
var Unpackr = class _Unpackr {
  static {
    __name(this, "Unpackr");
  }
  constructor(options4) {
    if (options4) {
      if (options4.useRecords === false && options4.mapsAsObjects === void 0)
        options4.mapsAsObjects = true;
      if (options4.sequential && options4.trusted !== false) {
        options4.trusted = true;
        if (!options4.structures && options4.useRecords != false) {
          options4.structures = [];
          if (!options4.maxSharedStructures)
            options4.maxSharedStructures = 0;
        }
      }
      if (options4.structures)
        options4.structures.sharedLength = options4.structures.length;
      else if (options4.getStructures) {
        (options4.structures = []).uninitialized = true;
        options4.structures.sharedLength = 0;
      }
      if (options4.int64AsNumber) {
        options4.int64AsType = "number";
      }
    }
    Object.assign(this, options4);
  }
  unpack(source, options4) {
    if (src) {
      return saveState(() => {
        clearSource();
        return this ? this.unpack(source, options4) : _Unpackr.prototype.unpack.call(defaultOptions, source, options4);
      });
    }
    if (!source.buffer && source.constructor === ArrayBuffer)
      source = typeof Buffer !== "undefined" ? Buffer.from(source) : new Uint8Array(source);
    if (typeof options4 === "object") {
      srcEnd = options4.end || source.length;
      position = options4.start || 0;
    } else {
      position = 0;
      srcEnd = options4 > -1 ? options4 : source.length;
    }
    stringPosition = 0;
    srcStringEnd = 0;
    srcString = null;
    strings = EMPTY_ARRAY;
    bundledStrings = null;
    src = source;
    try {
      dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error5) {
      src = null;
      if (source instanceof Uint8Array)
        throw error5;
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof _Unpackr) {
      currentUnpackr = this;
      if (this.structures) {
        currentStructures = this.structures;
        return checkedRead(options4);
      } else if (!currentStructures || currentStructures.length > 0) {
        currentStructures = [];
      }
    } else {
      currentUnpackr = defaultOptions;
      if (!currentStructures || currentStructures.length > 0)
        currentStructures = [];
    }
    return checkedRead(options4);
  }
  unpackMultiple(source, forEach16) {
    let values6, lastPosition = 0;
    try {
      sequentialMode = true;
      let size22 = source.length;
      let value6 = this ? this.unpack(source, size22) : defaultUnpackr.unpack(source, size22);
      if (forEach16) {
        if (forEach16(value6, lastPosition, position) === false) return;
        while (position < size22) {
          lastPosition = position;
          if (forEach16(checkedRead(), lastPosition, position) === false) {
            return;
          }
        }
      } else {
        values6 = [value6];
        while (position < size22) {
          lastPosition = position;
          values6.push(checkedRead());
        }
        return values6;
      }
    } catch (error5) {
      error5.lastPosition = lastPosition;
      error5.values = values6;
      throw error5;
    } finally {
      sequentialMode = false;
      clearSource();
    }
  }
  _mergeStructures(loadedStructures, existingStructures) {
    if (onLoadedStructures)
      loadedStructures = onLoadedStructures.call(this, loadedStructures);
    loadedStructures = loadedStructures || [];
    if (Object.isFrozen(loadedStructures))
      loadedStructures = loadedStructures.map((structure2) => structure2.slice(0));
    for (let i = 0, l = loadedStructures.length; i < l; i++) {
      let structure2 = loadedStructures[i];
      if (structure2) {
        structure2.isShared = true;
        if (i >= 32)
          structure2.highByte = i - 32 >> 5;
      }
    }
    loadedStructures.sharedLength = loadedStructures.length;
    for (let id4 in existingStructures || []) {
      if (id4 >= 0) {
        let structure2 = loadedStructures[id4];
        let existing = existingStructures[id4];
        if (existing) {
          if (structure2)
            (loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id4] = structure2;
          loadedStructures[id4] = existing;
        }
      }
    }
    return this.structures = loadedStructures;
  }
  decode(source, options4) {
    return this.unpack(source, options4);
  }
};
function checkedRead(options4) {
  try {
    if (!currentUnpackr.trusted && !sequentialMode) {
      let sharedLength = currentStructures.sharedLength || 0;
      if (sharedLength < currentStructures.length)
        currentStructures.length = sharedLength;
    }
    let result;
    if (currentUnpackr.randomAccessStructure && src[position] < 64 && src[position] >= 32 && readStruct) {
      result = readStruct(src, position, srcEnd, currentUnpackr);
      src = null;
      if (!(options4 && options4.lazy) && result)
        result = result.toJSON();
      position = srcEnd;
    } else
      result = read2();
    if (bundledStrings) {
      position = bundledStrings.postBundlePosition;
      bundledStrings = null;
    }
    if (sequentialMode)
      currentStructures.restoreStructures = null;
    if (position == srcEnd) {
      if (currentStructures && currentStructures.restoreStructures)
        restoreStructures();
      currentStructures = null;
      src = null;
      if (referenceMap)
        referenceMap = null;
    } else if (position > srcEnd) {
      throw new Error("Unexpected end of MessagePack data");
    } else if (!sequentialMode) {
      let jsonView;
      try {
        jsonView = JSON.stringify(result, (_, value6) => typeof value6 === "bigint" ? `${value6}n` : value6).slice(0, 100);
      } catch (error5) {
        jsonView = "(JSON view not available " + error5 + ")";
      }
      throw new Error("Data read, but end of buffer not reached " + jsonView);
    }
    return result;
  } catch (error5) {
    if (currentStructures && currentStructures.restoreStructures)
      restoreStructures();
    clearSource();
    if (error5 instanceof RangeError || error5.message.startsWith("Unexpected end of buffer") || position > srcEnd) {
      error5.incomplete = true;
    }
    throw error5;
  }
}
__name(checkedRead, "checkedRead");
function restoreStructures() {
  for (let id4 in currentStructures.restoreStructures) {
    currentStructures[id4] = currentStructures.restoreStructures[id4];
  }
  currentStructures.restoreStructures = null;
}
__name(restoreStructures, "restoreStructures");
function read2() {
  let token = src[position++];
  if (token < 160) {
    if (token < 128) {
      if (token < 64)
        return token;
      else {
        let structure2 = currentStructures[token & 63] || currentUnpackr.getStructures && loadStructures()[token & 63];
        if (structure2) {
          if (!structure2.read) {
            structure2.read = createStructureReader(structure2, token & 63);
          }
          return structure2.read();
        } else
          return token;
      }
    } else if (token < 144) {
      token -= 128;
      if (currentUnpackr.mapsAsObjects) {
        let object2 = {};
        for (let i = 0; i < token; i++) {
          let key = readKey();
          if (key === "__proto__")
            key = "__proto_";
          object2[key] = read2();
        }
        return object2;
      } else {
        let map38 = /* @__PURE__ */ new Map();
        for (let i = 0; i < token; i++) {
          map38.set(read2(), read2());
        }
        return map38;
      }
    } else {
      token -= 144;
      let array7 = new Array(token);
      for (let i = 0; i < token; i++) {
        array7[i] = read2();
      }
      if (currentUnpackr.freezeData)
        return Object.freeze(array7);
      return array7;
    }
  } else if (token < 192) {
    let length5 = token - 160;
    if (srcStringEnd >= position) {
      return srcString.slice(position - srcStringStart, (position += length5) - srcStringStart);
    }
    if (srcStringEnd == 0 && srcEnd < 140) {
      let string7 = length5 < 16 ? shortStringInJS(length5) : longStringInJS(length5);
      if (string7 != null)
        return string7;
    }
    return readFixedString(length5);
  } else {
    let value6;
    switch (token) {
      case 192:
        return null;
      case 193:
        if (bundledStrings) {
          value6 = read2();
          if (value6 > 0)
            return bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value6);
          else
            return bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value6);
        }
        return C1;
      // "never-used", return special object to denote that
      case 194:
        return false;
      case 195:
        return true;
      case 196:
        value6 = src[position++];
        if (value6 === void 0)
          throw new Error("Unexpected end of buffer");
        return readBin(value6);
      case 197:
        value6 = dataView.getUint16(position);
        position += 2;
        return readBin(value6);
      case 198:
        value6 = dataView.getUint32(position);
        position += 4;
        return readBin(value6);
      case 199:
        return readExt(src[position++]);
      case 200:
        value6 = dataView.getUint16(position);
        position += 2;
        return readExt(value6);
      case 201:
        value6 = dataView.getUint32(position);
        position += 4;
        return readExt(value6);
      case 202:
        value6 = dataView.getFloat32(position);
        if (currentUnpackr.useFloat32 > 2) {
          let multiplier = mult10[(src[position] & 127) << 1 | src[position + 1] >> 7];
          position += 4;
          return (multiplier * value6 + (value6 > 0 ? 0.5 : -0.5) >> 0) / multiplier;
        }
        position += 4;
        return value6;
      case 203:
        value6 = dataView.getFloat64(position);
        position += 8;
        return value6;
      // uint handlers
      case 204:
        return src[position++];
      case 205:
        value6 = dataView.getUint16(position);
        position += 2;
        return value6;
      case 206:
        value6 = dataView.getUint32(position);
        position += 4;
        return value6;
      case 207:
        if (currentUnpackr.int64AsType === "number") {
          value6 = dataView.getUint32(position) * 4294967296;
          value6 += dataView.getUint32(position + 4);
        } else if (currentUnpackr.int64AsType === "string") {
          value6 = dataView.getBigUint64(position).toString();
        } else if (currentUnpackr.int64AsType === "auto") {
          value6 = dataView.getBigUint64(position);
          if (value6 <= BigInt(2) << BigInt(52)) value6 = Number(value6);
        } else
          value6 = dataView.getBigUint64(position);
        position += 8;
        return value6;
      // int handlers
      case 208:
        return dataView.getInt8(position++);
      case 209:
        value6 = dataView.getInt16(position);
        position += 2;
        return value6;
      case 210:
        value6 = dataView.getInt32(position);
        position += 4;
        return value6;
      case 211:
        if (currentUnpackr.int64AsType === "number") {
          value6 = dataView.getInt32(position) * 4294967296;
          value6 += dataView.getUint32(position + 4);
        } else if (currentUnpackr.int64AsType === "string") {
          value6 = dataView.getBigInt64(position).toString();
        } else if (currentUnpackr.int64AsType === "auto") {
          value6 = dataView.getBigInt64(position);
          if (value6 >= BigInt(-2) << BigInt(52) && value6 <= BigInt(2) << BigInt(52)) value6 = Number(value6);
        } else
          value6 = dataView.getBigInt64(position);
        position += 8;
        return value6;
      case 212:
        value6 = src[position++];
        if (value6 == 114) {
          return recordDefinition(src[position++] & 63);
        } else {
          let extension = currentExtensions[value6];
          if (extension) {
            if (extension.read) {
              position++;
              return extension.read(read2());
            } else if (extension.noBuffer) {
              position++;
              return extension();
            } else
              return extension(src.subarray(position, ++position));
          } else
            throw new Error("Unknown extension " + value6);
        }
      case 213:
        value6 = src[position];
        if (value6 == 114) {
          position++;
          return recordDefinition(src[position++] & 63, src[position++]);
        } else
          return readExt(2);
      case 214:
        return readExt(4);
      case 215:
        return readExt(8);
      case 216:
        return readExt(16);
      case 217:
        value6 = src[position++];
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value6) - srcStringStart);
        }
        return readString8(value6);
      case 218:
        value6 = dataView.getUint16(position);
        position += 2;
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value6) - srcStringStart);
        }
        return readString16(value6);
      case 219:
        value6 = dataView.getUint32(position);
        position += 4;
        if (srcStringEnd >= position) {
          return srcString.slice(position - srcStringStart, (position += value6) - srcStringStart);
        }
        return readString32(value6);
      case 220:
        value6 = dataView.getUint16(position);
        position += 2;
        return readArray(value6);
      case 221:
        value6 = dataView.getUint32(position);
        position += 4;
        return readArray(value6);
      case 222:
        value6 = dataView.getUint16(position);
        position += 2;
        return readMap(value6);
      case 223:
        value6 = dataView.getUint32(position);
        position += 4;
        return readMap(value6);
      default:
        if (token >= 224)
          return token - 256;
        if (token === void 0) {
          let error5 = new Error("Unexpected end of MessagePack data");
          error5.incomplete = true;
          throw error5;
        }
        throw new Error("Unknown MessagePack token " + token);
    }
  }
}
__name(read2, "read");
var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader(structure2, firstId) {
  function readObject() {
    if (readObject.count++ > inlineObjectReadThreshold) {
      let readObject2 = structure2.read = new Function("r", "return function(){return " + (currentUnpackr.freezeData ? "Object.freeze" : "") + "({" + structure2.map((key) => key === "__proto__" ? "__proto_:r()" : validName.test(key) ? key + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "})}")(read2);
      if (structure2.highByte === 0)
        structure2.read = createSecondByteReader(firstId, structure2.read);
      return readObject2();
    }
    let object2 = {};
    for (let i = 0, l = structure2.length; i < l; i++) {
      let key = structure2[i];
      if (key === "__proto__")
        key = "__proto_";
      object2[key] = read2();
    }
    if (currentUnpackr.freezeData)
      return Object.freeze(object2);
    return object2;
  }
  __name(readObject, "readObject");
  readObject.count = 0;
  if (structure2.highByte === 0) {
    return createSecondByteReader(firstId, readObject);
  }
  return readObject;
}
__name(createStructureReader, "createStructureReader");
var createSecondByteReader = /* @__PURE__ */ __name((firstId, read0) => {
  return function() {
    let highByte = src[position++];
    if (highByte === 0)
      return read0();
    let id4 = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);
    let structure2 = currentStructures[id4] || loadStructures()[id4];
    if (!structure2) {
      throw new Error("Record id is not defined for " + id4);
    }
    if (!structure2.read)
      structure2.read = createStructureReader(structure2, firstId);
    return structure2.read();
  };
}, "createSecondByteReader");
function loadStructures() {
  let loadedStructures = saveState(() => {
    src = null;
    return currentUnpackr.getStructures();
  });
  return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures);
}
__name(loadStructures, "loadStructures");
var readFixedString = readStringJS;
var readString8 = readStringJS;
var readString16 = readStringJS;
var readString32 = readStringJS;
var isNativeAccelerationEnabled = false;
function readStringJS(length5) {
  let result;
  if (length5 < 16) {
    if (result = shortStringInJS(length5))
      return result;
  }
  if (length5 > 64 && decoder2)
    return decoder2.decode(src.subarray(position, position += length5));
  const end6 = position + length5;
  const units = [];
  result = "";
  while (position < end6) {
    const byte1 = src[position++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src[position++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src[position++] & 63;
      const byte3 = src[position++] & 63;
      const byte4 = src[position++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode.apply(String, units);
  }
  return result;
}
__name(readStringJS, "readStringJS");
function readArray(length5) {
  let array7 = new Array(length5);
  for (let i = 0; i < length5; i++) {
    array7[i] = read2();
  }
  if (currentUnpackr.freezeData)
    return Object.freeze(array7);
  return array7;
}
__name(readArray, "readArray");
function readMap(length5) {
  if (currentUnpackr.mapsAsObjects) {
    let object2 = {};
    for (let i = 0; i < length5; i++) {
      let key = readKey();
      if (key === "__proto__")
        key = "__proto_";
      object2[key] = read2();
    }
    return object2;
  } else {
    let map38 = /* @__PURE__ */ new Map();
    for (let i = 0; i < length5; i++) {
      map38.set(read2(), read2());
    }
    return map38;
  }
}
__name(readMap, "readMap");
var fromCharCode = String.fromCharCode;
function longStringInJS(length5) {
  let start3 = position;
  let bytes = new Array(length5);
  for (let i = 0; i < length5; i++) {
    const byte = src[position++];
    if ((byte & 128) > 0) {
      position = start3;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode.apply(String, bytes);
}
__name(longStringInJS, "longStringInJS");
function shortStringInJS(length5) {
  if (length5 < 4) {
    if (length5 < 2) {
      if (length5 === 0)
        return "";
      else {
        let a = src[position++];
        if ((a & 128) > 1) {
          position -= 1;
          return;
        }
        return fromCharCode(a);
      }
    } else {
      let a = src[position++];
      let b = src[position++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position -= 2;
        return;
      }
      if (length5 < 3)
        return fromCharCode(a, b);
      let c = src[position++];
      if ((c & 128) > 0) {
        position -= 3;
        return;
      }
      return fromCharCode(a, b, c);
    }
  } else {
    let a = src[position++];
    let b = src[position++];
    let c = src[position++];
    let d = src[position++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position -= 4;
      return;
    }
    if (length5 < 6) {
      if (length5 === 4)
        return fromCharCode(a, b, c, d);
      else {
        let e = src[position++];
        if ((e & 128) > 0) {
          position -= 5;
          return;
        }
        return fromCharCode(a, b, c, d, e);
      }
    } else if (length5 < 8) {
      let e = src[position++];
      let f = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0) {
        position -= 6;
        return;
      }
      if (length5 < 7)
        return fromCharCode(a, b, c, d, e, f);
      let g = src[position++];
      if ((g & 128) > 0) {
        position -= 7;
        return;
      }
      return fromCharCode(a, b, c, d, e, f, g);
    } else {
      let e = src[position++];
      let f = src[position++];
      let g = src[position++];
      let h = src[position++];
      if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position -= 8;
        return;
      }
      if (length5 < 10) {
        if (length5 === 8)
          return fromCharCode(a, b, c, d, e, f, g, h);
        else {
          let i = src[position++];
          if ((i & 128) > 0) {
            position -= 9;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i);
        }
      } else if (length5 < 12) {
        let i = src[position++];
        let j = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position -= 10;
          return;
        }
        if (length5 < 11)
          return fromCharCode(a, b, c, d, e, f, g, h, i, j);
        let k = src[position++];
        if ((k & 128) > 0) {
          position -= 11;
          return;
        }
        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src[position++];
        let j = src[position++];
        let k = src[position++];
        let l = src[position++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position -= 12;
          return;
        }
        if (length5 < 14) {
          if (length5 === 12)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);
          else {
            let m = src[position++];
            if ((m & 128) > 0) {
              position -= 13;
              return;
            }
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src[position++];
          let n = src[position++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position -= 14;
            return;
          }
          if (length5 < 15)
            return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          let o = src[position++];
          if ((o & 128) > 0) {
            position -= 15;
            return;
          }
          return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
__name(shortStringInJS, "shortStringInJS");
function readOnlyJSString() {
  let token = src[position++];
  let length5;
  if (token < 192) {
    length5 = token - 160;
  } else {
    switch (token) {
      case 217:
        length5 = src[position++];
        break;
      case 218:
        length5 = dataView.getUint16(position);
        position += 2;
        break;
      case 219:
        length5 = dataView.getUint32(position);
        position += 4;
        break;
      default:
        throw new Error("Expected string");
    }
  }
  return readStringJS(length5);
}
__name(readOnlyJSString, "readOnlyJSString");
function readBin(length5) {
  return currentUnpackr.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src, position, position += length5)
  ) : src.subarray(position, position += length5);
}
__name(readBin, "readBin");
function readExt(length5) {
  let type3 = src[position++];
  if (currentExtensions[type3]) {
    let end6;
    return currentExtensions[type3](src.subarray(position, end6 = position += length5), (readPosition) => {
      position = readPosition;
      try {
        return read2();
      } finally {
        position = end6;
      }
    });
  } else
    throw new Error("Unknown extension type " + type3);
}
__name(readExt, "readExt");
var keyCache = new Array(4096);
function readKey() {
  let length5 = src[position++];
  if (length5 >= 160 && length5 < 192) {
    length5 = length5 - 160;
    if (srcStringEnd >= position)
      return srcString.slice(position - srcStringStart, (position += length5) - srcStringStart);
    else if (!(srcStringEnd == 0 && srcEnd < 180))
      return readFixedString(length5);
  } else {
    position--;
    return asSafeString(read2());
  }
  let key = (length5 << 5 ^ (length5 > 1 ? dataView.getUint16(position) : length5 > 0 ? src[position] : 0)) & 4095;
  let entry = keyCache[key];
  let checkPosition = position;
  let end6 = position + length5 - 3;
  let chunk4;
  let i = 0;
  if (entry && entry.bytes == length5) {
    while (checkPosition < end6) {
      chunk4 = dataView.getUint32(checkPosition);
      if (chunk4 != entry[i++]) {
        checkPosition = 1879048192;
        break;
      }
      checkPosition += 4;
    }
    end6 += 3;
    while (checkPosition < end6) {
      chunk4 = src[checkPosition++];
      if (chunk4 != entry[i++]) {
        checkPosition = 1879048192;
        break;
      }
    }
    if (checkPosition === end6) {
      position = checkPosition;
      return entry.string;
    }
    end6 -= 3;
    checkPosition = position;
  }
  entry = [];
  keyCache[key] = entry;
  entry.bytes = length5;
  while (checkPosition < end6) {
    chunk4 = dataView.getUint32(checkPosition);
    entry.push(chunk4);
    checkPosition += 4;
  }
  end6 += 3;
  while (checkPosition < end6) {
    chunk4 = src[checkPosition++];
    entry.push(chunk4);
  }
  let string7 = length5 < 16 ? shortStringInJS(length5) : longStringInJS(length5);
  if (string7 != null)
    return entry.string = string7;
  return entry.string = readFixedString(length5);
}
__name(readKey, "readKey");
function asSafeString(property2) {
  if (typeof property2 === "string") return property2;
  if (typeof property2 === "number" || typeof property2 === "boolean" || typeof property2 === "bigint") return property2.toString();
  if (property2 == null) return property2 + "";
  if (currentUnpackr.allowArraysInMapKeys && Array.isArray(property2) && property2.flat().every((item) => ["string", "number", "boolean", "bigint"].includes(typeof item))) {
    return property2.flat().toString();
  }
  throw new Error(`Invalid property type for record: ${typeof property2}`);
}
__name(asSafeString, "asSafeString");
var recordDefinition = /* @__PURE__ */ __name((id4, highByte) => {
  let structure2 = read2().map(asSafeString);
  let firstByte = id4;
  if (highByte !== void 0) {
    id4 = id4 < 32 ? -((highByte << 5) + id4) : (highByte << 5) + id4;
    structure2.highByte = highByte;
  }
  let existingStructure = currentStructures[id4];
  if (existingStructure && (existingStructure.isShared || sequentialMode)) {
    (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id4] = existingStructure;
  }
  currentStructures[id4] = structure2;
  structure2.read = createStructureReader(structure2, firstByte);
  return structure2.read();
}, "recordDefinition");
currentExtensions[0] = () => {
};
currentExtensions[0].noBuffer = true;
currentExtensions[66] = (data) => {
  let headLength = data.byteLength % 8 || 8;
  let head13 = BigInt(data[0] & 128 ? data[0] - 256 : data[0]);
  for (let i = 1; i < headLength; i++) {
    head13 <<= BigInt(8);
    head13 += BigInt(data[i]);
  }
  if (data.byteLength !== headLength) {
    let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    let decode9 = /* @__PURE__ */ __name((start3, end6) => {
      let length5 = end6 - start3;
      if (length5 <= 40) {
        let out = view.getBigUint64(start3);
        for (let i = start3 + 8; i < end6; i += 8) {
          out <<= BigInt(64n);
          out |= view.getBigUint64(i);
        }
        return out;
      }
      let middle = start3 + (length5 >> 4 << 3);
      let left3 = decode9(start3, middle);
      let right3 = decode9(middle, end6);
      return left3 << BigInt((end6 - middle) * 8) | right3;
    }, "decode");
    head13 = head13 << BigInt((view.byteLength - headLength) * 8) | decode9(headLength, view.byteLength);
  }
  return head13;
};
var errors2 = {
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError,
  AggregateError: typeof AggregateError === "function" ? AggregateError : null
};
currentExtensions[101] = () => {
  let data = read2();
  if (!errors2[data[0]]) {
    let error5 = Error(data[1], { cause: data[2] });
    error5.name = data[0];
    return error5;
  }
  return errors2[data[0]](data[1], { cause: data[2] });
};
currentExtensions[105] = (data) => {
  if (currentUnpackr.structuredClone === false) throw new Error("Structured clone extension is disabled");
  let id4 = dataView.getUint32(position - 4);
  if (!referenceMap)
    referenceMap = /* @__PURE__ */ new Map();
  let token = src[position];
  let target3;
  if (token >= 144 && token < 160 || token == 220 || token == 221)
    target3 = [];
  else if (token >= 128 && token < 144 || token == 222 || token == 223)
    target3 = /* @__PURE__ */ new Map();
  else if ((token >= 199 && token <= 201 || token >= 212 && token <= 216) && src[position + 1] === 115)
    target3 = /* @__PURE__ */ new Set();
  else
    target3 = {};
  let refEntry = { target: target3 };
  referenceMap.set(id4, refEntry);
  let targetProperties = read2();
  if (!refEntry.used) {
    return refEntry.target = targetProperties;
  } else {
    Object.assign(target3, targetProperties);
  }
  if (target3 instanceof Map)
    for (let [k, v] of targetProperties.entries()) target3.set(k, v);
  if (target3 instanceof Set)
    for (let i of Array.from(targetProperties)) target3.add(i);
  return target3;
};
currentExtensions[112] = (data) => {
  if (currentUnpackr.structuredClone === false) throw new Error("Structured clone extension is disabled");
  let id4 = dataView.getUint32(position - 4);
  let refEntry = referenceMap.get(id4);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions[115] = () => new Set(read2());
var typedArrays = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map((type3) => type3 + "Array");
var glbl = typeof globalThis === "object" ? globalThis : window;
currentExtensions[116] = (data) => {
  let typeCode = data[0];
  let buffer4 = Uint8Array.prototype.slice.call(data, 1).buffer;
  let typedArrayName = typedArrays[typeCode];
  if (!typedArrayName) {
    if (typeCode === 16) return buffer4;
    if (typeCode === 17) return new DataView(buffer4);
    throw new Error("Could not find typed array for code " + typeCode);
  }
  return new glbl[typedArrayName](buffer4);
};
currentExtensions[120] = () => {
  let data = read2();
  return new RegExp(data[0], data[1]);
};
var TEMP_BUNDLE = [];
currentExtensions[98] = (data) => {
  let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
  let dataPosition = position;
  position += dataSize - data.length;
  bundledStrings = TEMP_BUNDLE;
  bundledStrings = [readOnlyJSString(), readOnlyJSString()];
  bundledStrings.position0 = 0;
  bundledStrings.position1 = 0;
  bundledStrings.postBundlePosition = position;
  position = dataPosition;
  return read2();
};
currentExtensions[255] = (data) => {
  if (data.length == 4)
    return new Date((data[0] * 16777216 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1e3);
  else if (data.length == 8)
    return new Date(
      ((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1e6 + ((data[3] & 3) * 4294967296 + data[4] * 16777216 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1e3
    );
  else if (data.length == 12)
    return new Date(
      ((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1e6 + ((data[4] & 128 ? -281474976710656 : 0) + data[6] * 1099511627776 + data[7] * 4294967296 + data[8] * 16777216 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1e3
    );
  else
    return /* @__PURE__ */ new Date("invalid");
};
function saveState(callback) {
  if (onSaveState)
    onSaveState();
  let savedSrcEnd = srcEnd;
  let savedPosition = position;
  let savedStringPosition = stringPosition;
  let savedSrcStringStart = srcStringStart;
  let savedSrcStringEnd = srcStringEnd;
  let savedSrcString = srcString;
  let savedStrings = strings;
  let savedReferenceMap = referenceMap;
  let savedBundledStrings = bundledStrings;
  let savedSrc = new Uint8Array(src.slice(0, srcEnd));
  let savedStructures = currentStructures;
  let savedStructuresContents = currentStructures.slice(0, currentStructures.length);
  let savedPackr = currentUnpackr;
  let savedSequentialMode = sequentialMode;
  let value6 = callback();
  srcEnd = savedSrcEnd;
  position = savedPosition;
  stringPosition = savedStringPosition;
  srcStringStart = savedSrcStringStart;
  srcStringEnd = savedSrcStringEnd;
  srcString = savedSrcString;
  strings = savedStrings;
  referenceMap = savedReferenceMap;
  bundledStrings = savedBundledStrings;
  src = savedSrc;
  sequentialMode = savedSequentialMode;
  currentStructures = savedStructures;
  currentStructures.splice(0, currentStructures.length, ...savedStructuresContents);
  currentUnpackr = savedPackr;
  dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
  return value6;
}
__name(saveState, "saveState");
function clearSource() {
  src = null;
  referenceMap = null;
  currentStructures = null;
}
__name(clearSource, "clearSource");
function addExtension(extension) {
  if (extension.unpack)
    currentExtensions[extension.type] = extension.unpack;
  else
    currentExtensions[extension.type] = extension;
}
__name(addExtension, "addExtension");
var mult10 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
}
var Decoder = Unpackr;
var defaultUnpackr = new Unpackr({ useRecords: false });
var unpack = defaultUnpackr.unpack;
var unpackMultiple = defaultUnpackr.unpackMultiple;
var decode7 = defaultUnpackr.unpack;
var FLOAT32_OPTIONS = {
  NEVER: 0,
  ALWAYS: 1,
  DECIMAL_ROUND: 3,
  DECIMAL_FIT: 4
};
var f32Array = new Float32Array(1);
var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
function roundFloat32(float32Number) {
  f32Array[0] = float32Number;
  let multiplier = mult10[(u8Array[3] & 127) << 1 | u8Array[2] >> 7];
  return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;
}
__name(roundFloat32, "roundFloat32");

// node_modules/.pnpm/msgpackr@1.11.8/node_modules/msgpackr/pack.js
var textEncoder;
try {
  textEncoder = new TextEncoder();
} catch (error5) {
}
var extensions;
var extensionClasses;
var hasNodeBuffer = typeof Buffer !== "undefined";
var ByteArrayAllocate = hasNodeBuffer ? function(length5) {
  return Buffer.allocUnsafeSlow(length5);
} : Uint8Array;
var ByteArray = hasNodeBuffer ? Buffer : Uint8Array;
var MAX_BUFFER_SIZE = hasNodeBuffer ? 4294967296 : 2144337920;
var target;
var keysTarget;
var targetView;
var position2 = 0;
var safeEnd;
var bundledStrings2 = null;
var writeStructSlots;
var MAX_BUNDLE_SIZE = 21760;
var hasNonLatin = /[\u0080-\uFFFF]/;
var RECORD_SYMBOL = Symbol("record-id");
var Packr = class extends Unpackr {
  static {
    __name(this, "Packr");
  }
  constructor(options4) {
    super(options4);
    this.offset = 0;
    let typeBuffer;
    let start3;
    let hasSharedUpdate;
    let structures;
    let referenceMap3;
    let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string7, position5) {
      return target.utf8Write(string7, position5, target.byteLength - position5);
    } : textEncoder && textEncoder.encodeInto ? function(string7, position5) {
      return textEncoder.encodeInto(string7, target.subarray(position5)).written;
    } : false;
    let packr = this;
    if (!options4)
      options4 = {};
    let isSequential2 = options4 && options4.sequential;
    let hasSharedStructures = options4.structures || options4.saveStructures;
    let maxSharedStructures = options4.maxSharedStructures;
    if (maxSharedStructures == null)
      maxSharedStructures = hasSharedStructures ? 32 : 0;
    if (maxSharedStructures > 8160)
      throw new Error("Maximum maxSharedStructure is 8160");
    if (options4.structuredClone && options4.moreTypes == void 0) {
      this.moreTypes = true;
    }
    let maxOwnStructures = options4.maxOwnStructures;
    if (maxOwnStructures == null)
      maxOwnStructures = hasSharedStructures ? 32 : 64;
    if (!this.structures && options4.useRecords != false)
      this.structures = [];
    let useTwoByteRecords = maxSharedStructures > 32 || maxOwnStructures + maxSharedStructures > 64;
    let sharedLimitId = maxSharedStructures + 64;
    let maxStructureId = maxSharedStructures + maxOwnStructures + 64;
    if (maxStructureId > 8256) {
      throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
    }
    let recordIdsToRemove = [];
    let transitionsCount = 0;
    let serializationsSinceTransitionRebuild = 0;
    this.pack = this.encode = function(value6, encodeOptions) {
      if (!target) {
        target = new ByteArrayAllocate(8192);
        targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));
        position2 = 0;
      }
      safeEnd = target.length - 10;
      if (safeEnd - position2 < 2048) {
        target = new ByteArrayAllocate(target.length);
        targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));
        safeEnd = target.length - 10;
        position2 = 0;
      } else
        position2 = position2 + 7 & 2147483640;
      start3 = position2;
      if (encodeOptions & RESERVE_START_SPACE) position2 += encodeOptions & 255;
      referenceMap3 = packr.structuredClone ? /* @__PURE__ */ new Map() : null;
      if (packr.bundleStrings && typeof value6 !== "string") {
        bundledStrings2 = [];
        bundledStrings2.size = Infinity;
      } else
        bundledStrings2 = null;
      structures = packr.structures;
      if (structures) {
        if (structures.uninitialized)
          structures = packr._mergeStructures(packr.getStructures());
        let sharedLength = structures.sharedLength || 0;
        if (sharedLength > maxSharedStructures) {
          throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + structures.sharedLength);
        }
        if (!structures.transitions) {
          structures.transitions = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < sharedLength; i++) {
            let keys6 = structures[i];
            if (!keys6)
              continue;
            let nextTransition, transition = structures.transitions;
            for (let j = 0, l = keys6.length; j < l; j++) {
              let key = keys6[j];
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              }
              transition = nextTransition;
            }
            transition[RECORD_SYMBOL] = i + 64;
          }
          this.lastNamedStructuresLength = sharedLength;
        }
        if (!isSequential2) {
          structures.nextId = sharedLength + 64;
        }
      }
      if (hasSharedUpdate)
        hasSharedUpdate = false;
      let encodingError;
      try {
        if (packr.randomAccessStructure && value6 && typeof value6 === "object") {
          if (value6.constructor === Object) writeStruct(value6);
          else if (value6.constructor !== Map && !Array.isArray(value6) && !extensionClasses.some((extClass) => value6 instanceof extClass)) {
            writeStruct(value6.toJSON ? value6.toJSON() : value6);
          } else pack4(value6);
        } else
          pack4(value6);
        let lastBundle = bundledStrings2;
        if (bundledStrings2)
          writeBundles(start3, pack4, 0);
        if (referenceMap3 && referenceMap3.idsToInsert) {
          let idsToInsert = referenceMap3.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
          let i = idsToInsert.length;
          let incrementPosition = -1;
          while (lastBundle && i > 0) {
            let insertionPoint = idsToInsert[--i].offset + start3;
            if (insertionPoint < lastBundle.stringsPosition + start3 && incrementPosition === -1)
              incrementPosition = 0;
            if (insertionPoint > lastBundle.position + start3) {
              if (incrementPosition >= 0)
                incrementPosition += 6;
            } else {
              if (incrementPosition >= 0) {
                targetView.setUint32(
                  lastBundle.position + start3,
                  targetView.getUint32(lastBundle.position + start3) + incrementPosition
                );
                incrementPosition = -1;
              }
              lastBundle = lastBundle.previous;
              i++;
            }
          }
          if (incrementPosition >= 0 && lastBundle) {
            targetView.setUint32(
              lastBundle.position + start3,
              targetView.getUint32(lastBundle.position + start3) + incrementPosition
            );
          }
          position2 += idsToInsert.length * 6;
          if (position2 > safeEnd)
            makeRoom(position2);
          packr.offset = position2;
          let serialized = insertIds(target.subarray(start3, position2), idsToInsert);
          referenceMap3 = null;
          return serialized;
        }
        packr.offset = position2;
        if (encodeOptions & REUSE_BUFFER_MODE) {
          target.start = start3;
          target.end = position2;
          return target;
        }
        return target.subarray(start3, position2);
      } catch (error5) {
        encodingError = error5;
        throw error5;
      } finally {
        if (structures) {
          resetStructures();
          if (hasSharedUpdate && packr.saveStructures) {
            let sharedLength = structures.sharedLength || 0;
            let returnBuffer = target.subarray(start3, position2);
            let newSharedData = prepareStructures(structures, packr);
            if (!encodingError) {
              if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {
                return packr.pack(value6, encodeOptions);
              }
              packr.lastNamedStructuresLength = sharedLength;
              if (target.length > 1073741824) target = null;
              return returnBuffer;
            }
          }
        }
        if (target.length > 1073741824) target = null;
        if (encodeOptions & RESET_BUFFER_MODE)
          position2 = start3;
      }
    };
    const resetStructures = /* @__PURE__ */ __name(() => {
      if (serializationsSinceTransitionRebuild < 10)
        serializationsSinceTransitionRebuild++;
      let sharedLength = structures.sharedLength || 0;
      if (structures.length > sharedLength && !isSequential2)
        structures.length = sharedLength;
      if (transitionsCount > 1e4) {
        structures.transitions = null;
        serializationsSinceTransitionRebuild = 0;
        transitionsCount = 0;
        if (recordIdsToRemove.length > 0)
          recordIdsToRemove = [];
      } else if (recordIdsToRemove.length > 0 && !isSequential2) {
        for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
          recordIdsToRemove[i][RECORD_SYMBOL] = 0;
        }
        recordIdsToRemove = [];
      }
    }, "resetStructures");
    const packArray = /* @__PURE__ */ __name((value6) => {
      var length5 = value6.length;
      if (length5 < 16) {
        target[position2++] = 144 | length5;
      } else if (length5 < 65536) {
        target[position2++] = 220;
        target[position2++] = length5 >> 8;
        target[position2++] = length5 & 255;
      } else {
        target[position2++] = 221;
        targetView.setUint32(position2, length5);
        position2 += 4;
      }
      for (let i = 0; i < length5; i++) {
        pack4(value6[i]);
      }
    }, "packArray");
    const pack4 = /* @__PURE__ */ __name((value6) => {
      if (position2 > safeEnd)
        target = makeRoom(position2);
      var type3 = typeof value6;
      var length5;
      if (type3 === "string") {
        let strLength = value6.length;
        if (bundledStrings2 && strLength >= 4 && strLength < 4096) {
          if ((bundledStrings2.size += strLength) > MAX_BUNDLE_SIZE) {
            let extStart;
            let maxBytes2 = (bundledStrings2[0] ? bundledStrings2[0].length * 3 + bundledStrings2[1].length : 0) + 10;
            if (position2 + maxBytes2 > safeEnd)
              target = makeRoom(position2 + maxBytes2);
            let lastBundle;
            if (bundledStrings2.position) {
              lastBundle = bundledStrings2;
              target[position2] = 200;
              position2 += 3;
              target[position2++] = 98;
              extStart = position2 - start3;
              position2 += 4;
              writeBundles(start3, pack4, 0);
              targetView.setUint16(extStart + start3 - 3, position2 - start3 - extStart);
            } else {
              target[position2++] = 214;
              target[position2++] = 98;
              extStart = position2 - start3;
              position2 += 4;
            }
            bundledStrings2 = ["", ""];
            bundledStrings2.previous = lastBundle;
            bundledStrings2.size = 0;
            bundledStrings2.position = extStart;
          }
          let twoByte = hasNonLatin.test(value6);
          bundledStrings2[twoByte ? 0 : 1] += value6;
          target[position2++] = 193;
          pack4(twoByte ? -strLength : strLength);
          return;
        }
        let headerSize;
        if (strLength < 32) {
          headerSize = 1;
        } else if (strLength < 256) {
          headerSize = 2;
        } else if (strLength < 65536) {
          headerSize = 3;
        } else {
          headerSize = 5;
        }
        let maxBytes = strLength * 3;
        if (position2 + maxBytes > safeEnd)
          target = makeRoom(position2 + maxBytes);
        if (strLength < 64 || !encodeUtf8) {
          let i, c1, c2, strPosition = position2 + headerSize;
          for (i = 0; i < strLength; i++) {
            c1 = value6.charCodeAt(i);
            if (c1 < 128) {
              target[strPosition++] = c1;
            } else if (c1 < 2048) {
              target[strPosition++] = c1 >> 6 | 192;
              target[strPosition++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = value6.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              i++;
              target[strPosition++] = c1 >> 18 | 240;
              target[strPosition++] = c1 >> 12 & 63 | 128;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            } else {
              target[strPosition++] = c1 >> 12 | 224;
              target[strPosition++] = c1 >> 6 & 63 | 128;
              target[strPosition++] = c1 & 63 | 128;
            }
          }
          length5 = strPosition - position2 - headerSize;
        } else {
          length5 = encodeUtf8(value6, position2 + headerSize);
        }
        if (length5 < 32) {
          target[position2++] = 160 | length5;
        } else if (length5 < 256) {
          if (headerSize < 2) {
            target.copyWithin(position2 + 2, position2 + 1, position2 + 1 + length5);
          }
          target[position2++] = 217;
          target[position2++] = length5;
        } else if (length5 < 65536) {
          if (headerSize < 3) {
            target.copyWithin(position2 + 3, position2 + 2, position2 + 2 + length5);
          }
          target[position2++] = 218;
          target[position2++] = length5 >> 8;
          target[position2++] = length5 & 255;
        } else {
          if (headerSize < 5) {
            target.copyWithin(position2 + 5, position2 + 3, position2 + 3 + length5);
          }
          target[position2++] = 219;
          targetView.setUint32(position2, length5);
          position2 += 4;
        }
        position2 += length5;
      } else if (type3 === "number") {
        if (value6 >>> 0 === value6) {
          if (value6 < 32 || value6 < 128 && this.useRecords === false || value6 < 64 && !this.randomAccessStructure) {
            target[position2++] = value6;
          } else if (value6 < 256) {
            target[position2++] = 204;
            target[position2++] = value6;
          } else if (value6 < 65536) {
            target[position2++] = 205;
            target[position2++] = value6 >> 8;
            target[position2++] = value6 & 255;
          } else {
            target[position2++] = 206;
            targetView.setUint32(position2, value6);
            position2 += 4;
          }
        } else if (value6 >> 0 === value6) {
          if (value6 >= -32) {
            target[position2++] = 256 + value6;
          } else if (value6 >= -128) {
            target[position2++] = 208;
            target[position2++] = value6 + 256;
          } else if (value6 >= -32768) {
            target[position2++] = 209;
            targetView.setInt16(position2, value6);
            position2 += 2;
          } else {
            target[position2++] = 210;
            targetView.setInt32(position2, value6);
            position2 += 4;
          }
        } else {
          let useFloat32;
          if ((useFloat32 = this.useFloat32) > 0 && value6 < 4294967296 && value6 >= -2147483648) {
            target[position2++] = 202;
            targetView.setFloat32(position2, value6);
            let xShifted;
            if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
            (xShifted = value6 * mult10[(target[position2] & 127) << 1 | target[position2 + 1] >> 7]) >> 0 === xShifted) {
              position2 += 4;
              return;
            } else
              position2--;
          }
          target[position2++] = 203;
          targetView.setFloat64(position2, value6);
          position2 += 8;
        }
      } else if (type3 === "object" || type3 === "function") {
        if (!value6)
          target[position2++] = 192;
        else {
          if (referenceMap3) {
            let referee = referenceMap3.get(value6);
            if (referee) {
              if (!referee.id) {
                let idsToInsert = referenceMap3.idsToInsert || (referenceMap3.idsToInsert = []);
                referee.id = idsToInsert.push(referee);
              }
              target[position2++] = 214;
              target[position2++] = 112;
              targetView.setUint32(position2, referee.id);
              position2 += 4;
              return;
            } else
              referenceMap3.set(value6, { offset: position2 - start3 });
          }
          let constructor = value6.constructor;
          if (constructor === Object) {
            writeObject(value6);
          } else if (constructor === Array) {
            packArray(value6);
          } else if (constructor === Map) {
            if (this.mapAsEmptyObject) target[position2++] = 128;
            else {
              length5 = value6.size;
              if (length5 < 16) {
                target[position2++] = 128 | length5;
              } else if (length5 < 65536) {
                target[position2++] = 222;
                target[position2++] = length5 >> 8;
                target[position2++] = length5 & 255;
              } else {
                target[position2++] = 223;
                targetView.setUint32(position2, length5);
                position2 += 4;
              }
              for (let [key, entryValue] of value6) {
                pack4(key);
                pack4(entryValue);
              }
            }
          } else {
            for (let i = 0, l = extensions.length; i < l; i++) {
              let extensionClass = extensionClasses[i];
              if (value6 instanceof extensionClass) {
                let extension = extensions[i];
                if (extension.write) {
                  if (extension.type) {
                    target[position2++] = 212;
                    target[position2++] = extension.type;
                    target[position2++] = 0;
                  }
                  let writeResult = extension.write.call(this, value6);
                  if (writeResult === value6) {
                    if (Array.isArray(value6)) {
                      packArray(value6);
                    } else {
                      writeObject(value6);
                    }
                  } else {
                    pack4(writeResult);
                  }
                  return;
                }
                let currentTarget = target;
                let currentTargetView = targetView;
                let currentPosition = position2;
                target = null;
                let result;
                try {
                  result = extension.pack.call(this, value6, (size22) => {
                    target = currentTarget;
                    currentTarget = null;
                    position2 += size22;
                    if (position2 > safeEnd)
                      makeRoom(position2);
                    return {
                      target,
                      targetView,
                      position: position2 - size22
                    };
                  }, pack4);
                } finally {
                  if (currentTarget) {
                    target = currentTarget;
                    targetView = currentTargetView;
                    position2 = currentPosition;
                    safeEnd = target.length - 10;
                  }
                }
                if (result) {
                  if (result.length + position2 > safeEnd)
                    makeRoom(result.length + position2);
                  position2 = writeExtensionData(result, target, position2, extension.type);
                }
                return;
              }
            }
            if (Array.isArray(value6)) {
              packArray(value6);
            } else {
              if (value6.toJSON) {
                const json8 = value6.toJSON();
                if (json8 !== value6)
                  return pack4(json8);
              }
              if (type3 === "function")
                return pack4(this.writeFunction && this.writeFunction(value6));
              writeObject(value6);
            }
          }
        }
      } else if (type3 === "boolean") {
        target[position2++] = value6 ? 195 : 194;
      } else if (type3 === "bigint") {
        if (value6 < 9223372036854776e3 && value6 >= -9223372036854776e3) {
          target[position2++] = 211;
          targetView.setBigInt64(position2, value6);
        } else if (value6 < 18446744073709552e3 && value6 > 0) {
          target[position2++] = 207;
          targetView.setBigUint64(position2, value6);
        } else {
          if (this.largeBigIntToFloat) {
            target[position2++] = 203;
            targetView.setFloat64(position2, Number(value6));
          } else if (this.largeBigIntToString) {
            return pack4(value6.toString());
          } else if (this.useBigIntExtension || this.moreTypes) {
            let empty45 = value6 < 0 ? BigInt(-1) : BigInt(0);
            let array7;
            if (value6 >> BigInt(65536) === empty45) {
              let mask = BigInt(18446744073709552e3) - BigInt(1);
              let chunks3 = [];
              while (true) {
                chunks3.push(value6 & mask);
                if (value6 >> BigInt(63) === empty45) break;
                value6 >>= BigInt(64);
              }
              array7 = new Uint8Array(new BigUint64Array(chunks3).buffer);
              array7.reverse();
            } else {
              let invert2 = value6 < 0;
              let string7 = (invert2 ? ~value6 : value6).toString(16);
              if (string7.length % 2) {
                string7 = "0" + string7;
              } else if (parseInt(string7.charAt(0), 16) >= 8) {
                string7 = "00" + string7;
              }
              if (hasNodeBuffer) {
                array7 = Buffer.from(string7, "hex");
              } else {
                array7 = new Uint8Array(string7.length / 2);
                for (let i = 0; i < array7.length; i++) {
                  array7[i] = parseInt(string7.slice(i * 2, i * 2 + 2), 16);
                }
              }
              if (invert2) {
                for (let i = 0; i < array7.length; i++) array7[i] = ~array7[i];
              }
            }
            if (array7.length + position2 > safeEnd)
              makeRoom(array7.length + position2);
            position2 = writeExtensionData(array7, target, position2, 66);
            return;
          } else {
            throw new RangeError(value6 + " was too large to fit in MessagePack 64-bit integer format, use useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set largeBigIntToString to convert to string");
          }
        }
        position2 += 8;
      } else if (type3 === "undefined") {
        if (this.encodeUndefinedAsNil)
          target[position2++] = 192;
        else {
          target[position2++] = 212;
          target[position2++] = 0;
          target[position2++] = 0;
        }
      } else {
        throw new Error("Unknown type: " + type3);
      }
    }, "pack");
    const writePlainObject = this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues ? (object2) => {
      let keys6;
      if (this.skipValues) {
        keys6 = [];
        for (let key2 in object2) {
          if ((typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key2)) && !this.skipValues.includes(object2[key2]))
            keys6.push(key2);
        }
      } else {
        keys6 = Object.keys(object2);
      }
      let length5 = keys6.length;
      if (length5 < 16) {
        target[position2++] = 128 | length5;
      } else if (length5 < 65536) {
        target[position2++] = 222;
        target[position2++] = length5 >> 8;
        target[position2++] = length5 & 255;
      } else {
        target[position2++] = 223;
        targetView.setUint32(position2, length5);
        position2 += 4;
      }
      let key;
      if (this.coercibleKeyAsNumber) {
        for (let i = 0; i < length5; i++) {
          key = keys6[i];
          let num = Number(key);
          pack4(isNaN(num) ? key : num);
          pack4(object2[key]);
        }
      } else {
        for (let i = 0; i < length5; i++) {
          pack4(key = keys6[i]);
          pack4(object2[key]);
        }
      }
    } : (object2) => {
      target[position2++] = 222;
      let objectOffset = position2 - start3;
      position2 += 2;
      let size22 = 0;
      for (let key in object2) {
        if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
          pack4(key);
          pack4(object2[key]);
          size22++;
        }
      }
      if (size22 > 65535) {
        throw new Error('Object is too large to serialize with fast 16-bit map size, use the "variableMapSize" option to serialize this object');
      }
      target[objectOffset++ + start3] = size22 >> 8;
      target[objectOffset + start3] = size22 & 255;
    };
    const writeRecord = this.useRecords === false ? writePlainObject : options4.progressiveRecords && !useTwoByteRecords ? (
      // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
      (object2) => {
        let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
        let objectOffset = position2++ - start3;
        let wroteKeys;
        for (let key in object2) {
          if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (nextTransition)
              transition = nextTransition;
            else {
              let keys6 = Object.keys(object2);
              let lastTransition = transition;
              transition = structures.transitions;
              let newTransitions = 0;
              for (let i = 0, l = keys6.length; i < l; i++) {
                let key2 = keys6[i];
                nextTransition = transition[key2];
                if (!nextTransition) {
                  nextTransition = transition[key2] = /* @__PURE__ */ Object.create(null);
                  newTransitions++;
                }
                transition = nextTransition;
              }
              if (objectOffset + start3 + 1 == position2) {
                position2--;
                newRecord(transition, keys6, newTransitions);
              } else
                insertNewRecord(transition, keys6, objectOffset, newTransitions);
              wroteKeys = true;
              transition = lastTransition[key];
            }
            pack4(object2[key]);
          }
        }
        if (!wroteKeys) {
          let recordId = transition[RECORD_SYMBOL];
          if (recordId)
            target[objectOffset + start3] = recordId;
          else
            insertNewRecord(transition, Object.keys(object2), objectOffset, 0);
        }
      }
    ) : (object2) => {
      let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
      let newTransitions = 0;
      for (let key in object2) if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
        nextTransition = transition[key];
        if (!nextTransition) {
          nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
          newTransitions++;
        }
        transition = nextTransition;
      }
      let recordId = transition[RECORD_SYMBOL];
      if (recordId) {
        if (recordId >= 96 && useTwoByteRecords) {
          target[position2++] = ((recordId -= 96) & 31) + 96;
          target[position2++] = recordId >> 5;
        } else
          target[position2++] = recordId;
      } else {
        newRecord(transition, transition.__keys__ || Object.keys(object2), newTransitions);
      }
      for (let key in object2)
        if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
          pack4(object2[key]);
        }
    };
    const checkUseRecords = typeof this.useRecords == "function" && this.useRecords;
    const writeObject = checkUseRecords ? (object2) => {
      checkUseRecords(object2) ? writeRecord(object2) : writePlainObject(object2);
    } : writeRecord;
    const makeRoom = /* @__PURE__ */ __name((end6) => {
      let newSize;
      if (end6 > 16777216) {
        if (end6 - start3 > MAX_BUFFER_SIZE)
          throw new Error("Packed buffer would be larger than maximum buffer size");
        newSize = Math.min(
          MAX_BUFFER_SIZE,
          Math.round(Math.max((end6 - start3) * (end6 > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
        );
      } else
        newSize = (Math.max(end6 - start3 << 2, target.length - 1) >> 12) + 1 << 12;
      let newBuffer = new ByteArrayAllocate(newSize);
      targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));
      end6 = Math.min(end6, target.length);
      if (target.copy)
        target.copy(newBuffer, 0, start3, end6);
      else
        newBuffer.set(target.slice(start3, end6));
      position2 -= start3;
      start3 = 0;
      safeEnd = newBuffer.length - 10;
      return target = newBuffer;
    }, "makeRoom");
    const newRecord = /* @__PURE__ */ __name((transition, keys6, newTransitions) => {
      let recordId = structures.nextId;
      if (!recordId)
        recordId = 64;
      if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys6)) {
        recordId = structures.nextOwnId;
        if (!(recordId < maxStructureId))
          recordId = sharedLimitId;
        structures.nextOwnId = recordId + 1;
      } else {
        if (recordId >= maxStructureId)
          recordId = sharedLimitId;
        structures.nextId = recordId + 1;
      }
      let highByte = keys6.highByte = recordId >= 96 && useTwoByteRecords ? recordId - 96 >> 5 : -1;
      transition[RECORD_SYMBOL] = recordId;
      transition.__keys__ = keys6;
      structures[recordId - 64] = keys6;
      if (recordId < sharedLimitId) {
        keys6.isShared = true;
        structures.sharedLength = recordId - 63;
        hasSharedUpdate = true;
        if (highByte >= 0) {
          target[position2++] = (recordId & 31) + 96;
          target[position2++] = highByte;
        } else {
          target[position2++] = recordId;
        }
      } else {
        if (highByte >= 0) {
          target[position2++] = 213;
          target[position2++] = 114;
          target[position2++] = (recordId & 31) + 96;
          target[position2++] = highByte;
        } else {
          target[position2++] = 212;
          target[position2++] = 114;
          target[position2++] = recordId;
        }
        if (newTransitions)
          transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
        if (recordIdsToRemove.length >= maxOwnStructures)
          recordIdsToRemove.shift()[RECORD_SYMBOL] = 0;
        recordIdsToRemove.push(transition);
        pack4(keys6);
      }
    }, "newRecord");
    const insertNewRecord = /* @__PURE__ */ __name((transition, keys6, insertionOffset, newTransitions) => {
      let mainTarget = target;
      let mainPosition = position2;
      let mainSafeEnd = safeEnd;
      let mainStart = start3;
      target = keysTarget;
      position2 = 0;
      start3 = 0;
      if (!target)
        keysTarget = target = new ByteArrayAllocate(8192);
      safeEnd = target.length - 10;
      newRecord(transition, keys6, newTransitions);
      keysTarget = target;
      let keysPosition = position2;
      target = mainTarget;
      position2 = mainPosition;
      safeEnd = mainSafeEnd;
      start3 = mainStart;
      if (keysPosition > 1) {
        let newEnd = position2 + keysPosition - 1;
        if (newEnd > safeEnd)
          makeRoom(newEnd);
        let insertionPosition = insertionOffset + start3;
        target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position2);
        target.set(keysTarget.slice(0, keysPosition), insertionPosition);
        position2 = newEnd;
      } else {
        target[insertionOffset + start3] = keysTarget[0];
      }
    }, "insertNewRecord");
    const writeStruct = /* @__PURE__ */ __name((object2) => {
      let newPosition = writeStructSlots(object2, target, start3, position2, structures, makeRoom, (value6, newPosition2, notifySharedUpdate) => {
        if (notifySharedUpdate)
          return hasSharedUpdate = true;
        position2 = newPosition2;
        let startTarget = target;
        pack4(value6);
        resetStructures();
        if (startTarget !== target) {
          return { position: position2, targetView, target };
        }
        return position2;
      }, this);
      if (newPosition === 0)
        return writeObject(object2);
      position2 = newPosition;
    }, "writeStruct");
  }
  useBuffer(buffer4) {
    target = buffer4;
    target.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength));
    targetView = target.dataView;
    position2 = 0;
  }
  set position(value6) {
    position2 = value6;
  }
  get position() {
    return position2;
  }
  clearSharedData() {
    if (this.structures)
      this.structures = [];
    if (this.typedStructs)
      this.typedStructs = [];
  }
};
extensionClasses = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, DataView, C1Type];
extensions = [{
  pack(date4, allocateForWrite, pack4) {
    let seconds2 = date4.getTime() / 1e3;
    if ((this.useTimestamp32 || date4.getMilliseconds() === 0) && seconds2 >= 0 && seconds2 < 4294967296) {
      let { target: target3, targetView: targetView3, position: position5 } = allocateForWrite(6);
      target3[position5++] = 214;
      target3[position5++] = 255;
      targetView3.setUint32(position5, seconds2);
    } else if (seconds2 > 0 && seconds2 < 4294967296) {
      let { target: target3, targetView: targetView3, position: position5 } = allocateForWrite(10);
      target3[position5++] = 215;
      target3[position5++] = 255;
      targetView3.setUint32(position5, date4.getMilliseconds() * 4e6 + (seconds2 / 1e3 / 4294967296 >> 0));
      targetView3.setUint32(position5 + 4, seconds2);
    } else if (isNaN(seconds2)) {
      if (this.onInvalidDate) {
        allocateForWrite(0);
        return pack4(this.onInvalidDate());
      }
      let { target: target3, targetView: targetView3, position: position5 } = allocateForWrite(3);
      target3[position5++] = 212;
      target3[position5++] = 255;
      target3[position5++] = 255;
    } else {
      let { target: target3, targetView: targetView3, position: position5 } = allocateForWrite(15);
      target3[position5++] = 199;
      target3[position5++] = 12;
      target3[position5++] = 255;
      targetView3.setUint32(position5, date4.getMilliseconds() * 1e6);
      targetView3.setBigInt64(position5 + 4, BigInt(Math.floor(seconds2)));
    }
  }
}, {
  pack(set20, allocateForWrite, pack4) {
    if (this.setAsEmptyObject) {
      allocateForWrite(0);
      return pack4({});
    }
    let array7 = Array.from(set20);
    let { target: target3, position: position5 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target3[position5++] = 212;
      target3[position5++] = 115;
      target3[position5++] = 0;
    }
    pack4(array7);
  }
}, {
  pack(error5, allocateForWrite, pack4) {
    let { target: target3, position: position5 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target3[position5++] = 212;
      target3[position5++] = 101;
      target3[position5++] = 0;
    }
    pack4([error5.name, error5.message, error5.cause]);
  }
}, {
  pack(regex, allocateForWrite, pack4) {
    let { target: target3, position: position5 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target3[position5++] = 212;
      target3[position5++] = 120;
      target3[position5++] = 0;
    }
    pack4([regex.source, regex.flags]);
  }
}, {
  pack(arrayBuffer, allocateForWrite) {
    if (this.moreTypes)
      writeExtBuffer(arrayBuffer, 16, allocateForWrite);
    else
      writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
  }
}, {
  pack(typedArray, allocateForWrite) {
    let constructor = typedArray.constructor;
    if (constructor !== ByteArray && this.moreTypes)
      writeExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite);
    else
      writeBuffer(typedArray, allocateForWrite);
  }
}, {
  pack(arrayBuffer, allocateForWrite) {
    if (this.moreTypes)
      writeExtBuffer(arrayBuffer, 17, allocateForWrite);
    else
      writeBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
  }
}, {
  pack(c1, allocateForWrite) {
    let { target: target3, position: position5 } = allocateForWrite(1);
    target3[position5] = 193;
  }
}];
function writeExtBuffer(typedArray, type3, allocateForWrite, encode8) {
  let length5 = typedArray.byteLength;
  if (length5 + 1 < 256) {
    var { target: target3, position: position5 } = allocateForWrite(4 + length5);
    target3[position5++] = 199;
    target3[position5++] = length5 + 1;
  } else if (length5 + 1 < 65536) {
    var { target: target3, position: position5 } = allocateForWrite(5 + length5);
    target3[position5++] = 200;
    target3[position5++] = length5 + 1 >> 8;
    target3[position5++] = length5 + 1 & 255;
  } else {
    var { target: target3, position: position5, targetView: targetView3 } = allocateForWrite(7 + length5);
    target3[position5++] = 201;
    targetView3.setUint32(position5, length5 + 1);
    position5 += 4;
  }
  target3[position5++] = 116;
  target3[position5++] = type3;
  if (!typedArray.buffer) typedArray = new Uint8Array(typedArray);
  target3.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position5);
}
__name(writeExtBuffer, "writeExtBuffer");
function writeBuffer(buffer4, allocateForWrite) {
  let length5 = buffer4.byteLength;
  var target3, position5;
  if (length5 < 256) {
    var { target: target3, position: position5 } = allocateForWrite(length5 + 2);
    target3[position5++] = 196;
    target3[position5++] = length5;
  } else if (length5 < 65536) {
    var { target: target3, position: position5 } = allocateForWrite(length5 + 3);
    target3[position5++] = 197;
    target3[position5++] = length5 >> 8;
    target3[position5++] = length5 & 255;
  } else {
    var { target: target3, position: position5, targetView: targetView3 } = allocateForWrite(length5 + 5);
    target3[position5++] = 198;
    targetView3.setUint32(position5, length5);
    position5 += 4;
  }
  target3.set(buffer4, position5);
}
__name(writeBuffer, "writeBuffer");
function writeExtensionData(result, target3, position5, type3) {
  let length5 = result.length;
  switch (length5) {
    case 1:
      target3[position5++] = 212;
      break;
    case 2:
      target3[position5++] = 213;
      break;
    case 4:
      target3[position5++] = 214;
      break;
    case 8:
      target3[position5++] = 215;
      break;
    case 16:
      target3[position5++] = 216;
      break;
    default:
      if (length5 < 256) {
        target3[position5++] = 199;
        target3[position5++] = length5;
      } else if (length5 < 65536) {
        target3[position5++] = 200;
        target3[position5++] = length5 >> 8;
        target3[position5++] = length5 & 255;
      } else {
        target3[position5++] = 201;
        target3[position5++] = length5 >> 24;
        target3[position5++] = length5 >> 16 & 255;
        target3[position5++] = length5 >> 8 & 255;
        target3[position5++] = length5 & 255;
      }
  }
  target3[position5++] = type3;
  target3.set(result, position5);
  position5 += length5;
  return position5;
}
__name(writeExtensionData, "writeExtensionData");
function insertIds(serialized, idsToInsert) {
  let nextId;
  let distanceToMove = idsToInsert.length * 6;
  let lastEnd = serialized.length - distanceToMove;
  while (nextId = idsToInsert.pop()) {
    let offset = nextId.offset;
    let id4 = nextId.id;
    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
    distanceToMove -= 6;
    let position5 = offset + distanceToMove;
    serialized[position5++] = 214;
    serialized[position5++] = 105;
    serialized[position5++] = id4 >> 24;
    serialized[position5++] = id4 >> 16 & 255;
    serialized[position5++] = id4 >> 8 & 255;
    serialized[position5++] = id4 & 255;
    lastEnd = offset;
  }
  return serialized;
}
__name(insertIds, "insertIds");
function writeBundles(start3, pack4, incrementPosition) {
  if (bundledStrings2.length > 0) {
    targetView.setUint32(bundledStrings2.position + start3, position2 + incrementPosition - bundledStrings2.position - start3);
    bundledStrings2.stringsPosition = position2 - start3;
    let writeStrings = bundledStrings2;
    bundledStrings2 = null;
    pack4(writeStrings[0]);
    pack4(writeStrings[1]);
  }
}
__name(writeBundles, "writeBundles");
function addExtension2(extension) {
  if (extension.Class) {
    if (!extension.pack && !extension.write)
      throw new Error("Extension has no pack or write function");
    if (extension.pack && !extension.type)
      throw new Error("Extension has no type (numeric code to identify the extension)");
    extensionClasses.unshift(extension.Class);
    extensions.unshift(extension);
  }
  addExtension(extension);
}
__name(addExtension2, "addExtension");
function prepareStructures(structures, packr) {
  structures.isCompatible = (existingStructures) => {
    let compatible = !existingStructures || (packr.lastNamedStructuresLength || 0) === existingStructures.length;
    if (!compatible)
      packr._mergeStructures(existingStructures);
    return compatible;
  };
  return structures;
}
__name(prepareStructures, "prepareStructures");
var defaultPackr = new Packr({ useRecords: false });
var pack2 = defaultPackr.pack;
var encode6 = defaultPackr.pack;
var Encoder = Packr;
var { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
var REUSE_BUFFER_MODE = 512;
var RESET_BUFFER_MODE = 1024;
var RESERVE_START_SPACE = 2048;

// node_modules/.pnpm/msgpackr@1.11.8/node_modules/msgpackr/iterators.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function packIter(objectIterator, options4 = {}) {
  if (!objectIterator || typeof objectIterator !== "object") {
    throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");
  } else if (typeof objectIterator[Symbol.iterator] === "function") {
    return packIterSync(objectIterator, options4);
  } else if (typeof objectIterator.then === "function" || typeof objectIterator[Symbol.asyncIterator] === "function") {
    return packIterAsync(objectIterator, options4);
  } else {
    throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise");
  }
}
__name(packIter, "packIter");
function* packIterSync(objectIterator, options4) {
  const packr = new Packr(options4);
  for (const value6 of objectIterator) {
    yield packr.pack(value6);
  }
}
__name(packIterSync, "packIterSync");
async function* packIterAsync(objectIterator, options4) {
  const packr = new Packr(options4);
  for await (const value6 of objectIterator) {
    yield packr.pack(value6);
  }
}
__name(packIterAsync, "packIterAsync");
function unpackIter(bufferIterator, options4 = {}) {
  if (!bufferIterator || typeof bufferIterator !== "object") {
    throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");
  }
  const unpackr = new Unpackr(options4);
  let incomplete;
  const parser = /* @__PURE__ */ __name((chunk4) => {
    let yields;
    if (incomplete) {
      chunk4 = Buffer.concat([incomplete, chunk4]);
      incomplete = void 0;
    }
    try {
      yields = unpackr.unpackMultiple(chunk4);
    } catch (err) {
      if (err.incomplete) {
        incomplete = chunk4.slice(err.lastPosition);
        yields = err.values;
      } else {
        throw err;
      }
    }
    return yields;
  }, "parser");
  if (typeof bufferIterator[Symbol.iterator] === "function") {
    return (/* @__PURE__ */ __name((function* iter() {
      for (const value6 of bufferIterator) {
        yield* parser(value6);
      }
    }), "iter"))();
  } else if (typeof bufferIterator[Symbol.asyncIterator] === "function") {
    return (/* @__PURE__ */ __name((async function* iter() {
      for await (const value6 of bufferIterator) {
        yield* parser(value6);
      }
    }), "iter"))();
  }
}
__name(unpackIter, "unpackIter");
var decodeIter = unpackIter;
var encodeIter = packIter;

// node_modules/.pnpm/msgpackr@1.11.8/node_modules/msgpackr/index.js
var useRecords = false;
var mapsAsObjects = true;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/MsgPack.js
var ErrorTypeId3 = /* @__PURE__ */ Symbol.for("@effect/platform/MsgPack/MsgPackError");
var MsgPackError = class extends (/* @__PURE__ */ TaggedError("MsgPackError")) {
  static {
    __name(this, "MsgPackError");
  }
  /**
   * @since 1.0.0
   */
  [ErrorTypeId3] = ErrorTypeId3;
  /**
   * @since 1.0.0
   */
  get message() {
    return this.reason;
  }
};

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/SocketServer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SocketServer = class extends (/* @__PURE__ */ Tag2("@effect/platform/SocketServer")()) {
  static {
    __name(this, "SocketServer");
  }
};
var ErrorTypeId4 = /* @__PURE__ */ Symbol.for("@effect/platform/SocketServer/SocketServerError");
var SocketServerError = class extends (/* @__PURE__ */ TaggedError("SocketServerError")) {
  static {
    __name(this, "SocketServerError");
  }
  /**
   * @since 1.0.0
   */
  [ErrorTypeId4] = ErrorTypeId4;
  /**
   * @since 1.0.0
   */
  get message() {
    return this.reason;
  }
};

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Transferable.js
var Transferable_exports = {};
__export(Transferable_exports, {
  Collector: () => Collector,
  ImageData: () => ImageData,
  MessagePort: () => MessagePort,
  Uint8Array: () => Uint8Array2,
  addAll: () => addAll,
  makeCollector: () => makeCollector,
  schema: () => schema2,
  unsafeMakeCollector: () => unsafeMakeCollector
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Collector = class extends (/* @__PURE__ */ Tag2("@effect/platform/Transferable/Collector")()) {
  static {
    __name(this, "Collector");
  }
};
var unsafeMakeCollector = /* @__PURE__ */ __name(() => {
  let tranferables = [];
  const unsafeAddAll = /* @__PURE__ */ __name((transfers) => {
    tranferables.push(...transfers);
  }, "unsafeAddAll");
  const unsafeRead = /* @__PURE__ */ __name(() => tranferables, "unsafeRead");
  const unsafeClear = /* @__PURE__ */ __name(() => {
    const prev = tranferables;
    tranferables = [];
    return prev;
  }, "unsafeClear");
  return Collector.of({
    unsafeAddAll,
    addAll: /* @__PURE__ */ __name((transferables) => sync7(() => unsafeAddAll(transferables)), "addAll"),
    unsafeRead,
    read: sync7(unsafeRead),
    unsafeClear,
    clear: sync7(unsafeClear)
  });
}, "unsafeMakeCollector");
var makeCollector = /* @__PURE__ */ sync7(unsafeMakeCollector);
var addAll = /* @__PURE__ */ __name((tranferables) => flatMap15(serviceOption2(Collector), match2({
  onNone: /* @__PURE__ */ __name(() => _void, "onNone"),
  onSome: /* @__PURE__ */ __name((_) => _.addAll(tranferables), "onSome")
})), "addAll");
var schema2 = /* @__PURE__ */ dual(2, (self2, f) => transformOrFail(encodedSchema(self2), self2, {
  strict: true,
  decode: succeed14,
  encode: /* @__PURE__ */ __name((i) => as8(addAll(f(i)), i), "encode")
}));
var ImageData = /* @__PURE__ */ schema2(Any, (_) => [_.data.buffer]);
var MessagePort = /* @__PURE__ */ schema2(Any, (_) => [_]);
var Uint8Array2 = /* @__PURE__ */ schema2(Uint8ArrayFromSelf, (_) => [_.buffer]);

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Worker.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/worker.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Pool.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/pool.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PoolTypeId = /* @__PURE__ */ Symbol.for("effect/Pool");
var poolVariance = {
  /* c8 ignore next */
  _E: /* @__PURE__ */ __name((_) => _, "_E"),
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var makeWith3 = /* @__PURE__ */ __name((options4) => uninterruptibleMask((restore) => flatMap10(context2(), (context17) => {
  const scope5 = get6(context17, scopeTag);
  const acquire = mapInputContext(options4.acquire, (input) => merge3(context17, input));
  const pool = new PoolImpl(scope5, acquire, options4.concurrency ?? 1, options4.min, options4.max, options4.strategy, Math.min(Math.max(options4.targetUtilization ?? 1, 0.1), 1));
  const initialize = tap2(forkDaemon(restore(pool.resize)), (fiber) => scope5.addFinalizer(() => interruptFiber(fiber)));
  const runStrategy = tap2(forkDaemon(restore(options4.strategy.run(pool))), (fiber) => scope5.addFinalizer(() => interruptFiber(fiber)));
  return succeed(pool).pipe(zipLeft2(scope5.addFinalizer(() => pool.shutdown)), zipLeft2(initialize), zipLeft2(runStrategy));
})), "makeWith");
var make88 = /* @__PURE__ */ __name((options4) => makeWith3({
  ...options4,
  min: options4.size,
  max: options4.size,
  strategy: strategyNoop()
}), "make");
var makeWithTTL = /* @__PURE__ */ __name((options4) => flatMap10(options4.timeToLiveStrategy === "creation" ? strategyCreationTTL(options4.timeToLive) : strategyUsageTTL(options4.timeToLive), (strategy) => makeWith3({
  ...options4,
  strategy
})), "makeWithTTL");
var PoolImpl = class extends Class2 {
  static {
    __name(this, "PoolImpl");
  }
  scope;
  acquire;
  concurrency;
  minSize;
  maxSize;
  strategy;
  targetUtilization;
  [PoolTypeId];
  isShuttingDown = false;
  semaphore;
  items = /* @__PURE__ */ new Set();
  available = /* @__PURE__ */ new Set();
  availableLatch = /* @__PURE__ */ unsafeMakeLatch(false);
  invalidated = /* @__PURE__ */ new Set();
  waiters = 0;
  constructor(scope5, acquire, concurrency, minSize, maxSize, strategy, targetUtilization) {
    super();
    this.scope = scope5;
    this.acquire = acquire;
    this.concurrency = concurrency;
    this.minSize = minSize;
    this.maxSize = maxSize;
    this.strategy = strategy;
    this.targetUtilization = targetUtilization;
    this[PoolTypeId] = poolVariance;
    this.semaphore = unsafeMakeSemaphore(concurrency * maxSize);
  }
  allocate = /* @__PURE__ */ acquireUseRelease(/* @__PURE__ */ scopeMake(), (scope5) => this.acquire.pipe(scopeExtend(scope5), exit2, flatMap10((exit5) => {
    const item = {
      exit: exit5,
      finalizer: catchAllCause(scope5.close(exit5), reportUnhandledError),
      refCount: 0,
      disableReclaim: false
    };
    this.items.add(item);
    this.available.add(item);
    return as3(exit5._tag === "Success" ? this.strategy.onAcquire(item) : zipRight2(item.finalizer, this.strategy.onAcquire(item)), item);
  })), (scope5, exit5) => exit5._tag === "Failure" ? scope5.close(exit5) : void_3);
  get currentUsage() {
    let count7 = this.waiters;
    for (const item of this.items) {
      count7 += item.refCount;
    }
    return count7;
  }
  get targetSize() {
    if (this.isShuttingDown) return 0;
    const utilization = this.currentUsage / this.targetUtilization;
    const target3 = Math.ceil(utilization / this.concurrency);
    return Math.min(Math.max(this.minSize, target3), this.maxSize);
  }
  get activeSize() {
    return this.items.size - this.invalidated.size;
  }
  resizeLoop = /* @__PURE__ */ suspend(() => {
    if (this.activeSize >= this.targetSize) {
      return void_3;
    }
    const toAcquire = this.targetSize - this.activeSize;
    return this.strategy.reclaim(this).pipe(flatMap10(match2({
      onNone: /* @__PURE__ */ __name(() => this.allocate, "onNone"),
      onSome: succeed
    })), replicateEffect(toAcquire, {
      concurrency: toAcquire
    }), zipLeft2(this.availableLatch.open), flatMap10((items) => items.some((_) => _.exit._tag === "Failure") ? void_3 : this.resizeLoop));
  });
  resizeSemaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  resize = /* @__PURE__ */ this.resizeSemaphore.withPermits(1)(this.resizeLoop);
  getPoolItem = /* @__PURE__ */ uninterruptibleMask((restore) => restore(this.semaphore.take(1)).pipe(zipRight2(scopeTag), flatMap10((scope5) => suspend(() => {
    this.waiters++;
    if (this.isShuttingDown) {
      return interrupt2;
    } else if (this.targetSize > this.activeSize) {
      const self2 = this;
      return flatMap10(this.resizeSemaphore.withPermitsIfAvailable(1)(forkIn(interruptible2(this.resize), this.scope)), /* @__PURE__ */ __name(function loop5() {
        if (self2.isShuttingDown) {
          return interrupt2;
        } else if (self2.available.size > 0) {
          return succeed(unsafeHead(self2.available));
        }
        self2.availableLatch.unsafeClose();
        return flatMap10(self2.availableLatch.await, loop5);
      }, "loop"));
    }
    return succeed(unsafeHead(this.available));
  }).pipe(ensuring(sync(() => this.waiters--)), tap2((item) => {
    if (item.exit._tag === "Failure") {
      this.items.delete(item);
      this.invalidated.delete(item);
      this.available.delete(item);
      return this.semaphore.release(1);
    }
    item.refCount++;
    this.available.delete(item);
    if (item.refCount < this.concurrency) {
      this.available.add(item);
    }
    return scope5.addFinalizer(() => zipRight2(suspend(() => {
      item.refCount--;
      if (this.invalidated.has(item)) {
        return this.invalidatePoolItem(item);
      }
      this.available.add(item);
      return exitVoid;
    }), this.semaphore.release(1)));
  }), onInterrupt(() => this.semaphore.release(1))))));
  commit() {
    return this.get;
  }
  get = /* @__PURE__ */ flatMap10(/* @__PURE__ */ suspend(() => this.isShuttingDown ? interrupt2 : this.getPoolItem), (_) => _.exit);
  invalidate(item) {
    return suspend(() => {
      if (this.isShuttingDown) return void_3;
      for (const poolItem of this.items) {
        if (poolItem.exit._tag === "Success" && poolItem.exit.value === item) {
          poolItem.disableReclaim = true;
          return uninterruptible(this.invalidatePoolItem(poolItem));
        }
      }
      return void_3;
    });
  }
  invalidatePoolItem(poolItem) {
    return suspend(() => {
      if (!this.items.has(poolItem)) {
        return void_3;
      } else if (poolItem.refCount === 0) {
        this.items.delete(poolItem);
        this.available.delete(poolItem);
        this.invalidated.delete(poolItem);
        return zipRight2(poolItem.finalizer, forkIn(interruptible2(this.resize), this.scope));
      }
      this.invalidated.add(poolItem);
      this.available.delete(poolItem);
      return void_3;
    });
  }
  get shutdown() {
    return suspend(() => {
      if (this.isShuttingDown) return void_3;
      this.isShuttingDown = true;
      const size22 = this.items.size;
      const semaphore = unsafeMakeSemaphore(size22);
      return forEachSequentialDiscard(this.items, (item) => {
        if (item.refCount > 0) {
          item.finalizer = zipLeft2(item.finalizer, semaphore.release(1));
          this.invalidated.add(item);
          return semaphore.take(1);
        }
        this.items.delete(item);
        this.available.delete(item);
        this.invalidated.delete(item);
        return item.finalizer;
      }).pipe(zipRight2(this.semaphore.releaseAll), zipRight2(this.availableLatch.open), zipRight2(semaphore.take(size22)));
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var strategyNoop = /* @__PURE__ */ __name(() => ({
  run: /* @__PURE__ */ __name((_) => void_3, "run"),
  onAcquire: /* @__PURE__ */ __name((_) => void_3, "onAcquire"),
  reclaim: /* @__PURE__ */ __name((_) => succeedNone, "reclaim")
}), "strategyNoop");
var strategyCreationTTL = /* @__PURE__ */ __name((ttl) => clockWith((clock3) => map12(unbounded2(), (queue) => {
  const ttlMillis = toMillis(ttl);
  const creationTimes = /* @__PURE__ */ new WeakMap();
  return identity({
    run: /* @__PURE__ */ __name((pool) => {
      const process2 = /* @__PURE__ */ __name((item) => suspend(() => {
        if (!pool.items.has(item) || pool.invalidated.has(item)) {
          return void_3;
        }
        const now2 = clock3.unsafeCurrentTimeMillis();
        const created = creationTimes.get(item);
        const remaining = ttlMillis - (now2 - created);
        return remaining > 0 ? delay(process2(item), remaining) : pool.invalidatePoolItem(item);
      }), "process");
      return queue.take.pipe(tap2(process2), forever);
    }, "run"),
    onAcquire: /* @__PURE__ */ __name((item) => suspend(() => {
      creationTimes.set(item, clock3.unsafeCurrentTimeMillis());
      return queue.offer(item);
    }), "onAcquire"),
    reclaim: /* @__PURE__ */ __name((_) => succeedNone, "reclaim")
  });
})), "strategyCreationTTL");
var strategyUsageTTL = /* @__PURE__ */ __name((ttl) => map12(unbounded2(), (queue) => {
  return identity({
    run: /* @__PURE__ */ __name((pool) => {
      const process2 = suspend(() => {
        const excess = pool.activeSize - pool.targetSize;
        if (excess <= 0) return void_3;
        return queue.take.pipe(tap2((item) => pool.invalidatePoolItem(item)), zipRight2(process2));
      });
      return process2.pipe(delay(ttl), forever);
    }, "run"),
    onAcquire: /* @__PURE__ */ __name((item) => queue.offer(item), "onAcquire"),
    reclaim(pool) {
      return suspend(() => {
        if (pool.invalidated.size === 0) {
          return succeedNone;
        }
        const item = head(filter2(pool.invalidated, (item2) => !item2.disableReclaim));
        if (item._tag === "None") {
          return succeedNone;
        }
        pool.invalidated.delete(item.value);
        if (item.value.refCount < pool.concurrency) {
          pool.available.add(item.value);
        }
        return as3(queue.offer(item.value), item);
      });
    }
  });
}), "strategyUsageTTL");
var reportUnhandledError = /* @__PURE__ */ __name((cause3) => withFiberRuntime((fiber) => {
  const unhandledLogLevel = fiber.getFiberRef(currentUnhandledErrorLogLevel);
  if (unhandledLogLevel._tag === "Some") {
    fiber.log("Unhandled error in pool finalizer", cause3, unhandledLogLevel);
  }
  return void_3;
}), "reportUnhandledError");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Pool.js
var make89 = make88;
var makeWithTTL2 = makeWithTTL;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/worker.js
var PlatformWorker = /* @__PURE__ */ GenericTag("@effect/platform/Worker/PlatformWorker");

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/Worker.js
var PlatformWorker2 = PlatformWorker;

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/WorkerRunner.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/internal/workerRunner.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PlatformRunner = /* @__PURE__ */ GenericTag("@effect/platform/Runner/PlatformRunner");
var CloseLatch = /* @__PURE__ */ Reference2()("@effect/platform/WorkerRunner/CloseLatch", {
  defaultValue: /* @__PURE__ */ __name(() => unsafeMake10(none4), "defaultValue")
});

// node_modules/.pnpm/@effect+platform@0.90.10_effect@3.19.13/node_modules/@effect/platform/dist/esm/WorkerRunner.js
var PlatformRunner2 = PlatformRunner;
var CloseLatch2 = CloseLatch;

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/Rpc.js
var Rpc_exports = {};
__export(Rpc_exports, {
  ForkTypeId: () => ForkTypeId,
  TypeId: () => TypeId46,
  exitSchema: () => exitSchema2,
  fork: () => fork4,
  fromTaggedRequest: () => fromTaggedRequest,
  isFork: () => isFork,
  isRpc: () => isRpc,
  make: () => make91
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/PrimaryKey.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var symbol4 = /* @__PURE__ */ Symbol.for("effect/PrimaryKey");

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/RpcSchema.js
var RpcSchema_exports = {};
__export(RpcSchema_exports, {
  Stream: () => Stream2,
  StreamSchemaId: () => StreamSchemaId,
  getStreamSchemas: () => getStreamSchemas,
  isStreamSchema: () => isStreamSchema,
  isStreamSerializable: () => isStreamSerializable
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var StreamSchemaId = /* @__PURE__ */ Symbol.for("@effect/rpc/RpcSchema/Stream");
var isStreamSchema = /* @__PURE__ */ __name((schema4) => schema4.ast.annotations[SchemaIdAnnotationId] === StreamSchemaId, "isStreamSchema");
var isStreamSerializable = /* @__PURE__ */ __name((schema4) => isStreamSchema(successSchema(schema4)), "isStreamSerializable");
var getStreamSchemas = /* @__PURE__ */ __name((ast) => ast.annotations[StreamSchemaId] ? some3(ast.annotations[StreamSchemaId]) : none2(), "getStreamSchemas");
var Stream2 = /* @__PURE__ */ __name(({
  failure,
  success
}) => Object.assign(declare([success, failure], {
  decode: /* @__PURE__ */ __name((success2, failure2) => parseStream(decodeUnknown2(ChunkFromSelf(success2)), decodeUnknown2(failure2)), "decode"),
  encode: /* @__PURE__ */ __name((success2, failure2) => parseStream(encodeUnknown(ChunkFromSelf(success2)), encodeUnknown(failure2)), "encode")
}, {
  schemaId: StreamSchemaId,
  [StreamSchemaId]: {
    success,
    failure
  }
}), {
  success,
  failure
}), "Stream");
var isStream2 = /* @__PURE__ */ __name((u) => hasProperty(u, StreamTypeId4), "isStream");
var parseStream = /* @__PURE__ */ __name((decodeSuccess, decodeFailure) => (u, options4, ast) => flatMap15(context4(), (context17) => {
  if (!isStream2(u)) return fail10(new Type2(ast, u));
  return succeed11(u.pipe(mapChunksEffect2((value6) => decodeSuccess(value6, options4)), catchAll8((error5) => {
    if (isParseError(error5)) return die12(error5);
    return matchEffect3(decodeFailure(error5, options4), {
      onFailure: die7,
      onSuccess: fail10
    });
  }), provideContext8(context17)));
}), "parseStream");

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/Rpc.js
var TypeId46 = /* @__PURE__ */ Symbol.for("@effect/rpc/Rpc");
var isRpc = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId46), "isRpc");
var Proto7 = {
  [TypeId46]: TypeId46,
  pipe() {
    return pipeArguments(this, arguments);
  },
  setSuccess(successSchema2) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: this.payloadSchema,
      successSchema: successSchema2,
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  setError(errorSchema) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: this.payloadSchema,
      successSchema: this.successSchema,
      errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  setPayload(payloadSchema) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: isSchema(payloadSchema) ? payloadSchema : Struct(payloadSchema),
      successSchema: this.successSchema,
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  middleware(middleware2) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: this.payloadSchema,
      successSchema: this.successSchema,
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: /* @__PURE__ */ new Set([...this.middlewares, middleware2])
    });
  },
  prefix(prefix) {
    return makeProto({
      _tag: `${prefix}${this._tag}`,
      payloadSchema: this.payloadSchema,
      successSchema: this.successSchema,
      errorSchema: this.errorSchema,
      annotations: this.annotations,
      middlewares: this.middlewares
    });
  },
  annotate(tag8, value6) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: this.payloadSchema,
      successSchema: this.successSchema,
      errorSchema: this.errorSchema,
      middlewares: this.middlewares,
      annotations: add4(this.annotations, tag8, value6)
    });
  },
  annotateContext(context17) {
    return makeProto({
      _tag: this._tag,
      payloadSchema: this.payloadSchema,
      successSchema: this.successSchema,
      errorSchema: this.errorSchema,
      middlewares: this.middlewares,
      annotations: merge3(this.annotations, context17)
    });
  }
};
var makeProto = /* @__PURE__ */ __name((options4) => {
  function Rpc() {
  }
  __name(Rpc, "Rpc");
  Object.setPrototypeOf(Rpc, Proto7);
  Object.assign(Rpc, options4);
  Rpc.key = `@effect/rpc/Rpc/${options4._tag}`;
  return Rpc;
}, "makeProto");
var make91 = /* @__PURE__ */ __name((tag8, options4) => {
  const successSchema2 = options4?.success ?? Void;
  const errorSchema = options4?.error ?? Never;
  let payloadSchema;
  if (options4?.primaryKey) {
    payloadSchema = class Payload extends Class6(`@effect/rpc/Rpc/${tag8}`)(options4.payload) {
      static {
        __name(this, "Payload");
      }
      [symbol4]() {
        return options4.primaryKey(this);
      }
    };
  } else {
    payloadSchema = isSchema(options4?.payload) ? options4?.payload : options4?.payload ? Struct(options4?.payload) : Void;
  }
  return makeProto({
    _tag: tag8,
    payloadSchema,
    successSchema: options4?.stream ? Stream2({
      success: successSchema2,
      failure: errorSchema
    }) : successSchema2,
    errorSchema: options4?.stream ? Never : errorSchema,
    annotations: empty10(),
    middlewares: /* @__PURE__ */ new Set()
  });
}, "make");
var fromTaggedRequest = /* @__PURE__ */ __name((schema4) => makeProto({
  _tag: schema4._tag,
  payloadSchema: schema4,
  successSchema: schema4.success,
  errorSchema: schema4.failure,
  annotations: empty10(),
  middlewares: /* @__PURE__ */ new Set()
}), "fromTaggedRequest");
var exitSchemaCache2 = /* @__PURE__ */ globalValue("@effect/rpc/Rpc/exitSchemaCache", () => /* @__PURE__ */ new WeakMap());
var exitSchema2 = /* @__PURE__ */ __name((self2) => {
  if (exitSchemaCache2.has(self2)) {
    return exitSchemaCache2.get(self2);
  }
  const rpc = self2;
  const failures3 = /* @__PURE__ */ new Set([rpc.errorSchema]);
  const streamSchemas = getStreamSchemas(rpc.successSchema.ast);
  if (isSome2(streamSchemas)) {
    failures3.add(streamSchemas.value.failure);
  }
  for (const middleware2 of rpc.middlewares) {
    failures3.add(middleware2.failure);
  }
  const schema4 = Exit({
    success: isSome2(streamSchemas) ? Void : rpc.successSchema,
    failure: Union2(...failures3),
    defect: Defect
  });
  exitSchemaCache2.set(self2, schema4);
  return schema4;
}, "exitSchema");
var ForkTypeId = /* @__PURE__ */ Symbol.for("@effect/rpc/Rpc/Fork");
var fork4 = /* @__PURE__ */ __name((value6) => ({
  [ForkTypeId]: ForkTypeId,
  value: value6
}), "fork");
var isFork = /* @__PURE__ */ __name((u) => ForkTypeId in u, "isFork");

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/RpcClient.js
var RpcClient_exports = {};
__export(RpcClient_exports, {
  Protocol: () => Protocol,
  currentHeaders: () => currentHeaders,
  layerProtocolHttp: () => layerProtocolHttp,
  layerProtocolSocket: () => layerProtocolSocket,
  layerProtocolWorker: () => layerProtocolWorker,
  make: () => make92,
  makeNoSerialization: () => makeNoSerialization,
  makeProtocolHttp: () => makeProtocolHttp,
  makeProtocolSocket: () => makeProtocolSocket,
  makeProtocolWorker: () => makeProtocolWorker,
  withHeaders: () => withHeaders,
  withHeadersEffect: () => withHeadersEffect
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/internal/utils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var withRun = /* @__PURE__ */ __name(() => (f) => suspend4(() => {
  const semaphore = unsafeMakeSemaphore2(1);
  let buffer4 = [];
  let write3 = /* @__PURE__ */ __name((...args2) => contextWith2((context17) => {
    buffer4.push([args2, context17]);
  }), "write");
  return map22(f((...args2) => write3(...args2)), (a) => ({
    ...a,
    run(f2) {
      return semaphore.withPermits(1)(gen4(function* () {
        const prev = write3;
        write3 = f2;
        for (const [args2, context17] of buffer4) {
          yield* provide2(write3(...args2), context17);
        }
        buffer4 = [];
        return yield* onExit3(never4, () => {
          write3 = prev;
          return _void;
        });
      }));
    }
  }));
}), "withRun");

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/RpcClientError.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId47 = /* @__PURE__ */ Symbol.for("@effect/rpc/RpcClientError");
var RpcClientError = class extends (/* @__PURE__ */ TaggedError2("@effect/rpc/RpcClientError")("RpcClientError", {
  reason: /* @__PURE__ */ Literal2("Protocol", "Unknown"),
  message: String$,
  cause: /* @__PURE__ */ optional(Defect)
})) {
  static {
    __name(this, "RpcClientError");
  }
  /**
   * @since 1.0.0
   */
  [TypeId47] = TypeId47;
};

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/RpcMessage.js
var RpcMessage_exports = {};
__export(RpcMessage_exports, {
  RequestId: () => RequestId,
  RequestIdTypeId: () => RequestIdTypeId,
  ResponseDefectEncoded: () => ResponseDefectEncoded,
  ResponseIdTypeId: () => ResponseIdTypeId,
  constEof: () => constEof,
  constPing: () => constPing,
  constPong: () => constPong
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var RequestIdTypeId = /* @__PURE__ */ Symbol.for("@effect/rpc/RpcServer/RequestId");
var RequestId = /* @__PURE__ */ __name((id4) => typeof id4 === "bigint" ? id4 : BigInt(id4), "RequestId");
var constEof = {
  _tag: "Eof"
};
var constPing = {
  _tag: "Ping"
};
var ResponseIdTypeId = /* @__PURE__ */ Symbol.for("@effect/rpc/RpcServer/ResponseId");
var encodeDefect = /* @__PURE__ */ encodeSync(Defect);
var ResponseDefectEncoded = /* @__PURE__ */ __name((input) => ({
  _tag: "Defect",
  defect: encodeDefect(input)
}), "ResponseDefectEncoded");
var constPong = {
  _tag: "Pong"
};

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/RpcSerialization.js
var RpcSerialization_exports = {};
__export(RpcSerialization_exports, {
  RpcSerialization: () => RpcSerialization,
  json: () => json5,
  jsonRpc: () => jsonRpc,
  layerJson: () => layerJson,
  layerJsonRpc: () => layerJsonRpc,
  layerMsgPack: () => layerMsgPack,
  layerNdJsonRpc: () => layerNdJsonRpc,
  layerNdjson: () => layerNdjson,
  msgPack: () => msgPack,
  ndJsonRpc: () => ndJsonRpc,
  ndjson: () => ndjson
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var RpcSerialization = class extends (/* @__PURE__ */ Tag2("@effect/rpc/RpcSerialization")()) {
  static {
    __name(this, "RpcSerialization");
  }
};
var json5 = /* @__PURE__ */ RpcSerialization.of({
  contentType: "application/json",
  includesFraming: false,
  unsafeMake: /* @__PURE__ */ __name(() => {
    const decoder4 = new TextDecoder();
    return {
      decode: /* @__PURE__ */ __name((bytes) => [JSON.parse(typeof bytes === "string" ? bytes : decoder4.decode(bytes))], "decode"),
      encode: /* @__PURE__ */ __name((response) => JSON.stringify(response), "encode")
    };
  }, "unsafeMake")
});
var ndjson = /* @__PURE__ */ RpcSerialization.of({
  contentType: "application/ndjson",
  includesFraming: true,
  unsafeMake: /* @__PURE__ */ __name(() => {
    const decoder4 = new TextDecoder();
    let buffer4 = "";
    return {
      decode: /* @__PURE__ */ __name((bytes) => {
        buffer4 += typeof bytes === "string" ? bytes : decoder4.decode(bytes);
        let position5 = 0;
        let nlIndex = buffer4.indexOf("\n", position5);
        const items = [];
        while (nlIndex !== -1) {
          const item = JSON.parse(buffer4.slice(position5, nlIndex));
          items.push(item);
          position5 = nlIndex + 1;
          nlIndex = buffer4.indexOf("\n", position5);
        }
        buffer4 = buffer4.slice(position5);
        return items;
      }, "decode"),
      encode: /* @__PURE__ */ __name((response) => {
        if (Array.isArray(response)) {
          if (response.length === 0) return void 0;
          let data = "";
          for (let i = 0; i < response.length; i++) {
            data += JSON.stringify(response[i]) + "\n";
          }
          return data;
        }
        return JSON.stringify(response) + "\n";
      }, "encode")
    };
  }, "unsafeMake")
});
var jsonRpc = /* @__PURE__ */ __name((options4) => RpcSerialization.of({
  contentType: options4?.contentType ?? "application/json",
  includesFraming: false,
  unsafeMake: /* @__PURE__ */ __name(() => {
    const decoder4 = new TextDecoder();
    const batches = /* @__PURE__ */ new Map();
    return {
      decode: /* @__PURE__ */ __name((bytes) => {
        const decoded = JSON.parse(typeof bytes === "string" ? bytes : decoder4.decode(bytes));
        return decodeJsonRpcRaw(decoded, batches);
      }, "decode"),
      encode: /* @__PURE__ */ __name((response) => {
        if (Array.isArray(response)) {
          if (response.length === 0) return void 0;
          return JSON.stringify(response.map(encodeJsonRpcMessage));
        }
        const encoded = encodeJsonRpcRaw(response, batches);
        return encoded && JSON.stringify(encoded);
      }, "encode")
    };
  }, "unsafeMake")
}), "jsonRpc");
var ndJsonRpc = /* @__PURE__ */ __name((options4) => RpcSerialization.of({
  contentType: options4?.contentType ?? "application/json-rpc",
  includesFraming: true,
  unsafeMake: /* @__PURE__ */ __name(() => {
    const parser = ndjson.unsafeMake();
    const batches = /* @__PURE__ */ new Map();
    return {
      decode: /* @__PURE__ */ __name((bytes) => {
        const frames = parser.decode(bytes);
        if (frames.length === 0) return [];
        const messages = [];
        for (let i = 0; i < frames.length; i++) {
          const frame = frames[i];
          messages.push(...decodeJsonRpcRaw(frame, batches));
        }
        return messages;
      }, "decode"),
      encode: /* @__PURE__ */ __name((response) => {
        if (Array.isArray(response)) {
          return parser.encode(response.map(encodeJsonRpcMessage));
        }
        const encoded = encodeJsonRpcRaw(response, batches);
        return encoded && parser.encode(encoded);
      }, "encode")
    };
  }, "unsafeMake")
}), "ndJsonRpc");
function decodeJsonRpcRaw(decoded, batches) {
  if (Array.isArray(decoded)) {
    const batch = {
      size: 0,
      responses: /* @__PURE__ */ new Map()
    };
    const messages = [];
    for (let i = 0; i < decoded.length; i++) {
      const message = decodeJsonRpcMessage(decoded[i]);
      if (message._tag === "Request") {
        batch.size++;
        batches.set(message.id, batch);
      }
    }
    return messages;
  }
  return Array.isArray(decoded) ? decoded.map(decodeJsonRpcMessage) : [decodeJsonRpcMessage(decoded)];
}
__name(decodeJsonRpcRaw, "decodeJsonRpcRaw");
function decodeJsonRpcMessage(decoded) {
  if ("method" in decoded) {
    if (!decoded.id && decoded.method.startsWith("@effect/rpc/")) {
      const tag8 = decoded.method.slice("@effect/rpc/".length);
      const requestId2 = decoded.params?.requestId;
      return requestId2 ? {
        _tag: tag8,
        requestId: String(requestId2)
      } : {
        _tag: tag8
      };
    }
    return {
      _tag: "Request",
      id: decoded.id ? String(decoded.id) : "",
      tag: decoded.method,
      payload: decoded.params,
      headers: decoded.headers ?? [],
      traceId: decoded.traceId,
      spanId: decoded.spanId,
      sampled: decoded.sampled
    };
  } else if (decoded.error && decoded.error._tag === "Defect") {
    return {
      _tag: "Defect",
      defect: decoded.error.data
    };
  } else if (decoded.chunk === true) {
    return {
      _tag: "Chunk",
      requestId: String(decoded.id),
      values: decoded.result
    };
  }
  return {
    _tag: "Exit",
    requestId: String(decoded.id),
    exit: decoded.error != null ? {
      _tag: "Failure",
      cause: decoded.error._tag === "Cause" ? decoded.error.data : {
        _tag: "Die",
        defect: decoded.error
      }
    } : {
      _tag: "Success",
      value: decoded.result
    }
  };
}
__name(decodeJsonRpcMessage, "decodeJsonRpcMessage");
function encodeJsonRpcRaw(response, batches) {
  if (!("requestId" in response)) {
    return encodeJsonRpcMessage(response);
  }
  const batch = batches.get(response.requestId);
  if (batch) {
    batches.delete(response.requestId);
    batch.responses.set(response.requestId, response);
    if (batch.size === batch.responses.size) {
      return Array.from(batch.responses.values(), encodeJsonRpcMessage);
    }
    return void 0;
  }
  return encodeJsonRpcMessage(response);
}
__name(encodeJsonRpcRaw, "encodeJsonRpcRaw");
function encodeJsonRpcMessage(response) {
  switch (response._tag) {
    case "Request":
      return {
        jsonrpc: "2.0",
        method: response.tag,
        params: response.payload,
        id: response.id && Number(response.id),
        headers: response.headers,
        traceId: response.traceId,
        spanId: response.spanId,
        sampled: response.sampled
      };
    case "Ping":
    case "Pong":
    case "Interrupt":
    case "Ack":
    case "Eof":
      return {
        jsonrpc: "2.0",
        method: `@effect/rpc/${response._tag}`,
        params: "requestId" in response ? {
          requestId: response.requestId
        } : void 0
      };
    case "Chunk":
      return {
        jsonrpc: "2.0",
        chunk: true,
        id: Number(response.requestId),
        result: response.values
      };
    case "Exit":
      return {
        jsonrpc: "2.0",
        id: response.requestId ? Number(response.requestId) : void 0,
        result: response.exit._tag === "Success" ? response.exit.value : void 0,
        error: response.exit._tag === "Failure" ? {
          _tag: "Cause",
          code: response.exit.cause._tag === "Fail" && hasProperty(response.exit.cause.error, "code") ? Number(response.exit.cause.error.code) : 0,
          message: response.exit.cause._tag === "Fail" && hasProperty(response.exit.cause.error, "message") ? response.exit.cause.error.message : JSON.stringify(response.exit.cause),
          data: response.exit.cause
        } : void 0
      };
    case "Defect":
      return {
        jsonrpc: "2.0",
        id: jsonRpcInternalError,
        error: {
          _tag: "Defect",
          code: 1,
          message: "A defect occurred",
          data: response.defect
        }
      };
    case "ClientProtocolError":
      return {};
  }
}
__name(encodeJsonRpcMessage, "encodeJsonRpcMessage");
var jsonRpcInternalError = -32603;
var msgPack = /* @__PURE__ */ RpcSerialization.of({
  contentType: "application/msgpack",
  includesFraming: true,
  unsafeMake: /* @__PURE__ */ __name(() => {
    const unpackr = new msgpackr_exports.Unpackr();
    const packr = new msgpackr_exports.Packr();
    const encoder3 = new TextEncoder();
    return {
      decode: /* @__PURE__ */ __name((bytes) => unpackr.unpackMultiple(typeof bytes === "string" ? encoder3.encode(bytes) : bytes), "decode"),
      encode: /* @__PURE__ */ __name((response) => packr.pack(response), "encode")
    };
  }, "unsafeMake")
});
var layerJson = /* @__PURE__ */ succeed13(RpcSerialization, json5);
var layerNdjson = /* @__PURE__ */ succeed13(RpcSerialization, ndjson);
var layerJsonRpc = /* @__PURE__ */ __name((options4) => succeed13(RpcSerialization, jsonRpc(options4)), "layerJsonRpc");
var layerNdJsonRpc = /* @__PURE__ */ __name((options4) => succeed13(RpcSerialization, ndJsonRpc(options4)), "layerNdJsonRpc");
var layerMsgPack = /* @__PURE__ */ succeed13(RpcSerialization, msgPack);

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/RpcWorker.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var InitialMessage = class extends (/* @__PURE__ */ Tag2("@effect/rpc/RpcWorker/InitialMessage")()) {
  static {
    __name(this, "InitialMessage");
  }
};

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/RpcClient.js
var requestIdCounter = /* @__PURE__ */ BigInt(0);
var makeNoSerialization = /* @__PURE__ */ fnUntraced2(function* (group5, options4) {
  const spanPrefix = options4?.spanPrefix ?? "RpcClient";
  const supportsAck = options4?.supportsAck ?? true;
  const disableTracing = options4?.disableTracing ?? false;
  const generateRequestId = options4?.generateRequestId ?? (() => requestIdCounter++);
  const context17 = yield* context4();
  const scope5 = get6(context17, Scope);
  const entries3 = /* @__PURE__ */ new Map();
  let isShutdown8 = false;
  yield* addFinalizer2(scope5, fiberIdWith2((fiberId5) => {
    isShutdown8 = true;
    return clearEntries(interrupt3(fiberId5));
  }));
  const clearEntries = fnUntraced2(function* (exit5) {
    for (const [id4, entry] of entries3) {
      entries3.delete(id4);
      if (entry._tag === "Mailbox") {
        yield* entry.mailbox.done(exit5);
      } else {
        entry.resume(exit5);
      }
    }
  });
  const onRequest = /* @__PURE__ */ __name((rpc) => {
    const isStream3 = isStreamSchema(rpc.successSchema);
    const middleware2 = getRpcClientMiddleware(rpc);
    return (payload, opts) => {
      const headers = opts?.headers ? fromInput(opts.headers) : empty34;
      const context18 = opts?.context ?? empty10();
      if (!isStream3) {
        const onRequest2 = /* @__PURE__ */ __name((span4) => onEffectRequest(rpc, middleware2, span4, rpc.payloadSchema.make ? rpc.payloadSchema.make(payload) : payload, headers, context18, opts?.discard ?? false), "onRequest");
        return disableTracing ? onRequest2(void 0) : useSpan2(`${spanPrefix}.${rpc._tag}`, {
          captureStackTrace: false,
          attributes: options4.spanAttributes
        }, onRequest2);
      }
      const mailbox = onStreamRequest(rpc, middleware2, rpc.payloadSchema.make ? rpc.payloadSchema.make(payload) : payload, headers, opts?.streamBufferSize ?? 16, context18);
      if (opts?.asMailbox) return mailbox;
      return unwrapScoped5(map22(mailbox, toStream2));
    };
  }, "onRequest");
  const onEffectRequest = /* @__PURE__ */ __name((rpc, middleware2, span4, payload, headers, context18, discard3) => withFiberRuntime2((parentFiber) => {
    if (isShutdown8) {
      return interrupt7;
    }
    const id4 = generateRequestId();
    const send2 = middleware2({
      _tag: "Request",
      id: id4,
      tag: rpc._tag,
      payload,
      traceId: span4?.traceId,
      spanId: span4?.spanId,
      sampled: span4?.sampled,
      headers: merge9(parentFiber.getFiberRef(currentHeaders), headers)
    });
    if (discard3) {
      return flatMap15(send2, (message) => options4.onFromClient({
        message,
        context: context18,
        discard: discard3
      }));
    }
    const runtime8 = make57({
      context: parentFiber.currentContext,
      fiberRefs: parentFiber.getFiberRefs(),
      runtimeFlags: defaultRuntime2.runtimeFlags
    });
    let fiber;
    return onInterrupt2(async2((resume2) => {
      const entry = {
        _tag: "Effect",
        rpc,
        context: context18,
        resume(exit5) {
          resume2(exit5);
          if (fiber && !fiber.unsafePoll()) {
            parentFiber.currentScheduler.scheduleTask(() => {
              fiber.unsafeInterruptAsFork(parentFiber.id());
            }, 0);
          }
        }
      };
      entries3.set(id4, entry);
      fiber = send2.pipe(flatMap15((request2) => options4.onFromClient({
        message: request2,
        context: context18,
        discard: discard3
      })), span4 ? withParentSpan3(span4) : identity, runFork3(runtime8));
      fiber.addObserver((exit5) => {
        if (exit5._tag === "Failure") {
          return resume2(exit5);
        }
      });
    }), (interruptors3) => {
      entries3.delete(id4);
      const ids3 = Array.from(interruptors3).flatMap((id5) => Array.from(toSet2(id5)));
      return zipRight7(interrupt5(fiber), sendInterrupt(id4, ids3, context18));
    });
  }), "onEffectRequest");
  const onStreamRequest = fnUntraced2(function* (rpc, middleware2, payload, headers, streamBufferSize, context18) {
    if (isShutdown8) {
      return yield* interrupt7;
    }
    const span4 = disableTracing ? void 0 : yield* makeSpanScoped2(`${spanPrefix}.${rpc._tag}`, {
      captureStackTrace: false,
      attributes: options4.spanAttributes
    });
    const fiber = getOrThrow2(getCurrentFiber2());
    const id4 = generateRequestId();
    const scope6 = unsafeGet5(fiber.currentContext, Scope);
    yield* addFinalizerExit(scope6, (exit5) => {
      if (!entries3.has(id4)) return _void;
      entries3.delete(id4);
      return sendInterrupt(id4, isFailure3(exit5) ? Array.from(interruptors2(exit5.cause)).flatMap((id5) => Array.from(toSet2(id5))) : [], context18);
    });
    const mailbox = yield* make77(streamBufferSize);
    entries3.set(id4, {
      _tag: "Mailbox",
      rpc,
      mailbox,
      scope: scope6,
      context: context18
    });
    yield* middleware2({
      _tag: "Request",
      id: id4,
      tag: rpc._tag,
      traceId: span4?.traceId,
      payload,
      spanId: span4?.spanId,
      sampled: span4?.sampled,
      headers: merge9(fiber.getFiberRef(currentHeaders), headers)
    }).pipe(flatMap15((request2) => options4.onFromClient({
      message: request2,
      context: context18,
      discard: false
    })), span4 ? withParentSpan3(span4) : identity, catchAllCause3((error5) => mailbox.failCause(error5)), interruptible4, forkIn2(scope6));
    return mailbox;
  });
  const getRpcClientMiddleware = /* @__PURE__ */ __name((rpc) => {
    const middlewares = [];
    for (const tag8 of rpc.middlewares.values()) {
      const middleware2 = context17.unsafeMap.get(`${tag8.key}/Client`);
      if (!middleware2) continue;
      middlewares.push(middleware2);
    }
    return middlewares.length === 0 ? succeed11 : function(request2) {
      let i = 0;
      return map22(whileLoop3({
        while: /* @__PURE__ */ __name(() => i < middlewares.length, "while"),
        body: /* @__PURE__ */ __name(() => middlewares[i]({
          rpc,
          request: request2
        }), "body"),
        step(nextRequest) {
          request2 = nextRequest;
          i++;
        }
      }), () => request2);
    };
  }, "getRpcClientMiddleware");
  const sendInterrupt = /* @__PURE__ */ __name((requestId2, interruptors3, context18) => async2((resume2) => {
    const parentFiber = getOrThrow2(getCurrentFiber2());
    const runtime8 = make57({
      context: parentFiber.currentContext,
      fiberRefs: parentFiber.getFiberRefs(),
      runtimeFlags: defaultRuntime2.runtimeFlags
    });
    const fiber = options4.onFromClient({
      message: {
        _tag: "Interrupt",
        requestId: requestId2,
        interruptors: interruptors3
      },
      context: context18,
      discard: false
    }).pipe(timeout2(1e3), runFork3(runtime8));
    fiber.addObserver(() => {
      resume2(_void);
    });
  }), "sendInterrupt");
  const write3 = /* @__PURE__ */ __name((message) => {
    switch (message._tag) {
      case "Chunk": {
        const requestId2 = message.requestId;
        const entry = entries3.get(requestId2);
        if (!entry || entry._tag !== "Mailbox") return _void;
        return entry.mailbox.offerAll(message.values).pipe(supportsAck ? zipRight7(options4.onFromClient({
          message: {
            _tag: "Ack",
            requestId: message.requestId
          },
          context: entry.context,
          discard: false
        })) : identity, catchAllCause3((cause3) => entry.mailbox.done(failCause3(cause3))));
      }
      case "Exit": {
        const requestId2 = message.requestId;
        const entry = entries3.get(requestId2);
        if (!entry) return _void;
        entries3.delete(requestId2);
        if (entry._tag === "Effect") {
          entry.resume(message.exit);
          return _void;
        }
        return entry.mailbox.done(asVoid3(message.exit));
      }
      case "Defect": {
        return clearEntries(die3(message.defect));
      }
      case "ClientEnd": {
        return _void;
      }
    }
  }, "write");
  let client;
  if (options4.flatten) {
    const fns = /* @__PURE__ */ new Map();
    client = /* @__PURE__ */ __name(function client2(tag8, payload, options5) {
      let fn2 = fns.get(tag8);
      if (!fn2) {
        fn2 = onRequest(group5.requests.get(tag8));
        fns.set(tag8, fn2);
      }
      return fn2(payload, options5);
    }, "client");
  } else {
    client = {};
    for (const rpc of group5.requests.values()) {
      const dot = rpc._tag.indexOf(".");
      const prefix = dot === -1 ? void 0 : rpc._tag.slice(0, dot);
      if (prefix !== void 0 && !(prefix in client)) {
        ;
        client[prefix] = {};
      }
      const target3 = prefix !== void 0 ? client[prefix] : client;
      const tag8 = prefix !== void 0 ? rpc._tag.slice(dot + 1) : rpc._tag;
      target3[tag8] = onRequest(rpc);
    }
  }
  return {
    client,
    write: write3
  };
});
var make92 = /* @__PURE__ */ fnUntraced2(function* (group5, options4) {
  const {
    run: run10,
    send: send2,
    supportsAck,
    supportsTransferables
  } = yield* Protocol;
  const entries3 = /* @__PURE__ */ new Map();
  const {
    client,
    write: write3
  } = yield* makeNoSerialization(group5, {
    ...options4,
    supportsAck,
    onFromClient({
      message
    }) {
      switch (message._tag) {
        case "Request": {
          const rpc = group5.requests.get(message.tag);
          const schemas = getStreamSchemas(rpc.successSchema.ast);
          const collector = supportsTransferables ? unsafeMakeCollector() : void 0;
          const fiber = getOrThrow2(getCurrentFiber2());
          const entry = {
            rpc,
            context: collector ? add4(fiber.currentContext, Collector, collector) : fiber.currentContext,
            decodeChunk: isSome2(schemas) ? decodeUnknown3(NonEmptyArray(schemas.value.success)) : void 0
          };
          entries3.set(message.id, entry);
          return encode5(rpc.payloadSchema)(message.payload).pipe(locally2(currentContext2, entry.context), orDie3, flatMap15((payload) => send2({
            ...message,
            id: String(message.id),
            payload,
            headers: Object.entries(message.headers)
          }, collector && collector.unsafeClear())));
        }
        case "Ack": {
          const entry = entries3.get(message.requestId);
          if (!entry) return _void;
          return send2({
            _tag: "Ack",
            requestId: String(message.requestId)
          });
        }
        case "Interrupt": {
          const entry = entries3.get(message.requestId);
          if (!entry) return _void;
          entries3.delete(message.requestId);
          return send2({
            _tag: "Interrupt",
            requestId: String(message.requestId)
          });
        }
        case "Eof": {
          return _void;
        }
      }
    }
  });
  yield* run10((message) => {
    switch (message._tag) {
      case "Chunk": {
        const requestId2 = RequestId(message.requestId);
        const entry = entries3.get(requestId2);
        if (!entry || !entry.decodeChunk) return _void;
        return entry.decodeChunk(message.values).pipe(locally2(currentContext2, entry.context), orDie3, flatMap15((chunk4) => write3({
          _tag: "Chunk",
          clientId: 0,
          requestId: RequestId(message.requestId),
          values: chunk4
        })), onError2((cause3) => write3({
          _tag: "Exit",
          clientId: 0,
          requestId: RequestId(message.requestId),
          exit: failCause3(cause3)
        })));
      }
      case "Exit": {
        const requestId2 = RequestId(message.requestId);
        const entry = entries3.get(requestId2);
        if (!entry) return _void;
        entries3.delete(requestId2);
        return decode6(exitSchema2(entry.rpc))(message.exit).pipe(locally2(currentContext2, entry.context), orDie3, matchCauseEffect3({
          onSuccess: /* @__PURE__ */ __name((exit5) => write3({
            _tag: "Exit",
            clientId: 0,
            requestId: requestId2,
            exit: exit5
          }), "onSuccess"),
          onFailure: /* @__PURE__ */ __name((cause3) => write3({
            _tag: "Exit",
            clientId: 0,
            requestId: requestId2,
            exit: failCause3(cause3)
          }), "onFailure")
        }));
      }
      case "Defect": {
        return write3({
          _tag: "Defect",
          clientId: 0,
          defect: decodeDefect(message.defect)
        });
      }
      case "ClientProtocolError": {
        const exit5 = fail3(message.error);
        return forEach11(entries3.keys(), (requestId2) => write3({
          _tag: "Exit",
          clientId: 0,
          requestId: requestId2,
          exit: exit5
        }));
      }
      default: {
        return _void;
      }
    }
  }).pipe(catchAllCause3(logError2), interruptible4, forkScoped2);
  return client;
});
var currentHeaders = /* @__PURE__ */ globalValue("@effect/rpc/RpcClient/currentHeaders", () => unsafeMake11(empty34));
var withHeaders = /* @__PURE__ */ dual(2, (effect4, headers) => locallyWith(effect4, currentHeaders, merge9(fromInput(headers))));
var withHeadersEffect = /* @__PURE__ */ dual(2, (effect4, headers) => flatMap15(headers, (headers2) => withHeaders(effect4, headers2)));
var Protocol = class extends (/* @__PURE__ */ Tag2("@effect/rpc/RpcClient/Protocol")()) {
  static {
    __name(this, "Protocol");
  }
  /**
   * @since 1.0.0
   */
  static make = /* @__PURE__ */ withRun();
};
var makeProtocolHttp = /* @__PURE__ */ __name((client) => Protocol.make(fnUntraced2(function* (writeResponse) {
  const serialization = yield* RpcSerialization;
  const isJson = serialization.contentType === "application/json";
  const send2 = /* @__PURE__ */ __name((request2) => {
    if (request2._tag !== "Request") {
      return _void;
    }
    const parser = serialization.unsafeMake();
    const encoded = parser.encode(request2);
    const body = typeof encoded === "string" ? text2(encoded, serialization.contentType) : uint8Array3(encoded, serialization.contentType);
    if (isJson) {
      return client.post("", {
        body
      }).pipe(flatMap15((r) => r.json), mapError4((cause3) => new RpcClientError({
        reason: "Protocol",
        message: "Failed to send HTTP request",
        cause: cause3
      })), flatMap15((u) => {
        if (!Array.isArray(u)) {
          return dieMessage2(`Expected an array of responses, but got: ${u}`);
        }
        let i = 0;
        return whileLoop3({
          while: /* @__PURE__ */ __name(() => i < u.length, "while"),
          body: /* @__PURE__ */ __name(() => writeResponse(u[i++]), "body"),
          step: constVoid
        });
      }));
    }
    return client.post("", {
      body
    }).pipe(flatMap15((r) => runForEachChunk2(r.stream, (chunk4) => {
      const responses = toReadonlyArray(chunk4).flatMap(parser.decode);
      if (responses.length === 0) return _void;
      let i = 0;
      return whileLoop3({
        while: /* @__PURE__ */ __name(() => i < responses.length, "while"),
        body: /* @__PURE__ */ __name(() => writeResponse(responses[i++]), "body"),
        step: constVoid
      });
    })), mapError4((cause3) => new RpcClientError({
      reason: "Protocol",
      message: "Failed to send HTTP request",
      cause: cause3
    })));
  }, "send");
  return {
    send: send2,
    supportsAck: false,
    supportsTransferables: false
  };
})), "makeProtocolHttp");
var layerProtocolHttp = /* @__PURE__ */ __name((options4) => scoped4(Protocol, flatMap15(HttpClient, (client) => {
  client = mapRequest2(client, prependUrl2(options4.url));
  return makeProtocolHttp(options4.transformClient ? options4.transformClient(client) : client);
})), "layerProtocolHttp");
var makeProtocolSocket = /* @__PURE__ */ __name((options4) => Protocol.make(fnUntraced2(function* (writeResponse) {
  const socket = yield* Socket;
  const serialization = yield* RpcSerialization;
  const write3 = yield* socket.writer;
  let parser = serialization.unsafeMake();
  const pinger = yield* makePinger(write3(parser.encode(constPing)));
  yield* suspend4(() => {
    parser = serialization.unsafeMake();
    pinger.reset();
    return socket.runRaw((message) => {
      try {
        const responses = parser.decode(message);
        if (responses.length === 0) return;
        let i = 0;
        return whileLoop3({
          while: /* @__PURE__ */ __name(() => i < responses.length, "while"),
          body: /* @__PURE__ */ __name(() => {
            const response = responses[i++];
            if (response._tag === "Pong") {
              pinger.onPong();
            }
            return writeResponse(response);
          }, "body"),
          step: constVoid
        });
      } catch (defect) {
        return writeResponse({
          _tag: "ClientProtocolError",
          error: new RpcClientError({
            reason: "Protocol",
            message: "Error decoding message",
            cause: fail5(defect)
          })
        });
      }
    }).pipe(raceFirst2(zipRight7(pinger.timeout, fail10(new SocketGenericError({
      reason: "OpenTimeout",
      cause: new Error("ping timeout")
    })))));
  }).pipe(zipRight7(fail10(new SocketCloseError({
    reason: "Close",
    code: 1e3
  }))), tapErrorCause3((cause3) => {
    const error5 = failureOption2(cause3);
    if (options4?.retryTransientErrors && isSome2(error5) && (error5.value.reason === "Open" || error5.value.reason === "OpenTimeout")) {
      return _void;
    }
    return writeResponse({
      _tag: "ClientProtocolError",
      error: new RpcClientError({
        reason: "Protocol",
        message: "Error in socket",
        cause: squash(cause3)
      })
    });
  }), retry2(spaced2(1e3)), annotateLogs3({
    module: "RpcClient",
    method: "makeProtocolSocket"
  }), interruptible4, forkScoped2);
  return {
    send(request2) {
      const encoded = parser.encode(request2);
      if (encoded === void 0) return _void;
      return orDie3(write3(encoded));
    },
    supportsAck: true,
    supportsTransferables: false
  };
})), "makeProtocolSocket");
var makePinger = /* @__PURE__ */ fnUntraced2(function* (writePing) {
  let recievedPong = true;
  const latch = unsafeMakeLatch2();
  const reset2 = /* @__PURE__ */ __name(() => {
    recievedPong = true;
    latch.unsafeClose();
  }, "reset");
  const onPong = /* @__PURE__ */ __name(() => {
    recievedPong = true;
  }, "onPong");
  yield* suspend4(() => {
    if (!recievedPong) return latch.open;
    recievedPong = false;
    return writePing;
  }).pipe(delay2("10 seconds"), ignore2, forever3, interruptible4, forkScoped2);
  return {
    timeout: latch.await,
    reset: reset2,
    onPong
  };
});
var makeProtocolWorker = /* @__PURE__ */ __name((options4) => Protocol.make(fnUntraced2(function* (writeResponse) {
  const worker = yield* PlatformWorker2;
  const scope5 = yield* scope3;
  let workerId = 0;
  const initialMessage = yield* serviceOption2(InitialMessage);
  const entries3 = /* @__PURE__ */ new Map();
  const acquire = gen4(function* () {
    const id4 = workerId++;
    const backing = yield* worker.spawn(id4);
    const readyLatch = yield* makeLatch2();
    yield* backing.run((message) => {
      if (message[0] === 0) {
        return readyLatch.open;
      }
      const response = message[1];
      if (response._tag === "Exit") {
        const entry = entries3.get(response.requestId);
        if (entry) {
          entries3.delete(response.requestId);
          entry.latch.unsafeOpen();
          return writeResponse(response);
        }
      } else if (response._tag === "Defect") {
        for (const [requestId2, entry] of entries3) {
          entries3.delete(requestId2);
          entry.latch.unsafeOpen();
        }
        return writeResponse(response);
      }
      return writeResponse(response);
    }).pipe(tapErrorCause3((cause3) => writeResponse({
      _tag: "ClientProtocolError",
      error: new RpcClientError({
        reason: "Protocol",
        message: "Error in worker",
        cause: squash(cause3)
      })
    })), retry2(spaced2(1e3)), annotateLogs3({
      module: "RpcClient",
      method: "makeProtocolWorker"
    }), interruptible4, forkScoped2);
    yield* readyLatch.await;
    if (isSome2(initialMessage)) {
      const [value6, transfers] = yield* initialMessage.value;
      yield* backing.send({
        _tag: "InitialMessage",
        value: value6
      }, transfers);
    }
    return backing;
  });
  const pool = "minSize" in options4 ? yield* makeWithTTL2({
    acquire,
    min: options4.minSize,
    max: options4.maxSize,
    concurrency: options4.concurrency,
    targetUtilization: options4.targetUtilization,
    timeToLive: options4.timeToLive
  }) : yield* make89({
    acquire,
    size: options4.size,
    concurrency: options4.concurrency,
    targetUtilization: options4.targetUtilization
  });
  yield* addFinalizer2(scope5, sync7(() => {
    for (const entry of entries3.values()) {
      entry.latch.unsafeOpen();
    }
    entries3.clear();
  }));
  const send2 = /* @__PURE__ */ __name((request2, transferables) => {
    switch (request2._tag) {
      case "Request": {
        return pool.get.pipe(flatMap15((worker2) => {
          const latch = unsafeMakeLatch2(false);
          entries3.set(request2.id, {
            worker: worker2,
            latch
          });
          return zipRight7(worker2.send(request2, transferables), latch.await);
        }), scoped3, orDie3);
      }
      case "Interrupt": {
        const entry = entries3.get(request2.requestId);
        if (!entry) return _void;
        entries3.delete(request2.requestId);
        entry.latch.unsafeOpen();
        return orDie3(entry.worker.send(request2));
      }
      case "Ack": {
        const entry = entries3.get(request2.requestId);
        if (!entry) return _void;
        return orDie3(entry.worker.send(request2));
      }
    }
    return _void;
  }, "send");
  yield* scoped3(pool.get);
  return {
    send: send2,
    supportsAck: true,
    supportsTransferables: true
  };
})), "makeProtocolWorker");
var layerProtocolWorker = /* @__PURE__ */ __name((options4) => scoped4(Protocol, makeProtocolWorker(options4)), "layerProtocolWorker");
var layerProtocolSocket = /* @__PURE__ */ __name((options4) => scoped4(Protocol, makeProtocolSocket(options4)), "layerProtocolSocket");
var decodeDefect = /* @__PURE__ */ decodeSync(Defect);

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/RpcGroup.js
var RpcGroup_exports = {};
__export(RpcGroup_exports, {
  TypeId: () => TypeId48,
  make: () => make93
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId48 = /* @__PURE__ */ Symbol.for("@effect/rpc/RpcGroup");
var RpcGroupProto = {
  add(...rpcs) {
    return makeProto2({
      requests: resolveInput(...this.requests.values(), ...rpcs),
      annotations: this.annotations
    });
  },
  merge(...groups) {
    const requests = new Map(this.requests);
    const annotations3 = new Map(this.annotations.unsafeMap);
    for (const group5 of groups) {
      for (const [tag8, rpc] of group5.requests) {
        requests.set(tag8, rpc);
      }
      for (const [key, value6] of group5.annotations.unsafeMap) {
        annotations3.set(key, value6);
      }
    }
    return makeProto2({
      requests,
      annotations: unsafeMake(annotations3)
    });
  },
  middleware(middleware2) {
    const requests = /* @__PURE__ */ new Map();
    for (const [tag8, rpc] of this.requests) {
      requests.set(tag8, rpc.middleware(middleware2));
    }
    return makeProto2({
      requests,
      annotations: this.annotations
    });
  },
  toHandlersContext(build3) {
    return gen4(this, function* () {
      const context17 = yield* context4();
      const handlers = isEffect2(build3) ? yield* build3 : build3;
      const contextMap = /* @__PURE__ */ new Map();
      for (const [tag8, handler] of Object.entries(handlers)) {
        const rpc = this.requests.get(tag8);
        contextMap.set(rpc.key, {
          handler,
          context: context17
        });
      }
      return unsafeMake(contextMap);
    });
  },
  prefix(prefix) {
    const requests = /* @__PURE__ */ new Map();
    for (const rpc of this.requests.values()) {
      const newRpc = rpc.prefix(prefix);
      requests.set(newRpc._tag, newRpc);
    }
    return makeProto2({
      requests,
      annotations: this.annotations
    });
  },
  toLayer(build3) {
    return scopedContext2(this.toHandlersContext(build3));
  },
  of: identity,
  toLayerHandler(tag8, build3) {
    return scopedContext2(gen4(this, function* () {
      const context17 = yield* context4();
      const handler = isEffect2(build3) ? yield* build3 : build3;
      const contextMap = /* @__PURE__ */ new Map();
      const rpc = this.requests.get(tag8);
      contextMap.set(rpc.key, {
        handler,
        context: context17
      });
      return unsafeMake(contextMap);
    }));
  },
  accessHandler(tag8) {
    return contextWith2((parentContext) => {
      const rpc = this.requests.get(tag8);
      const {
        context: context17,
        handler
      } = parentContext.unsafeMap.get(rpc.key);
      return (payload, headers) => {
        const result = handler(payload, headers);
        const effectOrStream = isFork(result) ? result.value : result;
        return isEffect2(effectOrStream) ? provide2(effectOrStream, context17) : provideContext8(effectOrStream, context17);
      };
    });
  },
  annotate(tag8, value6) {
    return makeProto2({
      requests: this.requests,
      annotations: add4(this.annotations, tag8, value6)
    });
  },
  annotateRpcs(tag8, value6) {
    return this.annotateRpcsContext(make11(tag8, value6));
  },
  annotateContext(context17) {
    return makeProto2({
      requests: this.requests,
      annotations: merge3(this.annotations, context17)
    });
  },
  annotateRpcsContext(context17) {
    const requests = /* @__PURE__ */ new Map();
    for (const [tag8, rpc] of this.requests) {
      requests.set(tag8, rpc.annotateContext(merge3(context17, rpc.annotations)));
    }
    return makeProto2({
      requests,
      annotations: this.annotations
    });
  }
};
var makeProto2 = /* @__PURE__ */ __name((options4) => Object.assign(function() {
}, RpcGroupProto, {
  requests: options4.requests,
  annotations: options4.annotations
}), "makeProto");
var resolveInput = /* @__PURE__ */ __name((...rpcs) => {
  const requests = /* @__PURE__ */ new Map();
  for (const rpc of rpcs) {
    requests.set(rpc._tag, isSchema(rpc) ? fromTaggedRequest(rpc) : rpc);
  }
  return requests;
}, "resolveInput");
var make93 = /* @__PURE__ */ __name((...rpcs) => makeProto2({
  requests: resolveInput(...rpcs),
  annotations: empty10()
}), "make");

// node_modules/.pnpm/@effect+rpc@0.68.4_@effect+platform@0.90.10_effect@3.19.13__effect@3.19.13/node_modules/@effect/rpc/dist/esm/RpcServer.js
var RpcServer_exports = {};
__export(RpcServer_exports, {
  Protocol: () => Protocol2,
  layer: () => layer11,
  layerHttpRouter: () => layerHttpRouter,
  layerProtocolHttp: () => layerProtocolHttp2,
  layerProtocolHttpRouter: () => layerProtocolHttpRouter,
  layerProtocolSocketServer: () => layerProtocolSocketServer,
  layerProtocolStdio: () => layerProtocolStdio,
  layerProtocolWebsocket: () => layerProtocolWebsocket,
  layerProtocolWebsocketRouter: () => layerProtocolWebsocketRouter,
  layerProtocolWorkerRunner: () => layerProtocolWorkerRunner,
  make: () => make94,
  makeNoSerialization: () => makeNoSerialization2,
  makeProtocolHttp: () => makeProtocolHttp2,
  makeProtocolHttpRouter: () => makeProtocolHttpRouter,
  makeProtocolSocketServer: () => makeProtocolSocketServer,
  makeProtocolStdio: () => makeProtocolStdio,
  makeProtocolWebsocket: () => makeProtocolWebsocket,
  makeProtocolWebsocketRouter: () => makeProtocolWebsocketRouter,
  makeProtocolWithHttpApp: () => makeProtocolWithHttpApp,
  makeProtocolWithHttpAppWebsocket: () => makeProtocolWithHttpAppWebsocket,
  makeProtocolWorkerRunner: () => makeProtocolWorkerRunner,
  toHttpApp: () => toHttpApp2,
  toHttpAppWebsocket: () => toHttpAppWebsocket,
  toWebHandler: () => toWebHandler2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeNoSerialization2 = /* @__PURE__ */ fnUntraced2(function* (group5, options4) {
  const enableTracing = options4.disableTracing !== true;
  const enableSpanPropagation = options4.disableSpanPropagation !== true;
  const supportsAck = options4.disableClientAcks !== true;
  const spanPrefix = options4.spanPrefix ?? "RpcServer";
  const concurrency = options4.concurrency ?? "unbounded";
  const disableFatalDefects = options4.disableFatalDefects ?? false;
  const context17 = yield* context4();
  const scope5 = get6(context17, Scope);
  const fiberSet = yield* make70();
  const runFork4 = yield* runtime5(fiberSet)().pipe(interruptible4);
  const concurrencySemaphore = concurrency === "unbounded" ? void 0 : yield* makeSemaphore2(concurrency);
  const clients = /* @__PURE__ */ new Map();
  let isShutdown8 = false;
  const shutdownLatch = unsafeMakeLatch2(false);
  yield* addFinalizer2(scope5, fiberIdWith2((fiberId5) => {
    isShutdown8 = true;
    for (const client of clients.values()) {
      client.ended = true;
      if (client.fibers.size === 0) {
        runFork4(endClient(client));
        continue;
      }
      for (const fiber of client.fibers.values()) {
        fiber.unsafeInterruptAsFork(fiberId5);
      }
    }
    if (clients.size === 0) {
      return _void;
    }
    return shutdownLatch.await;
  }));
  const disconnect4 = /* @__PURE__ */ __name((clientId2) => fiberIdWith2((fiberId5) => {
    const client = clients.get(clientId2);
    if (!client) return _void;
    for (const fiber of client.fibers.values()) {
      fiber.unsafeInterruptAsFork(fiberId5);
    }
    clients.delete(clientId2);
    return _void;
  }), "disconnect");
  const write3 = /* @__PURE__ */ __name((clientId2, message) => catchAllDefect2(withFiberRuntime2((requestFiber) => {
    if (isShutdown8) return interrupt7;
    let client = clients.get(clientId2);
    if (!client) {
      client = {
        id: clientId2,
        latches: /* @__PURE__ */ new Map(),
        fibers: /* @__PURE__ */ new Map(),
        ended: false
      };
      clients.set(clientId2, client);
    } else if (client.ended) {
      return interrupt7;
    }
    switch (message._tag) {
      case "Request": {
        return handleRequest(requestFiber, client, message);
      }
      case "Ack": {
        const latch = client.latches.get(message.requestId);
        return latch ? latch.open : _void;
      }
      case "Interrupt": {
        const fiber = client.fibers.get(message.requestId);
        return fiber ? interruptFork(fiber) : options4.onFromServer({
          _tag: "Exit",
          clientId: clientId2,
          requestId: message.requestId,
          exit: interrupt3(none4)
        });
      }
      case "Eof": {
        client.ended = true;
        if (client.fibers.size > 0) return _void;
        return endClient(client);
      }
      default: {
        return sendDefect(client, `Unknown request tag: ${message._tag}`);
      }
    }
  }), (defect) => sendDefect(clients.get(clientId2), defect)), "write");
  const endClient = /* @__PURE__ */ __name((client) => {
    clients.delete(client.id);
    const write4 = options4.onFromServer({
      _tag: "ClientEnd",
      clientId: client.id
    });
    if (isShutdown8 && clients.size === 0) {
      return zipRight7(write4, shutdownLatch.open);
    }
    return write4;
  }, "endClient");
  const handleRequest = /* @__PURE__ */ __name((requestFiber, client, request2) => {
    if (client.fibers.has(request2.id)) {
      return interrupt7;
    }
    const rpc = group5.requests.get(request2.tag);
    const entry = context17.unsafeMap.get(rpc?.key);
    if (!rpc || !entry) {
      const write4 = catchAllDefect2(options4.onFromServer({
        _tag: "Exit",
        clientId: client.id,
        requestId: request2.id,
        exit: die3(`Unknown request tag: ${request2.tag}`)
      }), (defect) => sendDefect(client, defect));
      if (!client.ended || client.fibers.size > 0) return write4;
      return zipRight7(write4, endClient(client));
    }
    const isStream3 = isStreamSchema(rpc.successSchema);
    const result = entry.handler(request2.payload, request2.headers);
    const isFork2 = isFork(result);
    const streamOrEffect = isFork2 ? result.value : result;
    let responded = false;
    let effect4 = uninterruptible2(matchCauseEffect3(interruptible4(applyMiddleware(rpc, context17, client.id, request2.payload, request2.headers, isStream3 ? streamEffect(client, request2, streamOrEffect) : streamOrEffect)), {
      onSuccess: /* @__PURE__ */ __name((value6) => {
        responded = true;
        return options4.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request2.id,
          exit: succeed3(value6)
        });
      }, "onSuccess"),
      onFailure: /* @__PURE__ */ __name((cause3) => {
        responded = true;
        if (!disableFatalDefects && isDie2(cause3)) {
          return sendDefect(client, squash(cause3));
        }
        return options4.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request2.id,
          exit: failCause3(cause3)
        });
      }, "onFailure")
    }));
    if (enableTracing) {
      const parentSpan3 = requestFiber.currentContext.unsafeMap.get(ParentSpan.key);
      effect4 = withSpan3(effect4, `${spanPrefix}.${request2.tag}`, {
        captureStackTrace: false,
        attributes: options4.spanAttributes,
        parent: enableSpanPropagation && request2.spanId ? {
          _tag: "ExternalSpan",
          traceId: request2.traceId,
          spanId: request2.spanId,
          sampled: request2.sampled,
          context: empty10()
        } : void 0,
        links: enableSpanPropagation && parentSpan3 ? [{
          _tag: "SpanLink",
          span: parentSpan3,
          attributes: {}
        }] : void 0
      });
    }
    if (!isFork2 && concurrencySemaphore) {
      effect4 = concurrencySemaphore.withPermits(1)(effect4);
    }
    const runtime8 = make57({
      context: merge3(entry.context, requestFiber.currentContext),
      fiberRefs: requestFiber.getFiberRefs(),
      runtimeFlags: defaultRuntime2.runtimeFlags
    });
    const fiber = runFork3(runtime8, effect4);
    unsafeAdd(fiberSet, fiber);
    client.fibers.set(request2.id, fiber);
    fiber.addObserver((exit5) => {
      if (!responded && exit5._tag === "Failure") {
        unsafeAdd(fiberSet, runFork3(runtime8, options4.onFromServer({
          _tag: "Exit",
          clientId: client.id,
          requestId: request2.id,
          exit: interrupt3(none4)
        })));
      }
      client.fibers.delete(request2.id);
      client.latches.delete(request2.id);
      if (client.ended && client.fibers.size === 0) {
        unsafeAdd(fiberSet, runFork3(runtime8, endClient(client)));
      }
    });
    return _void;
  }, "handleRequest");
  const streamEffect = /* @__PURE__ */ __name((client, request2, stream6) => {
    let latch = client.latches.get(request2.id);
    if (supportsAck && !latch) {
      latch = unsafeMakeLatch2(false);
      client.latches.set(request2.id, latch);
    }
    if (isEffect2(stream6)) {
      let done12 = false;
      return stream6.pipe(flatMap15((mailbox) => whileLoop3({
        while: /* @__PURE__ */ __name(() => !done12, "while"),
        body: constant(flatMap15(mailbox.takeAll, ([chunk4, done_]) => {
          done12 = done_;
          if (!isNonEmpty(chunk4)) return _void;
          const write4 = options4.onFromServer({
            _tag: "Chunk",
            clientId: client.id,
            requestId: request2.id,
            values: toReadonlyArray(chunk4)
          });
          if (!latch) return write4;
          latch.unsafeClose();
          return zipRight7(write4, latch.await);
        })),
        step: constVoid
      })), scoped3);
    }
    return runForEachChunk2(stream6, (chunk4) => {
      if (!isNonEmpty(chunk4)) return _void;
      const write4 = options4.onFromServer({
        _tag: "Chunk",
        clientId: client.id,
        requestId: request2.id,
        values: toReadonlyArray(chunk4)
      });
      if (!latch) return write4;
      latch.unsafeClose();
      return zipRight7(write4, latch.await);
    });
  }, "streamEffect");
  const sendDefect = /* @__PURE__ */ __name((client, defect) => suspend4(() => {
    const shouldEnd = client.ended && client.fibers.size === 0;
    const write4 = options4.onFromServer({
      _tag: "Defect",
      clientId: client.id,
      defect
    });
    if (!shouldEnd) return write4;
    return zipRight7(write4, endClient(client));
  }), "sendDefect");
  return identity({
    write: write3,
    disconnect: disconnect4
  });
});
var applyMiddleware = /* @__PURE__ */ __name((rpc, context17, clientId2, payload, headers, handler) => {
  if (rpc.middlewares.size === 0) {
    return handler;
  }
  const options4 = {
    rpc,
    payload,
    headers,
    clientId: clientId2
  };
  for (const tag8 of rpc.middlewares) {
    if (tag8.wrap) {
      const middleware2 = unsafeGet5(context17, tag8);
      handler = middleware2({
        ...options4,
        next: handler
      });
    } else if (tag8.optional) {
      const middleware2 = unsafeGet5(context17, tag8);
      const previous2 = handler;
      handler = matchEffect3(middleware2(options4), {
        onFailure: /* @__PURE__ */ __name(() => previous2, "onFailure"),
        onSuccess: tag8.provides !== void 0 ? (value6) => provideService4(previous2, tag8.provides, value6) : (_) => previous2
      });
    } else {
      const middleware2 = unsafeGet5(context17, tag8);
      handler = tag8.provides !== void 0 ? provideServiceEffect2(handler, tag8.provides, middleware2(options4)) : zipRight7(middleware2(options4), handler);
    }
  }
  return handler;
}, "applyMiddleware");
var make94 = /* @__PURE__ */ fnUntraced2(function* (group5, options4) {
  const {
    disconnects,
    end: end6,
    run: run10,
    send: send2,
    supportsAck,
    supportsSpanPropagation,
    supportsTransferables
  } = yield* Protocol2;
  const context17 = yield* context4();
  const scope5 = yield* make40();
  const server = yield* makeNoSerialization2(group5, {
    ...options4,
    disableClientAcks: !supportsAck,
    disableSpanPropagation: !supportsSpanPropagation,
    onFromServer(response) {
      const client = clients.get(response.clientId);
      if (!client) return _void;
      switch (response._tag) {
        case "Chunk": {
          const schemas = client.schemas.get(response.requestId);
          if (!schemas) return _void;
          return handleEncode(client, response.requestId, schemas.collector, provide2(schemas.encodeChunk(response.values), schemas.context), (values6) => ({
            _tag: "Chunk",
            requestId: String(response.requestId),
            values: values6
          }));
        }
        case "Exit": {
          const schemas = client.schemas.get(response.requestId);
          if (!schemas) return _void;
          client.schemas.delete(response.requestId);
          return handleEncode(client, response.requestId, schemas.collector, provide2(schemas.encodeExit(response.exit), schemas.context), (exit5) => ({
            _tag: "Exit",
            requestId: String(response.requestId),
            exit: exit5
          }));
        }
        case "Defect": {
          return sendDefect(client, response.defect);
        }
        case "ClientEnd": {
          clients.delete(response.clientId);
          return end6(response.clientId);
        }
      }
    }
  }).pipe(extend3(scope5));
  yield* fork3(interruptible4(whileLoop3({
    while: constTrue,
    body: constant(flatMap15(disconnects.take, (clientId2) => {
      clients.delete(clientId2);
      return server.disconnect(clientId2);
    })),
    step: constVoid
  })));
  const schemasCache = /* @__PURE__ */ new WeakMap();
  const getSchemas = /* @__PURE__ */ __name((rpc) => {
    let schemas = schemasCache.get(rpc);
    if (!schemas) {
      const entry = context17.unsafeMap.get(rpc.key);
      const streamSchemas = getStreamSchemas(rpc.successSchema.ast);
      schemas = {
        decode: decodeUnknown3(rpc.payloadSchema),
        encodeChunk: encodeUnknown2(Array$(isSome2(streamSchemas) ? streamSchemas.value.success : Any)),
        encodeExit: encodeUnknown2(exitSchema2(rpc)),
        context: entry.context
      };
      schemasCache.set(rpc, schemas);
    }
    return schemas;
  }, "getSchemas");
  const clients = /* @__PURE__ */ new Map();
  const handleEncode = /* @__PURE__ */ __name((client, requestId2, collector, effect4, onSuccess) => (collector ? provideService4(effect4, Collector, collector) : effect4).pipe(flatMap15((a) => send2(client.id, onSuccess(a), collector && collector.unsafeClear())), catchAllCause3((cause3) => {
    client.schemas.delete(requestId2);
    const defect = squash(map18(cause3, TreeFormatter.formatErrorSync));
    return zipRight7(sendRequestDefect(client, requestId2, defect), server.write(client.id, {
      _tag: "Interrupt",
      requestId: requestId2,
      interruptors: []
    }));
  })), "handleEncode");
  const sendRequestDefect = /* @__PURE__ */ __name((client, requestId2, defect) => catchAllCause3(send2(client.id, {
    _tag: "Exit",
    requestId: String(requestId2),
    exit: {
      _tag: "Failure",
      cause: {
        _tag: "Die",
        defect
      }
    }
  }), (cause3) => sendDefect(client, squash(cause3))), "sendRequestDefect");
  const sendDefect = /* @__PURE__ */ __name((client, defect) => catchAllCause3(send2(client.id, {
    _tag: "Defect",
    defect
  }), (cause3) => annotateLogs3(logDebug2(cause3), {
    module: "RpcServer",
    method: "sendDefect"
  })), "sendDefect");
  return yield* run10((clientId2, request2) => {
    let client = clients.get(clientId2);
    if (!client) {
      client = {
        id: clientId2,
        schemas: /* @__PURE__ */ new Map()
      };
      clients.set(clientId2, client);
    }
    switch (request2._tag) {
      case "Request": {
        const tag8 = hasProperty(request2, "tag") ? request2.tag : "";
        const rpc = group5.requests.get(tag8);
        if (!rpc) {
          return sendDefect(client, `Unknown request tag: ${tag8}`);
        }
        let requestId2;
        switch (typeof request2.id) {
          case "bigint":
          case "string": {
            requestId2 = RequestId(request2.id);
            break;
          }
          default: {
            return sendDefect(client, `Invalid request id: ${request2.id}`);
          }
        }
        const schemas = getSchemas(rpc);
        return matchEffect3(provide2(schemas.decode(request2.payload), schemas.context), {
          onFailure: /* @__PURE__ */ __name((error5) => sendRequestDefect(client, requestId2, TreeFormatter.formatErrorSync(error5)), "onFailure"),
          onSuccess: /* @__PURE__ */ __name((payload) => {
            client.schemas.set(requestId2, supportsTransferables ? {
              ...schemas,
              collector: unsafeMakeCollector()
            } : schemas);
            return server.write(clientId2, {
              ...request2,
              id: requestId2,
              payload,
              headers: fromInput(request2.headers)
            });
          }, "onSuccess")
        });
      }
      case "Ping": {
        return catchAllCause3(send2(client.id, constPong), (cause3) => sendDefect(client, squash(cause3)));
      }
      case "Eof": {
        return server.write(clientId2, request2);
      }
      case "Ack": {
        return server.write(clientId2, {
          ...request2,
          requestId: RequestId(request2.requestId)
        });
      }
      case "Interrupt": {
        return server.write(clientId2, {
          ...request2,
          requestId: RequestId(request2.requestId),
          interruptors: []
        });
      }
      default: {
        return sendDefect(client, `Unknown request tag: ${request2._tag}`);
      }
    }
  }).pipe(interruptible4, tapErrorCause3((cause3) => logFatal2("BUG: RpcServer protocol crashed", cause3)), onExit3((exit5) => close(scope5, exit5)));
});
var layer11 = /* @__PURE__ */ __name((group5, options4) => scopedDiscard2(forkScoped2(interruptible4(make94(group5, options4)))), "layer");
var layerHttpRouter = /* @__PURE__ */ __name((options4) => layer11(options4.group, options4).pipe(provide3(options4.protocol === "http" ? layerProtocolHttpRouter(options4) : layerProtocolWebsocketRouter(options4))), "layerHttpRouter");
var Protocol2 = class extends (/* @__PURE__ */ Tag2("@effect/rpc/RpcServer/Protocol")()) {
  static {
    __name(this, "Protocol");
  }
  /**
   * @since 1.0.0
   */
  static make = /* @__PURE__ */ withRun();
};
var makeProtocolSocketServer = /* @__PURE__ */ gen4(function* () {
  const server = yield* SocketServer;
  const {
    onSocket,
    protocol
  } = yield* makeSocketProtocol;
  yield* forkScoped2(interruptible4(server.run(fnUntraced2(onSocket, scoped3))));
  return protocol;
});
var layerProtocolSocketServer = /* @__PURE__ */ scoped4(Protocol2, makeProtocolSocketServer);
var makeProtocolWithHttpAppWebsocket = /* @__PURE__ */ gen4(function* () {
  const {
    onSocket,
    protocol
  } = yield* makeSocketProtocol;
  const httpApp = gen4(function* () {
    const request2 = yield* HttpServerRequest;
    const socket = yield* orDie3(request2.upgrade);
    yield* onSocket(socket, Object.entries(request2.headers));
    return empty42();
  });
  return {
    protocol,
    httpApp
  };
});
var makeProtocolWebsocket = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  const router = yield* options4.routerTag ?? Default;
  yield* router.get(options4.path, httpApp);
  return protocol;
});
var makeProtocolWebsocketRouter = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const router = yield* HttpRouter;
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  yield* router.add("GET", options4.path, httpApp);
  return protocol;
});
var layerProtocolWebsocket = /* @__PURE__ */ __name((options4) => {
  const routerTag = options4.routerTag ?? Default;
  return effect(Protocol2, makeProtocolWebsocket(options4)).pipe(provide3(routerTag.Live));
}, "layerProtocolWebsocket");
var layerProtocolWebsocketRouter = /* @__PURE__ */ __name((options4) => effect(Protocol2, makeProtocolWebsocketRouter(options4)), "layerProtocolWebsocketRouter");
var makeProtocolWithHttpApp = /* @__PURE__ */ gen4(function* () {
  const serialization = yield* RpcSerialization;
  const includesFraming = serialization.includesFraming;
  const disconnects = yield* make77();
  let writeRequest;
  let clientId2 = 0;
  const clients = /* @__PURE__ */ new Map();
  const httpApp = gen4(function* () {
    const request2 = yield* HttpServerRequest;
    const requestHeaders = Object.entries(request2.headers);
    const data = yield* orDie3(request2.arrayBuffer);
    const id4 = clientId2++;
    const mailbox = yield* make77();
    const parser = serialization.unsafeMake();
    const encoder3 = new TextEncoder();
    const offer7 = /* @__PURE__ */ __name((data2) => typeof data2 === "string" ? mailbox.offer(encoder3.encode(data2)) : mailbox.offer(data2), "offer");
    clients.set(id4, {
      write: /* @__PURE__ */ __name((response) => {
        try {
          if (!includesFraming) return mailbox.offer(response);
          const encoded = parser.encode(response);
          if (encoded === void 0) return _void;
          return offer7(encoded);
        } catch (cause3) {
          return !includesFraming ? mailbox.offer(ResponseDefectEncoded(cause3)) : offer7(parser.encode(ResponseDefectEncoded(cause3)));
        }
      }, "write"),
      end: mailbox.end
    });
    const requestIds = [];
    try {
      const decoded = parser.decode(new Uint8Array(data));
      for (const message of decoded) {
        if (message._tag === "Request") {
          requestIds.push(RequestId(message.id));
          message.headers = requestHeaders.concat(message.headers);
        }
        yield* writeRequest(id4, message);
      }
    } catch (cause3) {
      yield* offer7(parser.encode(ResponseDefectEncoded(cause3)));
    }
    yield* writeRequest(id4, constEof);
    if (!includesFraming) {
      let done12 = false;
      yield* addFinalizer3(() => {
        clients.delete(id4);
        disconnects.unsafeOffer(id4);
        if (done12) return _void;
        return forEach11(requestIds, (requestId2) => writeRequest(id4, {
          _tag: "Interrupt",
          requestId: String(requestId2)
        }), {
          discard: true
        });
      });
      const responses = empty3();
      while (true) {
        const [items, done13] = yield* mailbox.takeAll;
        responses.push(...items);
        if (done13) break;
      }
      done12 = true;
      return text4(parser.encode(responses), {
        contentType: serialization.contentType
      });
    }
    return stream5(ensuringWith3(toStream2(mailbox), (exit5) => {
      clients.delete(id4);
      disconnects.unsafeOffer(id4);
      if (!isInterrupted2(exit5)) return _void;
      return forEach11(requestIds, (requestId2) => writeRequest(id4, {
        _tag: "Interrupt",
        requestId: String(requestId2)
      }), {
        discard: true
      });
    }), {
      contentType: serialization.contentType
    });
  }).pipe(interruptible4);
  const protocol = yield* Protocol2.make((writeRequest_) => {
    writeRequest = writeRequest_;
    return succeed11({
      disconnects,
      send(clientId3, response) {
        const client = clients.get(clientId3);
        if (!client) return _void;
        return client.write(response);
      },
      end(clientId3) {
        const client = clients.get(clientId3);
        if (!client) return _void;
        return client.end;
      },
      clientIds: sync7(() => clients.keys()),
      initialMessage: succeedNone2,
      supportsAck: false,
      supportsTransferables: false,
      supportsSpanPropagation: false
    });
  });
  return {
    protocol,
    httpApp
  };
});
var makeProtocolHttp2 = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  const router = yield* options4.routerTag ?? Default;
  yield* router.post(options4.path, httpApp);
  return protocol;
});
var makeProtocolHttpRouter = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const router = yield* HttpRouter;
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  yield* router.add("POST", options4.path, httpApp);
  return protocol;
});
var makeProtocolWorkerRunner = /* @__PURE__ */ Protocol2.make(/* @__PURE__ */ fnUntraced2(function* (writeRequest) {
  const fiber = yield* withFiberRuntime2(succeed11);
  const runner = yield* PlatformRunner2;
  const closeLatch = yield* CloseLatch2;
  const backing = yield* runner.start(closeLatch);
  const initialMessage = yield* make43();
  const clientIds = /* @__PURE__ */ new Set();
  const disconnects = yield* make77();
  yield* _await3(closeLatch).pipe(onExit3(() => {
    fiber.currentScheduler.scheduleTask(() => fiber.unsafeInterruptAsFork(fiber.id()), 0);
    return _void;
  }), forkScoped2);
  yield* backing.run((clientId2, message) => {
    clientIds.add(clientId2);
    if (message._tag === "InitialMessage") {
      return succeed9(initialMessage, message.value);
    }
    return writeRequest(clientId2, message);
  });
  yield* disconnects.take.pipe(tap4((clientId2) => {
    clientIds.delete(clientId2);
    return disconnects.offer(clientId2);
  }), forkScoped2);
  return {
    disconnects,
    send: backing.send,
    end(_clientId) {
      return _void;
    },
    clientIds: sync7(() => clientIds.values()),
    initialMessage: asSome2(_await3(initialMessage)),
    supportsAck: true,
    supportsTransferables: true,
    supportsSpanPropagation: true
  };
}));
var layerProtocolWorkerRunner = /* @__PURE__ */ scoped4(Protocol2, makeProtocolWorkerRunner);
var layerProtocolHttp2 = /* @__PURE__ */ __name((options4) => {
  const routerTag = options4.routerTag ?? Default;
  return effect(Protocol2, makeProtocolHttp2(options4)).pipe(provide3(routerTag.Live));
}, "layerProtocolHttp");
var layerProtocolHttpRouter = /* @__PURE__ */ __name((options4) => effect(Protocol2, makeProtocolHttpRouter(options4)), "layerProtocolHttpRouter");
var toHttpApp2 = /* @__PURE__ */ fnUntraced2(function* (group5, options4) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpApp;
  yield* make94(group5, options4).pipe(provideService4(Protocol2, protocol), interruptible4, forkScoped2);
  return httpApp;
});
var toHttpAppWebsocket = /* @__PURE__ */ fnUntraced2(function* (group5, options4) {
  const {
    httpApp,
    protocol
  } = yield* makeProtocolWithHttpAppWebsocket;
  yield* make94(group5, options4).pipe(provideService4(Protocol2, protocol), interruptible4, forkScoped2);
  return httpApp;
});
var toWebHandler2 = /* @__PURE__ */ __name((group5, options4) => toWebHandlerLayerWith(mergeAll6(options4.layer, scope4), {
  memoMap: options4?.memoMap,
  middleware: options4?.middleware,
  toHandler: /* @__PURE__ */ __name((r) => provide2(toHttpApp2(group5, options4), r), "toHandler")
}), "toWebHandler");
var makeProtocolStdio = /* @__PURE__ */ fnUntraced2(function* (options4) {
  const fiber = getOrThrow2(getCurrentFiber2());
  const serialization = yield* RpcSerialization;
  return yield* Protocol2.make(fnUntraced2(function* (writeRequest) {
    const mailbox = yield* make77();
    const parser = serialization.unsafeMake();
    yield* options4.stdin.pipe(runForEach2((data) => {
      const decoded = parser.decode(data);
      if (decoded.length === 0) return _void;
      let i = 0;
      return whileLoop3({
        while: /* @__PURE__ */ __name(() => i < decoded.length, "while"),
        body: /* @__PURE__ */ __name(() => writeRequest(0, decoded[i++]), "body"),
        step: constVoid
      });
    }), sandbox2, tapError3(logError2), retry2(spaced2(500)), ensuring3(interruptFork(fiber)), forkScoped2, interruptible4);
    yield* toStream2(mailbox).pipe(run5(options4.stdout), retry2(spaced2(500)), forkScoped2, interruptible4);
    return {
      disconnects: yield* make77(),
      send(_clientId, response) {
        const responseEncoded = parser.encode(response);
        if (responseEncoded === void 0) {
          return _void;
        }
        return mailbox.offer(responseEncoded);
      },
      end(_clientId) {
        return mailbox.end;
      },
      clientIds: succeed11([0]),
      initialMessage: succeedNone2,
      supportsAck: true,
      supportsTransferables: false,
      supportsSpanPropagation: true
    };
  }));
});
var layerProtocolStdio = /* @__PURE__ */ __name((options4) => scoped4(Protocol2, makeProtocolStdio(options4)), "layerProtocolStdio");
var makeSocketProtocol = /* @__PURE__ */ gen4(function* () {
  const serialization = yield* RpcSerialization;
  const disconnects = yield* make77();
  let clientId2 = 0;
  const clients = /* @__PURE__ */ new Map();
  let writeRequest;
  const onSocket = /* @__PURE__ */ __name(function* (socket, headers) {
    const scope5 = yield* scope3;
    const parser = serialization.unsafeMake();
    const id4 = clientId2++;
    yield* addFinalizerExit(scope5, () => {
      clients.delete(id4);
      return disconnects.offer(id4);
    });
    const writeRaw = yield* socket.writer;
    const write3 = /* @__PURE__ */ __name((response) => {
      try {
        const encoded = parser.encode(response);
        if (encoded === void 0) {
          return _void;
        }
        return orDie3(writeRaw(encoded));
      } catch (cause3) {
        return orDie3(writeRaw(parser.encode(ResponseDefectEncoded(cause3))));
      }
    }, "write");
    clients.set(id4, {
      write: write3
    });
    yield* socket.runRaw((data) => {
      try {
        const decoded = parser.decode(data);
        if (decoded.length === 0) return _void;
        let i = 0;
        return whileLoop3({
          while: /* @__PURE__ */ __name(() => i < decoded.length, "while"),
          body() {
            const message = decoded[i++];
            if (message._tag === "Request" && headers) {
              ;
              message.headers = headers.concat(message.headers);
            }
            return writeRequest(id4, message);
          },
          step: constVoid
        });
      } catch (cause3) {
        return writeRaw(parser.encode(ResponseDefectEncoded(cause3)));
      }
    }).pipe(interruptible4, catchIf2((error5) => error5.reason === "Close", () => _void), orDie3);
  }, "onSocket");
  const protocol = yield* Protocol2.make((writeRequest_) => {
    writeRequest = writeRequest_;
    return succeed11({
      disconnects,
      send: /* @__PURE__ */ __name((clientId3, response) => {
        const client = clients.get(clientId3);
        if (!client) return _void;
        return orDie3(client.write(response));
      }, "send"),
      end(_clientId) {
        return _void;
      },
      clientIds: sync7(() => clients.keys()),
      initialMessage: succeedNone2,
      supportsAck: true,
      supportsTransferables: false,
      supportsSpanPropagation: true
    });
  });
  return {
    protocol,
    onSocket
  };
});

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Console.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var log6 = log4;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberHandle.js
var FiberHandle_exports = {};
__export(FiberHandle_exports, {
  TypeId: () => TypeId49,
  awaitEmpty: () => awaitEmpty,
  clear: () => clear4,
  get: () => get24,
  isFiberHandle: () => isFiberHandle,
  join: () => join6,
  make: () => make95,
  makeRuntime: () => makeRuntime2,
  makeRuntimePromise: () => makeRuntimePromise,
  run: () => run8,
  runtime: () => runtime6,
  runtimePromise: () => runtimePromise,
  set: () => set15,
  unsafeGet: () => unsafeGet9,
  unsafeSet: () => unsafeSet4
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId49 = /* @__PURE__ */ Symbol.for("effect/FiberHandle");
var isFiberHandle = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId49), "isFiberHandle");
var Proto8 = {
  [TypeId49]: TypeId49,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberHandle",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake15 = /* @__PURE__ */ __name((deferred) => {
  const self2 = Object.create(Proto8);
  self2.state = {
    _tag: "Open",
    fiber: void 0
  };
  self2.deferred = deferred;
  return self2;
}, "unsafeMake");
var make95 = /* @__PURE__ */ __name(() => acquireRelease2(map22(make43(), (deferred) => unsafeMake15(deferred)), (handle) => withFiberRuntime2((parent) => {
  const state2 = handle.state;
  if (state2._tag === "Closed") return _void;
  handle.state = {
    _tag: "Closed"
  };
  return state2.fiber ? intoDeferred2(asVoid5(interruptAs(state2.fiber, combine3(parent.id(), internalFiberId2))), handle.deferred) : done8(handle.deferred, void_5);
})), "make");
var makeRuntime2 = /* @__PURE__ */ __name(() => flatMap15(make95(), (self2) => runtime6(self2)()), "makeRuntime");
var makeRuntimePromise = /* @__PURE__ */ __name(() => flatMap15(make95(), (self2) => runtimePromise(self2)()), "makeRuntimePromise");
var internalFiberIdId2 = -1;
var internalFiberId2 = /* @__PURE__ */ make15(internalFiberIdId2, 0);
var isInternalInterruption2 = /* @__PURE__ */ reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: /* @__PURE__ */ __name((_, fiberId5) => has4(ids2(fiberId5), internalFiberIdId2), "interruptCase"),
  sequentialCase: /* @__PURE__ */ __name((_, left3, right3) => left3 || right3, "sequentialCase"),
  parallelCase: /* @__PURE__ */ __name((_, left3, right3) => left3 || right3, "parallelCase")
});
var unsafeSet4 = /* @__PURE__ */ dual((args2) => isFiberHandle(args2[0]), (self2, fiber, options4) => {
  if (self2.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine3(options4?.interruptAs ?? none4, internalFiberId2));
    return;
  } else if (self2.state.fiber !== void 0) {
    if (options4?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(combine3(options4?.interruptAs ?? none4, internalFiberId2));
      return;
    } else if (self2.state.fiber === fiber) {
      return;
    }
    self2.state.fiber.unsafeInterruptAsFork(combine3(options4?.interruptAs ?? none4, internalFiberId2));
    self2.state.fiber = void 0;
  }
  self2.state.fiber = fiber;
  fiber.addObserver((exit5) => {
    if (self2.state._tag === "Open" && fiber === self2.state.fiber) {
      self2.state.fiber = void 0;
    }
    if (isFailure3(exit5) && (options4?.propagateInterruption === true ? !isInternalInterruption2(exit5.cause) : !isInterruptedOnly2(exit5.cause))) {
      unsafeDone(self2.deferred, exit5);
    }
  });
});
var set15 = /* @__PURE__ */ dual((args2) => isFiberHandle(args2[0]), (self2, fiber, options4) => fiberIdWith2((fiberId5) => sync7(() => unsafeSet4(self2, fiber, {
  interruptAs: fiberId5,
  onlyIfMissing: options4?.onlyIfMissing,
  propagateInterruption: options4?.propagateInterruption
}))));
var unsafeGet9 = /* @__PURE__ */ __name((self2) => self2.state._tag === "Closed" ? none2() : fromNullable2(self2.state.fiber), "unsafeGet");
var get24 = /* @__PURE__ */ __name((self2) => suspend4(() => unsafeGet9(self2)), "get");
var clear4 = /* @__PURE__ */ __name((self2) => uninterruptibleMask3((restore) => withFiberRuntime2((fiber) => {
  if (self2.state._tag === "Closed" || self2.state.fiber === void 0) {
    return _void;
  }
  return zipRight7(restore(interruptAs(self2.state.fiber, combine3(fiber.id(), internalFiberId2))), sync7(() => {
    if (self2.state._tag === "Open") {
      self2.state.fiber = void 0;
    }
  }));
})), "clear");
var constInterruptedFiber2 = /* @__PURE__ */ (function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork2(interrupt7);
    }
    return fiber;
  };
})();
var run8 = /* @__PURE__ */ __name(function() {
  const self2 = arguments[0];
  if (isEffect2(arguments[1])) {
    return runImpl2(self2, arguments[1], arguments[2]);
  }
  const options4 = arguments[1];
  return (effect4) => runImpl2(self2, effect4, options4);
}, "run");
var runImpl2 = /* @__PURE__ */ __name((self2, effect4, options4) => withFiberRuntime2((parent) => {
  if (self2.state._tag === "Closed") {
    return interrupt7;
  } else if (self2.state.fiber !== void 0 && options4?.onlyIfMissing === true) {
    return sync7(constInterruptedFiber2);
  }
  const runtime8 = make57({
    context: parent.currentContext,
    fiberRefs: parent.getFiberRefs(),
    runtimeFlags: defaultRuntime2.runtimeFlags
  });
  const fiber = runFork3(runtime8)(effect4);
  unsafeSet4(self2, fiber, {
    ...options4,
    interruptAs: parent.id()
  });
  return succeed11(fiber);
}), "runImpl");
var runtime6 = /* @__PURE__ */ __name((self2) => () => map22(runtime4(), (runtime8) => {
  const runFork4 = runFork3(runtime8);
  return (effect4, options4) => {
    if (self2.state._tag === "Closed") {
      return constInterruptedFiber2();
    } else if (self2.state.fiber !== void 0 && options4?.onlyIfMissing === true) {
      return constInterruptedFiber2();
    }
    const fiber = runFork4(effect4, options4);
    unsafeSet4(self2, fiber, options4);
    return fiber;
  };
}), "runtime");
var runtimePromise = /* @__PURE__ */ __name((self2) => () => map22(runtime6(self2)(), (runFork4) => (effect4, options4) => new Promise((resolve3, reject3) => runFork4(effect4, options4).addObserver((exit5) => {
  if (isSuccess2(exit5)) {
    resolve3(exit5.value);
  } else {
    reject3(squash(exit5.cause));
  }
}))), "runtimePromise");
var join6 = /* @__PURE__ */ __name((self2) => _await3(self2.deferred), "join");
var awaitEmpty = /* @__PURE__ */ __name((self2) => suspend4(() => {
  if (self2.state._tag === "Closed" || self2.state.fiber === void 0) {
    return _void;
  }
  return _await2(self2.state.fiber);
}), "awaitEmpty");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/FiberMap.js
var FiberMap_exports = {};
__export(FiberMap_exports, {
  TypeId: () => TypeId50,
  awaitEmpty: () => awaitEmpty2,
  clear: () => clear5,
  get: () => get25,
  has: () => has11,
  isFiberMap: () => isFiberMap,
  join: () => join7,
  make: () => make96,
  makeRuntime: () => makeRuntime3,
  makeRuntimePromise: () => makeRuntimePromise2,
  remove: () => remove15,
  run: () => run9,
  runtime: () => runtime7,
  runtimePromise: () => runtimePromise2,
  set: () => set16,
  size: () => size20,
  unsafeGet: () => unsafeGet10,
  unsafeHas: () => unsafeHas,
  unsafeSet: () => unsafeSet5
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId50 = /* @__PURE__ */ Symbol.for("effect/FiberMap");
var isFiberMap = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId50), "isFiberMap");
var Proto9 = {
  [TypeId50]: TypeId50,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty2();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake16 = /* @__PURE__ */ __name((backing, deferred) => {
  const self2 = Object.create(Proto9);
  self2.state = {
    _tag: "Open",
    backing
  };
  self2.deferred = deferred;
  return self2;
}, "unsafeMake");
var make96 = /* @__PURE__ */ __name(() => acquireRelease2(map22(make43(), (deferred) => unsafeMake16(empty23(), deferred)), (map38) => withFiberRuntime2((parent) => {
  const state2 = map38.state;
  if (state2._tag === "Closed") return _void;
  map38.state = {
    _tag: "Closed"
  };
  return interruptAllAs2(map3(state2.backing, ([, fiber]) => fiber), combine3(parent.id(), internalFiberId3)).pipe(intoDeferred2(map38.deferred));
})), "make");
var makeRuntime3 = /* @__PURE__ */ __name(() => flatMap15(make96(), (self2) => runtime7(self2)()), "makeRuntime");
var makeRuntimePromise2 = /* @__PURE__ */ __name(() => flatMap15(make96(), (self2) => runtimePromise2(self2)()), "makeRuntimePromise");
var internalFiberIdId3 = -1;
var internalFiberId3 = /* @__PURE__ */ make15(internalFiberIdId3, 0);
var isInternalInterruption3 = /* @__PURE__ */ reduceWithContext3(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: /* @__PURE__ */ __name((_, fiberId5) => has4(ids2(fiberId5), internalFiberIdId3), "interruptCase"),
  sequentialCase: /* @__PURE__ */ __name((_, left3, right3) => left3 || right3, "sequentialCase"),
  parallelCase: /* @__PURE__ */ __name((_, left3, right3) => left3 || right3, "parallelCase")
});
var unsafeSet5 = /* @__PURE__ */ dual((args2) => isFiberMap(args2[0]), (self2, key, fiber, options4) => {
  if (self2.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine3(options4?.interruptAs ?? none4, internalFiberId3));
    return;
  }
  const previous2 = get13(self2.state.backing, key);
  if (previous2._tag === "Some") {
    if (options4?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(combine3(options4?.interruptAs ?? none4, internalFiberId3));
      return;
    } else if (previous2.value === fiber) {
      return;
    }
    previous2.value.unsafeInterruptAsFork(combine3(options4?.interruptAs ?? none4, internalFiberId3));
  }
  set6(self2.state.backing, key, fiber);
  fiber.addObserver((exit5) => {
    if (self2.state._tag === "Closed") {
      return;
    }
    const current2 = get13(self2.state.backing, key);
    if (isSome2(current2) && fiber === current2.value) {
      remove7(self2.state.backing, key);
    }
    if (isFailure3(exit5) && (options4?.propagateInterruption === true ? !isInternalInterruption3(exit5.cause) : !isInterruptedOnly2(exit5.cause))) {
      unsafeDone(self2.deferred, exit5);
    }
  });
});
var set16 = /* @__PURE__ */ dual((args2) => isFiberMap(args2[0]), (self2, key, fiber, options4) => fiberIdWith2((fiberId5) => sync7(() => unsafeSet5(self2, key, fiber, {
  ...options4,
  interruptAs: fiberId5
}))));
var unsafeGet10 = /* @__PURE__ */ dual(2, (self2, key) => self2.state._tag === "Closed" ? none2() : get13(self2.state.backing, key));
var get25 = /* @__PURE__ */ dual(2, (self2, key) => suspend4(() => unsafeGet10(self2, key)));
var unsafeHas = /* @__PURE__ */ dual(2, (self2, key) => self2.state._tag === "Closed" ? false : has6(self2.state.backing, key));
var has11 = /* @__PURE__ */ dual(2, (self2, key) => sync7(() => unsafeHas(self2, key)));
var remove15 = /* @__PURE__ */ dual(2, (self2, key) => withFiberRuntime2((removeFiber) => {
  if (self2.state._tag === "Closed") {
    return _void;
  }
  const fiber = get13(self2.state.backing, key);
  if (fiber._tag === "None") {
    return _void;
  }
  return interruptAs(fiber.value, combine3(removeFiber.id(), internalFiberId3));
}));
var clear5 = /* @__PURE__ */ __name((self2) => withFiberRuntime2((clearFiber) => {
  if (self2.state._tag === "Closed") {
    return _void;
  }
  return forEach11(self2.state.backing, ([, fiber]) => (
    // will be removed by the observer
    interruptAs(fiber, combine3(clearFiber.id(), internalFiberId3))
  ));
}), "clear");
var constInterruptedFiber3 = /* @__PURE__ */ (function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork2(interrupt7);
    }
    return fiber;
  };
})();
var run9 = /* @__PURE__ */ __name(function() {
  const self2 = arguments[0];
  if (isEffect2(arguments[2])) {
    return runImpl3(self2, arguments[1], arguments[2], arguments[3]);
  }
  const key = arguments[1];
  const options4 = arguments[2];
  return (effect4) => runImpl3(self2, key, effect4, options4);
}, "run");
var runImpl3 = /* @__PURE__ */ __name((self2, key, effect4, options4) => withFiberRuntime2((parent) => {
  if (self2.state._tag === "Closed") {
    return interrupt7;
  } else if (options4?.onlyIfMissing === true && unsafeHas(self2, key)) {
    return sync7(constInterruptedFiber3);
  }
  const runtime8 = make57({
    context: parent.currentContext,
    fiberRefs: parent.getFiberRefs(),
    runtimeFlags: defaultRuntime2.runtimeFlags
  });
  const fiber = runFork3(runtime8)(effect4);
  unsafeSet5(self2, key, fiber, {
    ...options4,
    interruptAs: parent.id()
  });
  return succeed11(fiber);
}), "runImpl");
var runtime7 = /* @__PURE__ */ __name((self2) => () => map22(runtime4(), (runtime8) => {
  const runFork4 = runFork3(runtime8);
  return (key, effect4, options4) => {
    if (self2.state._tag === "Closed") {
      return constInterruptedFiber3();
    } else if (options4?.onlyIfMissing === true && unsafeHas(self2, key)) {
      return constInterruptedFiber3();
    }
    const fiber = runFork4(effect4, options4);
    unsafeSet5(self2, key, fiber, options4);
    return fiber;
  };
}), "runtime");
var runtimePromise2 = /* @__PURE__ */ __name((self2) => () => map22(runtime7(self2)(), (runFork4) => (key, effect4, options4) => new Promise((resolve3, reject3) => runFork4(key, effect4, options4).addObserver((exit5) => {
  if (isSuccess2(exit5)) {
    resolve3(exit5.value);
  } else {
    reject3(squash(exit5.cause));
  }
}))), "runtimePromise");
var size20 = /* @__PURE__ */ __name((self2) => sync7(() => self2.state._tag === "Closed" ? 0 : size7(self2.state.backing)), "size");
var join7 = /* @__PURE__ */ __name((self2) => _await3(self2.deferred), "join");
var awaitEmpty2 = /* @__PURE__ */ __name((self2) => whileLoop3({
  while: /* @__PURE__ */ __name(() => self2.state._tag === "Open" && size7(self2.state.backing) > 0, "while"),
  body: /* @__PURE__ */ __name(() => _await2(unsafeHead(self2)[1]), "body"),
  step: constVoid
}), "awaitEmpty");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Match.js
var Match_exports = {};
__export(Match_exports, {
  MatcherTypeId: () => MatcherTypeId,
  SafeRefinementId: () => SafeRefinementId,
  any: () => any2,
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date3,
  defined: () => defined2,
  discriminator: () => discriminator2,
  discriminatorStartsWith: () => discriminatorStartsWith2,
  discriminators: () => discriminators2,
  discriminatorsExhaustive: () => discriminatorsExhaustive2,
  either: () => either10,
  exhaustive: () => exhaustive2,
  instanceOf: () => instanceOf3,
  instanceOfUnsafe: () => instanceOfUnsafe,
  is: () => is3,
  nonEmptyString: () => nonEmptyString4,
  not: () => not4,
  null: () => _null,
  number: () => number5,
  option: () => option7,
  orElse: () => orElse17,
  orElseAbsurd: () => orElseAbsurd2,
  record: () => record3,
  string: () => string6,
  symbol: () => symbol5,
  tag: () => tag7,
  tagStartsWith: () => tagStartsWith2,
  tags: () => tags2,
  tagsExhaustive: () => tagsExhaustive2,
  type: () => type2,
  typeTags: () => typeTags2,
  undefined: () => _undefined,
  value: () => value5,
  valueTags: () => valueTags2,
  when: () => when7,
  whenAnd: () => whenAnd2,
  whenOr: () => whenOr2,
  withReturnType: () => withReturnType2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/matcher.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId51 = /* @__PURE__ */ Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId51]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case2) {
    return makeTypeMatcher([...this.cases, _case2]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
__name(makeTypeMatcher, "makeTypeMatcher");
var ValueMatcherProto = {
  [TypeId51]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case2) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case2._tag === "When" && _case2.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case2.evaluate(this.provided)));
    } else if (_case2._tag === "Not" && _case2.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case2.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value6) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value6;
  return matcher;
}
__name(makeValueMatcher, "makeValueMatcher");
var makeWhen = /* @__PURE__ */ __name((guard, evaluate3) => ({
  _tag: "When",
  guard,
  evaluate: evaluate3
}), "makeWhen");
var makeNot = /* @__PURE__ */ __name((guard, evaluate3) => ({
  _tag: "Not",
  guard,
  evaluate: evaluate3
}), "makeNot");
var makePredicate = /* @__PURE__ */ __name((pattern2) => {
  if (typeof pattern2 === "function") {
    return pattern2;
  } else if (Array.isArray(pattern2)) {
    const predicates = pattern2.map(makePredicate);
    const len = predicates.length;
    return (u) => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern2 !== null && typeof pattern2 === "object") {
    const keysAndPredicates = Object.entries(pattern2).map(([k, p]) => [k, makePredicate(p)]);
    const len = keysAndPredicates.length;
    return (u) => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return (u) => u === pattern2;
}, "makePredicate");
var makeOrPredicate = /* @__PURE__ */ __name((patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === true) {
        return true;
      }
    }
    return false;
  };
}, "makeOrPredicate");
var makeAndPredicate = /* @__PURE__ */ __name((patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === false) {
        return false;
      }
    }
    return true;
  };
}, "makeAndPredicate");
var type = /* @__PURE__ */ __name(() => makeTypeMatcher([]), "type");
var value4 = /* @__PURE__ */ __name((i) => makeValueMatcher(i, left2(i)), "value");
var valueTags = /* @__PURE__ */ dual(2, (input, fields) => {
  const match24 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return match24(input);
});
var typeTags = /* @__PURE__ */ __name(() => (fields) => {
  const match24 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return (input) => match24(input);
}, "typeTags");
var withReturnType = /* @__PURE__ */ __name(() => (self2) => self2, "withReturnType");
var when6 = /* @__PURE__ */ __name((pattern2, f) => (self2) => self2.add(makeWhen(makePredicate(pattern2), f)), "when");
var whenOr = /* @__PURE__ */ __name((...args2) => (self2) => {
  const onMatch = args2[args2.length - 1];
  const patterns = args2.slice(0, -1);
  return self2.add(makeWhen(makeOrPredicate(patterns), onMatch));
}, "whenOr");
var whenAnd = /* @__PURE__ */ __name((...args2) => (self2) => {
  const onMatch = args2[args2.length - 1];
  const patterns = args2.slice(0, -1);
  return self2.add(makeWhen(makeAndPredicate(patterns), onMatch));
}, "whenAnd");
var discriminator = /* @__PURE__ */ __name((field) => (...pattern2) => {
  const f = pattern2[pattern2.length - 1];
  const values6 = pattern2.slice(0, -1);
  const pred = values6.length === 1 ? (_) => _[field] === values6[0] : (_) => values6.includes(_[field]);
  return (self2) => self2.add(makeWhen(pred, f));
}, "discriminator");
var discriminatorStartsWith = /* @__PURE__ */ __name((field) => (pattern2, f) => {
  const pred = /* @__PURE__ */ __name((_) => typeof _[field] === "string" && _[field].startsWith(pattern2), "pred");
  return (self2) => self2.add(makeWhen(pred, f));
}, "discriminatorStartsWith");
var discriminators = /* @__PURE__ */ __name((field) => (fields) => {
  const predicate = makeWhen((arg) => arg != null && arg[field] in fields, (data) => fields[data[field]](data));
  return (self2) => self2.add(predicate);
}, "discriminators");
var discriminatorsExhaustive = /* @__PURE__ */ __name((field) => (fields) => {
  const addCases = discriminators(field)(fields);
  return (matcher) => exhaustive(addCases(matcher));
}, "discriminatorsExhaustive");
var tag6 = /* @__PURE__ */ discriminator("_tag");
var tagStartsWith = /* @__PURE__ */ discriminatorStartsWith("_tag");
var tags = /* @__PURE__ */ discriminators("_tag");
var tagsExhaustive = /* @__PURE__ */ discriminatorsExhaustive("_tag");
var not3 = /* @__PURE__ */ __name((pattern2, f) => (self2) => self2.add(makeNot(makePredicate(pattern2), f)), "not");
var nonEmptyString3 = /* @__PURE__ */ __name((u) => typeof u === "string" && u.length > 0, "nonEmptyString");
var is2 = /* @__PURE__ */ __name((...literals) => {
  const len = literals.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (u === literals[i]) {
        return true;
      }
    }
    return false;
  };
}, "is");
var any = /* @__PURE__ */ __name(() => true, "any");
var defined = /* @__PURE__ */ __name((u) => u !== void 0 && u !== null, "defined");
var instanceOf2 = /* @__PURE__ */ __name((constructor) => (u) => u instanceof constructor, "instanceOf");
var orElse16 = /* @__PURE__ */ __name((f) => (self2) => {
  const result = either9(self2);
  if (isEither2(result)) {
    return result._tag === "Right" ? result.right : f(result.left);
  }
  return (input) => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
}, "orElse");
var orElseAbsurd = /* @__PURE__ */ __name((self2) => orElse16(() => {
  throw new Error("effect/Match/orElseAbsurd: absurd");
})(self2), "orElseAbsurd");
var either9 = /* @__PURE__ */ __name((self2) => {
  if (self2._tag === "ValueMatcher") {
    return self2.value;
  }
  const len = self2.cases.length;
  if (len === 1) {
    const _case2 = self2.cases[0];
    return (input) => {
      if (_case2._tag === "When" && _case2.guard(input) === true) {
        return right2(_case2.evaluate(input));
      } else if (_case2._tag === "Not" && _case2.guard(input) === false) {
        return right2(_case2.evaluate(input));
      }
      return left2(input);
    };
  }
  return (input) => {
    for (let i = 0; i < len; i++) {
      const _case2 = self2.cases[i];
      if (_case2._tag === "When" && _case2.guard(input) === true) {
        return right2(_case2.evaluate(input));
      } else if (_case2._tag === "Not" && _case2.guard(input) === false) {
        return right2(_case2.evaluate(input));
      }
    }
    return left2(input);
  };
}, "either");
var option6 = /* @__PURE__ */ __name((self2) => {
  const toEither = either9(self2);
  if (isEither2(toEither)) {
    return match(toEither, {
      onLeft: /* @__PURE__ */ __name(() => none2(), "onLeft"),
      onRight: some3
    });
  }
  return (input) => match(toEither(input), {
    onLeft: /* @__PURE__ */ __name(() => none2(), "onLeft"),
    onRight: some3
  });
}, "option");
var getExhaustiveAbsurdErrorMessage = "effect/Match/exhaustive: absurd";
var exhaustive = /* @__PURE__ */ __name((self2) => {
  const toEither = either9(self2);
  if (isEither2(toEither)) {
    if (toEither._tag === "Right") {
      return toEither.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  }
  return (u) => {
    const result = toEither(u);
    if (result._tag === "Right") {
      return result.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  };
}, "exhaustive");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Match.js
var MatcherTypeId = TypeId51;
var type2 = type;
var value5 = value4;
var valueTags2 = valueTags;
var typeTags2 = typeTags;
var withReturnType2 = withReturnType;
var when7 = when6;
var whenOr2 = whenOr;
var whenAnd2 = whenAnd;
var discriminator2 = discriminator;
var discriminatorStartsWith2 = discriminatorStartsWith;
var discriminators2 = discriminators;
var discriminatorsExhaustive2 = discriminatorsExhaustive;
var tag7 = tag6;
var tagStartsWith2 = tagStartsWith;
var tags2 = tags;
var tagsExhaustive2 = tagsExhaustive;
var not4 = not3;
var nonEmptyString4 = nonEmptyString3;
var is3 = is2;
var string6 = isString;
var number5 = isNumber;
var any2 = any;
var defined2 = defined;
var boolean3 = isBoolean;
var _undefined = isUndefined;
var _null = isNull;
var bigint3 = isBigInt;
var symbol5 = isSymbol;
var date3 = isDate;
var record3 = isRecord;
var instanceOf3 = instanceOf2;
var instanceOfUnsafe = instanceOf2;
var orElse17 = orElse16;
var orElseAbsurd2 = orElseAbsurd;
var either10 = either9;
var option7 = option6;
var exhaustive2 = exhaustive;
var SafeRefinementId = /* @__PURE__ */ Symbol.for("effect/SafeRefinement");

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/STM.js
var STM_exports = {};
__export(STM_exports, {
  Do: () => Do8,
  STMTypeId: () => STMTypeId3,
  acquireUseRelease: () => acquireUseRelease6,
  all: () => all13,
  as: () => as15,
  asSome: () => asSome4,
  asSomeError: () => asSomeError4,
  asVoid: () => asVoid9,
  attempt: () => attempt2,
  bind: () => bind10,
  bindTo: () => bindTo10,
  catchAll: () => catchAll11,
  catchSome: () => catchSome6,
  catchTag: () => catchTag8,
  catchTags: () => catchTags8,
  check: () => check5,
  collect: () => collect4,
  collectSTM: () => collectSTM2,
  commit: () => commit3,
  commitEither: () => commitEither2,
  cond: () => cond2,
  context: () => context12,
  contextWith: () => contextWith8,
  contextWithSTM: () => contextWithSTM2,
  die: () => die14,
  dieMessage: () => dieMessage7,
  dieSync: () => dieSync10,
  either: () => either11,
  ensuring: () => ensuring10,
  eventually: () => eventually4,
  every: () => every13,
  exists: () => exists6,
  fail: () => fail21,
  failSync: () => failSync11,
  fiberId: () => fiberId4,
  filter: () => filter17,
  filterNot: () => filterNot2,
  filterOrDie: () => filterOrDie4,
  filterOrDieMessage: () => filterOrDieMessage4,
  filterOrElse: () => filterOrElse5,
  filterOrFail: () => filterOrFail5,
  firstSuccessOf: () => firstSuccessOf3,
  flatMap: () => flatMap24,
  flatten: () => flatten17,
  flip: () => flip5,
  flipWith: () => flipWith4,
  forEach: () => forEach15,
  fromEither: () => fromEither4,
  fromOption: () => fromOption8,
  gen: () => gen7,
  head: () => head12,
  if: () => if_4,
  ignore: () => ignore4,
  interrupt: () => interrupt10,
  interruptAs: () => interruptAs3,
  isFailure: () => isFailure7,
  isSTM: () => isSTM2,
  isSuccess: () => isSuccess6,
  iterate: () => iterate6,
  let: () => let_10,
  loop: () => loop4,
  map: () => map36,
  mapAttempt: () => mapAttempt3,
  mapBoth: () => mapBoth11,
  mapError: () => mapError12,
  mapInputContext: () => mapInputContext9,
  match: () => match23,
  matchSTM: () => matchSTM2,
  merge: () => merge14,
  mergeAll: () => mergeAll11,
  negate: () => negate4,
  none: () => none12,
  option: () => option8,
  orDie: () => orDie9,
  orDieWith: () => orDieWith7,
  orElse: () => orElse18,
  orElseEither: () => orElseEither8,
  orElseFail: () => orElseFail6,
  orElseOptional: () => orElseOptional2,
  orElseSucceed: () => orElseSucceed6,
  orTry: () => orTry2,
  partition: () => partition10,
  provideContext: () => provideContext10,
  provideService: () => provideService12,
  provideServiceSTM: () => provideServiceSTM2,
  provideSomeContext: () => provideSomeContext5,
  reduce: () => reduce16,
  reduceAll: () => reduceAll2,
  reduceRight: () => reduceRight6,
  refineOrDie: () => refineOrDie5,
  refineOrDieWith: () => refineOrDieWith5,
  reject: () => reject2,
  rejectSTM: () => rejectSTM2,
  repeatUntil: () => repeatUntil2,
  repeatWhile: () => repeatWhile2,
  replicate: () => replicate5,
  replicateSTM: () => replicateSTM2,
  replicateSTMDiscard: () => replicateSTMDiscard2,
  retry: () => retry9,
  retryUntil: () => retryUntil2,
  retryWhile: () => retryWhile2,
  some: () => some14,
  succeed: () => succeed25,
  succeedNone: () => succeedNone4,
  succeedSome: () => succeedSome4,
  summarized: () => summarized5,
  suspend: () => suspend15,
  sync: () => sync19,
  tap: () => tap10,
  tapBoth: () => tapBoth6,
  tapError: () => tapError9,
  try: () => try_5,
  unless: () => unless4,
  unlessSTM: () => unlessSTM2,
  unsome: () => unsome3,
  validateAll: () => validateAll4,
  validateFirst: () => validateFirst4,
  void: () => void_13,
  when: () => when8,
  whenSTM: () => whenSTM2,
  zip: () => zip17,
  zipLeft: () => zipLeft15,
  zipRight: () => zipRight16,
  zipWith: () => zipWith18
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var STMTypeId3 = STMTypeId2;
var isSTM2 = isSTM;
var acquireUseRelease6 = acquireUseRelease4;
var all13 = all10;
var as15 = as11;
var asSome4 = asSome3;
var asSomeError4 = asSomeError3;
var asVoid9 = asVoid7;
var attempt2 = attempt;
var catchAll11 = catchAll6;
var catchSome6 = catchSome3;
var catchTag8 = catchTag3;
var catchTags8 = catchTags3;
var check5 = check4;
var collect4 = collect2;
var collectSTM2 = collectSTM;
var commit3 = commit2;
var commitEither2 = commitEither;
var cond2 = cond;
var context12 = context7;
var contextWith8 = contextWith3;
var contextWithSTM2 = contextWithSTM;
var mapInputContext9 = mapInputContext5;
var die14 = die10;
var dieMessage7 = dieMessage3;
var dieSync10 = dieSync6;
var either11 = either6;
var ensuring10 = ensuring6;
var eventually4 = eventually3;
var every13 = every11;
var exists6 = exists5;
var fail21 = fail17;
var failSync11 = failSync7;
var fiberId4 = fiberId3;
var filter17 = filter14;
var filterNot2 = filterNot;
var filterOrDie4 = filterOrDie3;
var filterOrDieMessage4 = filterOrDieMessage3;
var filterOrElse5 = filterOrElse3;
var filterOrFail5 = filterOrFail3;
var flatMap24 = flatMap20;
var flatten17 = flatten14;
var flip5 = flip4;
var flipWith4 = flipWith3;
var match23 = match21;
var matchSTM2 = matchSTM;
var forEach15 = forEach13;
var fromEither4 = fromEither2;
var fromOption8 = fromOption6;
var gen7 = gen6;
var head12 = head8;
var if_4 = if_3;
var ignore4 = ignore3;
var interrupt10 = interrupt9;
var interruptAs3 = interruptAs2;
var isFailure7 = isFailure6;
var isSuccess6 = isSuccess5;
var iterate6 = iterate3;
var loop4 = loop3;
var map36 = map31;
var mapAttempt3 = mapAttempt2;
var mapBoth11 = mapBoth8;
var mapError12 = mapError8;
var merge14 = merge10;
var mergeAll11 = mergeAll8;
var negate4 = negate3;
var none12 = none10;
var option8 = option5;
var orDie9 = orDie5;
var orDieWith7 = orDieWith4;
var orElse18 = orElse12;
var orElseEither8 = orElseEither5;
var orElseFail6 = orElseFail3;
var orElseOptional2 = orElseOptional;
var orElseSucceed6 = orElseSucceed3;
var orTry2 = orTry;
var partition10 = partition7;
var provideContext10 = provideContext6;
var provideSomeContext5 = provideSomeContext2;
var provideService12 = provideService7;
var provideServiceSTM2 = provideServiceSTM;
var reduce16 = reduce15;
var reduceAll2 = reduceAll;
var reduceRight6 = reduceRight5;
var refineOrDie5 = refineOrDie;
var refineOrDieWith5 = refineOrDieWith;
var reject2 = reject;
var rejectSTM2 = rejectSTM;
var repeatUntil2 = repeatUntil;
var repeatWhile2 = repeatWhile;
var replicate5 = replicate4;
var replicateSTM2 = replicateSTM;
var replicateSTMDiscard2 = replicateSTMDiscard;
var retry9 = retry5;
var retryUntil2 = retryUntil;
var retryWhile2 = retryWhile;
var some14 = some10;
var succeed25 = succeed18;
var succeedNone4 = succeedNone3;
var succeedSome4 = succeedSome3;
var summarized5 = summarized3;
var suspend15 = suspend11;
var sync19 = sync12;
var tap10 = tap6;
var tapBoth6 = tapBoth3;
var tapError9 = tapError5;
var try_5 = try_4;
var unless4 = unless3;
var unlessSTM2 = unlessSTM;
var unsome3 = unsome;
var void_13 = void_9;
var validateAll4 = validateAll3;
var validateFirst4 = validateFirst3;
var when8 = when3;
var whenSTM2 = whenSTM;
var zip17 = zip11;
var zipLeft15 = zipLeft10;
var zipRight16 = zipRight11;
var zipWith18 = zipWith15;
var firstSuccessOf3 = /* @__PURE__ */ __name((effects) => suspend15(() => {
  const list = fromIterable3(effects);
  if (!isNonEmpty(list)) {
    return dieSync10(() => new IllegalArgumentException2(`Received an empty collection of effects`));
  }
  return reduce2(tailNonEmpty2(list), headNonEmpty2(list), (left3, right3) => orElse18(left3, () => right3));
}), "firstSuccessOf");
var Do8 = /* @__PURE__ */ succeed25({});
var bind10 = bind7;
var let_10 = let_7;
var bindTo10 = bindTo7;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/Subscribable.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId52 = /* @__PURE__ */ Symbol.for("effect/Subscribable");
var Proto10 = {
  [TypeId12]: TypeId12,
  [TypeId52]: TypeId52,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/SubscriptionRef.js
var SubscriptionRef_exports = {};
__export(SubscriptionRef_exports, {
  SubscriptionRefTypeId: () => SubscriptionRefTypeId2,
  get: () => get27,
  getAndSet: () => getAndSet5,
  getAndUpdate: () => getAndUpdate5,
  getAndUpdateEffect: () => getAndUpdateEffect3,
  getAndUpdateSome: () => getAndUpdateSome5,
  getAndUpdateSomeEffect: () => getAndUpdateSomeEffect3,
  make: () => make98,
  modify: () => modify13,
  modifyEffect: () => modifyEffect3,
  modifySome: () => modifySome5,
  modifySomeEffect: () => modifySomeEffect3,
  set: () => set18,
  setAndGet: () => setAndGet4,
  update: () => update7,
  updateAndGet: () => updateAndGet5,
  updateAndGetEffect: () => updateAndGetEffect3,
  updateEffect: () => updateEffect3,
  updateSome: () => updateSome5,
  updateSomeAndGet: () => updateSomeAndGet5,
  updateSomeAndGetEffect: () => updateSomeAndGetEffect2,
  updateSomeEffect: () => updateSomeEffect3
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/subscriptionRef.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/SynchronizedRef.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SynchronizedRefTypeId = SynchronizedTypeId;
var getAndUpdateEffect2 = getAndUpdateEffect;
var getAndUpdateSomeEffect2 = getAndUpdateSomeEffect;
var modifySomeEffect2 = modifySomeEffect;
var updateEffect2 = updateEffect;
var updateAndGetEffect2 = updateAndGetEffect;
var updateSomeEffect2 = updateSomeEffect;
var updateSomeAndGetEffect = updateSomeAndGetEffectSynchronized;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/internal/subscriptionRef.js
var SubscriptionRefSymbolKey = "effect/SubscriptionRef";
var SubscriptionRefTypeId = /* @__PURE__ */ Symbol.for(SubscriptionRefSymbolKey);
var subscriptionRefVariance = {
  /* c8 ignore next */
  _A: /* @__PURE__ */ __name((_) => _, "_A")
};
var SubscriptionRefImpl = class extends Class2 {
  static {
    __name(this, "SubscriptionRefImpl");
  }
  ref;
  pubsub;
  semaphore;
  [TypeId12] = TypeId12;
  [TypeId52] = TypeId52;
  [RefTypeId2] = refVariance;
  [SynchronizedRefTypeId] = synchronizedVariance;
  [SubscriptionRefTypeId] = subscriptionRefVariance;
  constructor(ref2, pubsub, semaphore) {
    super();
    this.ref = ref2;
    this.pubsub = pubsub;
    this.semaphore = semaphore;
    this.get = get12(this.ref);
  }
  commit() {
    return this.get;
  }
  get;
  get changes() {
    return pipe(get12(this.ref), flatMap15((a) => map22(fromPubSub(this.pubsub, {
      scoped: true
    }), (s) => concat2(make63(a), s))), this.semaphore.withPermits(1), unwrapScoped4);
  }
  modify(f) {
    return this.modifyEffect((a) => succeed11(f(a)));
  }
  modifyEffect(f) {
    return pipe(get12(this.ref), flatMap15(f), flatMap15(([b, a]) => pipe(set5(this.ref, a), as8(b), zipLeft7(publish2(this.pubsub, a)))), this.semaphore.withPermits(1));
  }
};
var get26 = /* @__PURE__ */ __name((self2) => get12(self2.ref), "get");
var make97 = /* @__PURE__ */ __name((value6) => pipe(all8([unbounded5(), make26(value6), makeSemaphore2(1)]), map22(([pubsub, ref2, semaphore]) => new SubscriptionRefImpl(ref2, pubsub, semaphore))), "make");
var modify12 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
var modifyEffect2 = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect(f));
var set17 = /* @__PURE__ */ dual(2, (self2, value6) => pipe(set5(self2.ref, value6), zipLeft7(publish2(self2.pubsub, value6)), self2.semaphore.withPermits(1)));

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/SubscriptionRef.js
var SubscriptionRefTypeId2 = SubscriptionRefTypeId;
var get27 = get26;
var getAndSet5 = getAndSet2;
var getAndUpdate5 = getAndUpdate2;
var getAndUpdateEffect3 = getAndUpdateEffect2;
var getAndUpdateSome5 = getAndUpdateSome2;
var getAndUpdateSomeEffect3 = getAndUpdateSomeEffect2;
var make98 = make97;
var modify13 = modify12;
var modifyEffect3 = modifyEffect2;
var modifySome5 = modifySome2;
var modifySomeEffect3 = modifySomeEffect2;
var set18 = set17;
var setAndGet4 = setAndGet2;
var update7 = update3;
var updateEffect3 = updateEffect2;
var updateAndGet5 = updateAndGet2;
var updateAndGetEffect3 = updateAndGetEffect2;
var updateSome5 = updateSome2;
var updateSomeEffect3 = updateSomeEffect2;
var updateSomeAndGet5 = updateSomeAndGet2;
var updateSomeAndGetEffect2 = updateSomeAndGetEffect;

// node_modules/.pnpm/effect@3.19.13/node_modules/effect/dist/esm/TRef.js
var TRef_exports = {};
__export(TRef_exports, {
  TRefTypeId: () => TRefTypeId2,
  get: () => get28,
  getAndSet: () => getAndSet6,
  getAndUpdate: () => getAndUpdate6,
  getAndUpdateSome: () => getAndUpdateSome6,
  make: () => make99,
  modify: () => modify14,
  modifySome: () => modifySome6,
  set: () => set19,
  setAndGet: () => setAndGet5,
  update: () => update8,
  updateAndGet: () => updateAndGet6,
  updateSome: () => updateSome6,
  updateSomeAndGet: () => updateSomeAndGet6
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TRefTypeId2 = TRefTypeId;
var get28 = get18;
var getAndSet6 = getAndSet4;
var getAndUpdate6 = getAndUpdate4;
var getAndUpdateSome6 = getAndUpdateSome4;
var make99 = make60;
var modify14 = modify8;
var modifySome6 = modifySome4;
var set19 = set11;
var setAndGet5 = setAndGet3;
var update8 = update6;
var updateAndGet6 = updateAndGet4;
var updateSome6 = updateSome4;
var updateSomeAndGet6 = updateSomeAndGet4;

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/BucketQueue.js
var BucketQueue_exports = {};
__export(BucketQueue_exports, {
  clear: () => clear6,
  make: () => make100,
  offerAll: () => offerAll6,
  peekAll: () => peekAll,
  replace: () => replace4,
  size: () => size21,
  takeBetween: () => takeBetween5,
  takeSplitWhere: () => takeSplitWhere
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var make100 = /* @__PURE__ */ __name(() => TRef_exports.make([]), "make");
var offerAll6 = /* @__PURE__ */ __name((self2, elements) => TRef_exports.update(self2, (bucket) => Array_exports.appendAll(bucket, elements)), "offerAll");
var replace4 = /* @__PURE__ */ __name((self2, elements) => TRef_exports.set(self2, elements), "replace");
var clear6 = /* @__PURE__ */ __name((self2) => TRef_exports.set(self2, []), "clear");
var takeBetween5 = /* @__PURE__ */ __name((bucket, min6, max9) => STM_exports.gen(function* () {
  const bucketValue = yield* TRef_exports.get(bucket);
  if (bucketValue.length < min6) {
    return yield* STM_exports.retry;
  } else {
    const elements = bucketValue.splice(0, Math.min(max9, bucketValue.length));
    yield* TRef_exports.set(bucket, bucketValue);
    return elements;
  }
}), "takeBetween");
var peekAll = /* @__PURE__ */ __name((bucket) => TRef_exports.get(bucket), "peekAll");
var takeSplitWhere = /* @__PURE__ */ __name((bucket, predicate) => STM_exports.gen(function* () {
  const bucketValue = yield* TRef_exports.get(bucket);
  const [elements, rest] = Array_exports.splitWhere(bucketValue, predicate);
  yield* TRef_exports.set(bucket, rest);
  return elements;
}), "takeSplitWhere");
var size21 = /* @__PURE__ */ __name((bucket) => TRef_exports.get(bucket).pipe(Effect_exports.map((_) => _.length)), "size");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Logger.js
var Logger_exports2 = {};
__export(Logger_exports2, {
  LoggerTypeId: () => LoggerTypeId2,
  add: () => add7,
  addEffect: () => addEffect,
  addScoped: () => addScoped,
  batched: () => batched,
  consoleLogger: () => consoleLogger,
  consoleWithThread: () => consoleWithThread,
  defaultLogger: () => defaultLogger2,
  filterLogLevel: () => filterLogLevel2,
  isLogger: () => isLogger2,
  json: () => json3,
  jsonLogger: () => jsonLogger3,
  logFmt: () => logFmt,
  logfmtLogger: () => logfmtLogger2,
  make: () => make68,
  map: () => map34,
  mapInput: () => mapInput9,
  mapInputOptions: () => mapInputOptions2,
  minimumLogLevel: () => minimumLogLevel2,
  none: () => none11,
  pretty: () => pretty5,
  prettyLogger: () => prettyLogger3,
  prettyLoggerDefault: () => prettyLoggerDefault2,
  prettyWithThread: () => prettyWithThread,
  remove: () => remove12,
  replace: () => replace3,
  replaceEffect: () => replaceEffect,
  replaceScoped: () => replaceScoped,
  simple: () => simple2,
  stringLogger: () => stringLogger2,
  structured: () => structured,
  structuredLogger: () => structuredLogger3,
  succeed: () => succeed23,
  sync: () => sync17,
  test: () => test2,
  tracerLogger: () => tracerLogger2,
  withConsoleError: () => withConsoleError,
  withConsoleLog: () => withConsoleLog,
  withLeveledConsole: () => withLeveledConsole,
  withMinimumLogLevel: () => withMinimumLogLevel2,
  withSpanAnnotations: () => withSpanAnnotations,
  zip: () => zip15,
  zipLeft: () => zipLeft14,
  zipRight: () => zipRight15
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var defaultDateFormat2 = /* @__PURE__ */ __name((date4) => `${date4.getHours().toString().padStart(2, "0")}:${date4.getMinutes().toString().padStart(2, "0")}:${date4.getSeconds().toString().padStart(2, "0")}.${date4.getMilliseconds().toString().padStart(3, "0")}`, "defaultDateFormat");
var prettyWithThread = /* @__PURE__ */ __name((threadName3, options4 = {}) => Logger_exports.replace(Logger_exports.defaultLogger, Logger_exports.prettyLogger({
  formatDate: /* @__PURE__ */ __name((date4) => `${defaultDateFormat2(date4)} ${threadName3}`, "formatDate"),
  mode: options4.mode
})), "prettyWithThread");
var consoleLogger = /* @__PURE__ */ __name((threadName3) => Logger_exports.make(({ message, annotations: annotations3, date: date4, logLevel: logLevel2, cause: cause3 }) => {
  const isCloudflareWorker = typeof navigator !== "undefined" && true;
  const consoleFn = logLevel2 === LogLevel_exports.Debug ? (
    // Cloudflare Workers doesn't support console.debug 
    isCloudflareWorker ? console.log : console.debug
  ) : logLevel2 === LogLevel_exports.Info ? console.info : logLevel2 === LogLevel_exports.Warning ? console.warn : console.error;
  const annotationsObj = Object.fromEntries(HashMap_exports.entries(annotations3));
  const messages = Array.isArray(message) ? message : [message];
  if (Cause_exports.isEmpty(cause3) === false) {
    messages.push(Cause_exports.pretty(cause3, { renderErrorCause: true }));
  }
  if (Object.keys(annotationsObj).length > 0) {
    messages.push(annotationsObj);
  }
  consoleFn(`[${defaultDateFormat2(date4)} ${threadName3}]`, ...messages);
}), "consoleLogger");
var consoleWithThread = /* @__PURE__ */ __name((threadName3) => Logger_exports.replace(Logger_exports.defaultLogger, consoleLogger(threadName3)), "consoleWithThread");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/OtelTracer.js
var OtelTracer_exports = {};
__export(OtelTracer_exports, {
  OtelTraceFlags: () => OtelTraceFlags,
  OtelTraceState: () => OtelTraceState,
  OtelTracer: () => OtelTracer,
  OtelTracerProvider: () => OtelTracerProvider,
  currentOtelSpan: () => currentOtelSpan2,
  layer: () => layer13,
  layerGlobal: () => layerGlobal2,
  layerGlobalTracer: () => layerGlobalTracer2,
  layerTracer: () => layerTracer2,
  layerWithoutOtelTracer: () => layerWithoutOtelTracer2,
  make: () => make102,
  makeExternalSpan: () => makeExternalSpan2,
  makeSpanLink: () => makeSpanLink,
  withSpanContext: () => withSpanContext2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/Tracer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/internal/tracer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var OtelApi = __toESM(require_src(), 1);
var OtelSemConv = __toESM(require_src2(), 1);

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/Resource.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Resource = /* @__PURE__ */ GenericTag("@effect/opentelemetry/Resource");

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/internal/utils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var bigint1e92 = 1000000000n;
var nanosToHrTime = /* @__PURE__ */ __name((timestamp) => {
  return [Number(timestamp / bigint1e92), Number(timestamp % bigint1e92)];
}, "nanosToHrTime");
var recordToAttributes = /* @__PURE__ */ __name((value6) => Object.entries(value6).reduce((acc, [key, value7]) => {
  acc[key] = unknownToAttributeValue2(value7);
  return acc;
}, {}), "recordToAttributes");
var unknownToAttributeValue2 = /* @__PURE__ */ __name((value6) => {
  if (typeof value6 === "string" || typeof value6 === "number" || typeof value6 === "boolean") {
    return value6;
  } else if (typeof value6 === "bigint") {
    return Number(value6);
  }
  return toStringUnknown(value6);
}, "unknownToAttributeValue");

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/internal/tracer.js
var OtelSpanTypeId = /* @__PURE__ */ Symbol.for("@effect/opentelemetry/Tracer/OtelSpan");
var kindMap = {
  "internal": OtelApi.SpanKind.INTERNAL,
  "client": OtelApi.SpanKind.CLIENT,
  "server": OtelApi.SpanKind.SERVER,
  "producer": OtelApi.SpanKind.PRODUCER,
  "consumer": OtelApi.SpanKind.CONSUMER
};
var OtelSpan = class {
  static {
    __name(this, "OtelSpan");
  }
  name;
  parent;
  context;
  links;
  kind;
  [OtelSpanTypeId];
  _tag = "Span";
  span;
  spanId;
  traceId;
  attributes = /* @__PURE__ */ new Map();
  sampled;
  status;
  constructor(contextApi, tracer4, name, parent, context17, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context17;
    this.links = links;
    this.kind = kind;
    this[OtelSpanTypeId] = OtelSpanTypeId;
    const active2 = contextApi.active();
    this.span = tracer4.startSpan(name, {
      startTime: nanosToHrTime(startTime),
      links: links.length > 0 ? links.map((link) => ({
        context: makeSpanContext(link.span),
        attributes: recordToAttributes(link.attributes)
      })) : void 0,
      kind: kindMap[this.kind]
    }, parent._tag === "Some" ? populateContext(active2, parent.value, context17) : OtelApi.trace.deleteSpan(active2));
    const spanContext = this.span.spanContext();
    this.spanId = spanContext.spanId;
    this.traceId = spanContext.traceId;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.sampled = (spanContext.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED;
  }
  attribute(key, value6) {
    this.span.setAttribute(key, unknownToAttributeValue2(value6));
    this.attributes.set(key, value6);
  }
  addLinks(links) {
    this.links.push(...links);
    this.span.addLinks(links.map((link) => ({
      context: makeSpanContext(link.span),
      attributes: recordToAttributes(link.attributes)
    })));
  }
  end(endTime, exit5) {
    const hrTime = nanosToHrTime(endTime);
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit5,
      startTime: this.status.startTime
    };
    if (exit5._tag === "Success") {
      this.span.setStatus({
        code: OtelApi.SpanStatusCode.OK
      });
    } else {
      if (isInterruptedOnly2(exit5.cause)) {
        this.span.setStatus({
          code: OtelApi.SpanStatusCode.OK,
          message: pretty3(exit5.cause)
        });
        this.span.setAttribute("span.label", "\u26A0\uFE0E Interrupted");
        this.span.setAttribute("status.interrupted", true);
      } else {
        const firstError = prettyErrors2(exit5.cause)[0];
        if (firstError) {
          firstError.stack = pretty3(exit5.cause, {
            renderErrorCause: true
          });
          this.span.recordException(firstError, hrTime);
          this.span.setStatus({
            code: OtelApi.SpanStatusCode.ERROR,
            message: firstError.message
          });
        } else {
          this.span.setStatus({
            code: OtelApi.SpanStatusCode.OK
          });
        }
      }
    }
    this.span.end(hrTime);
  }
  event(name, startTime, attributes) {
    this.span.addEvent(name, attributes ? recordToAttributes(attributes) : void 0, nanosToHrTime(startTime));
  }
};
var TracerProvider = /* @__PURE__ */ GenericTag("@effect/opentelemetry/Tracer/OtelTracerProvider");
var Tracer = /* @__PURE__ */ GenericTag("@effect/opentelemetry/Tracer/OtelTracer");
var make101 = /* @__PURE__ */ map22(Tracer, (tracer4) => make29({
  span(name, parent, context17, links, startTime, kind) {
    return new OtelSpan(OtelApi.context, tracer4, name, parent, context17, links.slice(), startTime, kind);
  },
  context(execution, fiber) {
    const currentSpan3 = fiber.currentSpan;
    if (currentSpan3 === void 0) {
      return execution();
    }
    return OtelApi.context.with(populateContext(OtelApi.context.active(), currentSpan3), execution);
  }
}));
var traceFlagsTag = /* @__PURE__ */ GenericTag("@effect/opentelemetry/Tracer/OtelTraceFlags");
var traceStateTag = /* @__PURE__ */ GenericTag("@effect/opentelemetry/Tracer/OtelTraceState");
var makeExternalSpan = /* @__PURE__ */ __name((options4) => {
  let context17 = empty10();
  if (options4.traceFlags !== void 0) {
    context17 = add4(context17, traceFlagsTag, options4.traceFlags);
  }
  if (typeof options4.traceState === "string") {
    context17 = match2(createTraceState2(options4.traceState), {
      onNone: /* @__PURE__ */ __name(() => context17, "onNone"),
      onSome: /* @__PURE__ */ __name((traceState) => add4(context17, traceStateTag, traceState), "onSome")
    });
  } else if (options4.traceState) {
    context17 = add4(context17, traceStateTag, options4.traceState);
  }
  return {
    _tag: "ExternalSpan",
    traceId: options4.traceId,
    spanId: options4.spanId,
    sampled: options4.traceFlags !== void 0 ? (options4.traceFlags & OtelApi.TraceFlags.SAMPLED) === OtelApi.TraceFlags.SAMPLED : true,
    context: context17
  };
}, "makeExternalSpan");
var currentOtelSpan = /* @__PURE__ */ flatMap15(currentSpan2, (span4) => {
  if (OtelSpanTypeId in span4) {
    return succeed11(span4.span);
  }
  return fail10(new NoSuchElementException2());
});
var layerGlobalProvider = /* @__PURE__ */ sync9(TracerProvider, () => OtelApi.trace.getTracerProvider());
var layerTracer = /* @__PURE__ */ effect(Tracer, /* @__PURE__ */ flatMap15(/* @__PURE__ */ zip8(Resource, TracerProvider), ([resource, provider]) => sync7(() => provider.getTracer(resource.attributes[OtelSemConv.ATTR_SERVICE_NAME], resource.attributes[OtelSemConv.ATTR_SERVICE_VERSION]))));
var layerGlobalTracer = /* @__PURE__ */ layerTracer.pipe(/* @__PURE__ */ provide3(layerGlobalProvider));
var layerGlobal = /* @__PURE__ */ unwrapEffect2(map22(make101, setTracer2)).pipe(/* @__PURE__ */ provideMerge2(layerGlobalTracer));
var layerWithoutOtelTracer = /* @__PURE__ */ unwrapEffect2(/* @__PURE__ */ map22(make101, setTracer2));
var layer12 = /* @__PURE__ */ layerWithoutOtelTracer.pipe(/* @__PURE__ */ provideMerge2(layerTracer));
var createTraceState2 = /* @__PURE__ */ liftThrowable(OtelApi.createTraceState);
var populateContext = /* @__PURE__ */ __name((otelContext, span4, context17) => span4 instanceof OtelSpan ? OtelApi.trace.setSpan(otelContext, span4.span) : OtelApi.trace.setSpanContext(otelContext, makeSpanContext(span4, context17)), "populateContext");
var makeSpanContext = /* @__PURE__ */ __name((span4, context17) => ({
  spanId: span4.spanId,
  traceId: span4.traceId,
  isRemote: span4._tag === "ExternalSpan",
  traceFlags: getOrElse2(context17 ? extractTraceTag(span4, context17, traceFlagsTag) : getOption2(span4.context, traceFlagsTag), () => OtelApi.TraceFlags.SAMPLED),
  traceState: getOrUndefined2(context17 ? extractTraceTag(span4, context17, traceStateTag) : getOption2(span4.context, traceStateTag))
}), "makeSpanContext");
var extractTraceTag = /* @__PURE__ */ __name((parent, context17, tag8) => orElse2(getOption2(context17, tag8), () => getOption2(parent.context, tag8)), "extractTraceTag");
var withSpanContext = /* @__PURE__ */ dual(2, (effect4, spanContext) => withParentSpan3(effect4, makeExternalSpan(spanContext)));

// node_modules/.pnpm/@effect+opentelemetry@0.56.6_@effect+platform@0.90.10_effect@3.19.13__@opentelemetry+ap_f85ab8de086588e60845b7d78b166ba4/node_modules/@effect/opentelemetry/dist/esm/Tracer.js
var make102 = make101;
var makeExternalSpan2 = makeExternalSpan;
var currentOtelSpan2 = currentOtelSpan;
var layerWithoutOtelTracer2 = layerWithoutOtelTracer;
var layer13 = layer12;
var layerGlobal2 = layerGlobal;
var layerTracer2 = layerTracer;
var layerGlobalTracer2 = layerGlobalTracer;
var OtelTracerProvider = TracerProvider;
var OtelTracer = Tracer;
var OtelTraceFlags = traceFlagsTag;
var OtelTraceState = traceStateTag;
var withSpanContext2 = withSpanContext;

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/OtelTracer.js
var makeSpanLink = /* @__PURE__ */ __name((otelSpanLink) => ({
  _tag: "SpanLink",
  span: makeExternalSpan2(otelSpanLink.context),
  attributes: otelSpanLink.attributes ?? {}
}), "makeSpanLink");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/RpcClient.js
var RpcClient_exports2 = {};
__export(RpcClient_exports2, {
  Protocol: () => Protocol,
  RpcClientError: () => RpcClientError2,
  SocketPinger: () => SocketPinger,
  currentHeaders: () => currentHeaders,
  layerProtocolHttp: () => layerProtocolHttp,
  layerProtocolSocket: () => layerProtocolSocket,
  layerProtocolSocketWithIsConnected: () => layerProtocolSocketWithIsConnected,
  layerProtocolWorker: () => layerProtocolWorker,
  make: () => make92,
  makeNoSerialization: () => makeNoSerialization,
  makeProtocolHttp: () => makeProtocolHttp,
  makeProtocolSocket: () => makeProtocolSocket,
  makeProtocolSocketWithIsConnected: () => makeProtocolSocketWithIsConnected,
  makeProtocolWorker: () => makeProtocolWorker,
  withHeaders: () => withHeaders,
  withHeadersEffect: () => withHeadersEffect
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/SubscriptionRef.js
var SubscriptionRef_exports2 = {};
__export(SubscriptionRef_exports2, {
  SubscriptionRefTypeId: () => SubscriptionRefTypeId2,
  fromStream: () => fromStream3,
  get: () => get27,
  getAndSet: () => getAndSet5,
  getAndUpdate: () => getAndUpdate5,
  getAndUpdateEffect: () => getAndUpdateEffect3,
  getAndUpdateSome: () => getAndUpdateSome5,
  getAndUpdateSomeEffect: () => getAndUpdateSomeEffect3,
  make: () => make98,
  modify: () => modify13,
  modifyEffect: () => modifyEffect3,
  modifySome: () => modifySome5,
  modifySomeEffect: () => modifySomeEffect3,
  set: () => set18,
  setAndGet: () => setAndGet4,
  update: () => update7,
  updateAndGet: () => updateAndGet5,
  updateAndGetEffect: () => updateAndGetEffect3,
  updateEffect: () => updateEffect3,
  updateSome: () => updateSome5,
  updateSomeAndGet: () => updateSomeAndGet5,
  updateSomeAndGetEffect: () => updateSomeAndGetEffect2,
  updateSomeEffect: () => updateSomeEffect3,
  waitUntil: () => waitUntil
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var waitUntil = dual(2, (sref, predicate) => pipe(sref.changes, Stream_exports.filter(predicate), Stream_exports.take(1), Stream_exports.runCollect, Effect_exports.map(Chunk_exports.unsafeHead)));
var fromStream3 = /* @__PURE__ */ __name((stream6, initialValue) => Effect_exports.gen(function* () {
  const sref = yield* SubscriptionRef_exports.make(initialValue);
  yield* stream6.pipe(Stream_exports.tap((a) => SubscriptionRef_exports.set(sref, a)), Stream_exports.runDrain, Effect_exports.forkScoped);
  return sref;
}), "fromStream");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/RpcClient.js
var layerProtocolSocketWithIsConnected = /* @__PURE__ */ __name((options4) => Layer_exports.scoped(Protocol, makeProtocolSocketWithIsConnected(options4)), "layerProtocolSocketWithIsConnected");
var makeProtocolSocketWithIsConnected = /* @__PURE__ */ __name((options4) => Protocol.make(Effect_exports.fnUntraced(function* (writeResponse) {
  const socket = yield* Socket_exports.Socket;
  const serialization = yield* RpcSerialization_exports.RpcSerialization;
  const write3 = yield* socket.writer;
  const parser = serialization.unsafeMake();
  const pinger = yield* makePinger2(write3(parser.encode(constPing)), options4?.pingSchedule);
  yield* Effect_exports.suspend(() => {
    pinger.reset();
    return socket.runRaw((message) => {
      try {
        const responses = parser.decode(message);
        if (responses.length === 0)
          return;
        let i = 0;
        return Effect_exports.whileLoop({
          while: /* @__PURE__ */ __name(() => i < responses.length, "while"),
          body: /* @__PURE__ */ __name(() => {
            const response = responses[i++];
            if (response._tag === "Pong") {
              pinger.onPong();
            }
            return writeResponse(response).pipe(
              // CHANGED: set isConnected to true on pong
              Effect_exports.tap(Effect_exports.fn(function* () {
                if (options4?.isConnected !== void 0) {
                  yield* set18(options4.isConnected, true);
                }
              }))
            );
          }, "body"),
          step: constVoid
        });
      } catch (defect) {
        return writeResponse({
          _tag: "ClientProtocolError",
          error: new RpcClientError2({
            reason: "Protocol",
            message: "Error decoding message",
            cause: Cause_exports.fail(defect)
          })
        });
      }
    }).pipe(Effect_exports.raceFirst(Effect_exports.zipRight(pinger.timeout, Effect_exports.fail(new Socket_exports.SocketGenericError({
      reason: "OpenTimeout",
      cause: new Error("ping timeout")
    })))));
  }).pipe(
    Effect_exports.zipRight(Effect_exports.fail(new Socket_exports.SocketCloseError({
      reason: "Close",
      code: 1e3,
      closeReason: "Closing connection"
    }))),
    Effect_exports.tapErrorCause(Effect_exports.fn(function* (cause3) {
      if (options4?.isConnected !== void 0) {
        yield* set18(options4.isConnected, false);
      }
      const error5 = Cause_exports.failureOption(cause3);
      if (options4?.retryTransientErrors && Option_exports.isSome(error5) && (error5.value.reason === "Open" || error5.value.reason === "OpenTimeout")) {
        return;
      }
      return yield* writeResponse({
        _tag: "ClientProtocolError",
        error: new RpcClientError2({
          reason: "Protocol",
          message: "Error in socket",
          cause: Cause_exports.squash(cause3)
        })
      });
    })),
    // CHANGED: make configurable via schedule
    options4?.retryTransientErrors ? Effect_exports.retry(options4.retryTransientErrors) : identity,
    Effect_exports.annotateLogs({
      module: "RpcClient",
      method: "makeProtocolSocket"
    }),
    Effect_exports.interruptible,
    Effect_exports.ignore,
    // Errors are already handled
    Effect_exports.provide(Layer_exports.setUnhandledErrorLogLevel(Option_exports.none())),
    Effect_exports.forkScoped
  );
  return {
    send: /* @__PURE__ */ __name((request2) => {
      const encoded = parser.encode(request2);
      if (encoded === void 0)
        return Effect_exports.void;
      return Effect_exports.orDie(write3(encoded));
    }, "send"),
    supportsAck: true,
    supportsTransferables: false,
    pinger
  };
})), "makeProtocolSocketWithIsConnected");
var SocketPinger = Effect_exports.map(RpcClient_exports.Protocol, (protocol) => protocol.pinger);
var makePinger2 = Effect_exports.fnUntraced(function* (writePing, pingSchedule = Schedule_exports.spaced(1e4).pipe(Schedule_exports.addDelay(() => 5e3))) {
  const manualPingDeferreds = /* @__PURE__ */ new Set();
  let recievedPong = true;
  const latch = Effect_exports.unsafeMakeLatch();
  const reset2 = /* @__PURE__ */ __name(() => {
    recievedPong = true;
    latch.unsafeClose();
  }, "reset");
  const onPong = /* @__PURE__ */ __name(() => {
    recievedPong = true;
    for (const deferred of manualPingDeferreds) {
      Deferred_exports.unsafeDone(deferred, Effect_exports.void);
    }
  }, "onPong");
  yield* Effect_exports.suspend(() => {
    if (!recievedPong)
      return latch.open;
    recievedPong = false;
    return writePing;
  }).pipe(
    // CHANGED: make configurable via schedule
    Effect_exports.schedule(pingSchedule),
    Effect_exports.ignore,
    Effect_exports.forever,
    Effect_exports.interruptible,
    Effect_exports.forkScoped
  );
  const ping = Effect_exports.gen(function* () {
    const deferred = yield* Deferred_exports.make();
    manualPingDeferreds.add(deferred);
    yield* deferred;
    manualPingDeferreds.delete(deferred);
  });
  return { timeout: latch.await, reset: reset2, onPong, ping };
});
var RpcClientError2 = class {
  static {
    __name(this, "RpcClientError");
  }
  constructor(options4) {
    this.reason = options4.reason;
    this.message = options4.message;
    this.cause = options4.cause;
  }
};

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Schema/index.js
var Schema_exports2 = {};
__export(Schema_exports2, {
  Any: () => Any,
  Array: () => Array$,
  ArrayEnsure: () => ArrayEnsure,
  ArrayFormatterIssue: () => ArrayFormatterIssue,
  Base64FromUint8Array: () => Base64FromUint8Array,
  BetweenBigDecimalSchemaId: () => BetweenBigDecimalSchemaId,
  BetweenBigIntSchemaId: () => BetweenBigIntSchemaId,
  BetweenDateSchemaId: () => BetweenDateSchemaId,
  BetweenDurationSchemaId: () => BetweenDurationSchemaId,
  BetweenSchemaId: () => BetweenSchemaId2,
  BigDecimal: () => BigDecimal,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigInt: () => BigInt$,
  BigIntFromNumber: () => BigIntFromNumber,
  BigIntFromSelf: () => BigIntFromSelf,
  Boolean: () => Boolean$,
  BooleanFromString: () => BooleanFromString,
  BooleanFromUnknown: () => BooleanFromUnknown,
  BrandSchemaId: () => BrandSchemaId,
  Capitalize: () => Capitalize,
  Capitalized: () => Capitalized,
  CapitalizedSchemaId: () => CapitalizedSchemaId,
  Cause: () => Cause,
  CauseFromSelf: () => CauseFromSelf,
  Char: () => Char,
  Chunk: () => Chunk,
  ChunkFromSelf: () => ChunkFromSelf,
  Class: () => Class6,
  Config: () => Config,
  Data: () => Data,
  DataFromSelf: () => DataFromSelf,
  Date: () => Date$,
  DateFromNumber: () => DateFromNumber,
  DateFromSelf: () => DateFromSelf,
  DateFromSelfSchemaId: () => DateFromSelfSchemaId2,
  DateFromString: () => DateFromString,
  DateTimeUtc: () => DateTimeUtc,
  DateTimeUtcFromDate: () => DateTimeUtcFromDate,
  DateTimeUtcFromNumber: () => DateTimeUtcFromNumber,
  DateTimeUtcFromSelf: () => DateTimeUtcFromSelf,
  DateTimeZoned: () => DateTimeZoned,
  DateTimeZonedFromSelf: () => DateTimeZonedFromSelf,
  Defect: () => Defect,
  Duration: () => Duration,
  DurationFromMillis: () => DurationFromMillis,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromSelf: () => DurationFromSelf,
  Either: () => Either,
  EitherFromSelf: () => EitherFromSelf,
  EitherFromUnion: () => EitherFromUnion,
  EndsWithSchemaId: () => EndsWithSchemaId,
  Enums: () => Enums2,
  Exit: () => Exit,
  ExitFromSelf: () => ExitFromSelf,
  FiberId: () => FiberId,
  FiberIdFromSelf: () => FiberIdFromSelf,
  Finite: () => Finite,
  FiniteSchemaId: () => FiniteSchemaId2,
  FromPropertySignature: () => FromPropertySignature,
  GreaterThanBigDecimalSchemaId: () => GreaterThanBigDecimalSchemaId,
  GreaterThanBigIntSchemaId: () => GreaterThanBigIntSchemaId,
  GreaterThanDateSchemaId: () => GreaterThanDateSchemaId,
  GreaterThanDurationSchemaId: () => GreaterThanDurationSchemaId,
  GreaterThanOrEqualToBigDecimalSchemaId: () => GreaterThanOrEqualToBigDecimalSchemaId,
  GreaterThanOrEqualToBigIntSchemaId: () => GreaterThanOrEqualToBigIntSchemaId2,
  GreaterThanOrEqualToDateSchemaId: () => GreaterThanOrEqualToDateSchemaId,
  GreaterThanOrEqualToDurationSchemaId: () => GreaterThanOrEqualToDurationSchemaId,
  GreaterThanOrEqualToSchemaId: () => GreaterThanOrEqualToSchemaId2,
  GreaterThanSchemaId: () => GreaterThanSchemaId2,
  HashMap: () => HashMap,
  HashMapFromSelf: () => HashMapFromSelf,
  HashSet: () => HashSet,
  HashSetFromSelf: () => HashSetFromSelf,
  IncludesSchemaId: () => IncludesSchemaId,
  InstanceOfSchemaId: () => InstanceOfSchemaId,
  Int: () => Int,
  IntSchemaId: () => IntSchemaId2,
  ItemsCountSchemaId: () => ItemsCountSchemaId2,
  JsonNumber: () => JsonNumber,
  JsonNumberSchemaId: () => JsonNumberSchemaId2,
  JsonValue: () => JsonValue,
  LengthSchemaId: () => LengthSchemaId2,
  LessThanBigDecimalSchemaId: () => LessThanBigDecimalSchemaId,
  LessThanBigIntSchemaId: () => LessThanBigIntSchemaId2,
  LessThanDateSchemaId: () => LessThanDateSchemaId,
  LessThanDurationSchemaId: () => LessThanDurationSchemaId,
  LessThanOrEqualToBigDecimalSchemaId: () => LessThanOrEqualToBigDecimalSchemaId,
  LessThanOrEqualToBigIntSchemaId: () => LessThanOrEqualToBigIntSchemaId2,
  LessThanOrEqualToDateSchemaId: () => LessThanOrEqualToDateSchemaId,
  LessThanOrEqualToDurationSchemaId: () => LessThanOrEqualToDurationSchemaId,
  LessThanOrEqualToSchemaId: () => LessThanOrEqualToSchemaId2,
  LessThanSchemaId: () => LessThanSchemaId2,
  List: () => List,
  ListFromSelf: () => ListFromSelf,
  Literal: () => Literal2,
  Lowercase: () => Lowercase,
  Lowercased: () => Lowercased,
  LowercasedSchemaId: () => LowercasedSchemaId,
  Map: () => map27,
  MapFromRecord: () => MapFromRecord,
  MapFromSelf: () => MapFromSelf,
  MaxItemsSchemaId: () => MaxItemsSchemaId2,
  MaxLengthSchemaId: () => MaxLengthSchemaId2,
  MinItemsSchemaId: () => MinItemsSchemaId2,
  MinLengthSchemaId: () => MinLengthSchemaId2,
  MsgPack: () => MsgPack,
  MultipleOfSchemaId: () => MultipleOfSchemaId,
  Negative: () => Negative,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  NegativeBigDecimalSchemaId: () => NegativeBigDecimalSchemaId,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  Never: () => Never,
  NonEmptyArray: () => NonEmptyArray,
  NonEmptyArrayEnsure: () => NonEmptyArrayEnsure,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyString: () => NonEmptyString,
  NonEmptyTrimmedString: () => NonEmptyTrimmedString,
  NonNaN: () => NonNaN,
  NonNaNSchemaId: () => NonNaNSchemaId2,
  NonNegative: () => NonNegative,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegativeBigDecimalSchemaId: () => NonNegativeBigDecimalSchemaId,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeInt: () => NonNegativeInt,
  NonPositive: () => NonPositive,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositiveBigDecimalSchemaId: () => NonPositiveBigDecimalSchemaId,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  Not: () => Not,
  Null: () => Null,
  NullOr: () => NullOr,
  NullishOr: () => NullishOr,
  Number: () => Number$,
  NumberFromString: () => NumberFromString,
  Object: () => Object$,
  Option: () => Option,
  OptionFromNonEmptyTrimmedString: () => OptionFromNonEmptyTrimmedString,
  OptionFromNullOr: () => OptionFromNullOr,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  PatternSchemaId: () => PatternSchemaId,
  Positive: () => Positive,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  PositiveBigDecimalSchemaId: () => PositiveBigDecimalSchemaId,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PropertyKey: () => PropertyKey$,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PropertySignatureTransformation: () => PropertySignatureTransformation2,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  ReadonlyMap: () => ReadonlyMap,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  Record: () => Record,
  Redacted: () => Redacted,
  RedactedFromSelf: () => RedactedFromSelf,
  RefineSchemaId: () => RefineSchemaId,
  Set: () => set8,
  SetFromSelf: () => SetFromSelf,
  SortedSet: () => SortedSet,
  SortedSetFromSelf: () => SortedSetFromSelf,
  StartsWithSchemaId: () => StartsWithSchemaId,
  String: () => String$,
  StringFromBase64: () => StringFromBase64,
  StringFromBase64Url: () => StringFromBase64Url,
  StringFromHex: () => StringFromHex,
  StringFromUriComponent: () => StringFromUriComponent,
  Struct: () => Struct,
  Symbol: () => Symbol$,
  SymbolFromSelf: () => SymbolFromSelf,
  TaggedClass: () => TaggedClass3,
  TaggedError: () => TaggedError2,
  TaggedRequest: () => TaggedRequest,
  TaggedStruct: () => TaggedStruct,
  TemplateLiteral: () => TemplateLiteral2,
  TemplateLiteralParser: () => TemplateLiteralParser,
  TimeZone: () => TimeZone,
  TimeZoneFromSelf: () => TimeZoneFromSelf,
  TimeZoneNamed: () => TimeZoneNamed,
  TimeZoneNamedFromSelf: () => TimeZoneNamedFromSelf,
  TimeZoneOffset: () => TimeZoneOffset,
  TimeZoneOffsetFromSelf: () => TimeZoneOffsetFromSelf,
  ToPropertySignature: () => ToPropertySignature,
  Trim: () => Trim,
  Trimmed: () => Trimmed,
  TrimmedSchemaId: () => TrimmedSchemaId,
  Tuple: () => Tuple,
  TypeId: () => TypeId21,
  ULID: () => ULID,
  ULIDSchemaId: () => ULIDSchemaId,
  URL: () => URL$,
  URLFromSelf: () => URLFromSelf,
  UUID: () => UUID,
  UUIDSchemaId: () => UUIDSchemaId,
  Uint8: () => Uint8,
  Uint8Array: () => Uint8Array$,
  Uint8ArrayFromBase64: () => Uint8ArrayFromBase64,
  Uint8ArrayFromBase64Url: () => Uint8ArrayFromBase64Url,
  Uint8ArrayFromHex: () => Uint8ArrayFromHex,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uncapitalize: () => Uncapitalize,
  Uncapitalized: () => Uncapitalized,
  UncapitalizedSchemaId: () => UncapitalizedSchemaId,
  Undefined: () => Undefined,
  UndefinedOr: () => UndefinedOr,
  Union: () => Union2,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Unknown: () => Unknown,
  Uppercase: () => Uppercase,
  Uppercased: () => Uppercased,
  UppercasedSchemaId: () => UppercasedSchemaId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  ValidDateSchemaId: () => ValidDateSchemaId,
  Void: () => Void,
  annotations: () => annotations2,
  asSchema: () => asSchema,
  asSerializable: () => asSerializable,
  asSerializableWithResult: () => asSerializableWithResult,
  asWithResult: () => asWithResult,
  asserts: () => asserts,
  attachPropertySignature: () => attachPropertySignature,
  between: () => between5,
  betweenBigDecimal: () => betweenBigDecimal,
  betweenBigInt: () => betweenBigInt,
  betweenDate: () => betweenDate,
  betweenDuration: () => betweenDuration,
  brand: () => brand,
  capitalized: () => capitalized,
  clamp: () => clamp8,
  clampBigDecimal: () => clampBigDecimal,
  clampBigInt: () => clampBigInt,
  clampDuration: () => clampDuration,
  compose: () => compose4,
  debugDiff: () => debugDiff,
  declare: () => declare,
  decode: () => decode6,
  decodeEither: () => decodeEither2,
  decodeOption: () => decodeOption,
  decodePromise: () => decodePromise2,
  decodeSync: () => decodeSync,
  decodeSyncDebug: () => decodeSyncDebug,
  decodeUnknown: () => decodeUnknown3,
  decodeUnknownEither: () => decodeUnknownEither2,
  decodeUnknownOption: () => decodeUnknownOption,
  decodeUnknownPromise: () => decodeUnknownPromise2,
  decodeUnknownSync: () => decodeUnknownSync,
  deserialize: () => deserialize,
  deserializeExit: () => deserializeExit,
  deserializeFailure: () => deserializeFailure,
  deserializeSuccess: () => deserializeSuccess,
  element: () => element,
  encode: () => encode5,
  encodeEither: () => encodeEither2,
  encodeOption: () => encodeOption,
  encodePromise: () => encodePromise2,
  encodeSync: () => encodeSync,
  encodeSyncDebug: () => encodeSyncDebug,
  encodeUnknown: () => encodeUnknown2,
  encodeUnknownEither: () => encodeUnknownEither2,
  encodeUnknownOption: () => encodeUnknownOption,
  encodeUnknownPromise: () => encodeUnknownPromise2,
  encodeUnknownSync: () => encodeUnknownSync,
  encodeWithTransferables: () => encodeWithTransferables,
  encodedBoundSchema: () => encodedBoundSchema,
  encodedSchema: () => encodedSchema,
  endsWith: () => endsWith,
  equivalence: () => equivalence2,
  exitSchema: () => exitSchema,
  extend: () => extend4,
  failureSchema: () => failureSchema,
  filter: () => filter13,
  filterEffect: () => filterEffect,
  finite: () => finite,
  format: () => format6,
  fromBrand: () => fromBrand,
  fromKey: () => fromKey,
  getClassTag: () => getClassTag,
  getNumberIndexedAccess: () => getNumberIndexedAccess2,
  greaterThan: () => greaterThan6,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanDate: () => greaterThanDate,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo5,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToDate: () => greaterThanOrEqualToDate,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  hash: () => hash3,
  head: () => head6,
  headNonEmpty: () => headNonEmpty3,
  headOrElse: () => headOrElse,
  includes: () => includes,
  instanceOf: () => instanceOf,
  int: () => int,
  is: () => is,
  isPropertySignature: () => isPropertySignature,
  isSchema: () => isSchema,
  itemsCount: () => itemsCount,
  keyof: () => keyof2,
  length: () => length4,
  lessThan: () => lessThan10,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThanBigInt: () => lessThanBigInt,
  lessThanDate: () => lessThanDate,
  lessThanDuration: () => lessThanDuration,
  lessThanOrEqualTo: () => lessThanOrEqualTo5,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToDate: () => lessThanOrEqualToDate,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lowercased: () => lowercased,
  make: () => make50,
  makePropertySignature: () => makePropertySignature,
  maxItems: () => maxItems,
  maxLength: () => maxLength,
  minItems: () => minItems,
  minLength: () => minLength,
  multipleOf: () => multipleOf,
  mutable: () => mutable2,
  negative: () => negative,
  negativeBigDecimal: () => negativeBigDecimal,
  negativeBigInt: () => negativeBigInt,
  nonEmptyString: () => nonEmptyString2,
  nonNaN: () => nonNaN,
  nonNegative: () => nonNegative,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonPositive: () => nonPositive,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositiveBigInt: () => nonPositiveBigInt,
  omit: () => omit5,
  optional: () => optional,
  optionalElement: () => optionalElement,
  optionalToOptional: () => optionalToOptional,
  optionalToRequired: () => optionalToRequired,
  optionalWith: () => optionalWith,
  parseJson: () => parseJson,
  parseNumber: () => parseNumber,
  partial: () => partial2,
  partialWith: () => partialWith,
  pattern: () => pattern,
  pick: () => pick5,
  pickLiteral: () => pickLiteral,
  pluck: () => pluck,
  positive: () => positive,
  positiveBigDecimal: () => positiveBigDecimal,
  positiveBigInt: () => positiveBigInt,
  propertySignature: () => propertySignature,
  rename: () => rename2,
  required: () => required2,
  requiredToOptional: () => requiredToOptional,
  serializableSchema: () => serializableSchema,
  serialize: () => serialize,
  serializeExit: () => serializeExit,
  serializeFailure: () => serializeFailure,
  serializeSuccess: () => serializeSuccess,
  split: () => split3,
  standardSchemaV1: () => standardSchemaV1,
  startsWith: () => startsWith,
  successSchema: () => successSchema,
  suspend: () => suspend7,
  swap: () => swap3,
  symbolSerializable: () => symbolSerializable,
  symbolWithResult: () => symbolWithResult,
  tag: () => tag,
  transform: () => transform2,
  transformLiteral: () => transformLiteral,
  transformLiterals: () => transformLiterals,
  transformOrFail: () => transformOrFail,
  trimmed: () => trimmed,
  typeSchema: () => typeSchema,
  uncapitalized: () => uncapitalized,
  uppercased: () => uppercased,
  validDate: () => validDate,
  validate: () => validate5,
  validateEither: () => validateEither2,
  validateOption: () => validateOption,
  validatePromise: () => validatePromise2,
  validateSync: () => validateSync,
  withConstructorDefault: () => withConstructorDefault,
  withDecodingDefault: () => withDecodingDefault,
  withDefaults: () => withDefaults
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/mod.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/pretty-bytes@7.0.0/node_modules/pretty-bytes/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BYTE_UNITS = [
  "B",
  "kB",
  "MB",
  "GB",
  "TB",
  "PB",
  "EB",
  "ZB",
  "YB"
];
var BIBYTE_UNITS = [
  "B",
  "KiB",
  "MiB",
  "GiB",
  "TiB",
  "PiB",
  "EiB",
  "ZiB",
  "YiB"
];
var BIT_UNITS = [
  "b",
  "kbit",
  "Mbit",
  "Gbit",
  "Tbit",
  "Pbit",
  "Ebit",
  "Zbit",
  "Ybit"
];
var BIBIT_UNITS = [
  "b",
  "kibit",
  "Mibit",
  "Gibit",
  "Tibit",
  "Pibit",
  "Eibit",
  "Zibit",
  "Yibit"
];
var toLocaleString = /* @__PURE__ */ __name((number6, locale, options4) => {
  let result = number6;
  if (typeof locale === "string" || Array.isArray(locale)) {
    result = number6.toLocaleString(locale, options4);
  } else if (locale === true || options4 !== void 0) {
    result = number6.toLocaleString(void 0, options4);
  }
  return result;
}, "toLocaleString");
var log10 = /* @__PURE__ */ __name((numberOrBigInt) => {
  if (typeof numberOrBigInt === "number") {
    return Math.log10(numberOrBigInt);
  }
  const string7 = numberOrBigInt.toString(10);
  return string7.length + Math.log10("0." + string7.slice(0, 15));
}, "log10");
var log7 = /* @__PURE__ */ __name((numberOrBigInt) => {
  if (typeof numberOrBigInt === "number") {
    return Math.log(numberOrBigInt);
  }
  return log10(numberOrBigInt) * Math.log(10);
}, "log");
var divide2 = /* @__PURE__ */ __name((numberOrBigInt, divisor) => {
  if (typeof numberOrBigInt === "number") {
    return numberOrBigInt / divisor;
  }
  const integerPart = numberOrBigInt / BigInt(divisor);
  const remainder2 = numberOrBigInt % BigInt(divisor);
  return Number(integerPart) + Number(remainder2) / divisor;
}, "divide");
function prettyBytes(number6, options4) {
  if (typeof number6 !== "bigint" && !Number.isFinite(number6)) {
    throw new TypeError(`Expected a finite number, got ${typeof number6}: ${number6}`);
  }
  options4 = {
    bits: false,
    binary: false,
    space: true,
    ...options4
  };
  const UNITS = options4.bits ? options4.binary ? BIBIT_UNITS : BIT_UNITS : options4.binary ? BIBYTE_UNITS : BYTE_UNITS;
  const separator = options4.space ? " " : "";
  if (options4.signed && (typeof number6 === "number" ? number6 === 0 : number6 === 0n)) {
    return ` 0${separator}${UNITS[0]}`;
  }
  const isNegative2 = number6 < 0;
  const prefix = isNegative2 ? "-" : options4.signed ? "+" : "";
  if (isNegative2) {
    number6 = -number6;
  }
  let localeOptions;
  if (options4.minimumFractionDigits !== void 0) {
    localeOptions = { minimumFractionDigits: options4.minimumFractionDigits };
  }
  if (options4.maximumFractionDigits !== void 0) {
    localeOptions = { maximumFractionDigits: options4.maximumFractionDigits, ...localeOptions };
  }
  if (number6 < 1) {
    const numberString2 = toLocaleString(number6, options4.locale, localeOptions);
    return prefix + numberString2 + separator + UNITS[0];
  }
  const exponent = Math.min(Math.floor(options4.binary ? log7(number6) / Math.log(1024) : log10(number6) / 3), UNITS.length - 1);
  number6 = divide2(number6, (options4.binary ? 1024 : 1e3) ** exponent);
  if (!localeOptions) {
    number6 = number6.toPrecision(3);
  }
  const numberString = toLocaleString(Number(number6), options4.locale, localeOptions);
  const unit = UNITS[exponent];
  return prefix + numberString + separator + unit;
}
__name(prettyBytes, "prettyBytes");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/env.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/misc.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isDevEnv = /* @__PURE__ */ __name(() => {
  if (typeof process !== "undefined" && process.env !== void 0) {
    return true;
  }
  if (import.meta.env !== void 0) {
    return import.meta.env.DEV;
  }
  if (typeof globalThis !== "undefined" && globalThis.__DEV__) {
    return true;
  }
  return false;
}, "isDevEnv");
var objectToString = /* @__PURE__ */ __name((error5) => {
  const str = error5?.toString();
  if (str !== "[object Object]")
    return str;
  try {
    return JSON.stringify(error5, null, 2);
  } catch (e) {
    console.log(error5);
    return `Error while printing error: ${e}`;
  }
}, "objectToString");
var envTruish = /* @__PURE__ */ __name((env3) => env3 !== void 0 && env3.toLowerCase() !== "false" && env3.toLowerCase() !== "0", "envTruish");
var shouldNeverHappen = /* @__PURE__ */ __name((msg, ...args2) => {
  console.error(msg, ...args2);
  if (isDevEnv()) {
    debugger;
  }
  throw new Error(`This should never happen: ${msg}`);
}, "shouldNeverHappen");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/env.js
var env2 = /* @__PURE__ */ __name((name) => {
  if (typeof process !== "undefined" && process.env !== void 0) {
    return process.env[name];
  }
  if (import.meta.env !== void 0) {
    return import.meta.env[name];
  }
  return void 0;
}, "env");
var TRACE_VERBOSE = env2("LS_TRACE_VERBOSE") !== void 0 || env2("VITE_LS_TRACE_VERBOSE") !== void 0;
var LS_DEV = envTruish(env2("LS_DEV")) || envTruish(env2("VITE_LS_DEV"));
var IS_CI = envTruish(env2("CI"));
var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/fast-deep-equal.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var deepEqual = /* @__PURE__ */ __name((a, b) => {
  if (a === b)
    return true;
  if (a && b && typeof a === "object" && typeof b === "object") {
    if (a.constructor !== b.constructor)
      return false;
    let length5;
    let i;
    let keys6;
    if (Array.isArray(a)) {
      length5 = a.length;
      if (length5 !== b.length)
        return false;
      for (i = length5; i-- !== 0; )
        if (!deepEqual(a[i], b[i]))
          return false;
      return true;
    }
    if (a instanceof Map && b instanceof Map) {
      if (a.size !== b.size)
        return false;
      for (i of a.entries())
        if (!b.has(i[0]))
          return false;
      for (i of a.entries())
        if (!deepEqual(i[1], b.get(i[0])))
          return false;
      return true;
    }
    if (a instanceof Set && b instanceof Set) {
      if (a.size !== b.size)
        return false;
      for (i of a.entries())
        if (!b.has(i[0]))
          return false;
      return true;
    }
    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length5 = a.length;
      if (length5 !== b.length)
        return false;
      for (i = length5; i-- !== 0; )
        if (a[i] !== b[i])
          return false;
      return true;
    }
    if (a.constructor === RegExp)
      return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== void 0 && a.valueOf !== Object.prototype.valueOf)
      return a.valueOf() === b.valueOf();
    if (a.toString !== void 0 && a.toString !== Object.prototype.toString)
      return a.toString() === b.toString();
    keys6 = Object.keys(a);
    length5 = keys6.length;
    if (length5 !== Object.keys(b).length)
      return false;
    for (i = length5; i-- !== 0; )
      if (!Object.hasOwn(b, keys6[i]))
        return false;
    for (i = length5; i-- !== 0; ) {
      const key = keys6[i];
      if (!deepEqual(a[key], b[key]))
        return false;
    }
    return true;
  }
  return a !== a && b !== b;
}, "deepEqual");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/guards.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isNotUndefined2 = /* @__PURE__ */ __name((_) => _ !== void 0, "isNotUndefined");
var isNil2 = /* @__PURE__ */ __name((val) => val === null || val === void 0, "isNil");
var isNotNil = /* @__PURE__ */ __name((val) => val !== null && val !== void 0, "isNotNil");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/NoopTracer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeNoopSpan = /* @__PURE__ */ __name(() => {
  const performanceStartTime = performance.now();
  const span4 = {
    _performanceStartTime: performanceStartTime,
    setAttribute: /* @__PURE__ */ __name(() => null, "setAttribute"),
    setAttributes: /* @__PURE__ */ __name(() => null, "setAttributes"),
    addEvent: /* @__PURE__ */ __name(() => null, "addEvent"),
    addLink: /* @__PURE__ */ __name(() => null, "addLink"),
    setStatus: /* @__PURE__ */ __name(() => null, "setStatus"),
    updateName: /* @__PURE__ */ __name(() => null, "updateName"),
    recordException: /* @__PURE__ */ __name(() => null, "recordException"),
    end: /* @__PURE__ */ __name(() => {
      const endTime = performance.now();
      const duration4 = endTime - performanceStartTime;
      const durationSecs = duration4 / 1e3;
      const durationRestNs = duration4 % 1e3 * 1e6;
      span4._duration = [durationSecs, durationRestNs];
    }, "end"),
    spanContext: /* @__PURE__ */ __name(() => {
      return { traceId: "livestore-noop-trace-id", spanId: "livestore-noop-span-id" };
    }, "spanContext"),
    _duration: [0, 0]
  };
  return span4;
}, "makeNoopSpan");
var makeNoopTracer = /* @__PURE__ */ __name(() => {
  return new NoopTracer();
}, "makeNoopTracer");
var NoopTracer = class {
  static {
    __name(this, "NoopTracer");
  }
  startSpan = /* @__PURE__ */ __name(() => makeNoopSpan(), "startSpan");
  startActiveSpan(_name, arg2, arg3, arg4) {
    let _opts;
    let _ctx;
    let fn2;
    if (arguments.length < 2) {
      return;
    } else if (arguments.length === 2) {
      fn2 = arg2;
    } else if (arguments.length === 3) {
      _opts = arg2;
      fn2 = arg3;
    } else {
      _opts = arg2;
      _ctx = arg3;
      fn2 = arg4;
    }
    return fn2(makeNoopSpan());
  }
};

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/string.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var indent = /* @__PURE__ */ __name((str, n, char2 = " ") => str.split("\n").map((line) => char2.repeat(n) + line).join("\n"), "indent");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/mod.js
var isReadonlyArray = /* @__PURE__ */ __name((value6) => Array.isArray(value6), "isReadonlyArray");
function casesHandled(unexpectedCase) {
  debugger;
  throw new Error(`A case was not handled for value: ${truncate(objectToString(unexpectedCase), 1e3)}`);
}
__name(casesHandled, "casesHandled");
var assertNever = /* @__PURE__ */ __name((failIfFalse, msg) => {
  if (failIfFalse === false) {
    debugger;
    throw new Error(`This should never happen: ${msg}`);
  }
}, "assertNever");
var truncate = /* @__PURE__ */ __name((str, length5) => {
  if (str.length > length5) {
    return `${str.slice(0, length5)}...`;
  } else {
    return str;
  }
}, "truncate");
var notYetImplemented = /* @__PURE__ */ __name((msg) => {
  debugger;
  throw new Error(`Not yet implemented: ${msg}`);
}, "notYetImplemented");
var throttle3 = /* @__PURE__ */ __name((fn2, ms) => {
  let shouldWait = false;
  let shouldCallAgain = false;
  const timeoutFunc = /* @__PURE__ */ __name(() => {
    if (shouldCallAgain) {
      fn2();
      shouldCallAgain = false;
      setTimeout(timeoutFunc, ms);
    } else {
      shouldWait = false;
    }
  }, "timeoutFunc");
  return () => {
    if (shouldWait) {
      shouldCallAgain = true;
      return;
    }
    fn2();
    shouldWait = true;
    setTimeout(timeoutFunc, ms);
  };
}, "throttle");
var memoizeByStringifyArgs = /* @__PURE__ */ __name((fn2) => {
  const cache = /* @__PURE__ */ new Map();
  return ((...args2) => {
    const key = JSON.stringify(args2);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn2(...args2);
    cache.set(key, result);
    return result;
  });
}, "memoizeByStringifyArgs");
var memoizeByRef = /* @__PURE__ */ __name((fn2) => {
  const cache = /* @__PURE__ */ new Map();
  return ((arg) => {
    if (cache.has(arg)) {
      return cache.get(arg);
    }
    const result = fn2(arg);
    cache.set(arg, result);
    return result;
  });
}, "memoizeByRef");
var isPromise2 = /* @__PURE__ */ __name((value6) => typeof value6?.then === "function", "isPromise");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Schema/debug-diff.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var debugDiff = /* @__PURE__ */ __name((base) => (a, b) => {
  const bag = [];
  debugDiffImpl(base.ast, a, b, "", bag);
  return bag;
}, "debugDiff");
var debugDiffImpl = /* @__PURE__ */ __name((ast, a, b, path, bag) => {
  const eq = Schema_exports.equivalence({ ast });
  if (eq(a, b) === false) {
    if (SchemaAST_exports.isUnion(ast)) {
      if (isTaggedUnion(ast)) {
        bag.push({ path, a, b, ast });
        return;
      } else {
        for (const type3 of ast.types) {
          try {
            debugDiffImpl(type3, a, b, path, bag);
            return;
          } catch {
          }
        }
      }
    } else if (SchemaAST_exports.isTypeLiteral(ast)) {
      const props = SchemaAST_exports.getPropertySignatures(ast);
      for (const prop of props) {
        debugDiffImpl(prop.type, a[prop.name], b[prop.name], `${path}.${prop.name.toString()}`, bag);
      }
    } else {
      bag.push({ path, a, b, ast });
    }
  }
}, "debugDiffImpl");
var isTaggedUnion = /* @__PURE__ */ __name((ast) => {
  if (SchemaAST_exports.isUnion(ast)) {
    return ast.types.every((type3) => {
      if (SchemaAST_exports.isTypeLiteral(type3) === false)
        return false;
      const props = SchemaAST_exports.getPropertySignatures(type3);
      return props.some((prop) => prop.name.toString() === "_tag");
    });
  }
}, "isTaggedUnion");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Schema/msgpack.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/unpack.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var decoder3;
try {
  decoder3 = new TextDecoder();
} catch (error5) {
}
var src2;
var srcEnd2;
var position3 = 0;
var EMPTY_ARRAY2 = [];
var strings2 = EMPTY_ARRAY2;
var stringPosition2 = 0;
var currentUnpackr2 = {};
var currentStructures2;
var srcString2;
var srcStringStart2 = 0;
var srcStringEnd2 = 0;
var bundledStrings3;
var referenceMap2;
var currentExtensions2 = [];
var dataView2;
var defaultOptions2 = {
  useRecords: false,
  mapsAsObjects: true
};
var C1Type2 = class {
  static {
    __name(this, "C1Type");
  }
};
var C12 = new C1Type2();
C12.name = "MessagePack 0xC1";
var sequentialMode2 = false;
var inlineObjectReadThreshold2 = 2;
var readStruct2;
var onLoadedStructures2;
var onSaveState2;
try {
  new Function("");
} catch (error5) {
  inlineObjectReadThreshold2 = Infinity;
}
var Unpackr2 = class _Unpackr {
  static {
    __name(this, "Unpackr");
  }
  constructor(options4) {
    if (options4) {
      if (options4.useRecords === false && options4.mapsAsObjects === void 0)
        options4.mapsAsObjects = true;
      if (options4.sequential && options4.trusted !== false) {
        options4.trusted = true;
        if (!options4.structures && options4.useRecords != false) {
          options4.structures = [];
          if (!options4.maxSharedStructures)
            options4.maxSharedStructures = 0;
        }
      }
      if (options4.structures)
        options4.structures.sharedLength = options4.structures.length;
      else if (options4.getStructures) {
        (options4.structures = []).uninitialized = true;
        options4.structures.sharedLength = 0;
      }
      if (options4.int64AsNumber) {
        options4.int64AsType = "number";
      }
    }
    Object.assign(this, options4);
  }
  unpack(source, options4) {
    if (src2) {
      return saveState2(() => {
        clearSource2();
        return this ? this.unpack(source, options4) : _Unpackr.prototype.unpack.call(defaultOptions2, source, options4);
      });
    }
    if (!source.buffer && source.constructor === ArrayBuffer)
      source = typeof Buffer !== "undefined" ? Buffer.from(source) : new Uint8Array(source);
    if (typeof options4 === "object") {
      srcEnd2 = options4.end || source.length;
      position3 = options4.start || 0;
    } else {
      position3 = 0;
      srcEnd2 = options4 > -1 ? options4 : source.length;
    }
    stringPosition2 = 0;
    srcStringEnd2 = 0;
    srcString2 = null;
    strings2 = EMPTY_ARRAY2;
    bundledStrings3 = null;
    src2 = source;
    try {
      dataView2 = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
    } catch (error5) {
      src2 = null;
      if (source instanceof Uint8Array)
        throw error5;
      throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
    }
    if (this instanceof _Unpackr) {
      currentUnpackr2 = this;
      if (this.structures) {
        currentStructures2 = this.structures;
        return checkedRead2(options4);
      } else if (!currentStructures2 || currentStructures2.length > 0) {
        currentStructures2 = [];
      }
    } else {
      currentUnpackr2 = defaultOptions2;
      if (!currentStructures2 || currentStructures2.length > 0)
        currentStructures2 = [];
    }
    return checkedRead2(options4);
  }
  unpackMultiple(source, forEach16) {
    let values6, lastPosition = 0;
    try {
      sequentialMode2 = true;
      let size22 = source.length;
      let value6 = this ? this.unpack(source, size22) : defaultUnpackr2.unpack(source, size22);
      if (forEach16) {
        if (forEach16(value6, lastPosition, position3) === false) return;
        while (position3 < size22) {
          lastPosition = position3;
          if (forEach16(checkedRead2(), lastPosition, position3) === false) {
            return;
          }
        }
      } else {
        values6 = [value6];
        while (position3 < size22) {
          lastPosition = position3;
          values6.push(checkedRead2());
        }
        return values6;
      }
    } catch (error5) {
      error5.lastPosition = lastPosition;
      error5.values = values6;
      throw error5;
    } finally {
      sequentialMode2 = false;
      clearSource2();
    }
  }
  _mergeStructures(loadedStructures, existingStructures) {
    if (onLoadedStructures2)
      loadedStructures = onLoadedStructures2.call(this, loadedStructures);
    loadedStructures = loadedStructures || [];
    if (Object.isFrozen(loadedStructures))
      loadedStructures = loadedStructures.map((structure2) => structure2.slice(0));
    for (let i = 0, l = loadedStructures.length; i < l; i++) {
      let structure2 = loadedStructures[i];
      if (structure2) {
        structure2.isShared = true;
        if (i >= 32)
          structure2.highByte = i - 32 >> 5;
      }
    }
    loadedStructures.sharedLength = loadedStructures.length;
    for (let id4 in existingStructures || []) {
      if (id4 >= 0) {
        let structure2 = loadedStructures[id4];
        let existing = existingStructures[id4];
        if (existing) {
          if (structure2)
            (loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id4] = structure2;
          loadedStructures[id4] = existing;
        }
      }
    }
    return this.structures = loadedStructures;
  }
  decode(source, options4) {
    return this.unpack(source, options4);
  }
};
function checkedRead2(options4) {
  try {
    if (!currentUnpackr2.trusted && !sequentialMode2) {
      let sharedLength = currentStructures2.sharedLength || 0;
      if (sharedLength < currentStructures2.length)
        currentStructures2.length = sharedLength;
    }
    let result;
    if (currentUnpackr2.randomAccessStructure && src2[position3] < 64 && src2[position3] >= 32 && readStruct2) {
      result = readStruct2(src2, position3, srcEnd2, currentUnpackr2);
      src2 = null;
      if (!(options4 && options4.lazy) && result)
        result = result.toJSON();
      position3 = srcEnd2;
    } else
      result = read3();
    if (bundledStrings3) {
      position3 = bundledStrings3.postBundlePosition;
      bundledStrings3 = null;
    }
    if (sequentialMode2)
      currentStructures2.restoreStructures = null;
    if (position3 == srcEnd2) {
      if (currentStructures2 && currentStructures2.restoreStructures)
        restoreStructures2();
      currentStructures2 = null;
      src2 = null;
      if (referenceMap2)
        referenceMap2 = null;
    } else if (position3 > srcEnd2) {
      throw new Error("Unexpected end of MessagePack data");
    } else if (!sequentialMode2) {
      let jsonView;
      try {
        jsonView = JSON.stringify(result, (_, value6) => typeof value6 === "bigint" ? `${value6}n` : value6).slice(0, 100);
      } catch (error5) {
        jsonView = "(JSON view not available " + error5 + ")";
      }
      throw new Error("Data read, but end of buffer not reached " + jsonView);
    }
    return result;
  } catch (error5) {
    if (currentStructures2 && currentStructures2.restoreStructures)
      restoreStructures2();
    clearSource2();
    if (error5 instanceof RangeError || error5.message.startsWith("Unexpected end of buffer") || position3 > srcEnd2) {
      error5.incomplete = true;
    }
    throw error5;
  }
}
__name(checkedRead2, "checkedRead");
function restoreStructures2() {
  for (let id4 in currentStructures2.restoreStructures) {
    currentStructures2[id4] = currentStructures2.restoreStructures[id4];
  }
  currentStructures2.restoreStructures = null;
}
__name(restoreStructures2, "restoreStructures");
function read3() {
  let token = src2[position3++];
  if (token < 160) {
    if (token < 128) {
      if (token < 64)
        return token;
      else {
        let structure2 = currentStructures2[token & 63] || currentUnpackr2.getStructures && loadStructures2()[token & 63];
        if (structure2) {
          if (!structure2.read) {
            structure2.read = createStructureReader2(structure2, token & 63);
          }
          return structure2.read();
        } else
          return token;
      }
    } else if (token < 144) {
      token -= 128;
      if (currentUnpackr2.mapsAsObjects) {
        let object2 = {};
        for (let i = 0; i < token; i++) {
          let key = readKey2();
          if (key === "__proto__")
            key = "__proto_";
          object2[key] = read3();
        }
        return object2;
      } else {
        let map38 = /* @__PURE__ */ new Map();
        for (let i = 0; i < token; i++) {
          map38.set(read3(), read3());
        }
        return map38;
      }
    } else {
      token -= 144;
      let array7 = new Array(token);
      for (let i = 0; i < token; i++) {
        array7[i] = read3();
      }
      if (currentUnpackr2.freezeData)
        return Object.freeze(array7);
      return array7;
    }
  } else if (token < 192) {
    let length5 = token - 160;
    if (srcStringEnd2 >= position3) {
      return srcString2.slice(position3 - srcStringStart2, (position3 += length5) - srcStringStart2);
    }
    if (srcStringEnd2 == 0 && srcEnd2 < 140) {
      let string7 = length5 < 16 ? shortStringInJS2(length5) : longStringInJS2(length5);
      if (string7 != null)
        return string7;
    }
    return readFixedString2(length5);
  } else {
    let value6;
    switch (token) {
      case 192:
        return null;
      case 193:
        if (bundledStrings3) {
          value6 = read3();
          if (value6 > 0)
            return bundledStrings3[1].slice(bundledStrings3.position1, bundledStrings3.position1 += value6);
          else
            return bundledStrings3[0].slice(bundledStrings3.position0, bundledStrings3.position0 -= value6);
        }
        return C12;
      // "never-used", return special object to denote that
      case 194:
        return false;
      case 195:
        return true;
      case 196:
        value6 = src2[position3++];
        if (value6 === void 0)
          throw new Error("Unexpected end of buffer");
        return readBin2(value6);
      case 197:
        value6 = dataView2.getUint16(position3);
        position3 += 2;
        return readBin2(value6);
      case 198:
        value6 = dataView2.getUint32(position3);
        position3 += 4;
        return readBin2(value6);
      case 199:
        return readExt2(src2[position3++]);
      case 200:
        value6 = dataView2.getUint16(position3);
        position3 += 2;
        return readExt2(value6);
      case 201:
        value6 = dataView2.getUint32(position3);
        position3 += 4;
        return readExt2(value6);
      case 202:
        value6 = dataView2.getFloat32(position3);
        if (currentUnpackr2.useFloat32 > 2) {
          let multiplier = mult102[(src2[position3] & 127) << 1 | src2[position3 + 1] >> 7];
          position3 += 4;
          return (multiplier * value6 + (value6 > 0 ? 0.5 : -0.5) >> 0) / multiplier;
        }
        position3 += 4;
        return value6;
      case 203:
        value6 = dataView2.getFloat64(position3);
        position3 += 8;
        return value6;
      // uint handlers
      case 204:
        return src2[position3++];
      case 205:
        value6 = dataView2.getUint16(position3);
        position3 += 2;
        return value6;
      case 206:
        value6 = dataView2.getUint32(position3);
        position3 += 4;
        return value6;
      case 207:
        if (currentUnpackr2.int64AsType === "number") {
          value6 = dataView2.getUint32(position3) * 4294967296;
          value6 += dataView2.getUint32(position3 + 4);
        } else if (currentUnpackr2.int64AsType === "string") {
          value6 = dataView2.getBigUint64(position3).toString();
        } else if (currentUnpackr2.int64AsType === "auto") {
          value6 = dataView2.getBigUint64(position3);
          if (value6 <= BigInt(2) << BigInt(52)) value6 = Number(value6);
        } else
          value6 = dataView2.getBigUint64(position3);
        position3 += 8;
        return value6;
      // int handlers
      case 208:
        return dataView2.getInt8(position3++);
      case 209:
        value6 = dataView2.getInt16(position3);
        position3 += 2;
        return value6;
      case 210:
        value6 = dataView2.getInt32(position3);
        position3 += 4;
        return value6;
      case 211:
        if (currentUnpackr2.int64AsType === "number") {
          value6 = dataView2.getInt32(position3) * 4294967296;
          value6 += dataView2.getUint32(position3 + 4);
        } else if (currentUnpackr2.int64AsType === "string") {
          value6 = dataView2.getBigInt64(position3).toString();
        } else if (currentUnpackr2.int64AsType === "auto") {
          value6 = dataView2.getBigInt64(position3);
          if (value6 >= BigInt(-2) << BigInt(52) && value6 <= BigInt(2) << BigInt(52)) value6 = Number(value6);
        } else
          value6 = dataView2.getBigInt64(position3);
        position3 += 8;
        return value6;
      case 212:
        value6 = src2[position3++];
        if (value6 == 114) {
          return recordDefinition2(src2[position3++] & 63);
        } else {
          let extension = currentExtensions2[value6];
          if (extension) {
            if (extension.read) {
              position3++;
              return extension.read(read3());
            } else if (extension.noBuffer) {
              position3++;
              return extension();
            } else
              return extension(src2.subarray(position3, ++position3));
          } else
            throw new Error("Unknown extension " + value6);
        }
      case 213:
        value6 = src2[position3];
        if (value6 == 114) {
          position3++;
          return recordDefinition2(src2[position3++] & 63, src2[position3++]);
        } else
          return readExt2(2);
      case 214:
        return readExt2(4);
      case 215:
        return readExt2(8);
      case 216:
        return readExt2(16);
      case 217:
        value6 = src2[position3++];
        if (srcStringEnd2 >= position3) {
          return srcString2.slice(position3 - srcStringStart2, (position3 += value6) - srcStringStart2);
        }
        return readString82(value6);
      case 218:
        value6 = dataView2.getUint16(position3);
        position3 += 2;
        if (srcStringEnd2 >= position3) {
          return srcString2.slice(position3 - srcStringStart2, (position3 += value6) - srcStringStart2);
        }
        return readString162(value6);
      case 219:
        value6 = dataView2.getUint32(position3);
        position3 += 4;
        if (srcStringEnd2 >= position3) {
          return srcString2.slice(position3 - srcStringStart2, (position3 += value6) - srcStringStart2);
        }
        return readString322(value6);
      case 220:
        value6 = dataView2.getUint16(position3);
        position3 += 2;
        return readArray2(value6);
      case 221:
        value6 = dataView2.getUint32(position3);
        position3 += 4;
        return readArray2(value6);
      case 222:
        value6 = dataView2.getUint16(position3);
        position3 += 2;
        return readMap2(value6);
      case 223:
        value6 = dataView2.getUint32(position3);
        position3 += 4;
        return readMap2(value6);
      default:
        if (token >= 224)
          return token - 256;
        if (token === void 0) {
          let error5 = new Error("Unexpected end of MessagePack data");
          error5.incomplete = true;
          throw error5;
        }
        throw new Error("Unknown MessagePack token " + token);
    }
  }
}
__name(read3, "read");
var validName2 = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
function createStructureReader2(structure2, firstId) {
  function readObject() {
    if (readObject.count++ > inlineObjectReadThreshold2) {
      let readObject2 = structure2.read = new Function("r", "return function(){return " + (currentUnpackr2.freezeData ? "Object.freeze" : "") + "({" + structure2.map((key) => key === "__proto__" ? "__proto_:r()" : validName2.test(key) ? key + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "})}")(read3);
      if (structure2.highByte === 0)
        structure2.read = createSecondByteReader2(firstId, structure2.read);
      return readObject2();
    }
    let object2 = {};
    for (let i = 0, l = structure2.length; i < l; i++) {
      let key = structure2[i];
      if (key === "__proto__")
        key = "__proto_";
      object2[key] = read3();
    }
    if (currentUnpackr2.freezeData)
      return Object.freeze(object2);
    return object2;
  }
  __name(readObject, "readObject");
  readObject.count = 0;
  if (structure2.highByte === 0) {
    return createSecondByteReader2(firstId, readObject);
  }
  return readObject;
}
__name(createStructureReader2, "createStructureReader");
var createSecondByteReader2 = /* @__PURE__ */ __name((firstId, read0) => {
  return function() {
    let highByte = src2[position3++];
    if (highByte === 0)
      return read0();
    let id4 = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);
    let structure2 = currentStructures2[id4] || loadStructures2()[id4];
    if (!structure2) {
      throw new Error("Record id is not defined for " + id4);
    }
    if (!structure2.read)
      structure2.read = createStructureReader2(structure2, firstId);
    return structure2.read();
  };
}, "createSecondByteReader");
function loadStructures2() {
  let loadedStructures = saveState2(() => {
    src2 = null;
    return currentUnpackr2.getStructures();
  });
  return currentStructures2 = currentUnpackr2._mergeStructures(loadedStructures, currentStructures2);
}
__name(loadStructures2, "loadStructures");
var readFixedString2 = readStringJS2;
var readString82 = readStringJS2;
var readString162 = readStringJS2;
var readString322 = readStringJS2;
function readStringJS2(length5) {
  let result;
  if (length5 < 16) {
    if (result = shortStringInJS2(length5))
      return result;
  }
  if (length5 > 64 && decoder3)
    return decoder3.decode(src2.subarray(position3, position3 += length5));
  const end6 = position3 + length5;
  const units = [];
  result = "";
  while (position3 < end6) {
    const byte1 = src2[position3++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      const byte2 = src2[position3++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      const byte2 = src2[position3++] & 63;
      const byte3 = src2[position3++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      const byte2 = src2[position3++] & 63;
      const byte3 = src2[position3++] & 63;
      const byte4 = src2[position3++] & 63;
      let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= 4096) {
      result += fromCharCode2.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += fromCharCode2.apply(String, units);
  }
  return result;
}
__name(readStringJS2, "readStringJS");
function readArray2(length5) {
  let array7 = new Array(length5);
  for (let i = 0; i < length5; i++) {
    array7[i] = read3();
  }
  if (currentUnpackr2.freezeData)
    return Object.freeze(array7);
  return array7;
}
__name(readArray2, "readArray");
function readMap2(length5) {
  if (currentUnpackr2.mapsAsObjects) {
    let object2 = {};
    for (let i = 0; i < length5; i++) {
      let key = readKey2();
      if (key === "__proto__")
        key = "__proto_";
      object2[key] = read3();
    }
    return object2;
  } else {
    let map38 = /* @__PURE__ */ new Map();
    for (let i = 0; i < length5; i++) {
      map38.set(read3(), read3());
    }
    return map38;
  }
}
__name(readMap2, "readMap");
var fromCharCode2 = String.fromCharCode;
function longStringInJS2(length5) {
  let start3 = position3;
  let bytes = new Array(length5);
  for (let i = 0; i < length5; i++) {
    const byte = src2[position3++];
    if ((byte & 128) > 0) {
      position3 = start3;
      return;
    }
    bytes[i] = byte;
  }
  return fromCharCode2.apply(String, bytes);
}
__name(longStringInJS2, "longStringInJS");
function shortStringInJS2(length5) {
  if (length5 < 4) {
    if (length5 < 2) {
      if (length5 === 0)
        return "";
      else {
        let a = src2[position3++];
        if ((a & 128) > 1) {
          position3 -= 1;
          return;
        }
        return fromCharCode2(a);
      }
    } else {
      let a = src2[position3++];
      let b = src2[position3++];
      if ((a & 128) > 0 || (b & 128) > 0) {
        position3 -= 2;
        return;
      }
      if (length5 < 3)
        return fromCharCode2(a, b);
      let c = src2[position3++];
      if ((c & 128) > 0) {
        position3 -= 3;
        return;
      }
      return fromCharCode2(a, b, c);
    }
  } else {
    let a = src2[position3++];
    let b = src2[position3++];
    let c = src2[position3++];
    let d = src2[position3++];
    if ((a & 128) > 0 || (b & 128) > 0 || (c & 128) > 0 || (d & 128) > 0) {
      position3 -= 4;
      return;
    }
    if (length5 < 6) {
      if (length5 === 4)
        return fromCharCode2(a, b, c, d);
      else {
        let e = src2[position3++];
        if ((e & 128) > 0) {
          position3 -= 5;
          return;
        }
        return fromCharCode2(a, b, c, d, e);
      }
    } else if (length5 < 8) {
      let e = src2[position3++];
      let f = src2[position3++];
      if ((e & 128) > 0 || (f & 128) > 0) {
        position3 -= 6;
        return;
      }
      if (length5 < 7)
        return fromCharCode2(a, b, c, d, e, f);
      let g = src2[position3++];
      if ((g & 128) > 0) {
        position3 -= 7;
        return;
      }
      return fromCharCode2(a, b, c, d, e, f, g);
    } else {
      let e = src2[position3++];
      let f = src2[position3++];
      let g = src2[position3++];
      let h = src2[position3++];
      if ((e & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h & 128) > 0) {
        position3 -= 8;
        return;
      }
      if (length5 < 10) {
        if (length5 === 8)
          return fromCharCode2(a, b, c, d, e, f, g, h);
        else {
          let i = src2[position3++];
          if ((i & 128) > 0) {
            position3 -= 9;
            return;
          }
          return fromCharCode2(a, b, c, d, e, f, g, h, i);
        }
      } else if (length5 < 12) {
        let i = src2[position3++];
        let j = src2[position3++];
        if ((i & 128) > 0 || (j & 128) > 0) {
          position3 -= 10;
          return;
        }
        if (length5 < 11)
          return fromCharCode2(a, b, c, d, e, f, g, h, i, j);
        let k = src2[position3++];
        if ((k & 128) > 0) {
          position3 -= 11;
          return;
        }
        return fromCharCode2(a, b, c, d, e, f, g, h, i, j, k);
      } else {
        let i = src2[position3++];
        let j = src2[position3++];
        let k = src2[position3++];
        let l = src2[position3++];
        if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l & 128) > 0) {
          position3 -= 12;
          return;
        }
        if (length5 < 14) {
          if (length5 === 12)
            return fromCharCode2(a, b, c, d, e, f, g, h, i, j, k, l);
          else {
            let m = src2[position3++];
            if ((m & 128) > 0) {
              position3 -= 13;
              return;
            }
            return fromCharCode2(a, b, c, d, e, f, g, h, i, j, k, l, m);
          }
        } else {
          let m = src2[position3++];
          let n = src2[position3++];
          if ((m & 128) > 0 || (n & 128) > 0) {
            position3 -= 14;
            return;
          }
          if (length5 < 15)
            return fromCharCode2(a, b, c, d, e, f, g, h, i, j, k, l, m, n);
          let o = src2[position3++];
          if ((o & 128) > 0) {
            position3 -= 15;
            return;
          }
          return fromCharCode2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);
        }
      }
    }
  }
}
__name(shortStringInJS2, "shortStringInJS");
function readOnlyJSString2() {
  let token = src2[position3++];
  let length5;
  if (token < 192) {
    length5 = token - 160;
  } else {
    switch (token) {
      case 217:
        length5 = src2[position3++];
        break;
      case 218:
        length5 = dataView2.getUint16(position3);
        position3 += 2;
        break;
      case 219:
        length5 = dataView2.getUint32(position3);
        position3 += 4;
        break;
      default:
        throw new Error("Expected string");
    }
  }
  return readStringJS2(length5);
}
__name(readOnlyJSString2, "readOnlyJSString");
function readBin2(length5) {
  return currentUnpackr2.copyBuffers ? (
    // specifically use the copying slice (not the node one)
    Uint8Array.prototype.slice.call(src2, position3, position3 += length5)
  ) : src2.subarray(position3, position3 += length5);
}
__name(readBin2, "readBin");
function readExt2(length5) {
  let type3 = src2[position3++];
  if (currentExtensions2[type3]) {
    let end6;
    return currentExtensions2[type3](src2.subarray(position3, end6 = position3 += length5), (readPosition) => {
      position3 = readPosition;
      try {
        return read3();
      } finally {
        position3 = end6;
      }
    });
  } else
    throw new Error("Unknown extension type " + type3);
}
__name(readExt2, "readExt");
var keyCache2 = new Array(4096);
function readKey2() {
  let length5 = src2[position3++];
  if (length5 >= 160 && length5 < 192) {
    length5 = length5 - 160;
    if (srcStringEnd2 >= position3)
      return srcString2.slice(position3 - srcStringStart2, (position3 += length5) - srcStringStart2);
    else if (!(srcStringEnd2 == 0 && srcEnd2 < 180))
      return readFixedString2(length5);
  } else {
    position3--;
    return asSafeString2(read3());
  }
  let key = (length5 << 5 ^ (length5 > 1 ? dataView2.getUint16(position3) : length5 > 0 ? src2[position3] : 0)) & 4095;
  let entry = keyCache2[key];
  let checkPosition = position3;
  let end6 = position3 + length5 - 3;
  let chunk4;
  let i = 0;
  if (entry && entry.bytes == length5) {
    while (checkPosition < end6) {
      chunk4 = dataView2.getUint32(checkPosition);
      if (chunk4 != entry[i++]) {
        checkPosition = 1879048192;
        break;
      }
      checkPosition += 4;
    }
    end6 += 3;
    while (checkPosition < end6) {
      chunk4 = src2[checkPosition++];
      if (chunk4 != entry[i++]) {
        checkPosition = 1879048192;
        break;
      }
    }
    if (checkPosition === end6) {
      position3 = checkPosition;
      return entry.string;
    }
    end6 -= 3;
    checkPosition = position3;
  }
  entry = [];
  keyCache2[key] = entry;
  entry.bytes = length5;
  while (checkPosition < end6) {
    chunk4 = dataView2.getUint32(checkPosition);
    entry.push(chunk4);
    checkPosition += 4;
  }
  end6 += 3;
  while (checkPosition < end6) {
    chunk4 = src2[checkPosition++];
    entry.push(chunk4);
  }
  let string7 = length5 < 16 ? shortStringInJS2(length5) : longStringInJS2(length5);
  if (string7 != null)
    return entry.string = string7;
  return entry.string = readFixedString2(length5);
}
__name(readKey2, "readKey");
function asSafeString2(property2) {
  if (typeof property2 === "string") return property2;
  if (typeof property2 === "number" || typeof property2 === "boolean" || typeof property2 === "bigint") return property2.toString();
  if (property2 == null) return property2 + "";
  if (currentUnpackr2.allowArraysInMapKeys && Array.isArray(property2) && property2.flat().every((item) => ["string", "number", "boolean", "bigint"].includes(typeof item))) {
    return property2.flat().toString();
  }
  throw new Error(`Invalid property type for record: ${typeof property2}`);
}
__name(asSafeString2, "asSafeString");
var recordDefinition2 = /* @__PURE__ */ __name((id4, highByte) => {
  let structure2 = read3().map(asSafeString2);
  let firstByte = id4;
  if (highByte !== void 0) {
    id4 = id4 < 32 ? -((highByte << 5) + id4) : (highByte << 5) + id4;
    structure2.highByte = highByte;
  }
  let existingStructure = currentStructures2[id4];
  if (existingStructure && (existingStructure.isShared || sequentialMode2)) {
    (currentStructures2.restoreStructures || (currentStructures2.restoreStructures = []))[id4] = existingStructure;
  }
  currentStructures2[id4] = structure2;
  structure2.read = createStructureReader2(structure2, firstByte);
  return structure2.read();
}, "recordDefinition");
currentExtensions2[0] = () => {
};
currentExtensions2[0].noBuffer = true;
currentExtensions2[66] = (data) => {
  let headLength = data.byteLength % 8 || 8;
  let head13 = BigInt(data[0] & 128 ? data[0] - 256 : data[0]);
  for (let i = 1; i < headLength; i++) {
    head13 <<= BigInt(8);
    head13 += BigInt(data[i]);
  }
  if (data.byteLength !== headLength) {
    let view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    let decode9 = /* @__PURE__ */ __name((start3, end6) => {
      let length5 = end6 - start3;
      if (length5 <= 40) {
        let out = view.getBigUint64(start3);
        for (let i = start3 + 8; i < end6; i += 8) {
          out <<= BigInt(64n);
          out |= view.getBigUint64(i);
        }
        return out;
      }
      let middle = start3 + (length5 >> 4 << 3);
      let left3 = decode9(start3, middle);
      let right3 = decode9(middle, end6);
      return left3 << BigInt((end6 - middle) * 8) | right3;
    }, "decode");
    head13 = head13 << BigInt((view.byteLength - headLength) * 8) | decode9(headLength, view.byteLength);
  }
  return head13;
};
var errors3 = {
  Error,
  EvalError,
  RangeError,
  ReferenceError,
  SyntaxError,
  TypeError,
  URIError,
  AggregateError: typeof AggregateError === "function" ? AggregateError : null
};
currentExtensions2[101] = () => {
  let data = read3();
  if (!errors3[data[0]]) {
    let error5 = Error(data[1], { cause: data[2] });
    error5.name = data[0];
    return error5;
  }
  return errors3[data[0]](data[1], { cause: data[2] });
};
currentExtensions2[105] = (data) => {
  if (currentUnpackr2.structuredClone === false) throw new Error("Structured clone extension is disabled");
  let id4 = dataView2.getUint32(position3 - 4);
  if (!referenceMap2)
    referenceMap2 = /* @__PURE__ */ new Map();
  let token = src2[position3];
  let target3;
  if (token >= 144 && token < 160 || token == 220 || token == 221)
    target3 = [];
  else if (token >= 128 && token < 144 || token == 222 || token == 223)
    target3 = /* @__PURE__ */ new Map();
  else if ((token >= 199 && token <= 201 || token >= 212 && token <= 216) && src2[position3 + 1] === 115)
    target3 = /* @__PURE__ */ new Set();
  else
    target3 = {};
  let refEntry = { target: target3 };
  referenceMap2.set(id4, refEntry);
  let targetProperties = read3();
  if (!refEntry.used) {
    return refEntry.target = targetProperties;
  } else {
    Object.assign(target3, targetProperties);
  }
  if (target3 instanceof Map)
    for (let [k, v] of targetProperties.entries()) target3.set(k, v);
  if (target3 instanceof Set)
    for (let i of Array.from(targetProperties)) target3.add(i);
  return target3;
};
currentExtensions2[112] = (data) => {
  if (currentUnpackr2.structuredClone === false) throw new Error("Structured clone extension is disabled");
  let id4 = dataView2.getUint32(position3 - 4);
  let refEntry = referenceMap2.get(id4);
  refEntry.used = true;
  return refEntry.target;
};
currentExtensions2[115] = () => new Set(read3());
var typedArrays2 = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map((type3) => type3 + "Array");
var glbl2 = typeof globalThis === "object" ? globalThis : window;
currentExtensions2[116] = (data) => {
  let typeCode = data[0];
  let buffer4 = Uint8Array.prototype.slice.call(data, 1).buffer;
  let typedArrayName = typedArrays2[typeCode];
  if (!typedArrayName) {
    if (typeCode === 16) return buffer4;
    if (typeCode === 17) return new DataView(buffer4);
    throw new Error("Could not find typed array for code " + typeCode);
  }
  return new glbl2[typedArrayName](buffer4);
};
currentExtensions2[120] = () => {
  let data = read3();
  return new RegExp(data[0], data[1]);
};
var TEMP_BUNDLE2 = [];
currentExtensions2[98] = (data) => {
  let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
  let dataPosition = position3;
  position3 += dataSize - data.length;
  bundledStrings3 = TEMP_BUNDLE2;
  bundledStrings3 = [readOnlyJSString2(), readOnlyJSString2()];
  bundledStrings3.position0 = 0;
  bundledStrings3.position1 = 0;
  bundledStrings3.postBundlePosition = position3;
  position3 = dataPosition;
  return read3();
};
currentExtensions2[255] = (data) => {
  if (data.length == 4)
    return new Date((data[0] * 16777216 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1e3);
  else if (data.length == 8)
    return new Date(
      ((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1e6 + ((data[3] & 3) * 4294967296 + data[4] * 16777216 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1e3
    );
  else if (data.length == 12)
    return new Date(
      ((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1e6 + ((data[4] & 128 ? -281474976710656 : 0) + data[6] * 1099511627776 + data[7] * 4294967296 + data[8] * 16777216 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1e3
    );
  else
    return /* @__PURE__ */ new Date("invalid");
};
function saveState2(callback) {
  if (onSaveState2)
    onSaveState2();
  let savedSrcEnd = srcEnd2;
  let savedPosition = position3;
  let savedStringPosition = stringPosition2;
  let savedSrcStringStart = srcStringStart2;
  let savedSrcStringEnd = srcStringEnd2;
  let savedSrcString = srcString2;
  let savedStrings = strings2;
  let savedReferenceMap = referenceMap2;
  let savedBundledStrings = bundledStrings3;
  let savedSrc = new Uint8Array(src2.slice(0, srcEnd2));
  let savedStructures = currentStructures2;
  let savedStructuresContents = currentStructures2.slice(0, currentStructures2.length);
  let savedPackr = currentUnpackr2;
  let savedSequentialMode = sequentialMode2;
  let value6 = callback();
  srcEnd2 = savedSrcEnd;
  position3 = savedPosition;
  stringPosition2 = savedStringPosition;
  srcStringStart2 = savedSrcStringStart;
  srcStringEnd2 = savedSrcStringEnd;
  srcString2 = savedSrcString;
  strings2 = savedStrings;
  referenceMap2 = savedReferenceMap;
  bundledStrings3 = savedBundledStrings;
  src2 = savedSrc;
  sequentialMode2 = savedSequentialMode;
  currentStructures2 = savedStructures;
  currentStructures2.splice(0, currentStructures2.length, ...savedStructuresContents);
  currentUnpackr2 = savedPackr;
  dataView2 = new DataView(src2.buffer, src2.byteOffset, src2.byteLength);
  return value6;
}
__name(saveState2, "saveState");
function clearSource2() {
  src2 = null;
  referenceMap2 = null;
  currentStructures2 = null;
}
__name(clearSource2, "clearSource");
var mult102 = new Array(147);
for (let i = 0; i < 256; i++) {
  mult102[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
}
var defaultUnpackr2 = new Unpackr2({ useRecords: false });
var unpack2 = defaultUnpackr2.unpack;
var unpackMultiple2 = defaultUnpackr2.unpackMultiple;
var decode8 = defaultUnpackr2.unpack;
var FLOAT32_OPTIONS2 = {
  NEVER: 0,
  ALWAYS: 1,
  DECIMAL_ROUND: 3,
  DECIMAL_FIT: 4
};
var f32Array2 = new Float32Array(1);
var u8Array2 = new Uint8Array(f32Array2.buffer, 0, 4);

// node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/pack.js
var textEncoder2;
try {
  textEncoder2 = new TextEncoder();
} catch (error5) {
}
var extensions2;
var extensionClasses2;
var hasNodeBuffer2 = typeof Buffer !== "undefined";
var ByteArrayAllocate2 = hasNodeBuffer2 ? function(length5) {
  return Buffer.allocUnsafeSlow(length5);
} : Uint8Array;
var ByteArray2 = hasNodeBuffer2 ? Buffer : Uint8Array;
var MAX_BUFFER_SIZE2 = hasNodeBuffer2 ? 4294967296 : 2144337920;
var target2;
var keysTarget2;
var targetView2;
var position4 = 0;
var safeEnd2;
var bundledStrings4 = null;
var writeStructSlots2;
var MAX_BUNDLE_SIZE2 = 21760;
var hasNonLatin2 = /[\u0080-\uFFFF]/;
var RECORD_SYMBOL2 = Symbol("record-id");
var Packr2 = class extends Unpackr2 {
  static {
    __name(this, "Packr");
  }
  constructor(options4) {
    super(options4);
    this.offset = 0;
    let typeBuffer;
    let start3;
    let hasSharedUpdate;
    let structures;
    let referenceMap3;
    let encodeUtf8 = ByteArray2.prototype.utf8Write ? function(string7, position5) {
      return target2.utf8Write(string7, position5, target2.byteLength - position5);
    } : textEncoder2 && textEncoder2.encodeInto ? function(string7, position5) {
      return textEncoder2.encodeInto(string7, target2.subarray(position5)).written;
    } : false;
    let packr = this;
    if (!options4)
      options4 = {};
    let isSequential2 = options4 && options4.sequential;
    let hasSharedStructures = options4.structures || options4.saveStructures;
    let maxSharedStructures = options4.maxSharedStructures;
    if (maxSharedStructures == null)
      maxSharedStructures = hasSharedStructures ? 32 : 0;
    if (maxSharedStructures > 8160)
      throw new Error("Maximum maxSharedStructure is 8160");
    if (options4.structuredClone && options4.moreTypes == void 0) {
      this.moreTypes = true;
    }
    let maxOwnStructures = options4.maxOwnStructures;
    if (maxOwnStructures == null)
      maxOwnStructures = hasSharedStructures ? 32 : 64;
    if (!this.structures && options4.useRecords != false)
      this.structures = [];
    let useTwoByteRecords = maxSharedStructures > 32 || maxOwnStructures + maxSharedStructures > 64;
    let sharedLimitId = maxSharedStructures + 64;
    let maxStructureId = maxSharedStructures + maxOwnStructures + 64;
    if (maxStructureId > 8256) {
      throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
    }
    let recordIdsToRemove = [];
    let transitionsCount = 0;
    let serializationsSinceTransitionRebuild = 0;
    this.pack = this.encode = function(value6, encodeOptions) {
      if (!target2) {
        target2 = new ByteArrayAllocate2(8192);
        targetView2 = target2.dataView || (target2.dataView = new DataView(target2.buffer, 0, 8192));
        position4 = 0;
      }
      safeEnd2 = target2.length - 10;
      if (safeEnd2 - position4 < 2048) {
        target2 = new ByteArrayAllocate2(target2.length);
        targetView2 = target2.dataView || (target2.dataView = new DataView(target2.buffer, 0, target2.length));
        safeEnd2 = target2.length - 10;
        position4 = 0;
      } else
        position4 = position4 + 7 & 2147483640;
      start3 = position4;
      if (encodeOptions & RESERVE_START_SPACE2) position4 += encodeOptions & 255;
      referenceMap3 = packr.structuredClone ? /* @__PURE__ */ new Map() : null;
      if (packr.bundleStrings && typeof value6 !== "string") {
        bundledStrings4 = [];
        bundledStrings4.size = Infinity;
      } else
        bundledStrings4 = null;
      structures = packr.structures;
      if (structures) {
        if (structures.uninitialized)
          structures = packr._mergeStructures(packr.getStructures());
        let sharedLength = structures.sharedLength || 0;
        if (sharedLength > maxSharedStructures) {
          throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + structures.sharedLength);
        }
        if (!structures.transitions) {
          structures.transitions = /* @__PURE__ */ Object.create(null);
          for (let i = 0; i < sharedLength; i++) {
            let keys6 = structures[i];
            if (!keys6)
              continue;
            let nextTransition, transition = structures.transitions;
            for (let j = 0, l = keys6.length; j < l; j++) {
              let key = keys6[j];
              nextTransition = transition[key];
              if (!nextTransition) {
                nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
              }
              transition = nextTransition;
            }
            transition[RECORD_SYMBOL2] = i + 64;
          }
          this.lastNamedStructuresLength = sharedLength;
        }
        if (!isSequential2) {
          structures.nextId = sharedLength + 64;
        }
      }
      if (hasSharedUpdate)
        hasSharedUpdate = false;
      let encodingError;
      try {
        if (packr.randomAccessStructure && value6 && value6.constructor && value6.constructor === Object)
          writeStruct(value6);
        else
          pack4(value6);
        let lastBundle = bundledStrings4;
        if (bundledStrings4)
          writeBundles2(start3, pack4, 0);
        if (referenceMap3 && referenceMap3.idsToInsert) {
          let idsToInsert = referenceMap3.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);
          let i = idsToInsert.length;
          let incrementPosition = -1;
          while (lastBundle && i > 0) {
            let insertionPoint = idsToInsert[--i].offset + start3;
            if (insertionPoint < lastBundle.stringsPosition + start3 && incrementPosition === -1)
              incrementPosition = 0;
            if (insertionPoint > lastBundle.position + start3) {
              if (incrementPosition >= 0)
                incrementPosition += 6;
            } else {
              if (incrementPosition >= 0) {
                targetView2.setUint32(
                  lastBundle.position + start3,
                  targetView2.getUint32(lastBundle.position + start3) + incrementPosition
                );
                incrementPosition = -1;
              }
              lastBundle = lastBundle.previous;
              i++;
            }
          }
          if (incrementPosition >= 0 && lastBundle) {
            targetView2.setUint32(
              lastBundle.position + start3,
              targetView2.getUint32(lastBundle.position + start3) + incrementPosition
            );
          }
          position4 += idsToInsert.length * 6;
          if (position4 > safeEnd2)
            makeRoom(position4);
          packr.offset = position4;
          let serialized = insertIds2(target2.subarray(start3, position4), idsToInsert);
          referenceMap3 = null;
          return serialized;
        }
        packr.offset = position4;
        if (encodeOptions & REUSE_BUFFER_MODE2) {
          target2.start = start3;
          target2.end = position4;
          return target2;
        }
        return target2.subarray(start3, position4);
      } catch (error5) {
        encodingError = error5;
        throw error5;
      } finally {
        if (structures) {
          resetStructures();
          if (hasSharedUpdate && packr.saveStructures) {
            let sharedLength = structures.sharedLength || 0;
            let returnBuffer = target2.subarray(start3, position4);
            let newSharedData = prepareStructures2(structures, packr);
            if (!encodingError) {
              if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {
                return packr.pack(value6, encodeOptions);
              }
              packr.lastNamedStructuresLength = sharedLength;
              if (target2.length > 1073741824) target2 = null;
              return returnBuffer;
            }
          }
        }
        if (target2.length > 1073741824) target2 = null;
        if (encodeOptions & RESET_BUFFER_MODE2)
          position4 = start3;
      }
    };
    const resetStructures = /* @__PURE__ */ __name(() => {
      if (serializationsSinceTransitionRebuild < 10)
        serializationsSinceTransitionRebuild++;
      let sharedLength = structures.sharedLength || 0;
      if (structures.length > sharedLength && !isSequential2)
        structures.length = sharedLength;
      if (transitionsCount > 1e4) {
        structures.transitions = null;
        serializationsSinceTransitionRebuild = 0;
        transitionsCount = 0;
        if (recordIdsToRemove.length > 0)
          recordIdsToRemove = [];
      } else if (recordIdsToRemove.length > 0 && !isSequential2) {
        for (let i = 0, l = recordIdsToRemove.length; i < l; i++) {
          recordIdsToRemove[i][RECORD_SYMBOL2] = 0;
        }
        recordIdsToRemove = [];
      }
    }, "resetStructures");
    const packArray = /* @__PURE__ */ __name((value6) => {
      var length5 = value6.length;
      if (length5 < 16) {
        target2[position4++] = 144 | length5;
      } else if (length5 < 65536) {
        target2[position4++] = 220;
        target2[position4++] = length5 >> 8;
        target2[position4++] = length5 & 255;
      } else {
        target2[position4++] = 221;
        targetView2.setUint32(position4, length5);
        position4 += 4;
      }
      for (let i = 0; i < length5; i++) {
        pack4(value6[i]);
      }
    }, "packArray");
    const pack4 = /* @__PURE__ */ __name((value6) => {
      if (position4 > safeEnd2)
        target2 = makeRoom(position4);
      var type3 = typeof value6;
      var length5;
      if (type3 === "string") {
        let strLength = value6.length;
        if (bundledStrings4 && strLength >= 4 && strLength < 4096) {
          if ((bundledStrings4.size += strLength) > MAX_BUNDLE_SIZE2) {
            let extStart;
            let maxBytes2 = (bundledStrings4[0] ? bundledStrings4[0].length * 3 + bundledStrings4[1].length : 0) + 10;
            if (position4 + maxBytes2 > safeEnd2)
              target2 = makeRoom(position4 + maxBytes2);
            let lastBundle;
            if (bundledStrings4.position) {
              lastBundle = bundledStrings4;
              target2[position4] = 200;
              position4 += 3;
              target2[position4++] = 98;
              extStart = position4 - start3;
              position4 += 4;
              writeBundles2(start3, pack4, 0);
              targetView2.setUint16(extStart + start3 - 3, position4 - start3 - extStart);
            } else {
              target2[position4++] = 214;
              target2[position4++] = 98;
              extStart = position4 - start3;
              position4 += 4;
            }
            bundledStrings4 = ["", ""];
            bundledStrings4.previous = lastBundle;
            bundledStrings4.size = 0;
            bundledStrings4.position = extStart;
          }
          let twoByte = hasNonLatin2.test(value6);
          bundledStrings4[twoByte ? 0 : 1] += value6;
          target2[position4++] = 193;
          pack4(twoByte ? -strLength : strLength);
          return;
        }
        let headerSize;
        if (strLength < 32) {
          headerSize = 1;
        } else if (strLength < 256) {
          headerSize = 2;
        } else if (strLength < 65536) {
          headerSize = 3;
        } else {
          headerSize = 5;
        }
        let maxBytes = strLength * 3;
        if (position4 + maxBytes > safeEnd2)
          target2 = makeRoom(position4 + maxBytes);
        if (strLength < 64 || !encodeUtf8) {
          let i, c1, c2, strPosition = position4 + headerSize;
          for (i = 0; i < strLength; i++) {
            c1 = value6.charCodeAt(i);
            if (c1 < 128) {
              target2[strPosition++] = c1;
            } else if (c1 < 2048) {
              target2[strPosition++] = c1 >> 6 | 192;
              target2[strPosition++] = c1 & 63 | 128;
            } else if ((c1 & 64512) === 55296 && ((c2 = value6.charCodeAt(i + 1)) & 64512) === 56320) {
              c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
              i++;
              target2[strPosition++] = c1 >> 18 | 240;
              target2[strPosition++] = c1 >> 12 & 63 | 128;
              target2[strPosition++] = c1 >> 6 & 63 | 128;
              target2[strPosition++] = c1 & 63 | 128;
            } else {
              target2[strPosition++] = c1 >> 12 | 224;
              target2[strPosition++] = c1 >> 6 & 63 | 128;
              target2[strPosition++] = c1 & 63 | 128;
            }
          }
          length5 = strPosition - position4 - headerSize;
        } else {
          length5 = encodeUtf8(value6, position4 + headerSize);
        }
        if (length5 < 32) {
          target2[position4++] = 160 | length5;
        } else if (length5 < 256) {
          if (headerSize < 2) {
            target2.copyWithin(position4 + 2, position4 + 1, position4 + 1 + length5);
          }
          target2[position4++] = 217;
          target2[position4++] = length5;
        } else if (length5 < 65536) {
          if (headerSize < 3) {
            target2.copyWithin(position4 + 3, position4 + 2, position4 + 2 + length5);
          }
          target2[position4++] = 218;
          target2[position4++] = length5 >> 8;
          target2[position4++] = length5 & 255;
        } else {
          if (headerSize < 5) {
            target2.copyWithin(position4 + 5, position4 + 3, position4 + 3 + length5);
          }
          target2[position4++] = 219;
          targetView2.setUint32(position4, length5);
          position4 += 4;
        }
        position4 += length5;
      } else if (type3 === "number") {
        if (value6 >>> 0 === value6) {
          if (value6 < 32 || value6 < 128 && this.useRecords === false || value6 < 64 && !this.randomAccessStructure) {
            target2[position4++] = value6;
          } else if (value6 < 256) {
            target2[position4++] = 204;
            target2[position4++] = value6;
          } else if (value6 < 65536) {
            target2[position4++] = 205;
            target2[position4++] = value6 >> 8;
            target2[position4++] = value6 & 255;
          } else {
            target2[position4++] = 206;
            targetView2.setUint32(position4, value6);
            position4 += 4;
          }
        } else if (value6 >> 0 === value6) {
          if (value6 >= -32) {
            target2[position4++] = 256 + value6;
          } else if (value6 >= -128) {
            target2[position4++] = 208;
            target2[position4++] = value6 + 256;
          } else if (value6 >= -32768) {
            target2[position4++] = 209;
            targetView2.setInt16(position4, value6);
            position4 += 2;
          } else {
            target2[position4++] = 210;
            targetView2.setInt32(position4, value6);
            position4 += 4;
          }
        } else {
          let useFloat32;
          if ((useFloat32 = this.useFloat32) > 0 && value6 < 4294967296 && value6 >= -2147483648) {
            target2[position4++] = 202;
            targetView2.setFloat32(position4, value6);
            let xShifted;
            if (useFloat32 < 4 || // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
            (xShifted = value6 * mult102[(target2[position4] & 127) << 1 | target2[position4 + 1] >> 7]) >> 0 === xShifted) {
              position4 += 4;
              return;
            } else
              position4--;
          }
          target2[position4++] = 203;
          targetView2.setFloat64(position4, value6);
          position4 += 8;
        }
      } else if (type3 === "object" || type3 === "function") {
        if (!value6)
          target2[position4++] = 192;
        else {
          if (referenceMap3) {
            let referee = referenceMap3.get(value6);
            if (referee) {
              if (!referee.id) {
                let idsToInsert = referenceMap3.idsToInsert || (referenceMap3.idsToInsert = []);
                referee.id = idsToInsert.push(referee);
              }
              target2[position4++] = 214;
              target2[position4++] = 112;
              targetView2.setUint32(position4, referee.id);
              position4 += 4;
              return;
            } else
              referenceMap3.set(value6, { offset: position4 - start3 });
          }
          let constructor = value6.constructor;
          if (constructor === Object) {
            writeObject(value6);
          } else if (constructor === Array) {
            packArray(value6);
          } else if (constructor === Map) {
            if (this.mapAsEmptyObject) target2[position4++] = 128;
            else {
              length5 = value6.size;
              if (length5 < 16) {
                target2[position4++] = 128 | length5;
              } else if (length5 < 65536) {
                target2[position4++] = 222;
                target2[position4++] = length5 >> 8;
                target2[position4++] = length5 & 255;
              } else {
                target2[position4++] = 223;
                targetView2.setUint32(position4, length5);
                position4 += 4;
              }
              for (let [key, entryValue] of value6) {
                pack4(key);
                pack4(entryValue);
              }
            }
          } else {
            for (let i = 0, l = extensions2.length; i < l; i++) {
              let extensionClass = extensionClasses2[i];
              if (value6 instanceof extensionClass) {
                let extension = extensions2[i];
                if (extension.write) {
                  if (extension.type) {
                    target2[position4++] = 212;
                    target2[position4++] = extension.type;
                    target2[position4++] = 0;
                  }
                  let writeResult = extension.write.call(this, value6);
                  if (writeResult === value6) {
                    if (Array.isArray(value6)) {
                      packArray(value6);
                    } else {
                      writeObject(value6);
                    }
                  } else {
                    pack4(writeResult);
                  }
                  return;
                }
                let currentTarget = target2;
                let currentTargetView = targetView2;
                let currentPosition = position4;
                target2 = null;
                let result;
                try {
                  result = extension.pack.call(this, value6, (size22) => {
                    target2 = currentTarget;
                    currentTarget = null;
                    position4 += size22;
                    if (position4 > safeEnd2)
                      makeRoom(position4);
                    return {
                      target: target2,
                      targetView: targetView2,
                      position: position4 - size22
                    };
                  }, pack4);
                } finally {
                  if (currentTarget) {
                    target2 = currentTarget;
                    targetView2 = currentTargetView;
                    position4 = currentPosition;
                    safeEnd2 = target2.length - 10;
                  }
                }
                if (result) {
                  if (result.length + position4 > safeEnd2)
                    makeRoom(result.length + position4);
                  position4 = writeExtensionData2(result, target2, position4, extension.type);
                }
                return;
              }
            }
            if (Array.isArray(value6)) {
              packArray(value6);
            } else {
              if (value6.toJSON) {
                const json8 = value6.toJSON();
                if (json8 !== value6)
                  return pack4(json8);
              }
              if (type3 === "function")
                return pack4(this.writeFunction && this.writeFunction(value6));
              writeObject(value6);
            }
          }
        }
      } else if (type3 === "boolean") {
        target2[position4++] = value6 ? 195 : 194;
      } else if (type3 === "bigint") {
        if (value6 < 9223372036854776e3 && value6 >= -9223372036854776e3) {
          target2[position4++] = 211;
          targetView2.setBigInt64(position4, value6);
        } else if (value6 < 18446744073709552e3 && value6 > 0) {
          target2[position4++] = 207;
          targetView2.setBigUint64(position4, value6);
        } else {
          if (this.largeBigIntToFloat) {
            target2[position4++] = 203;
            targetView2.setFloat64(position4, Number(value6));
          } else if (this.largeBigIntToString) {
            return pack4(value6.toString());
          } else if (this.useBigIntExtension || this.moreTypes) {
            let empty45 = value6 < 0 ? BigInt(-1) : BigInt(0);
            let array7;
            if (value6 >> BigInt(65536) === empty45) {
              let mask = BigInt(18446744073709552e3) - BigInt(1);
              let chunks3 = [];
              while (true) {
                chunks3.push(value6 & mask);
                if (value6 >> BigInt(63) === empty45) break;
                value6 >>= BigInt(64);
              }
              array7 = new Uint8Array(new BigUint64Array(chunks3).buffer);
              array7.reverse();
            } else {
              let invert2 = value6 < 0;
              let string7 = (invert2 ? ~value6 : value6).toString(16);
              if (string7.length % 2) {
                string7 = "0" + string7;
              } else if (parseInt(string7.charAt(0), 16) >= 8) {
                string7 = "00" + string7;
              }
              if (hasNodeBuffer2) {
                array7 = Buffer.from(string7, "hex");
              } else {
                array7 = new Uint8Array(string7.length / 2);
                for (let i = 0; i < array7.length; i++) {
                  array7[i] = parseInt(string7.slice(i * 2, i * 2 + 2), 16);
                }
              }
              if (invert2) {
                for (let i = 0; i < array7.length; i++) array7[i] = ~array7[i];
              }
            }
            if (array7.length + position4 > safeEnd2)
              makeRoom(array7.length + position4);
            position4 = writeExtensionData2(array7, target2, position4, 66);
            return;
          } else {
            throw new RangeError(value6 + " was too large to fit in MessagePack 64-bit integer format, use useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set largeBigIntToString to convert to string");
          }
        }
        position4 += 8;
      } else if (type3 === "undefined") {
        if (this.encodeUndefinedAsNil)
          target2[position4++] = 192;
        else {
          target2[position4++] = 212;
          target2[position4++] = 0;
          target2[position4++] = 0;
        }
      } else {
        throw new Error("Unknown type: " + type3);
      }
    }, "pack");
    const writePlainObject = this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues ? (object2) => {
      let keys6;
      if (this.skipValues) {
        keys6 = [];
        for (let key2 in object2) {
          if ((typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key2)) && !this.skipValues.includes(object2[key2]))
            keys6.push(key2);
        }
      } else {
        keys6 = Object.keys(object2);
      }
      let length5 = keys6.length;
      if (length5 < 16) {
        target2[position4++] = 128 | length5;
      } else if (length5 < 65536) {
        target2[position4++] = 222;
        target2[position4++] = length5 >> 8;
        target2[position4++] = length5 & 255;
      } else {
        target2[position4++] = 223;
        targetView2.setUint32(position4, length5);
        position4 += 4;
      }
      let key;
      if (this.coercibleKeyAsNumber) {
        for (let i = 0; i < length5; i++) {
          key = keys6[i];
          let num = Number(key);
          pack4(isNaN(num) ? key : num);
          pack4(object2[key]);
        }
      } else {
        for (let i = 0; i < length5; i++) {
          pack4(key = keys6[i]);
          pack4(object2[key]);
        }
      }
    } : (object2) => {
      target2[position4++] = 222;
      let objectOffset = position4 - start3;
      position4 += 2;
      let size22 = 0;
      for (let key in object2) {
        if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
          pack4(key);
          pack4(object2[key]);
          size22++;
        }
      }
      if (size22 > 65535) {
        throw new Error('Object is too large to serialize with fast 16-bit map size, use the "variableMapSize" option to serialize this object');
      }
      target2[objectOffset++ + start3] = size22 >> 8;
      target2[objectOffset + start3] = size22 & 255;
    };
    const writeRecord = this.useRecords === false ? writePlainObject : options4.progressiveRecords && !useTwoByteRecords ? (
      // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
      (object2) => {
        let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
        let objectOffset = position4++ - start3;
        let wroteKeys;
        for (let key in object2) {
          if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (nextTransition)
              transition = nextTransition;
            else {
              let keys6 = Object.keys(object2);
              let lastTransition = transition;
              transition = structures.transitions;
              let newTransitions = 0;
              for (let i = 0, l = keys6.length; i < l; i++) {
                let key2 = keys6[i];
                nextTransition = transition[key2];
                if (!nextTransition) {
                  nextTransition = transition[key2] = /* @__PURE__ */ Object.create(null);
                  newTransitions++;
                }
                transition = nextTransition;
              }
              if (objectOffset + start3 + 1 == position4) {
                position4--;
                newRecord(transition, keys6, newTransitions);
              } else
                insertNewRecord(transition, keys6, objectOffset, newTransitions);
              wroteKeys = true;
              transition = lastTransition[key];
            }
            pack4(object2[key]);
          }
        }
        if (!wroteKeys) {
          let recordId = transition[RECORD_SYMBOL2];
          if (recordId)
            target2[objectOffset + start3] = recordId;
          else
            insertNewRecord(transition, Object.keys(object2), objectOffset, 0);
        }
      }
    ) : (object2) => {
      let nextTransition, transition = structures.transitions || (structures.transitions = /* @__PURE__ */ Object.create(null));
      let newTransitions = 0;
      for (let key in object2) if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
        nextTransition = transition[key];
        if (!nextTransition) {
          nextTransition = transition[key] = /* @__PURE__ */ Object.create(null);
          newTransitions++;
        }
        transition = nextTransition;
      }
      let recordId = transition[RECORD_SYMBOL2];
      if (recordId) {
        if (recordId >= 96 && useTwoByteRecords) {
          target2[position4++] = ((recordId -= 96) & 31) + 96;
          target2[position4++] = recordId >> 5;
        } else
          target2[position4++] = recordId;
      } else {
        newRecord(transition, transition.__keys__ || Object.keys(object2), newTransitions);
      }
      for (let key in object2)
        if (typeof object2.hasOwnProperty !== "function" || object2.hasOwnProperty(key)) {
          pack4(object2[key]);
        }
    };
    const checkUseRecords = typeof this.useRecords == "function" && this.useRecords;
    const writeObject = checkUseRecords ? (object2) => {
      checkUseRecords(object2) ? writeRecord(object2) : writePlainObject(object2);
    } : writeRecord;
    const makeRoom = /* @__PURE__ */ __name((end6) => {
      let newSize;
      if (end6 > 16777216) {
        if (end6 - start3 > MAX_BUFFER_SIZE2)
          throw new Error("Packed buffer would be larger than maximum buffer size");
        newSize = Math.min(
          MAX_BUFFER_SIZE2,
          Math.round(Math.max((end6 - start3) * (end6 > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096
        );
      } else
        newSize = (Math.max(end6 - start3 << 2, target2.length - 1) >> 12) + 1 << 12;
      let newBuffer = new ByteArrayAllocate2(newSize);
      targetView2 = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));
      end6 = Math.min(end6, target2.length);
      if (target2.copy)
        target2.copy(newBuffer, 0, start3, end6);
      else
        newBuffer.set(target2.slice(start3, end6));
      position4 -= start3;
      start3 = 0;
      safeEnd2 = newBuffer.length - 10;
      return target2 = newBuffer;
    }, "makeRoom");
    const newRecord = /* @__PURE__ */ __name((transition, keys6, newTransitions) => {
      let recordId = structures.nextId;
      if (!recordId)
        recordId = 64;
      if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys6)) {
        recordId = structures.nextOwnId;
        if (!(recordId < maxStructureId))
          recordId = sharedLimitId;
        structures.nextOwnId = recordId + 1;
      } else {
        if (recordId >= maxStructureId)
          recordId = sharedLimitId;
        structures.nextId = recordId + 1;
      }
      let highByte = keys6.highByte = recordId >= 96 && useTwoByteRecords ? recordId - 96 >> 5 : -1;
      transition[RECORD_SYMBOL2] = recordId;
      transition.__keys__ = keys6;
      structures[recordId - 64] = keys6;
      if (recordId < sharedLimitId) {
        keys6.isShared = true;
        structures.sharedLength = recordId - 63;
        hasSharedUpdate = true;
        if (highByte >= 0) {
          target2[position4++] = (recordId & 31) + 96;
          target2[position4++] = highByte;
        } else {
          target2[position4++] = recordId;
        }
      } else {
        if (highByte >= 0) {
          target2[position4++] = 213;
          target2[position4++] = 114;
          target2[position4++] = (recordId & 31) + 96;
          target2[position4++] = highByte;
        } else {
          target2[position4++] = 212;
          target2[position4++] = 114;
          target2[position4++] = recordId;
        }
        if (newTransitions)
          transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
        if (recordIdsToRemove.length >= maxOwnStructures)
          recordIdsToRemove.shift()[RECORD_SYMBOL2] = 0;
        recordIdsToRemove.push(transition);
        pack4(keys6);
      }
    }, "newRecord");
    const insertNewRecord = /* @__PURE__ */ __name((transition, keys6, insertionOffset, newTransitions) => {
      let mainTarget = target2;
      let mainPosition = position4;
      let mainSafeEnd = safeEnd2;
      let mainStart = start3;
      target2 = keysTarget2;
      position4 = 0;
      start3 = 0;
      if (!target2)
        keysTarget2 = target2 = new ByteArrayAllocate2(8192);
      safeEnd2 = target2.length - 10;
      newRecord(transition, keys6, newTransitions);
      keysTarget2 = target2;
      let keysPosition = position4;
      target2 = mainTarget;
      position4 = mainPosition;
      safeEnd2 = mainSafeEnd;
      start3 = mainStart;
      if (keysPosition > 1) {
        let newEnd = position4 + keysPosition - 1;
        if (newEnd > safeEnd2)
          makeRoom(newEnd);
        let insertionPosition = insertionOffset + start3;
        target2.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position4);
        target2.set(keysTarget2.slice(0, keysPosition), insertionPosition);
        position4 = newEnd;
      } else {
        target2[insertionOffset + start3] = keysTarget2[0];
      }
    }, "insertNewRecord");
    const writeStruct = /* @__PURE__ */ __name((object2) => {
      let newPosition = writeStructSlots2(object2, target2, start3, position4, structures, makeRoom, (value6, newPosition2, notifySharedUpdate) => {
        if (notifySharedUpdate)
          return hasSharedUpdate = true;
        position4 = newPosition2;
        let startTarget = target2;
        pack4(value6);
        resetStructures();
        if (startTarget !== target2) {
          return { position: position4, targetView: targetView2, target: target2 };
        }
        return position4;
      }, this);
      if (newPosition === 0)
        return writeObject(object2);
      position4 = newPosition;
    }, "writeStruct");
  }
  useBuffer(buffer4) {
    target2 = buffer4;
    target2.dataView || (target2.dataView = new DataView(target2.buffer, target2.byteOffset, target2.byteLength));
    targetView2 = target2.dataView;
    position4 = 0;
  }
  set position(value6) {
    position4 = value6;
  }
  get position() {
    return position4;
  }
  clearSharedData() {
    if (this.structures)
      this.structures = [];
    if (this.typedStructs)
      this.typedStructs = [];
  }
};
extensionClasses2 = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, DataView, C1Type2];
extensions2 = [{
  pack(date4, allocateForWrite, pack4) {
    let seconds2 = date4.getTime() / 1e3;
    if ((this.useTimestamp32 || date4.getMilliseconds() === 0) && seconds2 >= 0 && seconds2 < 4294967296) {
      let { target: target3, targetView: targetView3, position: position5 } = allocateForWrite(6);
      target3[position5++] = 214;
      target3[position5++] = 255;
      targetView3.setUint32(position5, seconds2);
    } else if (seconds2 > 0 && seconds2 < 4294967296) {
      let { target: target3, targetView: targetView3, position: position5 } = allocateForWrite(10);
      target3[position5++] = 215;
      target3[position5++] = 255;
      targetView3.setUint32(position5, date4.getMilliseconds() * 4e6 + (seconds2 / 1e3 / 4294967296 >> 0));
      targetView3.setUint32(position5 + 4, seconds2);
    } else if (isNaN(seconds2)) {
      if (this.onInvalidDate) {
        allocateForWrite(0);
        return pack4(this.onInvalidDate());
      }
      let { target: target3, targetView: targetView3, position: position5 } = allocateForWrite(3);
      target3[position5++] = 212;
      target3[position5++] = 255;
      target3[position5++] = 255;
    } else {
      let { target: target3, targetView: targetView3, position: position5 } = allocateForWrite(15);
      target3[position5++] = 199;
      target3[position5++] = 12;
      target3[position5++] = 255;
      targetView3.setUint32(position5, date4.getMilliseconds() * 1e6);
      targetView3.setBigInt64(position5 + 4, BigInt(Math.floor(seconds2)));
    }
  }
}, {
  pack(set20, allocateForWrite, pack4) {
    if (this.setAsEmptyObject) {
      allocateForWrite(0);
      return pack4({});
    }
    let array7 = Array.from(set20);
    let { target: target3, position: position5 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target3[position5++] = 212;
      target3[position5++] = 115;
      target3[position5++] = 0;
    }
    pack4(array7);
  }
}, {
  pack(error5, allocateForWrite, pack4) {
    let { target: target3, position: position5 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target3[position5++] = 212;
      target3[position5++] = 101;
      target3[position5++] = 0;
    }
    pack4([error5.name, error5.message, error5.cause]);
  }
}, {
  pack(regex, allocateForWrite, pack4) {
    let { target: target3, position: position5 } = allocateForWrite(this.moreTypes ? 3 : 0);
    if (this.moreTypes) {
      target3[position5++] = 212;
      target3[position5++] = 120;
      target3[position5++] = 0;
    }
    pack4([regex.source, regex.flags]);
  }
}, {
  pack(arrayBuffer, allocateForWrite) {
    if (this.moreTypes)
      writeExtBuffer2(arrayBuffer, 16, allocateForWrite);
    else
      writeBuffer2(hasNodeBuffer2 ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
  }
}, {
  pack(typedArray, allocateForWrite) {
    let constructor = typedArray.constructor;
    if (constructor !== ByteArray2 && this.moreTypes)
      writeExtBuffer2(typedArray, typedArrays2.indexOf(constructor.name), allocateForWrite);
    else
      writeBuffer2(typedArray, allocateForWrite);
  }
}, {
  pack(arrayBuffer, allocateForWrite) {
    if (this.moreTypes)
      writeExtBuffer2(arrayBuffer, 17, allocateForWrite);
    else
      writeBuffer2(hasNodeBuffer2 ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
  }
}, {
  pack(c1, allocateForWrite) {
    let { target: target3, position: position5 } = allocateForWrite(1);
    target3[position5] = 193;
  }
}];
function writeExtBuffer2(typedArray, type3, allocateForWrite, encode8) {
  let length5 = typedArray.byteLength;
  if (length5 + 1 < 256) {
    var { target: target3, position: position5 } = allocateForWrite(4 + length5);
    target3[position5++] = 199;
    target3[position5++] = length5 + 1;
  } else if (length5 + 1 < 65536) {
    var { target: target3, position: position5 } = allocateForWrite(5 + length5);
    target3[position5++] = 200;
    target3[position5++] = length5 + 1 >> 8;
    target3[position5++] = length5 + 1 & 255;
  } else {
    var { target: target3, position: position5, targetView: targetView3 } = allocateForWrite(7 + length5);
    target3[position5++] = 201;
    targetView3.setUint32(position5, length5 + 1);
    position5 += 4;
  }
  target3[position5++] = 116;
  target3[position5++] = type3;
  if (!typedArray.buffer) typedArray = new Uint8Array(typedArray);
  target3.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position5);
}
__name(writeExtBuffer2, "writeExtBuffer");
function writeBuffer2(buffer4, allocateForWrite) {
  let length5 = buffer4.byteLength;
  var target3, position5;
  if (length5 < 256) {
    var { target: target3, position: position5 } = allocateForWrite(length5 + 2);
    target3[position5++] = 196;
    target3[position5++] = length5;
  } else if (length5 < 65536) {
    var { target: target3, position: position5 } = allocateForWrite(length5 + 3);
    target3[position5++] = 197;
    target3[position5++] = length5 >> 8;
    target3[position5++] = length5 & 255;
  } else {
    var { target: target3, position: position5, targetView: targetView3 } = allocateForWrite(length5 + 5);
    target3[position5++] = 198;
    targetView3.setUint32(position5, length5);
    position5 += 4;
  }
  target3.set(buffer4, position5);
}
__name(writeBuffer2, "writeBuffer");
function writeExtensionData2(result, target3, position5, type3) {
  let length5 = result.length;
  switch (length5) {
    case 1:
      target3[position5++] = 212;
      break;
    case 2:
      target3[position5++] = 213;
      break;
    case 4:
      target3[position5++] = 214;
      break;
    case 8:
      target3[position5++] = 215;
      break;
    case 16:
      target3[position5++] = 216;
      break;
    default:
      if (length5 < 256) {
        target3[position5++] = 199;
        target3[position5++] = length5;
      } else if (length5 < 65536) {
        target3[position5++] = 200;
        target3[position5++] = length5 >> 8;
        target3[position5++] = length5 & 255;
      } else {
        target3[position5++] = 201;
        target3[position5++] = length5 >> 24;
        target3[position5++] = length5 >> 16 & 255;
        target3[position5++] = length5 >> 8 & 255;
        target3[position5++] = length5 & 255;
      }
  }
  target3[position5++] = type3;
  target3.set(result, position5);
  position5 += length5;
  return position5;
}
__name(writeExtensionData2, "writeExtensionData");
function insertIds2(serialized, idsToInsert) {
  let nextId;
  let distanceToMove = idsToInsert.length * 6;
  let lastEnd = serialized.length - distanceToMove;
  while (nextId = idsToInsert.pop()) {
    let offset = nextId.offset;
    let id4 = nextId.id;
    serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
    distanceToMove -= 6;
    let position5 = offset + distanceToMove;
    serialized[position5++] = 214;
    serialized[position5++] = 105;
    serialized[position5++] = id4 >> 24;
    serialized[position5++] = id4 >> 16 & 255;
    serialized[position5++] = id4 >> 8 & 255;
    serialized[position5++] = id4 & 255;
    lastEnd = offset;
  }
  return serialized;
}
__name(insertIds2, "insertIds");
function writeBundles2(start3, pack4, incrementPosition) {
  if (bundledStrings4.length > 0) {
    targetView2.setUint32(bundledStrings4.position + start3, position4 + incrementPosition - bundledStrings4.position - start3);
    bundledStrings4.stringsPosition = position4 - start3;
    let writeStrings = bundledStrings4;
    bundledStrings4 = null;
    pack4(writeStrings[0]);
    pack4(writeStrings[1]);
  }
}
__name(writeBundles2, "writeBundles");
function prepareStructures2(structures, packr) {
  structures.isCompatible = (existingStructures) => {
    let compatible = !existingStructures || (packr.lastNamedStructuresLength || 0) === existingStructures.length;
    if (!compatible)
      packr._mergeStructures(existingStructures);
    return compatible;
  };
  return structures;
}
__name(prepareStructures2, "prepareStructures");
var defaultPackr2 = new Packr2({ useRecords: false });
var pack3 = defaultPackr2.pack;
var encode7 = defaultPackr2.pack;
var { NEVER: NEVER2, ALWAYS: ALWAYS2, DECIMAL_ROUND: DECIMAL_ROUND2, DECIMAL_FIT: DECIMAL_FIT2 } = FLOAT32_OPTIONS2;
var REUSE_BUFFER_MODE2 = 512;
var RESET_BUFFER_MODE2 = 1024;
var RESERVE_START_SPACE2 = 2048;

// node_modules/.pnpm/msgpackr@1.11.5/node_modules/msgpackr/iterators.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Schema/msgpack.js
var MsgPack = /* @__PURE__ */ __name((schema4) => Schema_exports.transform(Schema_exports.Uint8ArrayFromSelf, schema4, {
  encode: /* @__PURE__ */ __name((decoded) => pack3(decoded), "encode"),
  decode: /* @__PURE__ */ __name((encodedBytes) => unpack2(encodedBytes), "decode")
}), "MsgPack");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Schema/index.js
var hash3 = /* @__PURE__ */ __name((schema4) => {
  try {
    return Hash_exports.string(JSON.stringify(schema4.ast, null, 2));
  } catch {
    console.warn(`Schema hashing failed, falling back to hashing the shortend schema AST string. This is less reliable and may cause false positives.`);
    return Hash_exports.hash(schema4.ast.toString());
  }
}, "hash");
var encodeWithTransferables = /* @__PURE__ */ __name((schema4, options4) => (a, overrideOptions) => Effect_exports.gen(function* () {
  const collector = yield* Transferable_exports.makeCollector;
  const encoded = yield* Schema_exports.encode(schema4, options4)(a, overrideOptions).pipe(Effect_exports.provideService(Transferable_exports.Collector, collector));
  return [encoded, collector.unsafeRead()];
}), "encodeWithTransferables");
var decodeSyncDebug = /* @__PURE__ */ __name((schema4, options4) => (input, overrideOptions) => {
  const res = Schema_exports.decodeEither(schema4, options4)(input, overrideOptions);
  if (res._tag === "Left") {
    return shouldNeverHappen(`decodeSyncDebug failed:`, res.left);
  } else {
    return res.right;
  }
}, "decodeSyncDebug");
var encodeSyncDebug = /* @__PURE__ */ __name((schema4, options4) => (input, overrideOptions) => {
  const res = Schema_exports.encodeEither(schema4, options4)(input, overrideOptions);
  if (res._tag === "Left") {
    return shouldNeverHappen(`encodeSyncDebug failed:`, res.left);
  } else {
    return res.right;
  }
}, "encodeSyncDebug");
var swap3 = /* @__PURE__ */ __name((schema4) => Schema_exports.transformOrFail(Schema_exports.typeSchema(schema4), Schema_exports.encodedSchema(schema4), {
  decode: ParseResult_exports.encode(schema4),
  encode: ParseResult_exports.decode(schema4)
}), "swap");
var Base64FromUint8Array = swap3(Schema_exports.Uint8ArrayFromBase64);
var JsonValue = Schema_exports.Union(Schema_exports.String, Schema_exports.Number, Schema_exports.Boolean, Schema_exports.Null, Schema_exports.Array(Schema_exports.suspend(() => JsonValue)), Schema_exports.Record({ key: Schema_exports.String, value: Schema_exports.suspend(() => JsonValue) })).annotations({ title: "JsonValue" });

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Stream.js
var Stream_exports2 = {};
__export(Stream_exports2, {
  DefaultChunkSize: () => DefaultChunkSize2,
  Do: () => Do7,
  StreamTypeId: () => StreamTypeId4,
  accumulate: () => accumulate2,
  accumulateChunks: () => accumulateChunks2,
  acquireRelease: () => acquireRelease4,
  aggregate: () => aggregate2,
  aggregateWithin: () => aggregateWithin2,
  aggregateWithinEither: () => aggregateWithinEither2,
  as: () => as13,
  async: () => _async2,
  asyncEffect: () => asyncEffect4,
  asyncPush: () => asyncPush2,
  asyncScoped: () => asyncScoped2,
  bind: () => bind9,
  bindEffect: () => bindEffect2,
  bindTo: () => bindTo9,
  branchAfter: () => branchAfter2,
  broadcast: () => broadcast2,
  broadcastDynamic: () => broadcastDynamic2,
  broadcastedQueues: () => broadcastedQueues2,
  broadcastedQueuesDynamic: () => broadcastedQueuesDynamic2,
  buffer: () => buffer2,
  bufferChunks: () => bufferChunks2,
  catchAll: () => catchAll8,
  catchAllCause: () => catchAllCause7,
  catchSome: () => catchSome5,
  catchSomeCause: () => catchSomeCause4,
  catchTag: () => catchTag5,
  catchTags: () => catchTags5,
  changes: () => changes2,
  changesWith: () => changesWith2,
  changesWithEffect: () => changesWithEffect2,
  chunks: () => chunks2,
  chunksWith: () => chunksWith2,
  combine: () => combine10,
  combineChunks: () => combineChunks2,
  concat: () => concat3,
  concatAll: () => concatAll3,
  concatWithLastElement: () => concatWithLastElement,
  context: () => context9,
  contextWith: () => contextWith5,
  contextWithEffect: () => contextWithEffect4,
  contextWithStream: () => contextWithStream2,
  cross: () => cross2,
  crossLeft: () => crossLeft2,
  crossRight: () => crossRight2,
  crossWith: () => crossWith2,
  debounce: () => debounce2,
  decodeText: () => decodeText2,
  die: () => die12,
  dieMessage: () => dieMessage5,
  dieSync: () => dieSync8,
  distributedWith: () => distributedWith2,
  distributedWithDynamic: () => distributedWithDynamic2,
  drain: () => drain4,
  drainFork: () => drainFork2,
  drop: () => drop4,
  dropRight: () => dropRight4,
  dropUntil: () => dropUntil4,
  dropUntilEffect: () => dropUntilEffect2,
  dropWhile: () => dropWhile6,
  dropWhileEffect: () => dropWhileEffect2,
  either: () => either8,
  emitIfEmpty: () => emitIfEmpty,
  empty: () => empty37,
  encodeText: () => encodeText2,
  ensuring: () => ensuring8,
  ensuringWith: () => ensuringWith3,
  execute: () => execute2,
  fail: () => fail19,
  failCause: () => failCause15,
  failCauseSync: () => failCauseSync8,
  failSync: () => failSync9,
  filter: () => filter16,
  filterEffect: () => filterEffect3,
  filterMap: () => filterMap9,
  filterMapEffect: () => filterMapEffect2,
  filterMapWhile: () => filterMapWhile4,
  filterMapWhileEffect: () => filterMapWhileEffect2,
  finalizer: () => finalizer2,
  find: () => find4,
  findEffect: () => findEffect2,
  flatMap: () => flatMap22,
  flatten: () => flatten16,
  flattenChunks: () => flattenChunks2,
  flattenEffect: () => flattenEffect2,
  flattenExitOption: () => flattenExitOption2,
  flattenIterables: () => flattenIterables2,
  flattenTake: () => flattenTake2,
  forever: () => forever6,
  fromAsyncIterable: () => fromAsyncIterable2,
  fromChannel: () => fromChannel3,
  fromChunk: () => fromChunk2,
  fromChunkPubSub: () => fromChunkPubSub2,
  fromChunkQueue: () => fromChunkQueue2,
  fromChunks: () => fromChunks2,
  fromEffect: () => fromEffect9,
  fromEffectOption: () => fromEffectOption2,
  fromEventListener: () => fromEventListener2,
  fromIterable: () => fromIterable15,
  fromIterableEffect: () => fromIterableEffect2,
  fromIteratorSucceed: () => fromIteratorSucceed2,
  fromPubSub: () => fromPubSub2,
  fromPull: () => fromPull3,
  fromQueue: () => fromQueue3,
  fromReadableStream: () => fromReadableStream2,
  fromReadableStreamByob: () => fromReadableStreamByob2,
  fromSchedule: () => fromSchedule2,
  fromTPubSub: () => fromTPubSub2,
  fromTQueue: () => fromTQueue2,
  groupAdjacentBy: () => groupAdjacentBy2,
  groupBy: () => groupBy3,
  groupByKey: () => groupByKey2,
  grouped: () => grouped2,
  groupedWithin: () => groupedWithin2,
  haltAfter: () => haltAfter2,
  haltWhen: () => haltWhen2,
  haltWhenDeferred: () => haltWhenDeferred2,
  identity: () => identity5,
  interleave: () => interleave2,
  interleaveWith: () => interleaveWith2,
  interruptAfter: () => interruptAfter2,
  interruptWhen: () => interruptWhen3,
  interruptWhenDeferred: () => interruptWhenDeferred3,
  intersperse: () => intersperse3,
  intersperseAffixes: () => intersperseAffixes2,
  iterate: () => iterate5,
  let: () => let_9,
  make: () => make65,
  map: () => map33,
  mapAccum: () => mapAccum6,
  mapAccumEffect: () => mapAccumEffect2,
  mapBoth: () => mapBoth10,
  mapChunks: () => mapChunks2,
  mapChunksEffect: () => mapChunksEffect2,
  mapConcat: () => mapConcat2,
  mapConcatChunk: () => mapConcatChunk2,
  mapConcatChunkEffect: () => mapConcatChunkEffect2,
  mapConcatEffect: () => mapConcatEffect2,
  mapEffect: () => mapEffect7,
  mapError: () => mapError10,
  mapErrorCause: () => mapErrorCause6,
  mapInputContext: () => mapInputContext7,
  merge: () => merge12,
  mergeAll: () => mergeAll10,
  mergeEither: () => mergeEither2,
  mergeLeft: () => mergeLeft2,
  mergeRight: () => mergeRight2,
  mergeWith: () => mergeWith4,
  mergeWithTag: () => mergeWithTag2,
  mkString: () => mkString3,
  never: () => never6,
  onDone: () => onDone2,
  onEnd: () => onEnd2,
  onError: () => onError4,
  onStart: () => onStart2,
  orDie: () => orDie7,
  orDieWith: () => orDieWith6,
  orElse: () => orElse14,
  orElseEither: () => orElseEither7,
  orElseFail: () => orElseFail5,
  orElseIfEmpty: () => orElseIfEmpty2,
  orElseIfEmptyChunk: () => orElseIfEmptyChunk2,
  orElseIfEmptyStream: () => orElseIfEmptyStream2,
  orElseSucceed: () => orElseSucceed5,
  paginate: () => paginate2,
  paginateChunk: () => paginateChunk2,
  paginateChunkEffect: () => paginateChunkEffect2,
  paginateEffect: () => paginateEffect2,
  partition: () => partition9,
  partitionEither: () => partitionEither2,
  peel: () => peel2,
  pipeThrough: () => pipeThrough2,
  pipeThroughChannel: () => pipeThroughChannel2,
  pipeThroughChannelOrFail: () => pipeThroughChannelOrFail2,
  prepend: () => prepend5,
  provideContext: () => provideContext8,
  provideLayer: () => provideLayer2,
  provideService: () => provideService9,
  provideServiceEffect: () => provideServiceEffect4,
  provideServiceStream: () => provideServiceStream2,
  provideSomeContext: () => provideSomeContext4,
  provideSomeLayer: () => provideSomeLayer3,
  race: () => race4,
  raceAll: () => raceAll4,
  range: () => range4,
  rechunk: () => rechunk2,
  refineOrDie: () => refineOrDie3,
  refineOrDieWith: () => refineOrDieWith3,
  repeat: () => repeat4,
  repeatEffect: () => repeatEffect2,
  repeatEffectChunk: () => repeatEffectChunk2,
  repeatEffectChunkOption: () => repeatEffectChunkOption2,
  repeatEffectOption: () => repeatEffectOption2,
  repeatEffectWithSchedule: () => repeatEffectWithSchedule2,
  repeatEither: () => repeatEither2,
  repeatElements: () => repeatElements2,
  repeatElementsWith: () => repeatElementsWith2,
  repeatValue: () => repeatValue2,
  repeatWith: () => repeatWith2,
  retry: () => retry7,
  run: () => run5,
  runCollect: () => runCollect2,
  runCollectReadonlyArray: () => runCollectReadonlyArray,
  runCount: () => runCount2,
  runDrain: () => runDrain3,
  runFirst: () => runFirst,
  runFirstUnsafe: () => runFirstUnsafe,
  runFold: () => runFold2,
  runFoldEffect: () => runFoldEffect2,
  runFoldScoped: () => runFoldScoped2,
  runFoldScopedEffect: () => runFoldScopedEffect2,
  runFoldWhile: () => runFoldWhile2,
  runFoldWhileEffect: () => runFoldWhileEffect2,
  runFoldWhileScoped: () => runFoldWhileScoped2,
  runFoldWhileScopedEffect: () => runFoldWhileScopedEffect2,
  runForEach: () => runForEach2,
  runForEachChunk: () => runForEachChunk2,
  runForEachChunkScoped: () => runForEachChunkScoped2,
  runForEachScoped: () => runForEachScoped2,
  runForEachWhile: () => runForEachWhile2,
  runForEachWhileScoped: () => runForEachWhileScoped2,
  runHead: () => runHead2,
  runIntoPubSub: () => runIntoPubSub2,
  runIntoPubSubScoped: () => runIntoPubSubScoped2,
  runIntoQueue: () => runIntoQueue2,
  runIntoQueueElementsScoped: () => runIntoQueueElementsScoped2,
  runIntoQueueScoped: () => runIntoQueueScoped2,
  runLast: () => runLast2,
  runScoped: () => runScoped3,
  runSum: () => runSum2,
  scan: () => scan3,
  scanEffect: () => scanEffect2,
  scanReduce: () => scanReduce2,
  scanReduceEffect: () => scanReduceEffect2,
  schedule: () => schedule3,
  scheduleWith: () => scheduleWith2,
  scoped: () => scoped7,
  scopedWith: () => scopedWith5,
  share: () => share2,
  skipRepeated: () => skipRepeated,
  skipRepeated_: () => skipRepeated_,
  sliding: () => sliding9,
  slidingSize: () => slidingSize2,
  some: () => some12,
  someOrElse: () => someOrElse2,
  someOrFail: () => someOrFail2,
  split: () => split5,
  splitLines: () => splitLines3,
  splitOnChunk: () => splitOnChunk2,
  succeed: () => succeed20,
  suspend: () => suspend13,
  sync: () => sync14,
  take: () => take9,
  takeRight: () => takeRight4,
  takeUntil: () => takeUntil4,
  takeUntilEffect: () => takeUntilEffect2,
  takeWhile: () => takeWhile6,
  tap: () => tap8,
  tapBoth: () => tapBoth5,
  tapChunk: () => tapChunk,
  tapError: () => tapError7,
  tapErrorCause: () => tapErrorCause6,
  tapLog: () => tapLog,
  tapLogWithLabel: () => tapLogWithLabel,
  tapSink: () => tapSink2,
  tapSync: () => tapSync,
  throttle: () => throttle2,
  throttleEffect: () => throttleEffect2,
  tick: () => tick2,
  timeout: () => timeout4,
  timeoutFail: () => timeoutFail4,
  timeoutFailCause: () => timeoutFailCause4,
  timeoutTo: () => timeoutTo4,
  toAsyncIterable: () => toAsyncIterable2,
  toAsyncIterableEffect: () => toAsyncIterableEffect2,
  toAsyncIterableRuntime: () => toAsyncIterableRuntime2,
  toChannel: () => toChannel3,
  toPubSub: () => toPubSub3,
  toPull: () => toPull3,
  toQueue: () => toQueue3,
  toQueueOfElements: () => toQueueOfElements2,
  toReadableStream: () => toReadableStream2,
  toReadableStreamEffect: () => toReadableStreamEffect2,
  toReadableStreamRuntime: () => toReadableStreamRuntime2,
  transduce: () => transduce2,
  unfold: () => unfold5,
  unfoldChunk: () => unfoldChunk2,
  unfoldChunkEffect: () => unfoldChunkEffect2,
  unfoldEffect: () => unfoldEffect2,
  unwrap: () => unwrap5,
  unwrapScoped: () => unwrapScoped5,
  unwrapScopedWith: () => unwrapScopedWith4,
  updateService: () => updateService5,
  void: () => void_11,
  when: () => when5,
  whenCase: () => whenCase2,
  whenCaseEffect: () => whenCaseEffect2,
  whenEffect: () => whenEffect4,
  withExecutionPlan: () => withExecutionPlan4,
  withSpan: () => withSpan7,
  zip: () => zip13,
  zipAll: () => zipAll2,
  zipAllLeft: () => zipAllLeft2,
  zipAllRight: () => zipAllRight2,
  zipAllSortedByKey: () => zipAllSortedByKey2,
  zipAllSortedByKeyLeft: () => zipAllSortedByKeyLeft2,
  zipAllSortedByKeyRight: () => zipAllSortedByKeyRight2,
  zipAllSortedByKeyWith: () => zipAllSortedByKeyWith2,
  zipAllWith: () => zipAllWith2,
  zipFlatten: () => zipFlatten2,
  zipLatest: () => zipLatest2,
  zipLatestAll: () => zipLatestAll2,
  zipLatestWith: () => zipLatestWith2,
  zipLeft: () => zipLeft12,
  zipRight: () => zipRight13,
  zipWith: () => zipWith17,
  zipWithChunks: () => zipWithChunks2,
  zipWithIndex: () => zipWithIndex2,
  zipWithNext: () => zipWithNext2,
  zipWithPrevious: () => zipWithPrevious2,
  zipWithPreviousAndNext: () => zipWithPreviousAndNext2
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var tapLog = /* @__PURE__ */ __name((stream6) => tapChunk(Effect_exports.forEach((_) => Effect_exports.succeed(console.log(_))))(stream6), "tapLog");
var tapSync = /* @__PURE__ */ __name((tapFn) => (stream6) => Stream_exports.tap(stream6, (a) => Effect_exports.sync(() => tapFn(a))), "tapSync");
var tapLogWithLabel = /* @__PURE__ */ __name((label) => (stream6) => tapChunk(Effect_exports.forEach((_) => Effect_exports.succeed(console.log(label, _))))(stream6), "tapLogWithLabel");
var tapChunk = /* @__PURE__ */ __name((f) => (self2) => Stream_exports.mapChunksEffect(self2, (chunks3) => pipe(f(chunks3), Effect_exports.map(() => chunks3))), "tapChunk");
var isIdentity = /* @__PURE__ */ __name((a1, a2) => a1 === a2, "isIdentity");
var skipRepeated = /* @__PURE__ */ __name((isEqual3 = isIdentity) => (stream6) => skipRepeated_(stream6, isEqual3), "skipRepeated");
var skipRepeated_ = /* @__PURE__ */ __name((stream6, isEqual3 = isIdentity) => pipe(Ref_exports.make(Option_exports.none()), Stream_exports.fromEffect, Stream_exports.flatMap((ref2) => pipe(stream6, Stream_exports.filterEffect((el) => pipe(Ref_exports.get(ref2), Effect_exports.flatMap((prevEl) => {
  if (prevEl._tag === "None" || isEqual3(prevEl.value, el) === false) {
    return pipe(Ref_exports.set(ref2, Option_exports.some(el)), Effect_exports.map(() => true));
  } else {
    return Effect_exports.succeed(false);
  }
})))))), "skipRepeated_");
var runFirst = /* @__PURE__ */ __name((stream6) => stream6.pipe(Stream_exports.take(1), Stream_exports.runCollect, Effect_exports.map(Chunk_exports.head)), "runFirst");
var runFirstUnsafe = /* @__PURE__ */ __name((stream6) => runFirst(stream6).pipe(Effect_exports.flatten), "runFirstUnsafe");
var runCollectReadonlyArray = /* @__PURE__ */ __name((stream6) => stream6.pipe(Stream_exports.runCollect, Effect_exports.map(Chunk_exports.toReadonlyArray)), "runCollectReadonlyArray");
var concatWithLastElement = dual(2, (stream1, getStream2) => pipe(Ref_exports.make(Option_exports.none()), Stream_exports.fromEffect, Stream_exports.flatMap((lastRef) => pipe(stream1, Stream_exports.tap((value6) => Ref_exports.set(lastRef, Option_exports.some(value6))), Stream_exports.concat(pipe(Ref_exports.get(lastRef), Effect_exports.map(getStream2), Stream_exports.unwrap))))));
var emitIfEmpty = dual(2, (stream6, fallbackValue) => concatWithLastElement(stream6, (lastElement) => lastElement._tag === "None" ? Stream_exports.make(fallbackValue) : Stream_exports.empty));

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Subscribable.js
var Subscribable_exports2 = {};
__export(Subscribable_exports2, {
  TypeId: () => TypeId53,
  fromSubscriptionRef: () => fromSubscriptionRef,
  isSubscribable: () => isSubscribable,
  make: () => make103,
  map: () => map37,
  mapEffect: () => mapEffect9,
  never: () => never9,
  unwrap: () => unwrap8
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TypeId53 = Symbol.for("effect/Subscribable");
var isSubscribable = /* @__PURE__ */ __name((u) => hasProperty(u, TypeId53), "isSubscribable");
var SubscribableImpl = class extends Effectable_exports.Class {
  static {
    __name(this, "SubscribableImpl");
  }
  // @ts-expect-error type symbol
  [TypeId53] = TypeId53;
  // @ts-expect-error type symbol
  [Readable_exports.TypeId] = Readable_exports.TypeId;
  get;
  changes;
  constructor(get29, changes3) {
    super();
    this.get = get29;
    this.changes = changes3;
  }
  commit() {
    return this.get;
  }
};
var make103 = /* @__PURE__ */ __name((options4) => new SubscribableImpl(options4.get, options4.changes), "make");
var fromSubscriptionRef = /* @__PURE__ */ __name((ref2) => make103({
  get: ref2.get,
  changes: ref2.changes
}), "fromSubscriptionRef");
var map37 = dual(2, (self2, f) => make103({
  get: Effect_exports.map(self2.get, f),
  changes: Stream_exports.map(self2.changes, f)
}));
var mapEffect9 = dual(2, (self2, f) => make103({
  get: Effect_exports.flatMap(self2.get, f),
  changes: Stream_exports.mapEffect(self2.changes, f)
}));
var unwrap8 = /* @__PURE__ */ __name((effect4) => make103({
  get: Effect_exports.flatMap(effect4, (s) => s.get),
  changes: Stream_exports.unwrap(Effect_exports.map(effect4, (s) => s.changes))
}), "unwrap");
var never9 = make103({
  get: Effect_exports.never,
  changes: Stream_exports.never
});

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/TaskTracing.js
var TaskTracing_exports = {};
__export(TaskTracing_exports, {
  withAsyncTaggingTracing: () => withAsyncTaggingTracing
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var withAsyncTaggingTracing = /* @__PURE__ */ __name((makeTrace) => (eff) => {
  if (Predicate_exports.hasProperty(console, "createTask") === false) {
    return eff;
  }
  const makeTracer = gen4(function* () {
    const oldTracer = yield* tracer2;
    return make29({
      span: /* @__PURE__ */ __name((name, ...args2) => {
        const span4 = oldTracer.span(name, ...args2);
        const trace9 = makeTrace(name);
        span4.runInTask = (f) => trace9.run(f);
        return span4;
      }, "span"),
      context: /* @__PURE__ */ __name((f, fiber) => {
        const maybeParentSpan = getOption2(ParentSpan)(fiber.currentContext);
        if (maybeParentSpan._tag === "None")
          return oldTracer.context(f, fiber);
        const parentSpan3 = maybeParentSpan.value;
        if (parentSpan3._tag === "ExternalSpan")
          return oldTracer.context(f, fiber);
        const span4 = parentSpan3;
        if ("runInTask" in span4 && typeof span4.runInTask === "function") {
          return span4.runInTask(() => oldTracer.context(f, fiber));
        }
        return oldTracer.context(f, fiber);
      }, "context")
    });
  });
  const withTracerLayer = pipe(makeTracer, map22(setTracer2), unwrapEffect2);
  return provide2(eff, withTracerLayer);
}, "withAsyncTaggingTracing");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/WebChannel/mod.js
var mod_exports = {};
__export(mod_exports, {
  DebugPingMessage: () => DebugPingMessage,
  WebChannelHeartbeat: () => WebChannelHeartbeat,
  WebChannelPing: () => WebChannelPing,
  WebChannelPong: () => WebChannelPong,
  WebChannelSymbol: () => WebChannelSymbol,
  broadcastChannel: () => broadcastChannel,
  broadcastChannelWithAck: () => broadcastChannelWithAck,
  isWebChannel: () => isWebChannel,
  listenToDebugPing: () => listenToDebugPing,
  mapSchema: () => mapSchema,
  messagePortChannel: () => messagePortChannel,
  messagePortChannelWithAck: () => messagePortChannelWithAck,
  noopChannel: () => noopChannel,
  queueChannelProxy: () => queueChannelProxy,
  sameThreadChannel: () => sameThreadChannel,
  schemaWithWebChannelMessages: () => schemaWithWebChannelMessages,
  sendDebugPing: () => sendDebugPing,
  shutdown: () => shutdown8,
  toOpenChannel: () => toOpenChannel,
  windowChannel: () => windowChannel
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/WebChannel/broadcastChannelWithAck.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Effect.js
var Effect_exports2 = {};
__export(Effect_exports2, {
  Do: () => Do5,
  EffectTypeId: () => EffectTypeId4,
  Service: () => Service,
  Tag: () => Tag3,
  acquireRelease: () => acquireRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireReleaseLog: () => acquireReleaseLog,
  acquireUseRelease: () => acquireUseRelease2,
  addFinalizer: () => addFinalizer3,
  addFinalizerLog: () => addFinalizerLog,
  all: () => all8,
  allSuccesses: () => allSuccesses2,
  allWith: () => allWith2,
  allowInterrupt: () => allowInterrupt2,
  andThen: () => andThen8,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  annotateLogs: () => annotateLogs3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateSpans: () => annotateSpans3,
  ap: () => ap3,
  as: () => as8,
  asSome: () => asSome2,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid5,
  async: () => async2,
  asyncEffect: () => asyncEffect2,
  awaitAllChildren: () => awaitAllChildren2,
  bind: () => bind6,
  bindAll: () => bindAll2,
  bindTo: () => bindTo6,
  blocked: () => blocked2,
  cacheRequestResult: () => cacheRequestResult,
  cached: () => cached3,
  cachedFunction: () => cachedFunction2,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedWithTTL: () => cachedWithTTL,
  catch: () => _catch2,
  catchAll: () => catchAll3,
  catchAllCause: () => catchAllCause3,
  catchAllDefect: () => catchAllDefect2,
  catchIf: () => catchIf2,
  catchSome: () => catchSome2,
  catchSomeCause: () => catchSomeCause2,
  catchSomeDefect: () => catchSomeDefect2,
  catchTag: () => catchTag2,
  catchTags: () => catchTags2,
  cause: () => cause2,
  checkInterruptible: () => checkInterruptible2,
  clock: () => clock2,
  clockWith: () => clockWith4,
  configProviderWith: () => configProviderWith2,
  console: () => console3,
  consoleWith: () => consoleWith2,
  context: () => context4,
  contextWith: () => contextWith2,
  contextWithEffect: () => contextWithEffect2,
  currentParentSpan: () => currentParentSpan2,
  currentSpan: () => currentSpan2,
  custom: () => custom2,
  daemonChildren: () => daemonChildren2,
  debugLogEnv: () => debugLogEnv,
  delay: () => delay2,
  descriptor: () => descriptor2,
  descriptorWith: () => descriptorWith2,
  die: () => die7,
  dieMessage: () => dieMessage2,
  dieSync: () => dieSync4,
  diffFiberRefs: () => diffFiberRefs2,
  disconnect: () => disconnect3,
  dropUntil: () => dropUntil2,
  dropWhile: () => dropWhile4,
  either: () => either4,
  ensureErrorType: () => ensureErrorType,
  ensureRequirementsType: () => ensureRequirementsType,
  ensureSuccessType: () => ensureSuccessType,
  ensuring: () => ensuring3,
  ensuringChild: () => ensuringChild2,
  ensuringChildren: () => ensuringChildren2,
  eventListener: () => eventListener,
  eventually: () => eventually2,
  every: () => every10,
  exists: () => exists4,
  exit: () => exit4,
  fail: () => fail10,
  failCause: () => failCause9,
  failCauseSync: () => failCauseSync4,
  failSync: () => failSync4,
  fiberId: () => fiberId2,
  fiberIdWith: () => fiberIdWith2,
  filter: () => filter12,
  filterEffectOrElse: () => filterEffectOrElse2,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterMap: () => filterMap7,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail2,
  finalizersMask: () => finalizersMask2,
  findFirst: () => findFirst8,
  firstSuccessOf: () => firstSuccessOf2,
  flatMap: () => flatMap15,
  flatten: () => flatten10,
  flip: () => flip3,
  flipWith: () => flipWith2,
  fn: () => fn,
  fnUntraced: () => fnUntraced2,
  forEach: () => forEach11,
  forever: () => forever3,
  fork: () => fork3,
  forkAll: () => forkAll2,
  forkDaemon: () => forkDaemon2,
  forkIn: () => forkIn2,
  forkScoped: () => forkScoped2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  fromFiber: () => fromFiber2,
  fromFiberEffect: () => fromFiberEffect2,
  fromNullable: () => fromNullable5,
  functionWithSpan: () => functionWithSpan2,
  gen: () => gen4,
  getFiberRefs: () => getFiberRefs,
  getRuntimeFlags: () => getRuntimeFlags,
  head: () => head5,
  if: () => if_2,
  ignore: () => ignore2,
  ignoreLogged: () => ignoreLogged2,
  inheritFiberRefs: () => inheritFiberRefs2,
  interrupt: () => interrupt7,
  interruptWith: () => interruptWith3,
  interruptible: () => interruptible4,
  interruptibleMask: () => interruptibleMask2,
  intoDeferred: () => intoDeferred2,
  isEffect: () => isEffect2,
  isFailure: () => isFailure5,
  isSuccess: () => isSuccess3,
  iterate: () => iterate2,
  labelMetrics: () => labelMetrics2,
  labelMetricsScoped: () => labelMetricsScoped2,
  let: () => let_6,
  liftPredicate: () => liftPredicate5,
  linkSpanCurrent: () => linkSpanCurrent2,
  linkSpans: () => linkSpans2,
  locally: () => locally2,
  locallyScoped: () => locallyScoped,
  locallyScopedWith: () => locallyScopedWith,
  locallyWith: () => locallyWith,
  log: () => log5,
  logAnnotations: () => logAnnotations2,
  logBefore: () => logBefore,
  logDebug: () => logDebug2,
  logDuration: () => logDuration,
  logError: () => logError2,
  logFatal: () => logFatal2,
  logInfo: () => logInfo2,
  logTrace: () => logTrace2,
  logWarnIfTakesLongerThan: () => logWarnIfTakesLongerThan,
  logWarning: () => logWarning2,
  logWithLevel: () => logWithLevel2,
  loop: () => loop2,
  makeLatch: () => makeLatch2,
  makeSemaphore: () => makeSemaphore2,
  makeSpan: () => makeSpan2,
  makeSpanScoped: () => makeSpanScoped2,
  map: () => map22,
  mapAccum: () => mapAccum4,
  mapBoth: () => mapBoth5,
  mapError: () => mapError4,
  mapErrorCause: () => mapErrorCause3,
  mapInputContext: () => mapInputContext3,
  match: () => match15,
  matchCause: () => matchCause4,
  matchCauseEffect: () => matchCauseEffect3,
  matchEffect: () => matchEffect3,
  merge: () => merge7,
  mergeAll: () => mergeAll5,
  metricLabels: () => metricLabels2,
  negate: () => negate2,
  never: () => never4,
  none: () => none9,
  onError: () => onError2,
  onExit: () => onExit3,
  onInterrupt: () => onInterrupt2,
  once: () => once4,
  option: () => option2,
  optionFromOptional: () => optionFromOptional2,
  orDie: () => orDie3,
  orDieWith: () => orDieWith2,
  orElse: () => orElse7,
  orElseFail: () => orElseFail2,
  orElseSucceed: () => orElseSucceed2,
  parallelErrors: () => parallelErrors2,
  parallelFinalizers: () => parallelFinalizers2,
  partition: () => partition6,
  patchFiberRefs: () => patchFiberRefs2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  promise: () => promise2,
  provide: () => provide2,
  provideService: () => provideService4,
  provideServiceEffect: () => provideServiceEffect2,
  race: () => race2,
  raceAll: () => raceAll2,
  raceFirst: () => raceFirst2,
  raceWith: () => raceWith2,
  random: () => random3,
  randomWith: () => randomWith2,
  reduce: () => reduce13,
  reduceEffect: () => reduceEffect3,
  reduceRight: () => reduceRight4,
  reduceWhile: () => reduceWhile2,
  repeat: () => repeat,
  repeatN: () => repeatN2,
  repeatOrElse: () => repeatOrElse,
  replicate: () => replicate3,
  replicateEffect: () => replicateEffect2,
  request: () => request,
  retry: () => retry2,
  retryOrElse: () => retryOrElse,
  runCallback: () => runCallback,
  runFork: () => runFork2,
  runPromise: () => runPromise,
  runPromiseExit: () => runPromiseExit,
  runRequestBlock: () => runRequestBlock2,
  runSync: () => runSync,
  runSyncExit: () => runSyncExit,
  runtime: () => runtime4,
  sandbox: () => sandbox2,
  schedule: () => schedule,
  scheduleForked: () => scheduleForked2,
  scheduleFrom: () => scheduleFrom,
  scope: () => scope3,
  scopeWith: () => scopeWith2,
  scopeWithCloseable: () => scopeWithCloseable,
  scoped: () => scoped3,
  scopedWith: () => scopedWith2,
  sequentialFinalizers: () => sequentialFinalizers2,
  serviceConstants: () => serviceConstants2,
  serviceFunction: () => serviceFunction2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunctions: () => serviceFunctions2,
  serviceMembers: () => serviceMembers2,
  serviceOption: () => serviceOption2,
  serviceOptional: () => serviceOptional2,
  setFiberRefs: () => setFiberRefs2,
  sleep: () => sleep4,
  spanAnnotations: () => spanAnnotations2,
  spanEvent: () => spanEvent,
  spanLinks: () => spanLinks2,
  step: () => step3,
  succeed: () => succeed11,
  succeedNone: () => succeedNone2,
  succeedSome: () => succeedSome2,
  summarized: () => summarized2,
  supervised: () => supervised2,
  suspend: () => suspend4,
  sync: () => sync7,
  tagMetrics: () => tagMetrics2,
  tagMetricsScoped: () => tagMetricsScoped2,
  takeUntil: () => takeUntil2,
  takeWhile: () => takeWhile4,
  tap: () => tap4,
  tapBoth: () => tapBoth2,
  tapCauseLogPretty: () => tapCauseLogPretty,
  tapDefect: () => tapDefect2,
  tapError: () => tapError3,
  tapErrorCause: () => tapErrorCause3,
  tapErrorTag: () => tapErrorTag2,
  tapSync: () => tapSync2,
  timed: () => timed2,
  timedWith: () => timedWith2,
  timeout: () => timeout2,
  timeoutDie: () => timeoutDie,
  timeoutDieMsg: () => timeoutDieMsg,
  timeoutFail: () => timeoutFail2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutOption: () => timeoutOption2,
  timeoutTo: () => timeoutTo2,
  toForkedDeferred: () => toForkedDeferred,
  tracer: () => tracer2,
  tracerWith: () => tracerWith4,
  transplant: () => transplant2,
  transposeMapOption: () => transposeMapOption2,
  transposeOption: () => transposeOption2,
  try: () => try_3,
  tryAll: () => tryAll,
  tryMap: () => tryMap2,
  tryMapPromise: () => tryMapPromise2,
  tryPromise: () => tryPromise2,
  uninterruptible: () => uninterruptible2,
  uninterruptibleMask: () => uninterruptibleMask3,
  unless: () => unless2,
  unlessEffect: () => unlessEffect2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsandbox: () => unsandbox2,
  updateFiberRefs: () => updateFiberRefs3,
  updateService: () => updateService2,
  useSpan: () => useSpan2,
  using: () => using2,
  validate: () => validate2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  validateWith: () => validateWith2,
  void: () => _void,
  when: () => when2,
  whenEffect: () => whenEffect2,
  whenFiberRef: () => whenFiberRef2,
  whenLogLevel: () => whenLogLevel2,
  whenRef: () => whenRef2,
  whileLoop: () => whileLoop3,
  withClock: () => withClock2,
  withClockScoped: () => withClockScoped2,
  withConcurrency: () => withConcurrency2,
  withConfigProvider: () => withConfigProvider2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConsole: () => withConsole2,
  withConsoleScoped: () => withConsoleScoped2,
  withEarlyRelease: () => withEarlyRelease2,
  withExecutionPlan: () => withExecutionPlan2,
  withFiberRuntime: () => withFiberRuntime2,
  withLogSpan: () => withLogSpan2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withMetric: () => withMetric2,
  withParentSpan: () => withParentSpan3,
  withPerformanceMeasure: () => withPerformanceMeasure,
  withRandom: () => withRandom2,
  withRandomFixed: () => withRandomFixed,
  withRandomScoped: () => withRandomScoped2,
  withRequestBatching: () => withRequestBatching2,
  withRequestCache: () => withRequestCache2,
  withRequestCaching: () => withRequestCaching2,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withScheduler: () => withScheduler2,
  withSchedulingPriority: () => withSchedulingPriority2,
  withSpan: () => withSpan3,
  withSpanScoped: () => withSpanScoped2,
  withTracer: () => withTracer2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracerScoped: () => withTracerScoped2,
  withTracerTiming: () => withTracerTiming2,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  yieldNow: () => yieldNow4,
  zip: () => zip8,
  zipLeft: () => zipLeft7,
  zipRight: () => zipRight7,
  zipWith: () => zipWith10
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Error.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UnknownError = class extends Schema_exports.TaggedError()("UnknownError", {
  cause: Schema_exports.Any,
  payload: Schema_exports.optional(Schema_exports.Any)
}) {
  static {
    __name(this, "UnknownError");
  }
};

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Effect.js
var scopeWithCloseable = /* @__PURE__ */ __name((fn2) => Effect_exports.gen(function* () {
  const scope5 = yield* Scope_exports.make();
  yield* Effect_exports.addFinalizer((exit5) => Scope_exports.close(scope5, exit5));
  return yield* fn2(scope5).pipe(Scope_exports.extend(scope5));
}), "scopeWithCloseable");
var tryAll = /* @__PURE__ */ __name((fn2) => Effect_exports.try(() => fn2()).pipe(Effect_exports.andThen((fnRes) => Effect_exports.isEffect(fnRes) ? fnRes : isPromise2(fnRes) ? Effect_exports.promise(() => fnRes) : Effect_exports.succeed(fnRes))), "tryAll");
var acquireReleaseLog = /* @__PURE__ */ __name((label) => Effect_exports.acquireRelease(Effect_exports.log(`${label} acquire`), (_, ex) => Effect_exports.log(`${label} release`, ex)), "acquireReleaseLog");
var addFinalizerLog = /* @__PURE__ */ __name((...msgs) => Effect_exports.addFinalizer((exit5) => Effect_exports.log(...msgs, exit5._tag === "Success" ? "with success" : `with failure: ${Cause_exports.pretty(exit5.cause)}`)), "addFinalizerLog");
var logBefore = /* @__PURE__ */ __name((...msgs) => (eff) => Effect_exports.andThen(Effect_exports.log(...msgs), eff), "logBefore");
var tapCauseLogPretty = /* @__PURE__ */ __name((eff) => Effect_exports.tapErrorCause(eff, (cause3) => Effect_exports.gen(function* () {
  if (Cause_exports.isInterruptedOnly(cause3)) {
    return;
  }
  const span4 = yield* currentOtelSpan2.pipe(Effect_exports.catchTag("NoSuchElementException", (_) => Effect_exports.succeed(void 0)));
  const firstErrLine = cause3.toString().split("\n")[0];
  yield* Effect_exports.logError(firstErrLine, cause3).pipe((_) => span4 === void 0 ? _ : Effect_exports.annotateLogs({ spanId: span4.spanContext().spanId, traceId: span4.spanContext().traceId })(_));
})), "tapCauseLogPretty");
var eventListener = /* @__PURE__ */ __name((target3, type3, handler, options4) => Effect_exports.gen(function* () {
  const runtime8 = yield* Effect_exports.runtime();
  const handlerFn = /* @__PURE__ */ __name((event) => handler(event).pipe(Effect_exports.provide(runtime8), Effect_exports.runFork), "handlerFn");
  target3.addEventListener(type3, handlerFn, { once: options4?.once ?? false });
  yield* Effect_exports.addFinalizer(() => Effect_exports.sync(() => target3.removeEventListener(type3, handlerFn)));
}), "eventListener");
var spanEvent = /* @__PURE__ */ __name((message, attributes) => Effect_exports.locallyWith(Effect_exports.log(message).pipe(Effect_exports.annotateLogs(attributes ?? {})), FiberRef_exports.currentLoggers, () => HashSet_exports.make(Logger_exports.tracerLogger)), "spanEvent");
var logWarnIfTakesLongerThan = /* @__PURE__ */ __name(({ label, duration: duration4 }) => (eff) => Effect_exports.gen(function* () {
  const runtime8 = yield* Effect_exports.runtime();
  let tookLongerThanTimer = false;
  const timeoutFiber = Effect_exports.sleep(duration4).pipe(Effect_exports.tap(() => {
    tookLongerThanTimer = true;
    return Effect_exports.logWarning(`${label}: Took longer than ${duration4}ms`);
  }), Effect_exports.provide(runtime8), Effect_exports.runFork);
  const start3 = Date.now();
  const res = yield* eff.pipe(Effect_exports.exit, Effect_exports.onInterrupt(Effect_exports.fn(function* () {
    const end6 = Date.now();
    yield* Fiber_exports.interrupt(timeoutFiber);
    if (tookLongerThanTimer) {
      yield* Effect_exports.logWarning(`${label}: Interrupted after ${end6 - start3}ms`);
    }
  })));
  if (tookLongerThanTimer) {
    const end6 = Date.now();
    yield* Effect_exports.logWarning(`${label}: Actual duration: ${end6 - start3}ms`);
  }
  yield* Fiber_exports.interrupt(timeoutFiber);
  return yield* res;
}), "logWarnIfTakesLongerThan");
var logDuration = /* @__PURE__ */ __name((label) => (eff) => Effect_exports.gen(function* () {
  const start3 = Date.now();
  const res = yield* eff;
  const end6 = Date.now();
  yield* Effect_exports.log(`${label}: ${end6 - start3}ms`);
  return res;
}), "logDuration");
var tapSync2 = /* @__PURE__ */ __name((tapFn) => (eff) => Effect_exports.tap(eff, (a) => Effect_exports.sync(() => tapFn(a))), "tapSync");
var debugLogEnv = /* @__PURE__ */ __name((msg) => pipe(Effect_exports.context(), Effect_exports.tap((env3) => log6(msg ?? "debugLogEnv", env3))), "debugLogEnv");
var timeoutDie = /* @__PURE__ */ __name((options4) => (self2) => Effect_exports.orDie(Effect_exports.timeoutFail(options4)(self2)), "timeoutDie");
var timeoutDieMsg = /* @__PURE__ */ __name((options4) => (self2) => Effect_exports.orDie(Effect_exports.timeoutFail({ onTimeout: /* @__PURE__ */ __name(() => new UnknownError({ cause: options4.error }), "onTimeout"), duration: options4.duration })(self2)), "timeoutDieMsg");
var toForkedDeferred = /* @__PURE__ */ __name((eff) => pipe(Deferred_exports.make(), Effect_exports.tap((deferred) => pipe(Effect_exports.exit(eff), Effect_exports.flatMap((ex) => Deferred_exports.done(deferred, ex)), tapCauseLogPretty, Effect_exports.forkScoped))), "toForkedDeferred");
var withPerformanceMeasure = /* @__PURE__ */ __name((meaureLabel) => (eff) => Effect_exports.acquireUseRelease(Effect_exports.sync(() => globalThis.performance.mark(`${meaureLabel}:start`)), () => eff, () => Effect_exports.sync(() => {
  globalThis.performance.mark(`${meaureLabel}:end`);
  globalThis.performance.measure(meaureLabel, `${meaureLabel}:start`, `${meaureLabel}:end`);
})), "withPerformanceMeasure");
var getSpanTrace = /* @__PURE__ */ __name(() => {
  const fiberOption = Fiber_exports.getCurrentFiber();
  if (fiberOption._tag === "None" || fiberOption.value.currentSpan === void 0) {
    return "No current fiber";
  }
  return "";
}, "getSpanTrace");
var logSpanTrace = /* @__PURE__ */ __name(() => console.log(getSpanTrace()), "logSpanTrace");
globalThis.getSpanTrace = getSpanTrace;
globalThis.logSpanTrace = logSpanTrace;

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/WebChannel/common.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var WebChannelSymbol = Symbol("WebChannel");
var isWebChannel = /* @__PURE__ */ __name((value6) => typeof value6 === "object" && value6 !== null && Predicate_exports.hasProperty(value6, WebChannelSymbol), "isWebChannel");
var DebugPingMessage = Schema_exports.TaggedStruct("WebChannel.DebugPing", {
  message: Schema_exports.String,
  payload: Schema_exports.optional(Schema_exports.String)
});
var WebChannelPing = Schema_exports.TaggedStruct("WebChannel.Ping", {
  requestId: Schema_exports.String
});
var WebChannelPong = Schema_exports.TaggedStruct("WebChannel.Pong", {
  requestId: Schema_exports.String
});
var WebChannelHeartbeat = Schema_exports.Union(WebChannelPing, WebChannelPong);
var schemaWithWebChannelMessages = /* @__PURE__ */ __name((schema4) => ({
  send: Schema_exports.Union(schema4.send, DebugPingMessage, WebChannelPing, WebChannelPong),
  listen: Schema_exports.Union(schema4.listen, DebugPingMessage, WebChannelPing, WebChannelPong)
}), "schemaWithWebChannelMessages");
var mapSchema = /* @__PURE__ */ __name((schema4) => Predicate_exports.hasProperty(schema4, "send") && Predicate_exports.hasProperty(schema4, "listen") ? schemaWithWebChannelMessages(schema4) : schemaWithWebChannelMessages({ send: schema4, listen: schema4 }), "mapSchema");
var listenToDebugPing = /* @__PURE__ */ __name((channelName) => (stream6) => stream6.pipe(Stream_exports.filterEffect(Effect_exports.fn(function* (msg) {
  if (msg._tag === "Right" && Schema_exports.is(DebugPingMessage)(msg.right)) {
    yield* Effect_exports.logDebug(`WebChannel:ping [${channelName}] ${msg.right.message}`, msg.right.payload);
    return false;
  }
  return true;
}))), "listenToDebugPing");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/WebChannel/broadcastChannelWithAck.js
var ConnectMessage = Schema_exports.TaggedStruct("ConnectMessage", {
  from: Schema_exports.String
});
var ConnectAckMessage = Schema_exports.TaggedStruct("ConnectAckMessage", {
  from: Schema_exports.String,
  to: Schema_exports.String
});
var DisconnectMessage = Schema_exports.TaggedStruct("DisconnectMessage", {
  from: Schema_exports.String
});
var PayloadMessage = Schema_exports.TaggedStruct("PayloadMessage", {
  from: Schema_exports.String,
  to: Schema_exports.String,
  payload: Schema_exports.Any
});
var Message = Schema_exports.Union(ConnectMessage, ConnectAckMessage, DisconnectMessage, PayloadMessage);
var broadcastChannelWithAck = /* @__PURE__ */ __name(({ channelName, schema: inputSchema }) => scopeWithCloseable((scope5) => gen4(function* () {
  const channel2 = new BroadcastChannel(channelName);
  const messageQueue = yield* Queue_exports.unbounded();
  const connectionId = crypto.randomUUID();
  const schema4 = mapSchema(inputSchema);
  const peerIdRef = { current: void 0 };
  const connectedLatch = yield* makeLatch2(false);
  const supportsTransferables = false;
  const postMessage = /* @__PURE__ */ __name((msg) => channel2.postMessage(Schema_exports.encodeSync(Message)(msg)), "postMessage");
  const send2 = /* @__PURE__ */ __name((message) => gen4(function* () {
    yield* connectedLatch.await;
    const payload = yield* Schema_exports.encode(schema4.send)(message);
    postMessage(PayloadMessage.make({ from: connectionId, to: peerIdRef.current, payload }));
  }), "send");
  const listen = Stream_exports.fromEventListener(channel2, "message").pipe(Stream_exports.map(({ data }) => data), Stream_exports.map(Schema_exports.decodeOption(Message)), Stream_exports.filterMap((_) => _), Stream_exports.mapEffect((data) => gen4(function* () {
    switch (data._tag) {
      // Case: other side sends connect message (because otherside wasn't yet online when this side send their connect message)
      case "ConnectMessage": {
        peerIdRef.current = data.from;
        postMessage(ConnectAckMessage.make({ from: connectionId, to: data.from }));
        yield* connectedLatch.open;
        break;
      }
      // Case: other side sends connect-ack message (because otherside was already online when this side connected)
      case "ConnectAckMessage": {
        if (data.to === connectionId) {
          peerIdRef.current = data.from;
          yield* connectedLatch.open;
        }
        break;
      }
      case "DisconnectMessage": {
        if (data.from === peerIdRef.current) {
          peerIdRef.current = void 0;
          yield* connectedLatch.close;
          yield* establishConnection;
        }
        break;
      }
      case "PayloadMessage": {
        if (data.to === connectionId) {
          return Schema_exports.decodeEither(schema4.listen)(data.payload);
        }
        break;
      }
    }
  })), Stream_exports.filter(Predicate_exports.isNotUndefined), listenToDebugPing(channelName));
  const establishConnection = gen4(function* () {
    postMessage(ConnectMessage.make({ from: connectionId }));
  });
  yield* establishConnection;
  yield* addFinalizer3(() => gen4(function* () {
    postMessage(DisconnectMessage.make({ from: connectionId }));
    channel2.close();
    yield* Queue_exports.shutdown(messageQueue);
  }));
  const closedDeferred = yield* Deferred_exports.make().pipe(acquireRelease2(Deferred_exports.done(Exit_exports.void)));
  return {
    [WebChannelSymbol]: WebChannelSymbol,
    send: send2,
    listen,
    closedDeferred,
    shutdown: Scope_exports.close(scope5, Exit_exports.void),
    schema: schema4,
    supportsTransferables
  };
}).pipe(withSpan3(`WebChannel:broadcastChannelWithAck(${channelName})`))), "broadcastChannelWithAck");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/WebChannel/WebChannel.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var shutdown8 = /* @__PURE__ */ __name((webChannel) => Deferred_exports.done(webChannel.closedDeferred, Exit_exports.void), "shutdown");
var noopChannel = /* @__PURE__ */ __name(() => scopeWithCloseable((scope5) => gen4(function* () {
  return {
    [WebChannelSymbol]: WebChannelSymbol,
    send: /* @__PURE__ */ __name(() => _void, "send"),
    listen: never6,
    closedDeferred: yield* Deferred_exports.make().pipe(acquireRelease2(Deferred_exports.done(Exit_exports.void))),
    shutdown: Scope_exports.close(scope5, Exit_exports.succeed("shutdown")),
    schema: {
      listen: Any,
      send: Any
    },
    supportsTransferables: false
  };
}).pipe(withSpan3(`WebChannel:noopChannel`))), "noopChannel");
var broadcastChannel = /* @__PURE__ */ __name(({ channelName, schema: inputSchema }) => scopeWithCloseable((scope5) => gen4(function* () {
  const schema4 = mapSchema(inputSchema);
  const channel2 = new BroadcastChannel(channelName);
  yield* addFinalizer3(() => try_3(() => channel2.close()).pipe(ignoreLogged2));
  const send2 = /* @__PURE__ */ __name((message) => gen4(function* () {
    const messageEncoded = yield* encode5(schema4.send)(message);
    channel2.postMessage(messageEncoded);
  }), "send");
  const listen = fromEventListener2(channel2, "message").pipe(map33((_) => decodeEither2(schema4.listen)(_.data)), listenToDebugPing(channelName));
  const closedDeferred = yield* Deferred_exports.make().pipe(acquireRelease2(Deferred_exports.done(Exit_exports.void)));
  const supportsTransferables = false;
  return {
    [WebChannelSymbol]: WebChannelSymbol,
    send: send2,
    listen,
    closedDeferred,
    shutdown: Scope_exports.close(scope5, Exit_exports.succeed("shutdown")),
    schema: schema4,
    supportsTransferables
  };
}).pipe(withSpan3(`WebChannel:broadcastChannel(${channelName})`))), "broadcastChannel");
var windowChannel = /* @__PURE__ */ __name(({ listenWindow, sendWindow, targetOrigin = "*", ids: ids3, schema: inputSchema }) => scopeWithCloseable((scope5) => gen4(function* () {
  const schema4 = mapSchema(inputSchema);
  const debugInfo = {
    sendTotal: 0,
    listenTotal: 0,
    targetOrigin,
    ids: ids3
  };
  const WindowMessageListen = Struct({
    message: schema4.listen,
    from: Literal2(ids3.other),
    to: Literal2(ids3.own)
  }).annotations({ title: "webmesh.WindowMessageListen" });
  const WindowMessageSend = Struct({
    message: schema4.send,
    from: Literal2(ids3.own),
    to: Literal2(ids3.other)
  }).annotations({ title: "webmesh.WindowMessageSend" });
  const send2 = /* @__PURE__ */ __name((message) => gen4(function* () {
    debugInfo.sendTotal++;
    const [messageEncoded, transferables] = yield* encodeWithTransferables(WindowMessageSend)({
      message,
      from: ids3.own,
      to: ids3.other
    });
    sendWindow.postMessage(messageEncoded, targetOrigin, transferables);
  }), "send");
  const listen = fromEventListener2(listenWindow, "message").pipe(
    // Stream.tap((_) => Effect.log(`${ids.other}${ids.own}:message`, _.data)),
    filter16((_) => is(encodedSchema(WindowMessageListen))(_.data)),
    map33((_) => {
      debugInfo.listenTotal++;
      return decodeEither2(schema4.listen)(_.data.message);
    }),
    listenToDebugPing("window")
  );
  const closedDeferred = yield* Deferred_exports.make().pipe(acquireRelease2(Deferred_exports.done(Exit_exports.void)));
  const supportsTransferables = true;
  return {
    [WebChannelSymbol]: WebChannelSymbol,
    send: send2,
    listen,
    closedDeferred,
    shutdown: Scope_exports.close(scope5, Exit_exports.succeed("shutdown")),
    schema: schema4,
    supportsTransferables,
    debugInfo
  };
}).pipe(withSpan3(`WebChannel:windowChannel`))), "windowChannel");
var messagePortChannel = /* @__PURE__ */ __name(({ port: port2, schema: inputSchema, debugId }) => scopeWithCloseable((scope5) => gen4(function* () {
  const schema4 = mapSchema(inputSchema);
  const label = debugId === void 0 ? "messagePort" : `messagePort:${debugId}`;
  const send2 = /* @__PURE__ */ __name((message) => gen4(function* () {
    const [messageEncoded, transferables] = yield* encodeWithTransferables(schema4.send)(message);
    port2.postMessage(messageEncoded, transferables);
  }), "send");
  const listen = fromEventListener2(port2, "message").pipe(
    // Stream.tap((_) => Effect.log(`${label}:message`, _.data)),
    map33((_) => decodeEither2(schema4.listen)(_.data)),
    listenToDebugPing(label)
  );
  port2.start();
  const closedDeferred = yield* Deferred_exports.make().pipe(acquireRelease2(Deferred_exports.done(Exit_exports.void)));
  const supportsTransferables = true;
  yield* addFinalizer3(() => try_3(() => port2.close()).pipe(ignoreLogged2));
  return {
    [WebChannelSymbol]: WebChannelSymbol,
    send: send2,
    listen,
    closedDeferred,
    shutdown: Scope_exports.close(scope5, Exit_exports.succeed("shutdown")),
    schema: schema4,
    supportsTransferables
  };
}).pipe(withSpan3(`WebChannel:messagePortChannel`))), "messagePortChannel");
var sameThreadChannels = GlobalValue_exports.globalValue("livestore:sameThreadChannels", () => /* @__PURE__ */ new Map());
var sameThreadChannel = /* @__PURE__ */ __name(({ schema: inputSchema, channelName }) => scopeWithCloseable((scope5) => gen4(function* () {
  let pubSub = sameThreadChannels.get(channelName);
  if (pubSub === void 0) {
    pubSub = yield* PubSub_exports.unbounded().pipe(acquireRelease2(PubSub_exports.shutdown));
    sameThreadChannels.set(channelName, pubSub);
  }
  const schema4 = mapSchema(inputSchema);
  const send2 = /* @__PURE__ */ __name((message) => gen4(function* () {
    yield* PubSub_exports.publish(pubSub, message);
  }), "send");
  const listen = fromPubSub2(pubSub).pipe(map33(Either_exports.right), listenToDebugPing(channelName));
  const closedDeferred = yield* Deferred_exports.make().pipe(acquireRelease2(Deferred_exports.done(Exit_exports.void)));
  return {
    [WebChannelSymbol]: WebChannelSymbol,
    send: send2,
    listen,
    closedDeferred,
    shutdown: Scope_exports.close(scope5, Exit_exports.succeed("shutdown")),
    schema: schema4,
    supportsTransferables: false
  };
})), "sameThreadChannel");
var messagePortChannelWithAck = /* @__PURE__ */ __name(({ port: port2, schema: inputSchema, debugId }) => scopeWithCloseable((scope5) => gen4(function* () {
  const schema4 = mapSchema(inputSchema);
  const label = debugId === void 0 ? "messagePort" : `messagePort:${debugId}`;
  const requestAckMap = /* @__PURE__ */ new Map();
  const ChannelRequest = TaggedStruct("ChannelRequest", {
    id: String$,
    payload: Union2(schema4.listen, schema4.send)
  }).annotations({ title: "webmesh.ChannelRequest" });
  const ChannelRequestAck = TaggedStruct("ChannelRequestAck", {
    reqId: String$
  }).annotations({ title: "webmesh.ChannelRequestAck" });
  const ChannelMessage = Union2(ChannelRequest, ChannelRequestAck).annotations({
    title: "webmesh.ChannelMessage"
  });
  const debugInfo = {
    sendTotal: 0,
    sendPending: 0,
    listenTotal: 0,
    id: debugId
  };
  const send2 = /* @__PURE__ */ __name((message) => gen4(function* () {
    debugInfo.sendTotal++;
    debugInfo.sendPending++;
    const id4 = crypto.randomUUID();
    const [messageEncoded, transferables] = yield* encodeWithTransferables(ChannelMessage)({
      _tag: "ChannelRequest",
      id: id4,
      payload: message
    });
    const ack = yield* Deferred_exports.make();
    requestAckMap.set(id4, ack);
    port2.postMessage(messageEncoded, transferables);
    yield* ack;
    requestAckMap.delete(id4);
    debugInfo.sendPending--;
  }), "send");
  const listen = fromEventListener2(port2, "message").pipe(
    // Stream.onStart(Effect.log(`${label}:listen:start`)),
    // Stream.tap((_) => Effect.log(`${label}:message`, _.data)),
    map33((_) => decodeEither2(ChannelMessage)(_.data)),
    tap8((msg) => gen4(function* () {
      if (msg._tag === "Right") {
        if (msg.right._tag === "ChannelRequestAck") {
          yield* Deferred_exports.succeed(requestAckMap.get(msg.right.reqId), void 0);
        } else if (msg.right._tag === "ChannelRequest") {
          debugInfo.listenTotal++;
          port2.postMessage(encodeSync(ChannelMessage)({ _tag: "ChannelRequestAck", reqId: msg.right.id }));
        }
      }
    })),
    filterMap9((msg) => msg._tag === "Left" ? Option_exports.some(msg) : msg.right._tag === "ChannelRequest" ? Option_exports.some(Either_exports.right(msg.right.payload)) : Option_exports.none()),
    (_) => _,
    listenToDebugPing(label)
  );
  port2.start();
  const closedDeferred = yield* Deferred_exports.make().pipe(acquireRelease2(Deferred_exports.done(Exit_exports.void)));
  const supportsTransferables = true;
  yield* addFinalizer3(() => try_3(() => port2.close()).pipe(ignoreLogged2));
  return {
    [WebChannelSymbol]: WebChannelSymbol,
    send: send2,
    listen,
    closedDeferred,
    shutdown: Scope_exports.close(scope5, Exit_exports.succeed("shutdown")),
    schema: schema4,
    supportsTransferables,
    debugInfo
  };
}).pipe(withSpan3(`WebChannel:messagePortChannelWithAck`))), "messagePortChannelWithAck");
var queueChannelProxy = /* @__PURE__ */ __name(({ schema: inputSchema }) => scopeWithCloseable((scope5) => gen4(function* () {
  const sendQueue = yield* Queue_exports.unbounded().pipe(acquireRelease2(Queue_exports.shutdown));
  const listenQueue = yield* Queue_exports.unbounded().pipe(acquireRelease2(Queue_exports.shutdown));
  const send2 = /* @__PURE__ */ __name((message) => Queue_exports.offer(sendQueue, message), "send");
  const listen = fromQueue3(listenQueue).pipe(map33(Either_exports.right), listenToDebugPing("queueChannel"));
  const closedDeferred = yield* Deferred_exports.make().pipe(acquireRelease2(Deferred_exports.done(Exit_exports.void)));
  const supportsTransferables = true;
  const schema4 = mapSchema(inputSchema);
  const webChannel = {
    [WebChannelSymbol]: WebChannelSymbol,
    send: send2,
    listen,
    closedDeferred,
    shutdown: Scope_exports.close(scope5, Exit_exports.succeed("shutdown")),
    schema: schema4,
    supportsTransferables
  };
  return { webChannel, sendQueue, listenQueue };
}).pipe(withSpan3(`WebChannel:queueChannelProxy`))), "queueChannelProxy");
var toOpenChannel = /* @__PURE__ */ __name((channel2, options4) => gen4(function* () {
  const queue = yield* Queue_exports.unbounded().pipe(acquireRelease2(Queue_exports.shutdown));
  const pendingPingDeferredRef = {
    current: void 0
  };
  yield* channel2.listen.pipe(
    // TODO implement this on the "chunk" level for better performance
    options4?.heartbeat ? filterEffect3(fn(function* (msg) {
      if (msg._tag === "Right" && is(WebChannelHeartbeat)(msg.right)) {
        if (msg.right._tag === "WebChannel.Ping") {
          yield* channel2.send(WebChannelPong.make({ requestId: msg.right.requestId }));
        } else {
          const { deferred, requestId: requestId2 } = pendingPingDeferredRef.current ?? shouldNeverHappen("No pending ping");
          if (requestId2 !== msg.right.requestId) {
            shouldNeverHappen("Received pong for unexpected requestId", requestId2, msg.right.requestId);
          }
          yield* Deferred_exports.succeed(deferred, void 0);
        }
        return false;
      }
      return true;
    })) : identity,
    tapChunk((chunk4) => Queue_exports.offerAll(queue, chunk4)),
    runDrain3,
    forkScoped2
  );
  if (options4?.heartbeat) {
    const { interval, timeout: timeout5 } = options4.heartbeat;
    yield* gen4(function* () {
      while (true) {
        yield* sleep4(interval);
        const requestId2 = crypto.randomUUID();
        yield* channel2.send(WebChannelPing.make({ requestId: requestId2 }));
        const deferred = yield* Deferred_exports.make();
        pendingPingDeferredRef.current = { deferred, requestId: requestId2 };
        yield* deferred.pipe(timeout2(timeout5), catchTag2("TimeoutException", () => channel2.shutdown));
      }
    }).pipe(withSpan3(`WebChannel:heartbeat`), forkScoped2);
  }
  const listen = fromQueue3(queue, { maxChunkSize: 1 });
  return {
    [WebChannelSymbol]: WebChannelSymbol,
    send: channel2.send,
    listen,
    closedDeferred: channel2.closedDeferred,
    shutdown: channel2.shutdown,
    schema: channel2.schema,
    supportsTransferables: channel2.supportsTransferables,
    debugInfo: {
      innerDebugInfo: channel2.debugInfo,
      listenQueueSize: queue
    }
  };
}), "toOpenChannel");
var sendDebugPing = /* @__PURE__ */ __name((channel2) => gen4(function* () {
  yield* channel2.send(DebugPingMessage.make({ message: "ping" }));
}), "sendDebugPing");

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/effect/Schedule.js
var Schedule_exports2 = {};
__export(Schedule_exports2, {
  CurrentIterationMetadata: () => CurrentIterationMetadata2,
  ScheduleDriverTypeId: () => ScheduleDriverTypeId2,
  ScheduleTypeId: () => ScheduleTypeId2,
  addDelay: () => addDelay2,
  addDelayEffect: () => addDelayEffect2,
  andThen: () => andThen9,
  andThenEither: () => andThenEither2,
  as: () => as10,
  asVoid: () => asVoid6,
  bothInOut: () => bothInOut2,
  check: () => check3,
  checkEffect: () => checkEffect2,
  collectAllInputs: () => collectAllInputs2,
  collectAllOutputs: () => collectAllOutputs2,
  collectUntil: () => collectUntil2,
  collectUntilEffect: () => collectUntilEffect2,
  collectWhile: () => collectWhile2,
  collectWhileEffect: () => collectWhileEffect2,
  compose: () => compose5,
  count: () => count4,
  cron: () => cron2,
  dayOfMonth: () => dayOfMonth2,
  dayOfWeek: () => dayOfWeek2,
  delayed: () => delayed2,
  delayedEffect: () => delayedEffect2,
  delayedSchedule: () => delayedSchedule2,
  delays: () => delays2,
  driver: () => driver2,
  duration: () => duration3,
  either: () => either5,
  eitherWith: () => eitherWith2,
  elapsed: () => elapsed2,
  ensuring: () => ensuring5,
  exponential: () => exponential3,
  exponentialBackoff10Sec: () => exponentialBackoff10Sec,
  fibonacci: () => fibonacci2,
  fixed: () => fixed4,
  forever: () => forever4,
  fromDelay: () => fromDelay2,
  fromDelays: () => fromDelays2,
  fromFunction: () => fromFunction4,
  hourOfDay: () => hourOfDay2,
  identity: () => identity4,
  intersect: () => intersect6,
  intersectWith: () => intersectWith2,
  isSchedule: () => isSchedule2,
  jittered: () => jittered2,
  jitteredWith: () => jitteredWith2,
  linear: () => linear2,
  makeWithState: () => makeWithState2,
  map: () => map29,
  mapBoth: () => mapBoth7,
  mapBothEffect: () => mapBothEffect2,
  mapEffect: () => mapEffect5,
  mapInput: () => mapInput6,
  mapInputContext: () => mapInputContext4,
  mapInputEffect: () => mapInputEffect2,
  minuteOfHour: () => minuteOfHour2,
  modifyDelay: () => modifyDelay2,
  modifyDelayEffect: () => modifyDelayEffect2,
  onDecision: () => onDecision2,
  once: () => once5,
  passthrough: () => passthrough4,
  provideContext: () => provideContext5,
  provideService: () => provideService6,
  recurUntil: () => recurUntil2,
  recurUntilEffect: () => recurUntilEffect2,
  recurUntilOption: () => recurUntilOption2,
  recurUpTo: () => recurUpTo2,
  recurWhile: () => recurWhile2,
  recurWhileEffect: () => recurWhileEffect2,
  recurs: () => recurs2,
  reduce: () => reduce14,
  reduceEffect: () => reduceEffect4,
  repeatForever: () => repeatForever,
  repetitions: () => repetitions2,
  resetAfter: () => resetAfter2,
  resetWhen: () => resetWhen2,
  run: () => run3,
  secondOfMinute: () => secondOfMinute2,
  spaced: () => spaced2,
  stop: () => stop2,
  succeed: () => succeed16,
  sync: () => sync11,
  tapInput: () => tapInput2,
  tapOutput: () => tapOutput2,
  unfold: () => unfold3,
  union: () => union11,
  unionWith: () => unionWith3,
  untilInput: () => untilInput2,
  untilInputEffect: () => untilInputEffect2,
  untilOutput: () => untilOutput2,
  untilOutputEffect: () => untilOutputEffect2,
  upTo: () => upTo2,
  whileInput: () => whileInput2,
  whileInputEffect: () => whileInputEffect2,
  whileOutput: () => whileOutput2,
  whileOutputEffect: () => whileOutputEffect2,
  windowed: () => windowed2,
  zipLeft: () => zipLeft9,
  zipRight: () => zipRight9,
  zipWith: () => zipWith13
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var exponentialBackoff10Sec = pipe(
  Schedule_exports.exponential(Duration_exports.millis(10), 4),
  // 10ms, 40ms, 160ms, 640ms, 2560ms, ...
  Schedule_exports.andThenEither(Schedule_exports.spaced(Duration_exports.seconds(1))),
  Schedule_exports.compose(Schedule_exports.elapsed),
  Schedule_exports.whileOutput(Duration_exports.lessThanOrEqualTo(Duration_exports.seconds(10)))
);

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/ClientSessionLeaderThreadProxy.js
var ClientSessionLeaderThreadProxy_exports = {};
__export(ClientSessionLeaderThreadProxy_exports, {
  of: () => of6
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var of6 = /* @__PURE__ */ __name((proxy, options4) => {
  if (options4?.overrides === void 0)
    return proxy;
  return { ...proxy, ...options4.overrides(proxy) };
}, "of");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/errors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var UnexpectedError = class _UnexpectedError extends Schema_exports2.TaggedError()("LiveStore.UnexpectedError", {
  cause: Schema_exports2.Defect,
  note: Schema_exports2.optional(Schema_exports2.String),
  payload: Schema_exports2.optional(Schema_exports2.Any)
}) {
  static {
    __name(this, "UnexpectedError");
  }
  static mapToUnexpectedError = /* @__PURE__ */ __name((effect4) => effect4.pipe(Effect_exports2.mapError((cause3) => Schema_exports2.is(_UnexpectedError)(cause3) ? cause3 : new _UnexpectedError({ cause: cause3 })), Effect_exports2.catchAllDefect((cause3) => new _UnexpectedError({ cause: cause3 }))), "mapToUnexpectedError");
  static mapToUnexpectedErrorStream = /* @__PURE__ */ __name((stream6) => stream6.pipe(Stream_exports2.mapError((cause3) => Schema_exports2.is(_UnexpectedError)(cause3) ? cause3 : new _UnexpectedError({ cause: cause3 }))), "mapToUnexpectedErrorStream");
};
var SyncError = class extends Schema_exports2.TaggedError()("LiveStore.SyncError", {
  cause: Schema_exports2.Defect
}) {
  static {
    __name(this, "SyncError");
  }
};
var MaterializerHashMismatchError = class extends Schema_exports2.TaggedError()("LiveStore.MaterializerHashMismatchError", {
  eventName: Schema_exports2.String,
  note: Schema_exports2.optionalWith(Schema_exports2.String, {
    default: /* @__PURE__ */ __name(() => "Please make sure your event materializer is a pure function without side effects.", "default")
  })
}) {
  static {
    __name(this, "MaterializerHashMismatchError");
  }
};
var IntentionalShutdownCause = class extends Schema_exports2.TaggedError()("LiveStore.IntentionalShutdownCause", {
  reason: Schema_exports2.Literal("devtools-reset", "devtools-import", "adapter-reset", "manual")
}) {
  static {
    __name(this, "IntentionalShutdownCause");
  }
};
var StoreInterrupted = class extends Schema_exports2.TaggedError()("LiveStore.StoreInterrupted", {
  reason: Schema_exports2.String
}) {
  static {
    __name(this, "StoreInterrupted");
  }
};
var SqliteError = class extends Schema_exports2.TaggedError()("LiveStore.SqliteError", {
  query: Schema_exports2.optional(Schema_exports2.Struct({
    sql: Schema_exports2.String,
    bindValues: Schema_exports2.Union(Schema_exports2.Record({ key: Schema_exports2.String, value: Schema_exports2.Any }), Schema_exports2.Array(Schema_exports2.Any))
  })),
  /** The SQLite result code */
  // code: Schema.optional(Schema.Number),
  // Added string support for Expo SQLite (we should refactor this to have a unified error type)
  code: Schema_exports2.optional(Schema_exports2.Union(Schema_exports2.Number, Schema_exports2.String)),
  /** The original SQLite3 error */
  cause: Schema_exports2.Defect,
  note: Schema_exports2.optional(Schema_exports2.String)
}) {
  static {
    __name(this, "SqliteError");
  }
};

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/adapter-types.js
var BootStateProgress = Schema_exports2.Struct({
  done: Schema_exports2.Number,
  total: Schema_exports2.Number
});
var BootStatus = Schema_exports2.Union(Schema_exports2.Struct({ stage: Schema_exports2.Literal("loading") }), Schema_exports2.Struct({ stage: Schema_exports2.Literal("migrating"), progress: BootStateProgress }), Schema_exports2.Struct({ stage: Schema_exports2.Literal("rehydrating"), progress: BootStateProgress }), Schema_exports2.Struct({ stage: Schema_exports2.Literal("syncing"), progress: BootStateProgress }), Schema_exports2.Struct({ stage: Schema_exports2.Literal("done") })).annotations({ title: "BootStatus" });
var SessionIdSymbol = Symbol.for("@livestore/session-id");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/bounded-collections.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BoundMap = class {
  static {
    __name(this, "BoundMap");
  }
  #map = /* @__PURE__ */ new Map();
  #sizeLimit;
  constructor(sizeLimit) {
    this.#sizeLimit = sizeLimit;
  }
  onEvict;
  set = /* @__PURE__ */ __name((key, value6) => {
    this.#map.set(key, value6);
    if (this.#map.size > this.#sizeLimit) {
      const firstKey = this.#map.keys().next().value;
      const deletedValue = this.#map.get(firstKey);
      this.#map.delete(firstKey);
      if (this.onEvict) {
        this.onEvict(firstKey, deletedValue);
      }
    }
  }, "set");
  get = /* @__PURE__ */ __name((key) => {
    return this.#map.get(key);
  }, "get");
  delete = /* @__PURE__ */ __name((key) => {
    this.#map.delete(key);
  }, "delete");
  keys = /* @__PURE__ */ __name(() => {
    return this.#map.keys();
  }, "keys");
};
var BoundSet = class {
  static {
    __name(this, "BoundSet");
  }
  #map;
  constructor(sizeLimit) {
    this.#map = new BoundMap(sizeLimit);
    this.#map.onEvict = this.#onEvict;
  }
  #onEvict = /* @__PURE__ */ __name((v) => {
    if (this.onEvict) {
      this.onEvict(v);
    }
  }, "#onEvict");
  onEvict;
  add = /* @__PURE__ */ __name((v) => {
    this.#map.set(v, v);
  }, "add");
  [Symbol.iterator] = () => {
    return this.#map.keys();
  };
};
var BoundArray = class _BoundArray {
  static {
    __name(this, "BoundArray");
  }
  #array = [];
  sizeLimit;
  constructor(sizeLimit) {
    this.sizeLimit = sizeLimit;
  }
  static make = /* @__PURE__ */ __name((sizeLimit, initial = []) => {
    const b = new _BoundArray(sizeLimit);
    for (const v of initial) {
      b.push(v);
    }
    return b;
  }, "make");
  onEvict;
  push = /* @__PURE__ */ __name((v) => {
    this.#array.push(v);
    if (this.#array.length > this.sizeLimit) {
      const first2 = this.#array.shift();
      if (first2 && this.onEvict) {
        this.onEvict(first2);
      }
    }
  }, "push");
  get = /* @__PURE__ */ __name((index2) => {
    return this.#array[index2];
  }, "get");
  delete = /* @__PURE__ */ __name((index2) => {
    this.#array.splice(index2, 1);
  }, "delete");
  get length() {
    return this.#array.length;
  }
  [Symbol.iterator] = () => {
    return this.#array[Symbol.iterator]();
  };
  map = /* @__PURE__ */ __name((fn2) => {
    return this.#array.map(fn2);
  }, "map");
  clear = /* @__PURE__ */ __name(() => {
    this.#array = [];
  }, "clear");
  sort = /* @__PURE__ */ __name((fn2) => {
    return this.#array.sort(fn2);
  }, "sort");
};

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/debug-info.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/util.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SqlValueSchema = Schema_exports2.Union(Schema_exports2.String, Schema_exports2.Number, Schema_exports2.Uint8Array, Schema_exports2.Null);
var PreparedBindValues = Schema_exports2.Union(Schema_exports2.Array(SqlValueSchema), Schema_exports2.Record({ key: Schema_exports2.String, value: SqlValueSchema })).pipe(Schema_exports2.brand("PreparedBindValues"));
var sql = /* @__PURE__ */ __name((template, ...args2) => {
  let str = "";
  for (const [i, arg] of args2.entries()) {
    str += template[i] + String(arg);
  }
  return str + template[template.length - 1];
}, "sql");
var prepareBindValues = /* @__PURE__ */ __name((values6, statement) => {
  if (Array.isArray(values6))
    return values6;
  const result = {};
  for (const [key, value6] of Object.entries(values6)) {
    if (statement.includes(key)) {
      result[`$${key}`] = value6;
    }
  }
  return result;
}, "prepareBindValues");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/debug-info.js
var SlowQueryInfo = Schema_exports2.Struct({
  queryStr: Schema_exports2.String,
  bindValues: Schema_exports2.UndefinedOr(PreparedBindValues),
  durationMs: Schema_exports2.Number,
  rowsCount: Schema_exports2.UndefinedOr(Schema_exports2.Number),
  queriedTables: Schema_exports2.ReadonlySet(Schema_exports2.String),
  startTimePerfNow: Schema_exports2.Number
});
var BoundArraySchemaFromSelf = /* @__PURE__ */ __name((item) => Schema_exports2.declare([item], {
  decode: /* @__PURE__ */ __name((item2) => (input, parseOptions, ast) => {
    if (input instanceof BoundArray) {
      const elements = ParseResult_exports.decodeUnknown(Schema_exports2.Array(item2))([...input], parseOptions);
      return ParseResult_exports.map(elements, (as16) => BoundArray.make(input.sizeLimit, as16));
    }
    return ParseResult_exports.fail(new ParseResult_exports.Type(ast, input));
  }, "decode"),
  encode: /* @__PURE__ */ __name((item2) => (input, parseOptions, ast) => {
    if (input instanceof BoundArray) {
      const elements = ParseResult_exports.encodeUnknown(Schema_exports2.Array(item2))([...input], parseOptions);
      return ParseResult_exports.map(elements, (is4) => BoundArray.make(input.sizeLimit, is4));
    }
    return ParseResult_exports.fail(new ParseResult_exports.Type(ast, input));
  }, "encode")
}, {
  description: `BoundArray<${Schema_exports2.format(item)}>`,
  pretty: /* @__PURE__ */ __name(() => (_) => `BoundArray(${_.length})`, "pretty"),
  arbitrary: /* @__PURE__ */ __name(() => (fc) => fc.anything(), "arbitrary"),
  equivalence: /* @__PURE__ */ __name(() => (a, b) => a === b, "equivalence")
}), "BoundArraySchemaFromSelf");
var BoundArraySchema = /* @__PURE__ */ __name((elSchema) => Schema_exports2.transform(Schema_exports2.Struct({
  size: Schema_exports2.Number,
  items: Schema_exports2.Array(elSchema)
}), BoundArraySchemaFromSelf(Schema_exports2.typeSchema(elSchema)), {
  encode: /* @__PURE__ */ __name((_) => ({ size: _.sizeLimit, items: [..._] }), "encode"),
  decode: /* @__PURE__ */ __name((_) => BoundArray.make(_.size, _.items), "decode")
}), "BoundArraySchema");
var DebugInfo = Schema_exports2.Struct({
  slowQueries: BoundArraySchema(SlowQueryInfo),
  queryFrameDuration: Schema_exports2.Number,
  queryFrameCount: Schema_exports2.Number,
  events: BoundArraySchema(Schema_exports2.Tuple(Schema_exports2.String, Schema_exports2.Any))
});
var MutableDebugInfo = Schema_exports2.mutable(DebugInfo);

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/devtools/mod.js
var mod_exports5 = {};
__export(mod_exports5, {
  ClientSession: () => devtools_messages_client_session_exports,
  DevtoolsMode: () => DevtoolsMode,
  DevtoolsModeTag: () => DevtoolsModeTag,
  LSDChannelMessage: () => LSDChannelMessage,
  LSDClientSessionChannelMessage: () => LSDClientSessionChannelMessage,
  LSDClientSessionReqResMessage: () => LSDClientSessionReqResMessage,
  LSDMessage: () => LSDMessage,
  LSDReqResMessage: () => LSDReqResMessage,
  Leader: () => devtools_messages_leader_exports,
  LeaderReqResMessage: () => LeaderReqResMessage,
  NetworkStatus: () => NetworkStatus,
  SessionInfo: () => devtools_sessioninfo_exports,
  clientId: () => clientId,
  isChannelName: () => isChannelName,
  liveStoreVersion: () => liveStoreVersion2,
  makeChannelName: () => makeChannelName,
  makeNodeName: () => makeNodeName,
  makeSessionInfoBroadcastChannel: () => makeSessionInfoBroadcastChannel,
  requestId: () => requestId,
  sessionId: () => sessionId
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+utils@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=8fd_6c17385282500e0892c0d379e2d148e1/node_modules/@livestore/utils/dist/nanoid/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/index.browser.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/url-alphabet/index.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/index.browser.js
var nanoid = /* @__PURE__ */ __name((size22 = 21) => {
  let id4 = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size22 |= 0));
  while (size22--) {
    id4 += urlAlphabet[bytes[size22] & 63];
  }
  return id4;
}, "nanoid");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/devtools/devtools-sessioninfo.js
var devtools_sessioninfo_exports = {};
__export(devtools_sessioninfo_exports, {
  Message: () => Message2,
  RequestSessions: () => RequestSessions,
  SessionInfo: () => SessionInfo,
  provideSessionInfo: () => provideSessionInfo,
  requestSessionInfoSubscription: () => requestSessionInfoSubscription
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var RequestSessions = Schema_exports2.TaggedStruct("RequestSessions", {});
var SessionInfo = Schema_exports2.TaggedStruct("SessionInfo", {
  storeId: Schema_exports2.String,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String,
  schemaAlias: Schema_exports2.String,
  isLeader: Schema_exports2.Boolean
});
var Message2 = Schema_exports2.Union(RequestSessions, SessionInfo);
var provideSessionInfo = /* @__PURE__ */ __name(({ webChannel, sessionInfo }) => Effect_exports2.gen(function* () {
  yield* webChannel.send(sessionInfo);
  yield* webChannel.listen.pipe(Stream_exports2.flatten(), Stream_exports2.filter(Schema_exports2.is(RequestSessions)), Stream_exports2.tap(() => webChannel.send(sessionInfo)), Stream_exports2.runDrain);
}), "provideSessionInfo");
var requestSessionInfoSubscription = /* @__PURE__ */ __name(({ webChannel, pollInterval = Duration_exports.seconds(1), staleTimeout = Duration_exports.seconds(5) }) => Effect_exports2.gen(function* () {
  yield* webChannel.send(RequestSessions.make({})).pipe(Effect_exports2.repeat(Schedule_exports2.spaced(pollInterval)), Effect_exports2.interruptible, Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
  const timeoutFiberMap = yield* FiberMap_exports.make();
  const sessionInfoSubRef = yield* SubscriptionRef_exports2.make(HashSet_exports.empty());
  yield* webChannel.listen.pipe(Stream_exports2.flatten(), Stream_exports2.filter(Schema_exports2.is(SessionInfo)), Stream_exports2.map(Data_exports.struct), Stream_exports2.tap(Effect_exports2.fn(function* (sessionInfo) {
    yield* SubscriptionRef_exports2.getAndUpdate(sessionInfoSubRef, HashSet_exports.add(sessionInfo));
    yield* FiberMap_exports.run(timeoutFiberMap, sessionInfo, Effect_exports2.gen(function* () {
      yield* Effect_exports2.sleep(staleTimeout);
      yield* SubscriptionRef_exports2.getAndUpdate(sessionInfoSubRef, HashSet_exports.remove(sessionInfo));
    }));
  })), Stream_exports2.runDrain, Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
  return Subscribable_exports2.make({
    get: sessionInfoSubRef.get.pipe(Effect_exports2.map((sessionInfos) => new Set(sessionInfos))),
    changes: sessionInfoSubRef.changes.pipe(Stream_exports2.map((sessionInfos) => new Set(sessionInfos)))
  });
}), "requestSessionInfoSubscription");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/devtools/devtools-messages.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/devtools/devtools-messages-client-session.js
var devtools_messages_client_session_exports = {};
__export(devtools_messages_client_session_exports, {
  DebugInfoHistoryRes: () => DebugInfoHistoryRes,
  DebugInfoHistorySubscribe: () => DebugInfoHistorySubscribe,
  DebugInfoHistoryUnsubscribe: () => DebugInfoHistoryUnsubscribe,
  DebugInfoReq: () => DebugInfoReq,
  DebugInfoRerunQueryReq: () => DebugInfoRerunQueryReq,
  DebugInfoRerunQueryRes: () => DebugInfoRerunQueryRes,
  DebugInfoRes: () => DebugInfoRes,
  DebugInfoResetReq: () => DebugInfoResetReq,
  DebugInfoResetRes: () => DebugInfoResetRes,
  Disconnect: () => Disconnect,
  LiveQueriesRes: () => LiveQueriesRes,
  LiveQueriesSubscribe: () => LiveQueriesSubscribe,
  LiveQueriesUnsubscribe: () => LiveQueriesUnsubscribe,
  MessageFromApp: () => MessageFromApp,
  MessageToApp: () => MessageToApp,
  Ping: () => Ping,
  Pong: () => Pong,
  ReactivityGraphRes: () => ReactivityGraphRes,
  ReactivityGraphSubscribe: () => ReactivityGraphSubscribe,
  ReactivityGraphUnsubscribe: () => ReactivityGraphUnsubscribe,
  SerializedLiveQuery: () => SerializedLiveQuery,
  SyncHeadRes: () => SyncHeadRes,
  SyncHeadSubscribe: () => SyncHeadSubscribe,
  SyncHeadUnsubscribe: () => SyncHeadUnsubscribe
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/mod.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/EventDef.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var defineFacts = /* @__PURE__ */ __name((record4) => record4, "defineFacts");
var defineEvent = /* @__PURE__ */ __name((args2) => {
  const { name, schema: schema4, ...options4 } = args2;
  const makePartialEvent = /* @__PURE__ */ __name((args3) => {
    const res = Schema_exports2.validateEither(schema4)(args3);
    if (res._tag === "Left") {
      shouldNeverHappen(`Invalid event args for event '${name}':`, res.left.message, "\n");
    }
    return { name, args: args3 };
  }, "makePartialEvent");
  Object.defineProperty(makePartialEvent, "name", { value: name });
  Object.defineProperty(makePartialEvent, "schema", { value: schema4 });
  Object.defineProperty(makePartialEvent, "encoded", {
    value: /* @__PURE__ */ __name((args3) => ({ name, args: args3 }), "value")
  });
  Object.defineProperty(makePartialEvent, "options", {
    value: {
      clientOnly: options4?.clientOnly ?? false,
      facts: options4?.facts ? (args3, currentFacts) => {
        const res = options4.facts(args3, currentFacts);
        return {
          modify: {
            set: res.modify?.set ? new Set(res.modify.set) : /* @__PURE__ */ new Set(),
            unset: res.modify?.unset ? new Set(res.modify.unset) : /* @__PURE__ */ new Set()
          },
          require: res.require ? new Set(res.require) : /* @__PURE__ */ new Set()
        };
      } : void 0,
      derived: options4?.derived ?? false
    }
  });
  return makePartialEvent;
}, "defineEvent");
var synced = /* @__PURE__ */ __name((args2) => defineEvent({ ...args2, clientOnly: false }), "synced");
var clientOnly = /* @__PURE__ */ __name((args2) => defineEvent({ ...args2, clientOnly: true }), "clientOnly");
var defineMaterializer = /* @__PURE__ */ __name((_eventDef, materializer) => {
  return materializer;
}, "defineMaterializer");
var materializers = /* @__PURE__ */ __name((_eventDefRecord, handlers) => {
  return handlers;
}, "materializers");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/EventSequenceNumber.js
var EventSequenceNumber_exports = {};
__export(EventSequenceNumber_exports, {
  ClientEventSequenceNumber: () => ClientEventSequenceNumber,
  EventSequenceNumber: () => EventSequenceNumber,
  GlobalEventSequenceNumber: () => GlobalEventSequenceNumber,
  ROOT: () => ROOT,
  clientDefault: () => clientDefault,
  compare: () => compare2,
  diff: () => diff8,
  fromGlobal: () => fromGlobal,
  fromString: () => fromString3,
  globalEventSequenceNumber: () => globalEventSequenceNumber,
  isEqual: () => isEqual2,
  isGreaterThan: () => isGreaterThan,
  isGreaterThanOrEqual: () => isGreaterThanOrEqual,
  localEventSequenceNumber: () => localEventSequenceNumber,
  make: () => make104,
  max: () => max8,
  nextPair: () => nextPair,
  rebaseGenerationDefault: () => rebaseGenerationDefault,
  toString: () => toString4
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var localEventSequenceNumber = Brand_exports.nominal();
var ClientEventSequenceNumber = Schema_exports2.fromBrand(localEventSequenceNumber)(Schema_exports2.Int);
var globalEventSequenceNumber = Brand_exports.nominal();
var GlobalEventSequenceNumber = Schema_exports2.fromBrand(globalEventSequenceNumber)(Schema_exports2.Int);
var clientDefault = 0;
var rebaseGenerationDefault = 0;
var EventSequenceNumber = Schema_exports2.Struct({
  global: GlobalEventSequenceNumber,
  /** Only increments for clientOnly events */
  client: ClientEventSequenceNumber,
  // TODO also provide a way to see "confirmation level" of event (e.g. confirmed by leader/sync backend)
  // Client only
  rebaseGeneration: Schema_exports2.Int
}).annotations({
  title: "LiveStore.EventSequenceNumber",
  pretty: /* @__PURE__ */ __name(() => (seqNum) => toString4(seqNum), "pretty")
});
var compare2 = /* @__PURE__ */ __name((a, b) => {
  if (a.global !== b.global) {
    return a.global - b.global;
  }
  if (a.client !== b.client) {
    return a.client - b.client;
  }
  return a.rebaseGeneration - b.rebaseGeneration;
}, "compare");
var toString4 = /* @__PURE__ */ __name((seqNum) => {
  const rebaseGenerationStr = seqNum.rebaseGeneration > 0 ? `r${seqNum.rebaseGeneration}` : "";
  return seqNum.client === 0 ? `e${seqNum.global}${rebaseGenerationStr}` : `e${seqNum.global}+${seqNum.client}${rebaseGenerationStr}`;
}, "toString");
var fromString3 = /* @__PURE__ */ __name((str) => {
  if (!str.startsWith("e")) {
    throw new Error('Invalid event sequence number string: must start with "e"');
  }
  const remaining = str.slice(1);
  let rebaseGeneration = rebaseGenerationDefault;
  let withoutRebase = remaining;
  const rebaseMatch = remaining.match(/r(\d+)$/);
  if (rebaseMatch !== null) {
    rebaseGeneration = Number.parseInt(rebaseMatch[1], 10);
    withoutRebase = remaining.slice(0, -rebaseMatch[0].length);
  }
  const parts2 = withoutRebase.split("+");
  if (parts2[0] === "" || !/^\d+$/.test(parts2[0])) {
    throw new Error("Invalid event sequence number string: invalid number format");
  }
  if (parts2.length > 1 && parts2[1] !== void 0 && (parts2[1] === "" || !/^\d+$/.test(parts2[1]))) {
    throw new Error("Invalid event sequence number string: invalid number format");
  }
  const global2 = Number.parseInt(parts2[0], 10);
  const client = parts2.length > 1 && parts2[1] !== void 0 ? Number.parseInt(parts2[1], 10) : 0;
  if (Number.isNaN(global2) || Number.isNaN(client) || Number.isNaN(rebaseGeneration)) {
    throw new TypeError("Invalid event sequence number string: invalid number format");
  }
  return {
    global: global2,
    client,
    rebaseGeneration
  };
}, "fromString");
var fromGlobal = /* @__PURE__ */ __name((seqNum) => ({
  global: seqNum,
  client: clientDefault,
  rebaseGeneration: rebaseGenerationDefault
}), "fromGlobal");
var isEqual2 = /* @__PURE__ */ __name((a, b) => a.global === b.global && a.client === b.client && a.rebaseGeneration === b.rebaseGeneration, "isEqual");
var ROOT = {
  global: 0,
  client: clientDefault,
  rebaseGeneration: rebaseGenerationDefault
};
var isGreaterThan = /* @__PURE__ */ __name((a, b) => {
  return a.global > b.global || a.global === b.global && a.client > b.client;
}, "isGreaterThan");
var isGreaterThanOrEqual = /* @__PURE__ */ __name((a, b) => {
  return a.global > b.global || a.global === b.global && a.client >= b.client;
}, "isGreaterThanOrEqual");
var max8 = /* @__PURE__ */ __name((a, b) => {
  return a.global > b.global || a.global === b.global && a.client > b.client ? a : b;
}, "max");
var diff8 = /* @__PURE__ */ __name((a, b) => {
  return {
    global: a.global - b.global,
    client: a.client - b.client
  };
}, "diff");
var make104 = /* @__PURE__ */ __name((seqNum) => {
  return Schema_exports2.is(EventSequenceNumber)(seqNum) ? seqNum : Schema_exports2.decodeSync(EventSequenceNumber)({
    ...seqNum,
    rebaseGeneration: seqNum.rebaseGeneration ?? rebaseGenerationDefault
  });
}, "make");
var nextPair = /* @__PURE__ */ __name(({ seqNum, isClient, rebaseGeneration }) => {
  if (isClient) {
    return {
      seqNum: {
        global: seqNum.global,
        client: seqNum.client + 1,
        rebaseGeneration: rebaseGeneration ?? seqNum.rebaseGeneration
      },
      parentSeqNum: seqNum
    };
  }
  return {
    seqNum: {
      global: seqNum.global + 1,
      client: clientDefault,
      rebaseGeneration: rebaseGenerationDefault
    },
    // NOTE we always point to `client: 0` for non-clientOnly events
    parentSeqNum: { global: seqNum.global, client: clientDefault, rebaseGeneration: seqNum.rebaseGeneration }
  };
}, "nextPair");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/events.js
var events_exports = {};
__export(events_exports, {
  clientOnly: () => clientOnly,
  defineEvent: () => defineEvent,
  synced: () => synced
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/LiveStoreEvent.js
var LiveStoreEvent_exports = {};
__export(LiveStoreEvent_exports, {
  AnyDecoded: () => AnyDecoded,
  AnyEncoded: () => AnyEncoded,
  AnyEncodedGlobal: () => AnyEncodedGlobal,
  EncodedWithMeta: () => EncodedWithMeta,
  PartialAnyEncoded: () => PartialAnyEncoded,
  encodedFromGlobal: () => encodedFromGlobal,
  isEqualEncoded: () => isEqualEncoded,
  isPartialEventDef: () => isPartialEventDef,
  makeEventDefPartialSchema: () => makeEventDefPartialSchema,
  makeEventDefSchema: () => makeEventDefSchema,
  makeEventDefSchemaMemo: () => makeEventDefSchemaMemo
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var AnyDecoded = Schema_exports2.Struct({
  name: Schema_exports2.String,
  args: Schema_exports2.Any,
  seqNum: EventSequenceNumber,
  parentSeqNum: EventSequenceNumber,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String
}).annotations({ title: "LiveStoreEvent.AnyDecoded" });
var AnyEncoded = Schema_exports2.Struct({
  name: Schema_exports2.String,
  args: Schema_exports2.Any,
  seqNum: EventSequenceNumber,
  parentSeqNum: EventSequenceNumber,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String
}).annotations({ title: "LiveStoreEvent.AnyEncoded" });
var AnyEncodedGlobal = Schema_exports2.Struct({
  name: Schema_exports2.String,
  args: Schema_exports2.Any,
  seqNum: GlobalEventSequenceNumber,
  parentSeqNum: GlobalEventSequenceNumber,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String
}).annotations({ title: "LiveStoreEvent.AnyEncodedGlobal" });
var PartialAnyEncoded = Schema_exports2.Struct({
  name: Schema_exports2.String,
  args: Schema_exports2.Any
});
var isPartialEventDef = /* @__PURE__ */ __name((event) => "num" in event === false && "parentSeqNum" in event === false, "isPartialEventDef");
var makeEventDefSchema = /* @__PURE__ */ __name((schema4) => Schema_exports2.Union(...[...schema4.eventsDefsMap.values()].map((def) => Schema_exports2.Struct({
  name: Schema_exports2.Literal(def.name),
  args: def.schema,
  seqNum: EventSequenceNumber,
  parentSeqNum: EventSequenceNumber,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String
}))).annotations({ title: "EventDef" }), "makeEventDefSchema");
var makeEventDefPartialSchema = /* @__PURE__ */ __name((schema4) => Schema_exports2.Union(...[...schema4.eventsDefsMap.values()].map((def) => Schema_exports2.Struct({
  name: Schema_exports2.Literal(def.name),
  args: def.schema
}))).annotations({ title: "EventDefPartial" }), "makeEventDefPartialSchema");
var makeEventDefSchemaMemo = memoizeByRef(makeEventDefSchema);
var encodedFromGlobal = /* @__PURE__ */ __name((event) => ({
  ...event,
  seqNum: fromGlobal(event.seqNum),
  parentSeqNum: fromGlobal(event.parentSeqNum)
}), "encodedFromGlobal");
var EncodedWithMeta = class _EncodedWithMeta extends Schema_exports2.Class("LiveStoreEvent.EncodedWithMeta")({
  name: Schema_exports2.String,
  args: Schema_exports2.Any,
  seqNum: EventSequenceNumber,
  parentSeqNum: EventSequenceNumber,
  clientId: Schema_exports2.String,
  sessionId: Schema_exports2.String,
  // TODO get rid of `meta` again by cleaning up the usage implementations
  meta: Schema_exports2.Struct({
    sessionChangeset: Schema_exports2.Union(Schema_exports2.TaggedStruct("sessionChangeset", {
      data: Schema_exports2.Uint8Array,
      debug: Schema_exports2.Any.pipe(Schema_exports2.optional)
    }), Schema_exports2.TaggedStruct("no-op", {}), Schema_exports2.TaggedStruct("unset", {})),
    syncMetadata: Schema_exports2.Option(Schema_exports2.JsonValue),
    /** Used to detect if the materializer is side effecting (during dev) */
    materializerHashLeader: Schema_exports2.Option(Schema_exports2.Number),
    materializerHashSession: Schema_exports2.Option(Schema_exports2.Number)
  }).pipe(Schema_exports2.mutable, Schema_exports2.optional, Schema_exports2.withDefaults({
    constructor: /* @__PURE__ */ __name(() => ({
      sessionChangeset: { _tag: "unset" },
      syncMetadata: Option_exports.none(),
      materializerHashLeader: Option_exports.none(),
      materializerHashSession: Option_exports.none()
    }), "constructor"),
    decoding: /* @__PURE__ */ __name(() => ({
      sessionChangeset: { _tag: "unset" },
      syncMetadata: Option_exports.none(),
      materializerHashLeader: Option_exports.none(),
      materializerHashSession: Option_exports.none()
    }), "decoding")
  }))
}) {
  static {
    __name(this, "EncodedWithMeta");
  }
  toJSON = /* @__PURE__ */ __name(() => {
    return {
      seqNum: `${toString4(this.seqNum)} \u2192 ${toString4(this.parentSeqNum)} (${this.clientId}, ${this.sessionId})`,
      name: this.name,
      args: this.args
    };
  }, "toJSON");
  /**
   * Example: (global event)
   * For event e2  e1 which should be rebased on event e3  e2
   * the resulting event num will be e4  e3
   *
   * Example: (client event)
   * For event e2+1  e2 which should be rebased on event e3  e2
   * the resulting event num will be e3+1  e3
   *
   * Syntax: e2+2  e2+1
   *          ^ ^    ^ ^
   *          | |    | +- client parent number
   *          | |    +--- global parent number
   *          | +-- client number
   *          +---- global number
   * Client num is ommitted for global events
   */
  rebase = /* @__PURE__ */ __name(({ parentSeqNum, isClient, rebaseGeneration }) => new _EncodedWithMeta({
    ...this,
    ...nextPair({ seqNum: parentSeqNum, isClient, rebaseGeneration })
  }), "rebase");
  static fromGlobal = /* @__PURE__ */ __name((event, meta) => new _EncodedWithMeta({
    ...event,
    seqNum: {
      global: event.seqNum,
      client: clientDefault,
      rebaseGeneration: rebaseGenerationDefault
    },
    parentSeqNum: {
      global: event.parentSeqNum,
      client: clientDefault,
      rebaseGeneration: rebaseGenerationDefault
    },
    meta: {
      sessionChangeset: { _tag: "unset" },
      syncMetadata: meta.syncMetadata,
      materializerHashLeader: meta.materializerHashLeader,
      materializerHashSession: meta.materializerHashSession
    }
  }), "fromGlobal");
  toGlobal = /* @__PURE__ */ __name(() => ({
    ...this,
    seqNum: this.seqNum.global,
    parentSeqNum: this.parentSeqNum.global
  }), "toGlobal");
};
var isEqualEncoded = /* @__PURE__ */ __name((a, b) => a.seqNum.global === b.seqNum.global && a.seqNum.client === b.seqNum.client && a.name === b.name && a.clientId === b.clientId && a.sessionId === b.sessionId && JSON.stringify(a.args) === JSON.stringify(b.args), "isEqualEncoded");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/schema.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/client-document-def.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/mod.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/ast/sqlite.js
var sqlite_exports = {};
__export(sqlite_exports, {
  column: () => column,
  dbSchema: () => dbSchema,
  hash: () => hash4,
  index: () => index,
  structSchemaForTable: () => structSchemaForTable,
  table: () => table4
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/hash.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var hashCode = /* @__PURE__ */ __name((str) => {
  let hash5 = 0;
  let i;
  let chr;
  if (str.length === 0)
    return hash5;
  for (i = 0; i < str.length; i++) {
    chr = str.charCodeAt(i);
    hash5 = (hash5 << 5) - hash5 + chr;
    hash5 = Math.trunc(hash5);
  }
  return hash5;
}, "hashCode");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/ast/sqlite.js
var column = /* @__PURE__ */ __name((props) => ({ _tag: "column", ...props }), "column");
var index = /* @__PURE__ */ __name((columns, name, unique, primaryKey) => ({
  _tag: "index",
  columns,
  name,
  unique,
  primaryKey
}), "index");
var table4 = /* @__PURE__ */ __name((name, columns, indexes) => ({
  _tag: "table",
  name,
  columns,
  indexes
}), "table");
var dbSchema = /* @__PURE__ */ __name((tables2) => ({ _tag: "dbSchema", tables: tables2 }), "dbSchema");
var hash4 = /* @__PURE__ */ __name((obj) => hashCode(JSON.stringify(trimInfoForHasing(obj))), "hash");
var trimInfoForHasing = /* @__PURE__ */ __name((obj) => {
  switch (obj._tag) {
    case "table": {
      return {
        _tag: "table",
        name: obj.name,
        columns: obj.columns.map((column4) => trimInfoForHasing(column4)),
        indexes: obj.indexes.map((index2) => trimInfoForHasing(index2))
      };
    }
    case "column": {
      return {
        _tag: "column",
        name: obj.name,
        type: obj.type._tag,
        primaryKey: obj.primaryKey,
        nullable: obj.nullable,
        autoIncrement: obj.autoIncrement,
        default: obj.default
      };
    }
    case "index": {
      return {
        _tag: "index",
        columns: obj.columns,
        name: obj.name,
        unique: obj.unique,
        primaryKey: obj.primaryKey
      };
    }
    case "foreignKey": {
      return {
        _tag: "foreignKey",
        references: obj.references,
        key: obj.key,
        columns: obj.columns
      };
    }
    case "dbSchema": {
      return {
        _tag: "dbSchema",
        tables: obj.tables.map(trimInfoForHasing)
      };
    }
    default: {
      throw new Error(`Unreachable: ${obj}`);
    }
  }
}, "trimInfoForHasing");
var structSchemaForTable = /* @__PURE__ */ __name((tableDef) => Schema_exports2.Struct(Object.fromEntries(tableDef.columns.map((column4) => [column4.name, column4.schema]))), "structSchemaForTable");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/dsl/mod.js
var mod_exports2 = {};
__export(mod_exports2, {
  NoDefault: () => NoDefault,
  blob: () => blob,
  boolean: () => boolean4,
  column: () => column2,
  datetime: () => datetime,
  datetimeInteger: () => datetimeInteger,
  defaultSchemaForColumnType: () => defaultSchemaForColumnType,
  insertStructSchemaForTable: () => insertStructSchemaForTable,
  integer: () => integer3,
  isColumnDefinition: () => isColumnDefinition,
  isSqlDefaultValue: () => isSqlDefaultValue,
  json: () => json6,
  makeDbSchema: () => makeDbSchema,
  real: () => real,
  structSchemaForTable: () => structSchemaForTable2,
  table: () => table5,
  text: () => text5
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/dsl/field-defs.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isColumnDefinition = /* @__PURE__ */ __name((value6) => {
  const validColumnTypes = ["text", "integer", "real", "blob"];
  return typeof value6 === "object" && value6 !== null && "columnType" in value6 && validColumnTypes.includes(value6.columnType);
}, "isColumnDefinition");
var NoDefault = Symbol.for("NoDefault");
var isSqlDefaultValue = /* @__PURE__ */ __name((value6) => {
  return typeof value6 === "object" && value6 !== null && "sql" in value6 && typeof value6.sql === "string";
}, "isSqlDefaultValue");
var makeColDef = /* @__PURE__ */ __name((columnType) => (def) => {
  const nullable = def?.nullable ?? false;
  const schemaWithoutNull = def?.schema ?? defaultSchemaForColumnType(columnType);
  const schema4 = nullable === true ? Schema_exports2.NullOr(schemaWithoutNull) : schemaWithoutNull;
  const default_ = def?.default === void 0 || def.default === NoDefault ? Option_exports.none() : Option_exports.some(def.default);
  return {
    columnType,
    schema: schema4,
    default: default_,
    nullable,
    primaryKey: def?.primaryKey ?? false,
    autoIncrement: def?.autoIncrement ?? false
  };
}, "makeColDef");
var column2 = /* @__PURE__ */ __name((columnType) => makeColDef(columnType), "column");
var text5 = makeColDef("text");
var integer3 = makeColDef("integer");
var real = makeColDef("real");
var blob = makeColDef("blob");
var makeSpecializedColDef = /* @__PURE__ */ __name((columnType, opts) => (def) => {
  const nullable = def?.nullable ?? false;
  const schemaWithoutNull = opts._tag === "baseSchemaFn" ? opts.baseSchemaFn(def?.schema) : opts.baseSchema;
  const schema4 = nullable === true ? Schema_exports2.NullOr(schemaWithoutNull) : schemaWithoutNull;
  const default_ = def?.default === void 0 || def.default === NoDefault ? Option_exports.none() : Option_exports.some(def.default);
  return {
    columnType,
    schema: schema4,
    default: default_,
    nullable,
    primaryKey: def?.primaryKey ?? false,
    autoIncrement: def?.autoIncrement ?? false
  };
}, "makeSpecializedColDef");
var json6 = makeSpecializedColDef("text", {
  _tag: "baseSchemaFn",
  baseSchemaFn: /* @__PURE__ */ __name((customSchema) => Schema_exports2.parseJson(customSchema ?? Schema_exports2.Any), "baseSchemaFn")
});
var datetime = makeSpecializedColDef("text", {
  _tag: "baseSchema",
  baseSchema: Schema_exports2.Date
});
var datetimeInteger = makeSpecializedColDef("integer", {
  _tag: "baseSchema",
  baseSchema: Schema_exports2.transform(Schema_exports2.Number, Schema_exports2.DateFromSelf, {
    decode: /* @__PURE__ */ __name((ms) => new Date(ms), "decode"),
    encode: /* @__PURE__ */ __name((date4) => date4.getTime(), "encode")
  })
});
var boolean4 = makeSpecializedColDef("integer", {
  _tag: "baseSchema",
  baseSchema: Schema_exports2.transform(Schema_exports2.Number, Schema_exports2.Boolean, {
    decode: /* @__PURE__ */ __name((_) => _ === 1, "decode"),
    encode: /* @__PURE__ */ __name((_) => _ ? 1 : 0, "encode")
  })
});
var defaultSchemaForColumnType = /* @__PURE__ */ __name((columnType) => {
  switch (columnType) {
    case "text": {
      return Schema_exports2.String;
    }
    case "integer": {
      return Schema_exports2.Number;
    }
    case "real": {
      return Schema_exports2.Number;
    }
    case "blob": {
      return Schema_exports2.Uint8ArrayFromSelf;
    }
    default: {
      return casesHandled(columnType);
    }
  }
}, "defaultSchemaForColumnType");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/db-schema/dsl/mod.js
var makeDbSchema = /* @__PURE__ */ __name((schema4) => {
  return Array.isArray(schema4) ? Object.fromEntries(schema4.map((_) => [_.name, _])) : schema4;
}, "makeDbSchema");
var table5 = /* @__PURE__ */ __name((name, columns, indexes) => {
  const ast = {
    _tag: "table",
    name,
    columns: columsToAst(columns),
    indexes: indexesToAst(indexes ?? [])
  };
  return { name, columns, indexes, ast };
}, "table");
var structSchemaForTable2 = /* @__PURE__ */ __name((tableDef) => Schema_exports2.Struct(Object.fromEntries(tableDef.ast.columns.map((column4) => [column4.name, column4.schema]))).annotations({
  title: tableDef.name
}), "structSchemaForTable");
var insertStructSchemaForTable = /* @__PURE__ */ __name((tableDef) => Schema_exports2.Struct(Object.fromEntries(tableDef.ast.columns.map((column4) => [
  column4.name,
  column4.nullable === true || column4.default._tag === "Some" ? Schema_exports2.optional(column4.schema) : column4.schema
]))).annotations({
  title: tableDef.name
}), "insertStructSchemaForTable");
var columsToAst = /* @__PURE__ */ __name((columns) => {
  return Object.entries(columns).map(([name, column4]) => {
    return {
      _tag: "column",
      name,
      schema: column4.schema,
      default: column4.default,
      nullable: column4.nullable ?? false,
      primaryKey: column4.primaryKey ?? false,
      autoIncrement: column4.autoIncrement ?? false,
      type: { _tag: column4.columnType }
    };
  });
}, "columsToAst");
var indexesToAst = /* @__PURE__ */ __name((indexes) => {
  return indexes.map((_) => ({ _tag: "index", columns: _.columns, name: _.name, unique: _.isUnique ?? false }));
}, "indexesToAst");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/query-builder/api.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var QueryBuilderAstSymbol = Symbol.for("QueryBuilderAst");
var QueryBuilderResultSymbol = Symbol.for("QueryBuilderResult");
var QueryBuilderTypeId = Symbol.for("QueryBuilder");
var isQueryBuilder = /* @__PURE__ */ __name((value6) => Predicate_exports.hasProperty(value6, QueryBuilderTypeId), "isQueryBuilder");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/query-builder/impl.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/query-builder/astToSql.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var formatWhereClause = /* @__PURE__ */ __name((whereConditions, tableDef, bindValues) => {
  if (whereConditions.length === 0)
    return "";
  const whereClause = whereConditions.map(({ col, op, value: value6 }) => {
    if (value6 === null) {
      if (op !== "=" && op !== "!=") {
        throw new Error(`Unsupported operator for NULL value: ${op}`);
      }
      const opStmt = op === "=" ? "IS" : "IS NOT";
      return `${col} ${opStmt} NULL`;
    }
    const colDef = tableDef.sqliteDef.columns[col];
    if (colDef === void 0) {
      throw new Error(`Column ${col} not found`);
    }
    const isArray2 = op === "IN" || op === "NOT IN";
    if (isArray2) {
      if (!Array.isArray(value6)) {
        return shouldNeverHappen(`Expected array value for ${op} operator but got`, value6);
      }
      if (value6.length === 0) {
        return op === "IN" ? "0=1" : "1=1";
      }
      const encodedValues = value6.map((v) => Schema_exports2.encodeSync(colDef.schema)(v));
      bindValues.push(...encodedValues);
      const placeholders = encodedValues.map(() => "?").join(", ");
      return `${col} ${op} (${placeholders})`;
    } else {
      const encodedValue = Schema_exports2.encodeSync(colDef.schema)(value6);
      bindValues.push(encodedValue);
      return `${col} ${op} ?`;
    }
  }).join(" AND ");
  return `WHERE ${whereClause}`;
}, "formatWhereClause");
var formatReturningClause = /* @__PURE__ */ __name((returning) => {
  if (!returning || returning.length === 0)
    return "";
  return ` RETURNING ${returning.join(", ")}`;
}, "formatReturningClause");
var astToSql = /* @__PURE__ */ __name((ast) => {
  const bindValues = [];
  const usedTables = /* @__PURE__ */ new Set([ast.tableDef.sqliteDef.name]);
  if (ast._tag === "InsertQuery") {
    const columns = Object.keys(ast.values);
    const placeholders = columns.map(() => "?").join(", ");
    const encodedValues = Schema_exports2.encodeSync(ast.tableDef.insertSchema)(ast.values);
    columns.forEach((col) => {
      bindValues.push(encodedValues[col]);
    });
    let insertVerb = "INSERT";
    let conflictClause = "";
    if (ast.onConflict) {
      if (ast.onConflict.action._tag === "replace") {
        insertVerb = "INSERT OR REPLACE";
      } else {
        conflictClause = ` ON CONFLICT (${ast.onConflict.targets.join(", ")}) `;
        if (ast.onConflict.action._tag === "ignore") {
          conflictClause += "DO NOTHING";
        } else {
          const updateValues = ast.onConflict.action.update;
          const updateCols = Object.keys(updateValues);
          if (updateCols.length === 0) {
            throw new Error("No update columns provided for ON CONFLICT DO UPDATE");
          }
          const updates = updateCols.map((col) => {
            const value6 = updateValues[col];
            return value6 === void 0 ? `${col} = excluded.${col}` : `${col} = ?`;
          }).join(", ");
          updateCols.forEach((col) => {
            const value6 = updateValues[col];
            if (value6 !== void 0) {
              const colDef = ast.tableDef.sqliteDef.columns[col];
              if (colDef === void 0) {
                throw new Error(`Column ${col} not found`);
              }
              const encodedValue = Schema_exports2.encodeSync(colDef.schema)(value6);
              bindValues.push(encodedValue);
            }
          });
          conflictClause += `DO UPDATE SET ${updates}`;
        }
      }
    }
    let query2 = `${insertVerb} INTO '${ast.tableDef.sqliteDef.name}' (${columns.join(", ")}) VALUES (${placeholders})`;
    query2 += conflictClause;
    query2 += formatReturningClause(ast.returning);
    return { query: query2, bindValues, usedTables };
  }
  if (ast._tag === "UpdateQuery") {
    const setColumns = Object.keys(ast.values);
    if (setColumns.length === 0) {
      console.warn(`UPDATE query requires at least one column to set (for table ${ast.tableDef.sqliteDef.name}). Running no-op query instead to skip this update query.`);
      return { query: "SELECT 1", bindValues: [], usedTables };
    }
    const encodedValues = Schema_exports2.encodeSync(Schema_exports2.partial(ast.tableDef.rowSchema))(ast.values);
    setColumns.forEach((col) => {
      bindValues.push(encodedValues[col]);
    });
    let query2 = `UPDATE '${ast.tableDef.sqliteDef.name}' SET ${setColumns.map((col) => `${col} = ?`).join(", ")}`;
    const whereClause = formatWhereClause(ast.where, ast.tableDef, bindValues);
    if (whereClause)
      query2 += ` ${whereClause}`;
    query2 += formatReturningClause(ast.returning);
    return { query: query2, bindValues, usedTables };
  }
  if (ast._tag === "DeleteQuery") {
    let query2 = `DELETE FROM '${ast.tableDef.sqliteDef.name}'`;
    const whereClause = formatWhereClause(ast.where, ast.tableDef, bindValues);
    if (whereClause)
      query2 += ` ${whereClause}`;
    query2 += formatReturningClause(ast.returning);
    return { query: query2, bindValues, usedTables };
  }
  if (ast._tag === "CountQuery") {
    const query2 = [
      `SELECT COUNT(*) as count FROM '${ast.tableDef.sqliteDef.name}'`,
      formatWhereClause(ast.where, ast.tableDef, bindValues)
    ].filter((clause) => clause.length > 0).join(" ");
    return { query: query2, bindValues, usedTables };
  }
  if (ast._tag === "RowQuery") {
    const idColDef = ast.tableDef.sqliteDef.columns.id;
    if (idColDef === void 0) {
      throw new Error("Column id not found for ROW query");
    }
    const encodedId = ast.id === SessionIdSymbol ? ast.id : Schema_exports2.encodeSync(idColDef.schema)(ast.id);
    return {
      query: `SELECT * FROM '${ast.tableDef.sqliteDef.name}' WHERE id = ?`,
      bindValues: [encodedId],
      usedTables
    };
  }
  const columnsStmt = ast.select.columns.length === 0 ? "*" : ast.select.columns.join(", ");
  const selectStmt = `SELECT ${columnsStmt}`;
  const fromStmt = `FROM '${ast.tableDef.sqliteDef.name}'`;
  const whereStmt = formatWhereClause(ast.where, ast.tableDef, bindValues);
  const orderByStmt = ast.orderBy.length > 0 ? `ORDER BY ${ast.orderBy.map(({ col, direction }) => `${col} ${direction}`).join(", ")}` : "";
  const limitStmt = ast.limit._tag === "Some" ? `LIMIT ?` : "";
  const offsetStmt = ast.offset._tag === "Some" ? `OFFSET ?` : "";
  if (ast.offset._tag === "Some")
    bindValues.push(ast.offset.value);
  if (ast.limit._tag === "Some")
    bindValues.push(ast.limit.value);
  const query = [selectStmt, fromStmt, whereStmt, orderByStmt, offsetStmt, limitStmt].map((clause) => clause.trim()).filter((clause) => clause.length > 0).join(" ");
  return { query, bindValues, usedTables };
}, "astToSql");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/query-builder/impl.js
var makeQueryBuilder = /* @__PURE__ */ __name((tableDef, ast = emptyAst(tableDef)) => {
  const api = {
    select() {
      assertSelectQueryBuilderAst(ast);
      const params2 = [...arguments];
      if (params2.length === 1) {
        const [col] = params2;
        return makeQueryBuilder(tableDef, {
          ...ast,
          resultSchemaSingle: ast.resultSchemaSingle.pipe(Schema_exports2.pluck(col)),
          select: { columns: [col] }
        });
      }
      const columns = params2;
      return makeQueryBuilder(tableDef, {
        ...ast,
        resultSchemaSingle: columns.length === 0 ? ast.resultSchemaSingle : ast.resultSchemaSingle.pipe(Schema_exports2.pick(...columns)),
        select: { columns }
      });
    },
    // biome-ignore lint/complexity/useArrowFunction: prefer function over arrow function for this case
    where: /* @__PURE__ */ __name(function() {
      if (ast._tag === "InsertQuery")
        return invalidQueryBuilder("Cannot use where with insert");
      if (ast._tag === "RowQuery")
        return invalidQueryBuilder("Cannot use where with row");
      if (arguments.length === 1) {
        const params2 = arguments[0];
        const newOps = Object.entries(params2).filter(([, value7]) => value7 !== void 0).map(([col2, value7]) => Predicate_exports.hasProperty(value7, "op") && Predicate_exports.hasProperty(value7, "value") ? { col: col2, op: value7.op, value: value7.value } : { col: col2, op: "=", value: value7 });
        switch (ast._tag) {
          case "CountQuery":
          case "SelectQuery":
          case "UpdateQuery":
          case "DeleteQuery": {
            return makeQueryBuilder(tableDef, {
              ...ast,
              where: [...ast.where, ...newOps]
            });
          }
          default: {
            return casesHandled(ast);
          }
        }
      }
      const [col, opOrValue, valueOrUndefined] = arguments;
      const op = valueOrUndefined === void 0 ? "=" : opOrValue;
      const value6 = valueOrUndefined === void 0 ? opOrValue : valueOrUndefined;
      switch (ast._tag) {
        case "CountQuery":
        case "SelectQuery":
        case "UpdateQuery":
        case "DeleteQuery": {
          return makeQueryBuilder(tableDef, {
            ...ast,
            where: [...ast.where, { col, op, value: value6 }]
          });
        }
        default: {
          return casesHandled(ast);
        }
      }
    }, "where"),
    orderBy() {
      assertSelectQueryBuilderAst(ast);
      if (arguments.length === 0 || arguments.length > 2)
        return invalidQueryBuilder();
      if (arguments.length === 1) {
        const params2 = arguments[0];
        return makeQueryBuilder(tableDef, {
          ...ast,
          orderBy: [...ast.orderBy, ...params2]
        });
      }
      const [col, direction] = arguments;
      return makeQueryBuilder(tableDef, {
        ...ast,
        orderBy: [...ast.orderBy, { col, direction }]
      });
    },
    limit: /* @__PURE__ */ __name((limit) => {
      assertSelectQueryBuilderAst(ast);
      return makeQueryBuilder(tableDef, { ...ast, limit: Option_exports.some(limit) });
    }, "limit"),
    offset: /* @__PURE__ */ __name((offset) => {
      assertSelectQueryBuilderAst(ast);
      return makeQueryBuilder(tableDef, { ...ast, offset: Option_exports.some(offset) });
    }, "offset"),
    count: /* @__PURE__ */ __name(() => {
      if (isRowQuery(ast) || ast._tag === "InsertQuery" || ast._tag === "UpdateQuery" || ast._tag === "DeleteQuery")
        return invalidQueryBuilder();
      return makeQueryBuilder(tableDef, {
        _tag: "CountQuery",
        tableDef,
        where: ast.where,
        resultSchema: Schema_exports2.Struct({ count: Schema_exports2.Number }).pipe(Schema_exports2.pluck("count"), Schema_exports2.Array, Schema_exports2.headOrElse())
      });
    }, "count"),
    first: /* @__PURE__ */ __name((behaviour) => {
      assertSelectQueryBuilderAst(ast);
      if (ast.limit._tag === "Some")
        return invalidQueryBuilder(`.first() can't be called after .limit()`);
      return makeQueryBuilder(tableDef, {
        ...ast,
        limit: Option_exports.some(1),
        pickFirst: { _tag: "enabled", ...behaviour ?? { behaviour: "undefined" } }
      });
    }, "first"),
    //
    // getOrCreate() {
    //   if (tableDef.options.isClientDocumentTable === false) {
    //     return invalidQueryBuilder(`getOrCreate() is not allowed when table is not a client document table`)
    //   }
    //
    //   const params = [...arguments]
    //   let id: string | number
    //   // TODO refactor to handle default id
    //   id = params[0] as string | number
    //   if (id === undefined) {
    //     invalidQueryBuilder(`Id missing for row query on non-singleton table ${tableDef.sqliteDef.name}`)
    //   }
    //   // TODO validate all required columns are present and values are matching the schema
    //   const insertValues: Record<string, unknown> = params[1]?.insertValues ?? {}
    //   return makeQueryBuilder(tableDef, {
    //     _tag: 'RowQuery',
    //     id,
    //     tableDef,
    //     insertValues,
    //   }) as any
    // },
    insert: /* @__PURE__ */ __name((values6) => {
      const filteredValues = Object.fromEntries(Object.entries(values6).filter(([, value6]) => value6 !== void 0));
      return makeQueryBuilder(tableDef, {
        _tag: "InsertQuery",
        tableDef,
        values: filteredValues,
        onConflict: void 0,
        returning: void 0,
        resultSchema: Schema_exports2.Void
      });
    }, "insert"),
    onConflict: /* @__PURE__ */ __name((targetOrTargets, action, updateValues) => {
      const targets = Array.isArray(targetOrTargets) ? targetOrTargets : [targetOrTargets];
      assertInsertQueryBuilderAst(ast);
      const onConflict = Match_exports.value(action).pipe(Match_exports.when("ignore", () => ({ targets, action: { _tag: "ignore" } })), Match_exports.when("replace", () => ({ targets, action: { _tag: "replace" } })), Match_exports.when("update", () => ({ targets, action: { _tag: "update", update: updateValues } })), Match_exports.exhaustive);
      return makeQueryBuilder(tableDef, {
        ...ast,
        onConflict
      });
    }, "onConflict"),
    returning: /* @__PURE__ */ __name((...columns) => {
      assertWriteQueryBuilderAst(ast);
      return makeQueryBuilder(tableDef, {
        ...ast,
        returning: columns,
        resultSchema: tableDef.rowSchema.pipe(Schema_exports2.pick(...columns), Schema_exports2.Array)
      });
    }, "returning"),
    update: /* @__PURE__ */ __name((values6) => {
      const filteredValues = Object.fromEntries(Object.entries(values6).filter(([, value6]) => value6 !== void 0));
      return makeQueryBuilder(tableDef, {
        _tag: "UpdateQuery",
        tableDef,
        values: filteredValues,
        where: [],
        returning: void 0,
        resultSchema: Schema_exports2.Void
      });
    }, "update"),
    delete: /* @__PURE__ */ __name(() => {
      return makeQueryBuilder(tableDef, {
        _tag: "DeleteQuery",
        tableDef,
        where: [],
        returning: void 0,
        resultSchema: Schema_exports2.Void
      });
    }, "delete")
  };
  return {
    [QueryBuilderTypeId]: QueryBuilderTypeId,
    [QueryBuilderAstSymbol]: ast,
    ResultType: "only-for-type-inference",
    asSql: /* @__PURE__ */ __name(() => astToSql(ast), "asSql"),
    toString: /* @__PURE__ */ __name(() => {
      try {
        return astToSql(ast).query;
      } catch (cause3) {
        console.debug(`QueryBuilder.toString(): Error converting query builder to string`, cause3, ast);
        return `Error converting query builder to string`;
      }
    }, "toString"),
    ...api
  };
}, "makeQueryBuilder");
var emptyAst = /* @__PURE__ */ __name((tableDef) => ({
  _tag: "SelectQuery",
  columns: [],
  pickFirst: { _tag: "disabled" },
  select: { columns: [] },
  orderBy: [],
  offset: Option_exports.none(),
  limit: Option_exports.none(),
  tableDef,
  where: [],
  resultSchemaSingle: tableDef.rowSchema
}), "emptyAst");
function assertSelectQueryBuilderAst(ast) {
  if (ast._tag !== "SelectQuery") {
    return shouldNeverHappen(`Expected SelectQuery but got ${ast._tag}`);
  }
}
__name(assertSelectQueryBuilderAst, "assertSelectQueryBuilderAst");
function assertInsertQueryBuilderAst(ast) {
  if (ast._tag !== "InsertQuery") {
    return shouldNeverHappen(`Expected InsertQuery but got ${ast._tag}`);
  }
}
__name(assertInsertQueryBuilderAst, "assertInsertQueryBuilderAst");
function assertWriteQueryBuilderAst(ast) {
  if (ast._tag !== "InsertQuery" && ast._tag !== "UpdateQuery" && ast._tag !== "DeleteQuery") {
    return shouldNeverHappen(`Expected WriteQuery but got ${ast._tag}`);
  }
}
__name(assertWriteQueryBuilderAst, "assertWriteQueryBuilderAst");
var isRowQuery = /* @__PURE__ */ __name((ast) => ast._tag === "RowQuery", "isRowQuery");
var invalidQueryBuilder = /* @__PURE__ */ __name((msg) => {
  return shouldNeverHappen(`Invalid query builder${msg ? `: ${msg}` : ""}`);
}, "invalidQueryBuilder");
var getResultSchema = /* @__PURE__ */ __name((qb) => {
  const queryAst = qb[QueryBuilderAstSymbol];
  switch (queryAst._tag) {
    case "SelectQuery": {
      const arraySchema = Schema_exports2.Array(queryAst.resultSchemaSingle);
      if (queryAst.pickFirst._tag === "disabled") {
        return arraySchema;
      } else if (queryAst.pickFirst.behaviour === "undefined") {
        const arraySchema2 = Schema_exports2.Array(Schema_exports2.UndefinedOr(queryAst.resultSchemaSingle));
        return arraySchema2.pipe(Schema_exports2.headOrElse(() => void 0));
      } else if (queryAst.pickFirst.behaviour === "error") {
        return arraySchema.pipe(Schema_exports2.headOrElse());
      } else {
        const fallbackValue = queryAst.pickFirst.fallback();
        return Schema_exports2.Union(arraySchema, Schema_exports2.Tuple(Schema_exports2.Literal(fallbackValue))).pipe(Schema_exports2.headOrElse(() => fallbackValue));
      }
    }
    case "CountQuery": {
      return Schema_exports2.Struct({ count: Schema_exports2.Number }).pipe(Schema_exports2.pluck("count"), Schema_exports2.Array, Schema_exports2.headOrElse());
    }
    case "InsertQuery":
    case "UpdateQuery":
    case "DeleteQuery": {
      if (queryAst.returning && queryAst.returning.length > 0) {
        return queryAst.tableDef.rowSchema.pipe(Schema_exports2.pick(...queryAst.returning), Schema_exports2.Array);
      }
      return Schema_exports2.Number;
    }
    case "RowQuery": {
      return queryAst.tableDef.rowSchema.pipe(Schema_exports2.pluck("value"), Schema_exports2.annotations({ title: `${queryAst.tableDef.sqliteDef.name}.value` }), Schema_exports2.Array, Schema_exports2.headOrElse());
    }
    default: {
      casesHandled(queryAst);
    }
  }
}, "getResultSchema");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/table-def.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/column-def.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/column-annotations.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PrimaryKeyId = Symbol.for("livestore/state/sqlite/annotations/primary-key");
var ColumnType = Symbol.for("livestore/state/sqlite/annotations/column-type");
var Default2 = Symbol.for("livestore/state/sqlite/annotations/default");
var AutoIncrement = Symbol.for("livestore/state/sqlite/annotations/auto-increment");
var Unique = Symbol.for("livestore/state/sqlite/annotations/unique");
var withPrimaryKey = /* @__PURE__ */ __name((schema4) => schema4.annotations({ [PrimaryKeyId]: true }), "withPrimaryKey");
var withColumnType = dual(2, (schema4, type3) => {
  validateSchemaColumnTypeCompatibility(schema4, type3);
  return schema4.annotations({ [ColumnType]: type3 });
});
var withAutoIncrement = /* @__PURE__ */ __name((schema4) => schema4.annotations({ [AutoIncrement]: true }), "withAutoIncrement");
var withUnique = /* @__PURE__ */ __name((schema4) => schema4.annotations({ [Unique]: true }), "withUnique");
var withDefault3 = dual(2, (schema4, value6) => schema4.annotations({ [Default2]: value6 }));
var validateSchemaColumnTypeCompatibility = /* @__PURE__ */ __name((_schema, _columnType) => {
}, "validateSchemaColumnTypeCompatibility");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/column-def.js
var getColumnDefForSchema = /* @__PURE__ */ __name((schema4, propertySignature2, forceNullable = false) => {
  const ast = schema4.ast;
  const getAnnotation2 = /* @__PURE__ */ __name((annotationId) => propertySignature2 ? hasPropertyAnnotation(propertySignature2, annotationId) : SchemaAST_exports.getAnnotation(annotationId)(ast), "getAnnotation");
  const columnType = SchemaAST_exports.getAnnotation(ColumnType)(ast);
  const isNullable2 = forceNullable || hasNull(ast) || hasUndefined(ast);
  const baseColumn = Option_exports.isSome(columnType) ? getColumnForType(columnType.value, isNullable2) : getColumnForSchema(schema4, isNullable2);
  const primaryKey = getAnnotation2(PrimaryKeyId).pipe(Option_exports.getOrElse(() => false));
  const autoIncrement = getAnnotation2(AutoIncrement).pipe(Option_exports.getOrElse(() => false));
  const defaultValue = getAnnotation2(Default2);
  return {
    ...baseColumn,
    ...primaryKey && { primaryKey: true },
    ...autoIncrement && { autoIncrement: true },
    ...Option_exports.isSome(defaultValue) && { default: Option_exports.some(defaultValue.value) }
  };
}, "getColumnDefForSchema");
var hasPropertyAnnotation = /* @__PURE__ */ __name((propertySignature2, annotationId) => {
  if ("annotations" in propertySignature2 && propertySignature2.annotations) {
    const annotation = SchemaAST_exports.getAnnotation(annotationId)(propertySignature2);
    if (Option_exports.isSome(annotation))
      return annotation;
  }
  return SchemaAST_exports.getAnnotation(annotationId)(propertySignature2.type);
}, "hasPropertyAnnotation");
var schemaFieldsToColumns = /* @__PURE__ */ __name((propertySignatures) => {
  const columns = {};
  const uniqueColumns = [];
  for (const prop of propertySignatures) {
    if (typeof prop.name !== "string")
      continue;
    const fieldSchema = Schema_exports2.make(prop.type);
    if (prop.isOptional) {
      const { hasNull: hasNull2, hasUndefined: hasUndefined2 } = checkNullUndefined(fieldSchema.ast);
      if (hasNull2 && hasUndefined2) {
        console.warn(`Field '${prop.name}' has both null and undefined - treating | undefined as | null`);
      }
    }
    const columnDef = getColumnDefForSchema(fieldSchema, prop, prop.isOptional);
    const hasPrimaryKey = hasPropertyAnnotation(prop, PrimaryKeyId).pipe(Option_exports.getOrElse(() => false));
    const hasUnique = hasPropertyAnnotation(prop, Unique).pipe(Option_exports.getOrElse(() => false));
    columns[prop.name] = {
      ...columnDef,
      ...hasPrimaryKey && { primaryKey: true }
    };
    const column4 = columns[prop.name];
    if (column4?.primaryKey && column4.nullable) {
      throw new Error("Primary key columns cannot be nullable");
    }
    if (hasUnique)
      uniqueColumns.push(prop.name);
  }
  return { columns, uniqueColumns };
}, "schemaFieldsToColumns");
var checkNullUndefined = /* @__PURE__ */ __name((ast) => {
  let hasNull2 = false;
  let hasUndefined2 = false;
  const visit = /* @__PURE__ */ __name((type3) => {
    if (SchemaAST_exports.isUndefinedKeyword(type3))
      hasUndefined2 = true;
    else if (SchemaAST_exports.isLiteral(type3) && type3.literal === null)
      hasNull2 = true;
    else if (SchemaAST_exports.isUnion(type3))
      type3.types.forEach(visit);
  }, "visit");
  visit(ast);
  return { hasNull: hasNull2, hasUndefined: hasUndefined2 };
}, "checkNullUndefined");
var hasNull = /* @__PURE__ */ __name((ast) => {
  if (SchemaAST_exports.isLiteral(ast) && ast.literal === null)
    return true;
  if (SchemaAST_exports.isUnion(ast)) {
    return ast.types.some((type3) => hasNull(type3));
  }
  return false;
}, "hasNull");
var hasUndefined = /* @__PURE__ */ __name((ast) => {
  if (SchemaAST_exports.isUndefinedKeyword(ast))
    return true;
  if (SchemaAST_exports.isUnion(ast)) {
    return ast.types.some((type3) => hasUndefined(type3));
  }
  return false;
}, "hasUndefined");
var getColumnForType = /* @__PURE__ */ __name((columnType, nullable = false) => {
  switch (columnType) {
    case "text":
      return mod_exports2.text({ nullable });
    case "integer":
      return mod_exports2.integer({ nullable });
    case "real":
      return mod_exports2.real({ nullable });
    case "blob":
      return mod_exports2.blob({ nullable });
    default:
      return shouldNeverHappen(`Unsupported column type: ${columnType}`);
  }
}, "getColumnForType");
var getColumnForSchema = /* @__PURE__ */ __name((schema4, nullable = false) => {
  const ast = schema4.ast;
  const coreAst = stripNullable(ast);
  const coreSchema = stripNullable(ast) === ast ? schema4 : Schema_exports2.make(coreAst);
  if (SchemaAST_exports.isBooleanKeyword(coreAst)) {
    return mod_exports2.boolean({ nullable });
  }
  const encodedAst = Schema_exports2.encodedSchema(coreSchema).ast;
  if (SchemaAST_exports.isStringKeyword(encodedAst)) {
    return mod_exports2.text({ schema: coreSchema, nullable });
  }
  if (SchemaAST_exports.isNumberKeyword(encodedAst)) {
    const id4 = SchemaAST_exports.getIdentifierAnnotation(coreAst).pipe(Option_exports.getOrElse(() => ""));
    if (id4 === "Int" || id4 === "DateFromNumber") {
      return mod_exports2.integer({ schema: coreSchema, nullable });
    }
    return mod_exports2.real({ schema: coreSchema, nullable });
  }
  if (SchemaAST_exports.isLiteral(coreAst)) {
    const value6 = coreAst.literal;
    if (typeof value6 === "boolean")
      return mod_exports2.boolean({ nullable });
  }
  if (SchemaAST_exports.isLiteral(encodedAst)) {
    const value6 = encodedAst.literal;
    if (typeof value6 === "string")
      return mod_exports2.text({ schema: coreSchema, nullable });
    if (typeof value6 === "number") {
      const id4 = SchemaAST_exports.getIdentifierAnnotation(coreAst).pipe(Option_exports.getOrElse(() => ""));
      if (id4 === "Int") {
        return mod_exports2.integer({ schema: coreSchema, nullable });
      }
      return mod_exports2.real({ schema: coreSchema, nullable });
    }
  }
  return mod_exports2.json({ schema: coreSchema, nullable });
}, "getColumnForSchema");
var stripNullable = /* @__PURE__ */ __name((ast) => {
  if (!SchemaAST_exports.isUnion(ast))
    return ast;
  const core = ast.types.find((type3) => !(SchemaAST_exports.isLiteral(type3) && type3.literal === null) && !SchemaAST_exports.isUndefinedKeyword(type3));
  return core || ast;
}, "stripNullable");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/table-def.js
var { blob: blob2, boolean: boolean5, column: column3, datetime: datetime2, integer: integer4, isColumnDefinition: isColumnDefinition2, json: json7, real: real2, text: text6 } = mod_exports2;
var TableDefInternalsSymbol = Symbol("TableDefInternals");
function table6(args2) {
  const { ...options4 } = args2;
  let tableName;
  let columns;
  let additionalIndexes = [];
  if ("columns" in args2) {
    tableName = args2.name;
    const columnOrColumns = args2.columns;
    columns = mod_exports2.isColumnDefinition(columnOrColumns) ? { value: columnOrColumns } : columnOrColumns;
    additionalIndexes = [];
  } else if ("schema" in args2) {
    const result = schemaFieldsToColumns(SchemaAST_exports.getPropertySignatures(args2.schema.ast));
    columns = result.columns;
    let tempTableName;
    if ("name" in args2) {
      tempTableName = args2.name;
    } else {
      tempTableName = SchemaAST_exports.getTitleAnnotation(args2.schema.ast).pipe(Option_exports.orElse(() => SchemaAST_exports.getIdentifierAnnotation(args2.schema.ast)), Option_exports.getOrElse(() => shouldNeverHappen("When using schema without explicit name, the schema must have a title or identifier annotation")));
    }
    tableName = tempTableName;
    additionalIndexes = (result.uniqueColumns || []).map((columnName) => ({
      name: `idx_${tableName}_${columnName}_unique`,
      columns: [columnName],
      isUnique: true
    }));
  } else {
    return shouldNeverHappen("Either `columns` or `schema` must be provided when calling `table()`");
  }
  const options_ = {
    isClientDocumentTable: false
  };
  const allIndexes = [...options4?.indexes ?? [], ...additionalIndexes];
  const sqliteDef = mod_exports2.table(tableName, columns, allIndexes);
  const rowSchema = mod_exports2.structSchemaForTable(sqliteDef);
  const insertSchema = mod_exports2.insertStructSchemaForTable(sqliteDef);
  const tableDef = {
    sqliteDef,
    options: options_,
    rowSchema,
    insertSchema
  };
  const query = makeQueryBuilder(tableDef);
  for (const key of Object.keys(query)) {
    tableDef[key] = query[key];
  }
  tableDef[QueryBuilderAstSymbol] = query[QueryBuilderAstSymbol];
  tableDef[QueryBuilderTypeId] = query[QueryBuilderTypeId];
  return tableDef;
}
__name(table6, "table");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/client-document-def.js
var clientDocument = /* @__PURE__ */ __name(({ name, schema: valueSchema, ...inputOptions }) => {
  const options4 = {
    partialSet: inputOptions.partialSet ?? true,
    default: {
      id: inputOptions.default.id,
      value: inputOptions.default.value
    }
  };
  const columns = {
    id: mod_exports2.text({ primaryKey: true }),
    value: mod_exports2.json({ schema: valueSchema })
  };
  const tableDef = table6({ name, columns });
  tableDef.options.isClientDocumentTable = true;
  const { eventDef: derivedSetEventDef, materializer: derivedSetMaterializer } = deriveEventAndMaterializer({
    name,
    valueSchema,
    defaultValue: options4.default.value,
    partialSet: options4.partialSet
  });
  const setEventDef = /* @__PURE__ */ __name((...args2) => {
    const [value6, id4 = options4.default.id] = args2;
    return derivedSetEventDef({ id: id4, value: value6 });
  }, "setEventDef");
  Object.defineProperty(setEventDef, "name", { value: `${name}Set` });
  Object.defineProperty(setEventDef, "schema", {
    value: Schema_exports2.Struct({
      id: Schema_exports2.String,
      value: options4.partialSet ? Schema_exports2.partial(valueSchema) : valueSchema
    }).annotations({ title: `${name}Set:Args` })
  });
  Object.defineProperty(setEventDef, "options", { value: { derived: true, clientOnly: true, facts: void 0 } });
  const clientDocumentTableDefTrait = {
    get: makeGetQueryBuilder(() => clientDocumentTableDef),
    set: setEventDef,
    Value: "only-for-type-inference",
    default: options4.default,
    valueSchema,
    [ClientDocumentTableDefSymbol]: {
      derived: {
        setEventDef: derivedSetEventDef,
        setMaterializer: derivedSetMaterializer
      },
      options: options4
    }
  };
  const clientDocumentTableDef = {
    ...tableDef,
    ...clientDocumentTableDefTrait
  };
  return clientDocumentTableDef;
}, "clientDocument");
var mergeDefaultValues = /* @__PURE__ */ __name((defaultValues, explicitDefaultValues) => {
  if (typeof defaultValues !== "object" || typeof explicitDefaultValues !== "object" || defaultValues === null || explicitDefaultValues === null) {
    return explicitDefaultValues;
  }
  const allKeys = /* @__PURE__ */ new Set([...Object.keys(defaultValues), ...Object.keys(explicitDefaultValues)]);
  return Array.from(allKeys).reduce((acc, key) => {
    acc[key] = explicitDefaultValues[key] ?? defaultValues[key];
    return acc;
  }, {});
}, "mergeDefaultValues");
var deriveEventAndMaterializer = /* @__PURE__ */ __name(({ name, valueSchema, defaultValue, partialSet }) => {
  const derivedSetEventDef = defineEvent({
    name: `${name}Set`,
    schema: Schema_exports2.Struct({
      id: Schema_exports2.Union(Schema_exports2.String, Schema_exports2.UniqueSymbolFromSelf(SessionIdSymbol)),
      value: partialSet ? Schema_exports2.partial(valueSchema) : valueSchema
    }).annotations({ title: `${name}Set:Args` }),
    clientOnly: true,
    derived: true
  });
  const derivedSetMaterializer = defineMaterializer(derivedSetEventDef, ({ id: id4, value: value6 }) => {
    if (id4 === SessionIdSymbol) {
      return shouldNeverHappen(`SessionIdSymbol needs to be replaced before materializing the set event`);
    }
    const schemaProps = SchemaAST_exports.getPropertySignatures(valueSchema.ast);
    if (schemaProps.length === 0 || partialSet === false) {
      const valueColJsonSchema = Schema_exports2.parseJson(valueSchema);
      const encodedInsertValue = Schema_exports2.encodeSyncDebug(valueColJsonSchema)(value6 ?? defaultValue);
      const encodedUpdateValue = Schema_exports2.encodeSyncDebug(valueColJsonSchema)(value6);
      return {
        sql: `INSERT INTO '${name}' (id, value) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET value = ?`,
        bindValues: [id4, encodedInsertValue, encodedUpdateValue],
        writeTables: /* @__PURE__ */ new Set([name])
      };
    } else {
      const valueColJsonSchema = Schema_exports2.parseJson(Schema_exports2.partial(valueSchema));
      const encodedInsertValue = Schema_exports2.encodeSyncDebug(valueColJsonSchema)(mergeDefaultValues(defaultValue, value6));
      let jsonSetSql = "value";
      const setBindValues = [];
      const keys6 = Object.keys(value6);
      const partialUpdateSchema = valueSchema.pipe(Schema_exports2.pick(...keys6));
      const encodedPartialUpdate = Schema_exports2.encodeSyncDebug(partialUpdateSchema)(value6);
      for (const key in encodedPartialUpdate) {
        const encodedValueForKey = encodedPartialUpdate[key];
        if (encodedValueForKey === void 0) {
          continue;
        }
        jsonSetSql = `json_set(${jsonSetSql}, ?, json(?))`;
        setBindValues.push(`$.${key}`, JSON.stringify(encodedValueForKey));
      }
      const onConflictClause = setBindValues.length > 0 ? `ON CONFLICT (id) DO UPDATE SET value = ${jsonSetSql}` : "ON CONFLICT (id) DO NOTHING";
      const sqlQuery = `
      INSERT INTO '${name}' (id, value)
      VALUES (?, ?)
      ${onConflictClause}
    `;
      return {
        sql: sqlQuery,
        bindValues: [id4, encodedInsertValue, ...setBindValues],
        writeTables: /* @__PURE__ */ new Set([name])
      };
    }
  });
  return { eventDef: derivedSetEventDef, materializer: derivedSetMaterializer };
}, "deriveEventAndMaterializer");
var tableIsClientDocumentTable = /* @__PURE__ */ __name((tableDef) => tableDef.options.isClientDocumentTable === true, "tableIsClientDocumentTable");
var makeGetQueryBuilder = /* @__PURE__ */ __name((getTableDef) => {
  return ((...args2) => {
    const tableDef = getTableDef();
    const [id4 = tableDef[ClientDocumentTableDefSymbol].options.default.id, options4 = {}] = args2;
    const explicitDefaultValues = options4.default ?? tableDef[ClientDocumentTableDefSymbol].options.default.value;
    const ast = {
      _tag: "RowQuery",
      tableDef,
      id: id4,
      explicitDefaultValues
    };
    const query = sql`SELECT * FROM '${tableDef.sqliteDef.name}' WHERE id = ?`;
    return {
      [QueryBuilderTypeId]: QueryBuilderTypeId,
      [QueryBuilderAstSymbol]: ast,
      ResultType: "only-for-type-inference",
      asSql: /* @__PURE__ */ __name(() => ({ query, bindValues: [id4] }), "asSql"),
      toString: /* @__PURE__ */ __name(() => query.toString(), "toString"),
      ...{}
      // Needed for type cast
    };
  });
}, "makeGetQueryBuilder");
var ClientDocumentTableDefSymbol = Symbol("ClientDocumentTableDef");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/system-tables.js
var system_tables_exports = {};
__export(system_tables_exports, {
  EVENTLOG_META_TABLE: () => EVENTLOG_META_TABLE,
  SCHEMA_EVENT_DEFS_META_TABLE: () => SCHEMA_EVENT_DEFS_META_TABLE,
  SCHEMA_META_TABLE: () => SCHEMA_META_TABLE,
  SESSION_CHANGESET_META_TABLE: () => SESSION_CHANGESET_META_TABLE,
  SYNC_STATUS_TABLE: () => SYNC_STATUS_TABLE,
  eventlogMetaTable: () => eventlogMetaTable,
  eventlogSystemTables: () => eventlogSystemTables,
  isStateSystemTable: () => isStateSystemTable,
  schemaEventDefsMetaTable: () => schemaEventDefsMetaTable,
  schemaMetaTable: () => schemaMetaTable,
  sessionChangesetMetaTable: () => sessionChangesetMetaTable,
  stateSystemTables: () => stateSystemTables,
  syncStatusTable: () => syncStatusTable
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SCHEMA_META_TABLE = "__livestore_schema";
var schemaMetaTable = table6({
  name: SCHEMA_META_TABLE,
  columns: {
    tableName: mod_exports2.text({ primaryKey: true }),
    schemaHash: mod_exports2.integer({ nullable: false }),
    /** ISO date format */
    updatedAt: mod_exports2.text({ nullable: false })
  }
});
var SCHEMA_EVENT_DEFS_META_TABLE = "__livestore_schema_event_defs";
var schemaEventDefsMetaTable = table6({
  name: SCHEMA_EVENT_DEFS_META_TABLE,
  columns: {
    eventName: mod_exports2.text({ primaryKey: true }),
    schemaHash: mod_exports2.integer({ nullable: false }),
    /** ISO date format */
    updatedAt: mod_exports2.text({ nullable: false })
  }
});
var SESSION_CHANGESET_META_TABLE = "__livestore_session_changeset";
var sessionChangesetMetaTable = table6({
  name: SESSION_CHANGESET_META_TABLE,
  columns: {
    // TODO bring back primary key
    seqNumGlobal: mod_exports2.integer({ schema: GlobalEventSequenceNumber }),
    seqNumClient: mod_exports2.integer({ schema: ClientEventSequenceNumber }),
    seqNumRebaseGeneration: mod_exports2.integer({}),
    changeset: mod_exports2.blob({ nullable: true }),
    debug: mod_exports2.json({ nullable: true })
  },
  indexes: [{ columns: ["seqNumGlobal", "seqNumClient"], name: "idx_session_changeset_id" }]
});
var stateSystemTables = [schemaMetaTable, schemaEventDefsMetaTable, sessionChangesetMetaTable];
var isStateSystemTable = /* @__PURE__ */ __name((tableName) => stateSystemTables.some((_) => _.sqliteDef.name === tableName), "isStateSystemTable");
var EVENTLOG_META_TABLE = "eventlog";
var eventlogMetaTable = table6({
  name: EVENTLOG_META_TABLE,
  columns: {
    // TODO Adjust modeling so a global event never needs a client id component
    seqNumGlobal: mod_exports2.integer({ primaryKey: true, schema: GlobalEventSequenceNumber }),
    seqNumClient: mod_exports2.integer({ primaryKey: true, schema: ClientEventSequenceNumber }),
    seqNumRebaseGeneration: mod_exports2.integer({ primaryKey: true }),
    parentSeqNumGlobal: mod_exports2.integer({ schema: GlobalEventSequenceNumber }),
    parentSeqNumClient: mod_exports2.integer({ schema: ClientEventSequenceNumber }),
    parentSeqNumRebaseGeneration: mod_exports2.integer({}),
    /** Event definition name */
    name: mod_exports2.text({}),
    argsJson: mod_exports2.text({ schema: Schema_exports2.parseJson(Schema_exports2.Any) }),
    clientId: mod_exports2.text({}),
    sessionId: mod_exports2.text({}),
    schemaHash: mod_exports2.integer({}),
    syncMetadataJson: mod_exports2.text({ schema: Schema_exports2.parseJson(Schema_exports2.Option(Schema_exports2.JsonValue)) })
  },
  indexes: [
    { columns: ["seqNumGlobal"], name: "idx_eventlog_seqNumGlobal" },
    { columns: ["seqNumGlobal", "seqNumClient", "seqNumRebaseGeneration"], name: "idx_eventlog_seqNum" }
  ]
});
var SYNC_STATUS_TABLE = "__livestore_sync_status";
var syncStatusTable = table6({
  name: SYNC_STATUS_TABLE,
  columns: {
    head: mod_exports2.integer({ primaryKey: true })
  }
});
var eventlogSystemTables = [eventlogMetaTable, syncStatusTable];

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/schema.js
var LiveStoreSchemaSymbol = Symbol.for("livestore.LiveStoreSchema");
var makeSchema = /* @__PURE__ */ __name((inputSchema) => {
  const state2 = inputSchema.state;
  const tables2 = inputSchema.state.sqlite.tables;
  for (const tableDef of stateSystemTables) {
    tables2.set(tableDef.sqliteDef.name, tableDef);
  }
  const eventsDefsMap = /* @__PURE__ */ new Map();
  if (isReadonlyArray(inputSchema.events)) {
    for (const eventDef of inputSchema.events) {
      eventsDefsMap.set(eventDef.name, eventDef);
    }
  } else {
    for (const eventDef of Object.values(inputSchema.events ?? {})) {
      if (eventsDefsMap.has(eventDef.name)) {
        shouldNeverHappen(`Duplicate event name: ${eventDef.name}. Please use unique names for events.`);
      }
      eventsDefsMap.set(eventDef.name, eventDef);
    }
  }
  for (const tableDef of tables2.values()) {
    if (tableIsClientDocumentTable(tableDef) && eventsDefsMap.has(tableDef.set.name) === false) {
      eventsDefsMap.set(tableDef.set.name, tableDef.set);
    }
  }
  return {
    LiveStoreSchemaSymbol,
    _DbSchemaType: Symbol.for("livestore.DbSchemaType"),
    _EventDefMapType: Symbol.for("livestore.EventDefMapType"),
    state: state2,
    eventsDefsMap,
    devtools: {
      alias: inputSchema.devtools?.alias ?? "default"
    }
  };
}, "makeSchema");
var getEventDef = /* @__PURE__ */ __name((schema4, eventName) => {
  const eventDef = schema4.eventsDefsMap.get(eventName);
  if (eventDef === void 0) {
    return shouldNeverHappen(`No mutation definition found for \`${eventName}\`.`);
  }
  const materializer = schema4.state.materializers.get(eventName);
  if (materializer === void 0) {
    return shouldNeverHappen(`No materializer found for \`${eventName}\`.`);
  }
  return { eventDef, materializer };
}, "getEventDef");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/mod.js
var mod_exports4 = {};
__export(mod_exports4, {
  QueryBuilderAstSymbol: () => QueryBuilderAstSymbol,
  QueryBuilderTypeId: () => QueryBuilderTypeId,
  SQLite: () => mod_exports3
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/mod.js
var mod_exports3 = {};
__export(mod_exports3, {
  AutoIncrement: () => AutoIncrement,
  ClientDocumentTableDefSymbol: () => ClientDocumentTableDefSymbol,
  ColumnType: () => ColumnType,
  Default: () => Default2,
  PrimaryKeyId: () => PrimaryKeyId,
  TableDefInternalsSymbol: () => TableDefInternalsSymbol,
  Unique: () => Unique,
  blob: () => blob2,
  boolean: () => boolean5,
  clientDocument: () => clientDocument,
  clientOnly: () => clientOnly,
  column: () => column3,
  datetime: () => datetime2,
  defineEvent: () => defineEvent,
  defineFacts: () => defineFacts,
  defineMaterializer: () => defineMaterializer,
  getColumnDefForSchema: () => getColumnDefForSchema,
  integer: () => integer4,
  isColumnDefinition: () => isColumnDefinition2,
  json: () => json7,
  makeColumnSpec: () => makeColumnSpec,
  makeState: () => makeState2,
  materializers: () => materializers,
  real: () => real2,
  synced: () => synced,
  table: () => table6,
  tableIsClientDocumentTable: () => tableIsClientDocumentTable,
  text: () => text6,
  withAutoIncrement: () => withAutoIncrement,
  withColumnType: () => withColumnType,
  withDefault: () => withDefault3,
  withPrimaryKey: () => withPrimaryKey,
  withUnique: () => withUnique
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/column-spec.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeColumnSpec = /* @__PURE__ */ __name((tableAst) => {
  const primaryKeys = tableAst.columns.filter((_) => _.primaryKey).map((_) => `'${_.name}'`);
  const columnDefStrs = tableAst.columns.map(toSqliteColumnSpec);
  if (primaryKeys.length > 0) {
    columnDefStrs.push(`PRIMARY KEY (${primaryKeys.join(", ")})`);
  }
  return columnDefStrs.join(", ");
}, "makeColumnSpec");
var toSqliteColumnSpec = /* @__PURE__ */ __name((column4) => {
  const columnTypeStr = column4.type._tag;
  const nullableStr = column4.nullable === false ? "not null" : "";
  const autoIncrementStr = column4.autoIncrement ? "autoincrement" : "";
  const defaultValueStr = (() => {
    if (column4.default._tag === "None")
      return "";
    if (column4.default.value === null)
      return "default null";
    if (mod_exports2.isSqlDefaultValue(column4.default.value))
      return `default ${column4.default.value.sql}`;
    const encodeValue = Schema_exports2.encodeSync(column4.schema);
    const encodedDefaultValue = encodeValue(column4.default.value);
    if (columnTypeStr === "text")
      return `default '${encodedDefaultValue}'`;
    return `default ${encodedDefaultValue}`;
  })();
  return `'${column4.name}' ${columnTypeStr} ${nullableStr} ${autoIncrementStr} ${defaultValueStr}`;
}, "toSqliteColumnSpec");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema/state/sqlite/mod.js
var makeState2 = /* @__PURE__ */ __name((inputSchema) => {
  const inputTables = Array.isArray(inputSchema.tables) ? inputSchema.tables : Object.values(inputSchema.tables);
  const tables2 = /* @__PURE__ */ new Map();
  for (const tableDef of inputTables) {
    const sqliteDef = tableDef.sqliteDef;
    if (tables2.has(sqliteDef.ast.name)) {
      shouldNeverHappen(`Duplicate table name: ${sqliteDef.ast.name}. Please use unique names for tables.`);
    }
    tables2.set(sqliteDef.ast.name, tableDef);
  }
  for (const tableDef of stateSystemTables) {
    tables2.set(tableDef.sqliteDef.name, tableDef);
  }
  const materializers3 = /* @__PURE__ */ new Map();
  for (const [name, materializer] of Object.entries(inputSchema.materializers)) {
    materializers3.set(name, materializer);
  }
  for (const tableDef of inputTables) {
    if (tableIsClientDocumentTable(tableDef)) {
      materializers3.set(tableDef[ClientDocumentTableDefSymbol].derived.setEventDef.name, tableDef[ClientDocumentTableDefSymbol].derived.setMaterializer);
    }
  }
  const hash5 = sqlite_exports.hash({
    _tag: "dbSchema",
    tables: [...tables2.values()].map((_) => _.sqliteDef.ast)
  });
  return { sqlite: { tables: tables2, migrations: inputSchema.migrations ?? { strategy: "auto" }, hash: hash5 }, materializers: materializers3 };
}, "makeState");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/devtools/devtools-messages-common.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/version.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var liveStoreVersion = "0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f";
var liveStoreStorageFormatVersion = 5;

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/devtools/devtools-messages-common.js
var NetworkStatus = Schema_exports2.Struct({
  isConnected: Schema_exports2.Boolean,
  timestampMs: Schema_exports2.Number,
  /** Whether the network status devtools latch is closed. Used to simulate network disconnection. */
  latchClosed: Schema_exports2.Boolean
});
var requestId = Schema_exports2.String;
var clientId = Schema_exports2.String;
var sessionId = Schema_exports2.String;
var liveStoreVersion2 = Schema_exports2.Literal(liveStoreVersion);
var LSDMessage = /* @__PURE__ */ __name((tag8, fields) => Schema_exports2.TaggedStruct(tag8, {
  liveStoreVersion: liveStoreVersion2,
  ...fields
}).annotations({ identifier: tag8 }), "LSDMessage");
var LSDChannelMessage = /* @__PURE__ */ __name((tag8, fields) => LSDMessage(tag8, {
  clientId,
  ...fields
}), "LSDChannelMessage");
var LSDClientSessionChannelMessage = /* @__PURE__ */ __name((tag8, fields) => LSDMessage(tag8, {
  clientId,
  sessionId,
  ...fields
}), "LSDClientSessionChannelMessage");
var LSDClientSessionReqResMessage = /* @__PURE__ */ __name((tag8, fields) => LSDMessage(tag8, {
  clientId,
  sessionId,
  requestId,
  ...fields
}), "LSDClientSessionReqResMessage");
var LSDReqResMessage = /* @__PURE__ */ __name((tag8, fields) => LSDChannelMessage(tag8, {
  requestId,
  ...fields
}), "LSDReqResMessage");
var LeaderReqResMessage = /* @__PURE__ */ __name((tag8, fields) => {
  const Success = Schema_exports2.TaggedStruct(`${tag8}.Response.Success`, {
    requestId,
    liveStoreVersion: liveStoreVersion2,
    ...fields.success
  }).annotations({ identifier: `${tag8}.Response.Success` });
  const Error4 = fields.error ? Schema_exports2.TaggedStruct(`${tag8}.Response.Error`, {
    requestId,
    liveStoreVersion: liveStoreVersion2,
    ...fields.error
  }).annotations({ identifier: `${tag8}.Response.Error` }) : Schema_exports2.Never;
  return {
    Request: Schema_exports2.TaggedStruct(`${tag8}.Request`, {
      requestId,
      liveStoreVersion: liveStoreVersion2,
      ...fields.payload
    }).annotations({ identifier: `${tag8}.Request` }),
    Response: Schema_exports2.Union(Success, Error4),
    Success,
    Error: Error4
  };
}, "LeaderReqResMessage");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/devtools/devtools-messages-client-session.js
var DebugInfoReq = class extends LSDClientSessionReqResMessage("LSD.ClientSession.DebugInfoReq", {}) {
  static {
    __name(this, "DebugInfoReq");
  }
};
var DebugInfoRes = class extends LSDClientSessionReqResMessage("LSD.ClientSession.DebugInfoRes", {
  debugInfo: DebugInfo
}) {
  static {
    __name(this, "DebugInfoRes");
  }
};
var DebugInfoHistorySubscribe = class extends LSDClientSessionReqResMessage("LSD.ClientSession.DebugInfoHistorySubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "DebugInfoHistorySubscribe");
  }
};
var DebugInfoHistoryRes = class extends LSDClientSessionReqResMessage("LSD.ClientSession.DebugInfoHistoryRes", {
  debugInfoHistory: Schema_exports2.Array(DebugInfo),
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "DebugInfoHistoryRes");
  }
};
var DebugInfoHistoryUnsubscribe = class extends LSDClientSessionReqResMessage("LSD.ClientSession.DebugInfoHistoryUnsubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "DebugInfoHistoryUnsubscribe");
  }
};
var DebugInfoResetReq = class extends LSDClientSessionReqResMessage("LSD.ClientSession.DebugInfoResetReq", {}) {
  static {
    __name(this, "DebugInfoResetReq");
  }
};
var DebugInfoResetRes = class extends LSDClientSessionReqResMessage("LSD.ClientSession.DebugInfoResetRes", {}) {
  static {
    __name(this, "DebugInfoResetRes");
  }
};
var DebugInfoRerunQueryReq = class extends LSDClientSessionReqResMessage("LSD.ClientSession.DebugInfoRerunQueryReq", {
  queryStr: Schema_exports2.String,
  bindValues: Schema_exports2.UndefinedOr(PreparedBindValues),
  queriedTables: Schema_exports2.ReadonlySet(Schema_exports2.String)
}) {
  static {
    __name(this, "DebugInfoRerunQueryReq");
  }
};
var DebugInfoRerunQueryRes = class extends LSDClientSessionReqResMessage("LSD.ClientSession.DebugInfoRerunQueryRes", {}) {
  static {
    __name(this, "DebugInfoRerunQueryRes");
  }
};
var SyncHeadSubscribe = class extends LSDClientSessionReqResMessage("LSD.ClientSession.SyncHeadSubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "SyncHeadSubscribe");
  }
};
var SyncHeadUnsubscribe = class extends LSDClientSessionReqResMessage("LSD.ClientSession.SyncHeadUnsubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "SyncHeadUnsubscribe");
  }
};
var SyncHeadRes = class extends LSDClientSessionReqResMessage("LSD.ClientSession.SyncHeadRes", {
  local: EventSequenceNumber_exports.EventSequenceNumber,
  upstream: EventSequenceNumber_exports.EventSequenceNumber,
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "SyncHeadRes");
  }
};
var ReactivityGraphSubscribe = class extends LSDClientSessionReqResMessage("LSD.ClientSession.ReactivityGraphSubscribe", {
  includeResults: Schema_exports2.Boolean,
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "ReactivityGraphSubscribe");
  }
};
var ReactivityGraphUnsubscribe = class extends LSDClientSessionReqResMessage("LSD.ClientSession.ReactivityGraphUnsubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "ReactivityGraphUnsubscribe");
  }
};
var ReactivityGraphRes = class extends LSDClientSessionReqResMessage("LSD.ClientSession.ReactivityGraphRes", {
  reactivityGraph: Schema_exports2.Any,
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "ReactivityGraphRes");
  }
};
var LiveQueriesSubscribe = class extends LSDClientSessionReqResMessage("LSD.ClientSession.LiveQueriesSubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "LiveQueriesSubscribe");
  }
};
var LiveQueriesUnsubscribe = class extends LSDClientSessionReqResMessage("LSD.ClientSession.LiveQueriesUnsubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "LiveQueriesUnsubscribe");
  }
};
var SerializedLiveQuery = class extends Schema_exports2.Struct({
  _tag: Schema_exports2.Literal("computed", "db", "graphql", "signal"),
  id: Schema_exports2.Number,
  label: Schema_exports2.String,
  hash: Schema_exports2.String,
  runs: Schema_exports2.Number,
  executionTimes: Schema_exports2.Array(Schema_exports2.Number),
  lastestResult: Schema_exports2.Any,
  activeSubscriptions: Schema_exports2.Array(Schema_exports2.Struct({ frames: Schema_exports2.Array(Schema_exports2.Struct({ name: Schema_exports2.String, filePath: Schema_exports2.String })) }))
}) {
  static {
    __name(this, "SerializedLiveQuery");
  }
};
var LiveQueriesRes = class extends LSDClientSessionReqResMessage("LSD.ClientSession.LiveQueriesRes", {
  liveQueries: Schema_exports2.Array(SerializedLiveQuery),
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "LiveQueriesRes");
  }
};
var Ping = class extends LSDClientSessionReqResMessage("LSD.ClientSession.Ping", {}) {
  static {
    __name(this, "Ping");
  }
};
var Pong = class extends LSDClientSessionReqResMessage("LSD.ClientSession.Pong", {}) {
  static {
    __name(this, "Pong");
  }
};
var Disconnect = class extends LSDClientSessionChannelMessage("LSD.ClientSession.Disconnect", {}) {
  static {
    __name(this, "Disconnect");
  }
};
var MessageToApp = Schema_exports2.Union(DebugInfoReq, DebugInfoHistorySubscribe, DebugInfoHistoryUnsubscribe, DebugInfoResetReq, DebugInfoRerunQueryReq, ReactivityGraphSubscribe, ReactivityGraphUnsubscribe, LiveQueriesSubscribe, LiveQueriesUnsubscribe, Disconnect, Ping, SyncHeadSubscribe, SyncHeadUnsubscribe).annotations({ identifier: "LSD.ClientSession.MessageToApp" });
var MessageFromApp = Schema_exports2.Union(DebugInfoRes, DebugInfoHistoryRes, DebugInfoResetRes, DebugInfoRerunQueryRes, ReactivityGraphRes, LiveQueriesRes, Disconnect, Pong, SyncHeadRes).annotations({ identifier: "LSD.ClientSession.MessageFromApp" });

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/devtools/devtools-messages-leader.js
var devtools_messages_leader_exports = {};
__export(devtools_messages_leader_exports, {
  CommitEventReq: () => CommitEventReq,
  CommitEventRes: () => CommitEventRes,
  DatabaseFileInfo: () => DatabaseFileInfo,
  DatabaseFileInfoReq: () => DatabaseFileInfoReq,
  DatabaseFileInfoRes: () => DatabaseFileInfoRes,
  Disconnect: () => Disconnect2,
  EventlogReq: () => EventlogReq,
  EventlogRes: () => EventlogRes,
  LoadDatabaseFile: () => LoadDatabaseFile,
  MessageFromApp: () => MessageFromApp2,
  MessageToApp: () => MessageToApp2,
  NetworkStatusRes: () => NetworkStatusRes,
  NetworkStatusSubscribe: () => NetworkStatusSubscribe,
  NetworkStatusUnsubscribe: () => NetworkStatusUnsubscribe,
  Ping: () => Ping2,
  Pong: () => Pong2,
  ResetAllData: () => ResetAllData,
  ResetAllDataReq: () => ResetAllDataReq,
  SetSyncLatch: () => SetSyncLatch,
  SnapshotReq: () => SnapshotReq,
  SnapshotRes: () => SnapshotRes,
  SyncHeadRes: () => SyncHeadRes2,
  SyncHeadSubscribe: () => SyncHeadSubscribe2,
  SyncHeadUnsubscribe: () => SyncHeadUnsubscribe2,
  SyncHistoryRes: () => SyncHistoryRes,
  SyncHistorySubscribe: () => SyncHistorySubscribe,
  SyncHistoryUnsubscribe: () => SyncHistoryUnsubscribe,
  SyncPull: () => SyncPull,
  SyncingInfo: () => SyncingInfo,
  SyncingInfoReq: () => SyncingInfoReq,
  SyncingInfoRes: () => SyncingInfoRes
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/sync/syncstate.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SyncState = class extends Schema_exports2.Class("SyncState")({
  pending: Schema_exports2.Array(EncodedWithMeta),
  /** What this node expects the next upstream node to have as its own local head */
  upstreamHead: EventSequenceNumber,
  /** Equivalent to `pending.at(-1)?.id` if there are pending events */
  localHead: EventSequenceNumber
}) {
  static {
    __name(this, "SyncState");
  }
  toJSON = /* @__PURE__ */ __name(() => ({
    pending: this.pending.map((e) => e.toJSON()),
    upstreamHead: toString4(this.upstreamHead),
    localHead: toString4(this.localHead)
  }), "toJSON");
};
var PayloadUpstreamRebase = class extends Schema_exports2.TaggedStruct("upstream-rebase", {
  /** Events which need to be rolled back */
  rollbackEvents: Schema_exports2.Array(EncodedWithMeta),
  /** Events which need to be applied after the rollback (already rebased by the upstream node) */
  newEvents: Schema_exports2.Array(EncodedWithMeta)
}) {
  static {
    __name(this, "PayloadUpstreamRebase");
  }
};
var PayloadUpstreamAdvance = class extends Schema_exports2.TaggedStruct("upstream-advance", {
  newEvents: Schema_exports2.Array(EncodedWithMeta)
}) {
  static {
    __name(this, "PayloadUpstreamAdvance");
  }
};
var PayloadLocalPush = class extends Schema_exports2.TaggedStruct("local-push", {
  newEvents: Schema_exports2.Array(EncodedWithMeta)
}) {
  static {
    __name(this, "PayloadLocalPush");
  }
};
var Payload = class extends Schema_exports2.Union(PayloadUpstreamRebase, PayloadUpstreamAdvance, PayloadLocalPush) {
  static {
    __name(this, "Payload");
  }
};
var PayloadUpstream = class extends Schema_exports2.Union(PayloadUpstreamRebase, PayloadUpstreamAdvance) {
  static {
    __name(this, "PayloadUpstream");
  }
};
var MergeContext = class extends Schema_exports2.Class("MergeContext")({
  payload: Payload,
  syncState: SyncState
}) {
  static {
    __name(this, "MergeContext");
  }
  toJSON = /* @__PURE__ */ __name(() => {
    const payload = Match_exports.value(this.payload).pipe(Match_exports.tag("local-push", () => ({
      _tag: "local-push",
      newEvents: this.payload.newEvents.map((e) => e.toJSON())
    })), Match_exports.tag("upstream-advance", () => ({
      _tag: "upstream-advance",
      newEvents: this.payload.newEvents.map((e) => e.toJSON())
    })), Match_exports.tag("upstream-rebase", (payload2) => ({
      _tag: "upstream-rebase",
      newEvents: payload2.newEvents.map((e) => e.toJSON()),
      rollbackEvents: payload2.rollbackEvents.map((e) => e.toJSON())
    })), Match_exports.exhaustive);
    return {
      payload,
      syncState: this.syncState.toJSON()
    };
  }, "toJSON");
};
var MergeResultAdvance = class extends Schema_exports2.Class("MergeResultAdvance")({
  _tag: Schema_exports2.Literal("advance"),
  newSyncState: SyncState,
  newEvents: Schema_exports2.Array(EncodedWithMeta),
  /** Events which were previously pending but are now confirmed */
  confirmedEvents: Schema_exports2.Array(EncodedWithMeta),
  mergeContext: MergeContext
}) {
  static {
    __name(this, "MergeResultAdvance");
  }
  toJSON = /* @__PURE__ */ __name(() => {
    return {
      _tag: this._tag,
      newSyncState: this.newSyncState.toJSON(),
      newEvents: this.newEvents.map((e) => e.toJSON()),
      confirmedEvents: this.confirmedEvents.map((e) => e.toJSON()),
      mergeContext: this.mergeContext.toJSON()
    };
  }, "toJSON");
};
var MergeResultRebase = class extends Schema_exports2.Class("MergeResultRebase")({
  _tag: Schema_exports2.Literal("rebase"),
  newSyncState: SyncState,
  newEvents: Schema_exports2.Array(EncodedWithMeta),
  /** Events which need to be rolled back */
  rollbackEvents: Schema_exports2.Array(EncodedWithMeta),
  mergeContext: MergeContext
}) {
  static {
    __name(this, "MergeResultRebase");
  }
  toJSON = /* @__PURE__ */ __name(() => {
    return {
      _tag: this._tag,
      newSyncState: this.newSyncState.toJSON(),
      newEvents: this.newEvents.map((e) => e.toJSON()),
      rollbackEvents: this.rollbackEvents.map((e) => e.toJSON()),
      mergeContext: this.mergeContext.toJSON()
    };
  }, "toJSON");
};
var MergeResultReject = class extends Schema_exports2.Class("MergeResultReject")({
  _tag: Schema_exports2.Literal("reject"),
  /** The minimum id that the new events must have */
  expectedMinimumId: EventSequenceNumber,
  mergeContext: MergeContext
}) {
  static {
    __name(this, "MergeResultReject");
  }
  toJSON = /* @__PURE__ */ __name(() => {
    return {
      _tag: this._tag,
      expectedMinimumId: toString4(this.expectedMinimumId),
      mergeContext: this.mergeContext.toJSON()
    };
  }, "toJSON");
};
var MergeResultUnexpectedError = class extends Schema_exports2.Class("MergeResultUnexpectedError")({
  _tag: Schema_exports2.Literal("unexpected-error"),
  message: Schema_exports2.String
}) {
  static {
    __name(this, "MergeResultUnexpectedError");
  }
};
var MergeResult = class extends Schema_exports2.Union(MergeResultAdvance, MergeResultRebase, MergeResultReject, MergeResultUnexpectedError) {
  static {
    __name(this, "MergeResult");
  }
};
var payloadFromMergeResult = /* @__PURE__ */ __name((mergeResult) => Match_exports.value(mergeResult).pipe(Match_exports.tag("advance", (result) => ({
  _tag: "upstream-advance",
  newEvents: result.newEvents
})), Match_exports.tag("rebase", (result) => ({
  _tag: "upstream-rebase",
  newEvents: result.newEvents,
  rollbackEvents: result.rollbackEvents
})), Match_exports.exhaustive), "payloadFromMergeResult");
var unexpectedError = /* @__PURE__ */ __name((message) => {
  if (LS_DEV) {
    debugger;
  }
  return MergeResultUnexpectedError.make({ _tag: "unexpected-error", message });
}, "unexpectedError");
var merge15 = /* @__PURE__ */ __name(({ syncState, payload, isClientEvent, isEqualEvent, ignoreClientEvents = false }) => {
  validateSyncState(syncState);
  validatePayload(payload);
  const mergeContext = MergeContext.make({ payload, syncState });
  switch (payload._tag) {
    case "upstream-rebase": {
      const rollbackEvents = [...payload.rollbackEvents, ...syncState.pending];
      const newUpstreamHead = payload.newEvents.at(-1)?.seqNum ?? syncState.upstreamHead;
      const rebasedPending = rebaseEvents({
        events: syncState.pending,
        baseEventSequenceNumber: newUpstreamHead,
        isClientEvent
      });
      return validateMergeResult(MergeResultRebase.make({
        _tag: "rebase",
        newSyncState: new SyncState({
          pending: rebasedPending,
          upstreamHead: newUpstreamHead,
          localHead: rebasedPending.at(-1)?.seqNum ?? newUpstreamHead
        }),
        newEvents: [...payload.newEvents, ...rebasedPending],
        rollbackEvents,
        mergeContext
      }));
    }
    // #region upstream-advance
    case "upstream-advance": {
      if (payload.newEvents.length === 0) {
        return validateMergeResult(MergeResultAdvance.make({
          _tag: "advance",
          newSyncState: new SyncState({
            pending: syncState.pending,
            upstreamHead: syncState.upstreamHead,
            localHead: syncState.localHead
          }),
          newEvents: [],
          confirmedEvents: [],
          mergeContext
        }));
      }
      for (let i = 1; i < payload.newEvents.length; i++) {
        if (isGreaterThan(payload.newEvents[i - 1].seqNum, payload.newEvents[i].seqNum)) {
          return unexpectedError(`Events must be sorted in ascending order by event number. Received: [${payload.newEvents.map((e) => toString4(e.seqNum)).join(", ")}]`);
        }
      }
      if (isGreaterThan(syncState.upstreamHead, payload.newEvents[0].seqNum) || isEqual2(syncState.upstreamHead, payload.newEvents[0].seqNum)) {
        return unexpectedError(`Incoming events must be greater than upstream head. Expected greater than: ${toString4(syncState.upstreamHead)}. Received: [${payload.newEvents.map((e) => toString4(e.seqNum)).join(", ")}]`);
      }
      const newUpstreamHead = payload.newEvents.at(-1).seqNum;
      const divergentPendingIndex = findDivergencePoint({
        existingEvents: syncState.pending,
        incomingEvents: payload.newEvents,
        isEqualEvent,
        isClientEvent,
        ignoreClientEvents
      });
      if (divergentPendingIndex === -1) {
        const pendingEventSequenceNumbers = new Set(syncState.pending.map((e) => `${e.seqNum.global},${e.seqNum.client}`));
        const newEvents = payload.newEvents.filter((e) => !pendingEventSequenceNumbers.has(`${e.seqNum.global},${e.seqNum.client}`));
        let clientIndexOffset = 0;
        const [pendingMatching, pendingRemaining] = Array_exports.splitWhere(syncState.pending, (pendingEvent, index2) => {
          if (ignoreClientEvents && isClientEvent(pendingEvent)) {
            clientIndexOffset++;
            return false;
          }
          const newEvent = payload.newEvents.at(index2 - clientIndexOffset);
          if (!newEvent) {
            return true;
          }
          return isEqualEvent(pendingEvent, newEvent) === false;
        });
        return validateMergeResult(MergeResultAdvance.make({
          _tag: "advance",
          newSyncState: new SyncState({
            pending: pendingRemaining,
            upstreamHead: newUpstreamHead,
            localHead: pendingRemaining.at(-1)?.seqNum ?? max8(syncState.localHead, newUpstreamHead)
          }),
          newEvents,
          confirmedEvents: pendingMatching,
          mergeContext
        }));
      } else {
        const divergentPending = syncState.pending.slice(divergentPendingIndex);
        const rebasedPending = rebaseEvents({
          events: divergentPending,
          baseEventSequenceNumber: newUpstreamHead,
          isClientEvent
        });
        const divergentNewEventsIndex = findDivergencePoint({
          existingEvents: payload.newEvents,
          incomingEvents: syncState.pending,
          isEqualEvent,
          isClientEvent,
          ignoreClientEvents
        });
        return validateMergeResult(MergeResultRebase.make({
          _tag: "rebase",
          newSyncState: new SyncState({
            pending: rebasedPending,
            upstreamHead: newUpstreamHead,
            localHead: rebasedPending.at(-1).seqNum
          }),
          newEvents: [...payload.newEvents.slice(divergentNewEventsIndex), ...rebasedPending],
          rollbackEvents: divergentPending,
          mergeContext
        }));
      }
    }
    // #endregion
    // This is the same as what's running in the sync backend
    case "local-push": {
      if (payload.newEvents.length === 0) {
        return validateMergeResult(MergeResultAdvance.make({
          _tag: "advance",
          newSyncState: syncState,
          newEvents: [],
          confirmedEvents: [],
          mergeContext
        }));
      }
      const newEventsFirst = payload.newEvents.at(0);
      const invalidEventSequenceNumber = isGreaterThan(newEventsFirst.seqNum, syncState.localHead) === false;
      if (invalidEventSequenceNumber) {
        const expectedMinimumId = nextPair({
          seqNum: syncState.localHead,
          isClient: true
        }).seqNum;
        return validateMergeResult(MergeResultReject.make({
          _tag: "reject",
          expectedMinimumId,
          mergeContext
        }));
      } else {
        return validateMergeResult(MergeResultAdvance.make({
          _tag: "advance",
          newSyncState: new SyncState({
            pending: [...syncState.pending, ...payload.newEvents],
            upstreamHead: syncState.upstreamHead,
            localHead: payload.newEvents.at(-1).seqNum
          }),
          newEvents: payload.newEvents,
          confirmedEvents: [],
          mergeContext
        }));
      }
    }
    default: {
      casesHandled(payload);
    }
  }
}, "merge");
var findDivergencePoint = /* @__PURE__ */ __name(({ existingEvents, incomingEvents, isEqualEvent, isClientEvent, ignoreClientEvents }) => {
  if (ignoreClientEvents) {
    const filteredExistingEvents = existingEvents.filter((event) => !isClientEvent(event));
    const divergencePointWithoutClientEvents = findDivergencePoint({
      existingEvents: filteredExistingEvents,
      incomingEvents,
      isEqualEvent,
      isClientEvent,
      ignoreClientEvents: false
    });
    if (divergencePointWithoutClientEvents === -1)
      return -1;
    const divergencePointEventSequenceNumber = existingEvents[divergencePointWithoutClientEvents].seqNum;
    return existingEvents.findIndex((event) => isEqual2(event.seqNum, divergencePointEventSequenceNumber));
  }
  return existingEvents.findIndex((existingEvent, index2) => {
    const incomingEvent = incomingEvents[index2];
    return incomingEvent && !isEqualEvent(existingEvent, incomingEvent);
  });
}, "findDivergencePoint");
var rebaseEvents = /* @__PURE__ */ __name(({ events: events2, baseEventSequenceNumber, isClientEvent }) => {
  let prevEventSequenceNumber = baseEventSequenceNumber;
  const rebaseGeneration = baseEventSequenceNumber.rebaseGeneration + 1;
  return events2.map((event) => {
    const isClient = isClientEvent(event);
    const newEvent = event.rebase({
      parentSeqNum: prevEventSequenceNumber,
      isClient,
      rebaseGeneration
    });
    prevEventSequenceNumber = newEvent.seqNum;
    return newEvent;
  });
}, "rebaseEvents");
var validatePayload = /* @__PURE__ */ __name((payload) => {
  for (let i = 1; i < payload.newEvents.length; i++) {
    if (isGreaterThanOrEqual(payload.newEvents[i - 1].seqNum, payload.newEvents[i].seqNum)) {
      return unexpectedError(`Events must be ordered in monotonically ascending order by eventNum. Received: [${payload.newEvents.map((e) => toString4(e.seqNum)).join(", ")}]`);
    }
  }
}, "validatePayload");
var validateSyncState = /* @__PURE__ */ __name((syncState) => {
  for (let i = 0; i < syncState.pending.length; i++) {
    const event = syncState.pending[i];
    const nextEvent = syncState.pending[i + 1];
    if (nextEvent === void 0)
      break;
    if (isGreaterThanOrEqual(event.seqNum, nextEvent.seqNum)) {
      shouldNeverHappen(`Events must be ordered in monotonically ascending order by eventNum. Received: [${syncState.pending.map((e) => toString4(e.seqNum)).join(", ")}]`, {
        event,
        nextEvent
      });
    }
    const globalIdHasIncreased = nextEvent.seqNum.global > event.seqNum.global;
    if (globalIdHasIncreased) {
      if (nextEvent.seqNum.client !== 0) {
        shouldNeverHappen(`New global events must point to clientId 0 in the parentSeqNum. Received: (${toString4(nextEvent.seqNum)})`, syncState.pending, {
          event,
          nextEvent
        });
      }
    } else {
      if (isEqual2(nextEvent.parentSeqNum, event.seqNum) === false) {
        shouldNeverHappen("Events must be linked in a continuous chain via the parentSeqNum", syncState.pending, {
          event,
          nextEvent
        });
      }
    }
  }
}, "validateSyncState");
var validateMergeResult = /* @__PURE__ */ __name((mergeResult) => {
  if (mergeResult._tag === "unexpected-error" || mergeResult._tag === "reject")
    return mergeResult;
  validateSyncState(mergeResult.newSyncState);
  if (isGreaterThan(mergeResult.newSyncState.upstreamHead, mergeResult.newSyncState.localHead)) {
    shouldNeverHappen("Local head must be greater than or equal to upstream head", {
      localHead: mergeResult.newSyncState.localHead,
      upstreamHead: mergeResult.newSyncState.upstreamHead
    });
  }
  if (isGreaterThanOrEqual(mergeResult.newSyncState.localHead, mergeResult.mergeContext.syncState.localHead) === false) {
    shouldNeverHappen("New local head must be greater than or equal to the previous local head", {
      localHead: mergeResult.newSyncState.localHead,
      previousLocalHead: mergeResult.mergeContext.syncState.localHead
    });
  }
  if (isGreaterThanOrEqual(mergeResult.newSyncState.upstreamHead, mergeResult.mergeContext.syncState.upstreamHead) === false) {
    shouldNeverHappen("New upstream head must be greater than or equal to the previous upstream head", {
      upstreamHead: mergeResult.newSyncState.upstreamHead,
      previousUpstreamHead: mergeResult.mergeContext.syncState.upstreamHead
    });
  }
  return mergeResult;
}, "validateMergeResult");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/devtools/devtools-messages-leader.js
var ResetAllDataReq = class extends LSDReqResMessage("LSD.Leader.ResetAllDataReq", {
  mode: Schema_exports2.Literal("all-data", "only-app-db")
}) {
  static {
    __name(this, "ResetAllDataReq");
  }
};
var DatabaseFileInfoReq = class extends LSDReqResMessage("LSD.Leader.DatabaseFileInfoReq", {}) {
  static {
    __name(this, "DatabaseFileInfoReq");
  }
};
var DatabaseFileInfo = class extends Schema_exports2.Struct({
  fileSize: Schema_exports2.Number,
  persistenceInfo: Schema_exports2.Struct({ fileName: Schema_exports2.String }, { key: Schema_exports2.String, value: Schema_exports2.Any })
}) {
  static {
    __name(this, "DatabaseFileInfo");
  }
};
var DatabaseFileInfoRes = class extends LSDReqResMessage("LSD.Leader.DatabaseFileInfoRes", {
  state: DatabaseFileInfo,
  eventlog: DatabaseFileInfo
}) {
  static {
    __name(this, "DatabaseFileInfoRes");
  }
};
var NetworkStatusSubscribe = class extends LSDReqResMessage("LSD.Leader.NetworkStatusSubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "NetworkStatusSubscribe");
  }
};
var NetworkStatusUnsubscribe = class extends LSDReqResMessage("LSD.Leader.NetworkStatusUnsubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "NetworkStatusUnsubscribe");
  }
};
var NetworkStatusRes = class extends LSDReqResMessage("LSD.Leader.NetworkStatusRes", {
  networkStatus: NetworkStatus,
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "NetworkStatusRes");
  }
};
var SyncingInfoReq = class extends LSDReqResMessage("LSD.Leader.SyncingInfoReq", {}) {
  static {
    __name(this, "SyncingInfoReq");
  }
};
var SyncingInfo = class extends Schema_exports2.Struct({
  enabled: Schema_exports2.Boolean,
  metadata: Schema_exports2.Record({ key: Schema_exports2.String, value: Schema_exports2.Any })
}) {
  static {
    __name(this, "SyncingInfo");
  }
};
var SyncingInfoRes = class extends LSDReqResMessage("LSD.Leader.SyncingInfoRes", {
  syncingInfo: SyncingInfo
}) {
  static {
    __name(this, "SyncingInfoRes");
  }
};
var SyncHistorySubscribe = class extends LSDReqResMessage("LSD.Leader.SyncHistorySubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "SyncHistorySubscribe");
  }
};
var SyncHistoryUnsubscribe = class extends LSDReqResMessage("LSD.Leader.SyncHistoryUnsubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "SyncHistoryUnsubscribe");
  }
};
var SyncHistoryRes = class extends LSDReqResMessage("LSD.Leader.SyncHistoryRes", {
  eventEncoded: AnyEncodedGlobal,
  metadata: Schema_exports2.Option(Schema_exports2.JsonValue),
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "SyncHistoryRes");
  }
};
var SyncHeadSubscribe2 = class extends LSDReqResMessage("LSD.Leader.SyncHeadSubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "SyncHeadSubscribe");
  }
};
var SyncHeadUnsubscribe2 = class extends LSDReqResMessage("LSD.Leader.SyncHeadUnsubscribe", {
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "SyncHeadUnsubscribe");
  }
};
var SyncHeadRes2 = class extends LSDReqResMessage("LSD.Leader.SyncHeadRes", {
  local: EventSequenceNumber_exports.EventSequenceNumber,
  upstream: EventSequenceNumber_exports.EventSequenceNumber,
  subscriptionId: Schema_exports2.String
}) {
  static {
    __name(this, "SyncHeadRes");
  }
};
var SnapshotReq = class extends LSDReqResMessage("LSD.Leader.SnapshotReq", {}) {
  static {
    __name(this, "SnapshotReq");
  }
};
var SnapshotRes = class extends LSDReqResMessage("LSD.Leader.SnapshotRes", {
  snapshot: Transferable_exports.Uint8Array
}) {
  static {
    __name(this, "SnapshotRes");
  }
};
var LoadDatabaseFile = LeaderReqResMessage("LSD.Leader.LoadDatabaseFile", {
  payload: {
    data: Transferable_exports.Uint8Array
  },
  success: {},
  error: {
    cause: Schema_exports2.Union(Schema_exports2.TaggedStruct("unsupported-file", {}), Schema_exports2.TaggedStruct("unsupported-database", {}), Schema_exports2.TaggedStruct("unexpected-error", { cause: Schema_exports2.Defect }))
  }
});
var SyncPull = class extends LSDMessage("LSD.Leader.SyncPull", {
  payload: PayloadUpstream
}) {
  static {
    __name(this, "SyncPull");
  }
};
var CommitEventReq = class extends LSDReqResMessage("LSD.Leader.CommitEventReq", {
  eventEncoded: PartialAnyEncoded
}) {
  static {
    __name(this, "CommitEventReq");
  }
};
var CommitEventRes = class extends LSDReqResMessage("LSD.Leader.CommitEventRes", {}) {
  static {
    __name(this, "CommitEventRes");
  }
};
var EventlogReq = class extends LSDReqResMessage("LSD.Leader.EventlogReq", {}) {
  static {
    __name(this, "EventlogReq");
  }
};
var EventlogRes = class extends LSDReqResMessage("LSD.Leader.EventlogRes", {
  eventlog: Transferable_exports.Uint8Array
}) {
  static {
    __name(this, "EventlogRes");
  }
};
var Ping2 = class extends LSDReqResMessage("LSD.Leader.Ping", {}) {
  static {
    __name(this, "Ping");
  }
};
var Pong2 = class extends LSDReqResMessage("LSD.Leader.Pong", {}) {
  static {
    __name(this, "Pong");
  }
};
var Disconnect2 = class extends LSDReqResMessage("LSD.Leader.Disconnect", {}) {
  static {
    __name(this, "Disconnect");
  }
};
var SetSyncLatch = LeaderReqResMessage("LSD.Leader.SetSyncLatch", {
  payload: {
    closeLatch: Schema_exports2.Boolean
  },
  success: {}
});
var ResetAllData = LeaderReqResMessage("LSD.Leader.ResetAllData", {
  payload: {
    mode: Schema_exports2.Literal("all-data", "only-app-db")
  },
  success: {}
});
var MessageToApp2 = Schema_exports2.Union(SnapshotReq, LoadDatabaseFile.Request, EventlogReq, ResetAllData.Request, NetworkStatusSubscribe, NetworkStatusUnsubscribe, Disconnect2, CommitEventReq, Ping2, DatabaseFileInfoReq, SyncHistorySubscribe, SyncHistoryUnsubscribe, SyncingInfoReq, SyncHeadSubscribe2, SyncHeadUnsubscribe2, SetSyncLatch.Request).annotations({ identifier: "LSD.Leader.MessageToApp" });
var MessageFromApp2 = Schema_exports2.Union(SnapshotRes, LoadDatabaseFile.Response, EventlogRes, Disconnect2, SyncPull, NetworkStatusRes, CommitEventRes, Pong2, DatabaseFileInfoRes, SyncHistoryRes, SyncingInfoRes, SyncHeadRes2, ResetAllData.Success, SetSyncLatch.Success).annotations({ identifier: "LSD.Leader.MessageFromApp" });

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/devtools/mod.js
var DevtoolsMode = Schema_exports2.Union(Schema_exports2.TaggedStruct("node", {
  /** WebSocket URL */
  url: Schema_exports2.String
}), Schema_exports2.TaggedStruct("web", {}), Schema_exports2.TaggedStruct("browser-extension", {}));
var DevtoolsModeTag = DevtoolsMode.pipe(Schema_exports2.pluck("_tag"), Schema_exports2.typeSchema);
var makeNodeName = {
  devtools: {
    random: /* @__PURE__ */ __name(() => `devtools-instance-${nanoid()}`, "random")
  },
  client: {
    session: /* @__PURE__ */ __name(({ storeId: storeId2, clientId: clientId2, sessionId: sessionId2 }) => `client-session-${storeId2}-${clientId2}-${sessionId2}`, "session"),
    leader: /* @__PURE__ */ __name(({ storeId: storeId2, clientId: clientId2 }) => `client-leader-${storeId2}-${clientId2}`, "leader")
  }
};
var makeChannelName = {
  sessionInfo: /* @__PURE__ */ __name(() => `session-info`, "sessionInfo"),
  devtoolsClientSession: /* @__PURE__ */ __name(({ storeId: storeId2, clientId: clientId2, sessionId: sessionId2 }) => `devtools-channel(client-session-${storeId2}-${clientId2}-${sessionId2})`, "devtoolsClientSession"),
  devtoolsClientLeader: /* @__PURE__ */ __name(({ storeId: storeId2, clientId: clientId2, sessionId: sessionId2 }) => `devtools-channel(client-leader-${storeId2}-${clientId2}-${sessionId2})`, "devtoolsClientLeader")
};
var isChannelName = {
  devtoolsClientSession: /* @__PURE__ */ __name((channelName, { storeId: storeId2, clientId: clientId2, sessionId: sessionId2 }) => channelName === makeChannelName.devtoolsClientSession({ storeId: storeId2, clientId: clientId2, sessionId: sessionId2 }), "devtoolsClientSession"),
  devtoolsClientLeader: /* @__PURE__ */ __name((channelName, { storeId: storeId2, clientId: clientId2 }) => channelName.startsWith(`devtools-channel(client-leader-${storeId2}-${clientId2}`), "devtoolsClientLeader")
};
var makeSessionInfoBroadcastChannel = /* @__PURE__ */ __name((webmeshNode) => webmeshNode.makeBroadcastChannel({
  channelName: makeChannelName.sessionInfo(),
  schema: Message2
}), "makeSessionInfoBroadcastChannel");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/make-client-session.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+webmesh@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/webmesh/dist/common.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var EdgeAlreadyExistsError = class extends Schema_exports2.TaggedError()("EdgeAlreadyExistsError", {
  target: Schema_exports2.String
}) {
  static {
    __name(this, "EdgeAlreadyExistsError");
  }
};
var packetAsOtelAttributes = /* @__PURE__ */ __name((packet) => ({
  packetId: packet.id,
  "span.label": packet.id + (Predicate_exports.hasProperty(packet, "reqId") && packet.reqId !== void 0 ? ` for ${packet.reqId}` : ""),
  ...packet._tag !== "DirectChannelResponseSuccess" && packet._tag !== "ProxyChannelPayload" ? { packet } : {}
}), "packetAsOtelAttributes");
var ListenForChannelResult = Schema_exports2.Struct({
  channelName: Schema_exports2.String,
  source: Schema_exports2.String,
  mode: Schema_exports2.Union(Schema_exports2.Literal("proxy"), Schema_exports2.Literal("direct"))
});

// node_modules/.pnpm/@livestore+webmesh@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/webmesh/dist/mesh-schema.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var id3 = Schema_exports2.String.pipe(Schema_exports2.optional, Schema_exports2.withDefaults({ constructor: /* @__PURE__ */ __name(() => nanoid(10), "constructor"), decoding: /* @__PURE__ */ __name(() => nanoid(10), "decoding") }));
var defaultPacketFields = {
  id: id3,
  target: Schema_exports2.String,
  source: Schema_exports2.String,
  channelName: Schema_exports2.String,
  hops: Schema_exports2.Array(Schema_exports2.String)
};
var remainingHopsUndefined = Schema_exports2.Undefined.pipe(Schema_exports2.optional);
var DirectChannelRequest = class extends Schema_exports2.TaggedStruct("DirectChannelRequest", {
  ...defaultPacketFields,
  remainingHops: Schema_exports2.Array(Schema_exports2.String).pipe(Schema_exports2.optional),
  channelVersion: Schema_exports2.Number,
  /** Only set if the request is in response to an incoming request */
  reqId: Schema_exports2.UndefinedOr(Schema_exports2.String),
  /**
   * Additionally to the `source` field, we use this field to track whether the instance of a
   * source has changed.
   */
  sourceId: Schema_exports2.String
}) {
  static {
    __name(this, "DirectChannelRequest");
  }
};
var DirectChannelResponseSuccess = class extends Schema_exports2.TaggedStruct("DirectChannelResponseSuccess", {
  ...defaultPacketFields,
  reqId: Schema_exports2.String,
  port: Transferable_exports.MessagePort,
  // Since we can't copy this message, we need to follow the exact route back to the sender
  remainingHops: Schema_exports2.Array(Schema_exports2.String),
  channelVersion: Schema_exports2.Number
}) {
  static {
    __name(this, "DirectChannelResponseSuccess");
  }
};
var DirectChannelResponseNoTransferables = class extends Schema_exports2.TaggedStruct("DirectChannelResponseNoTransferables", {
  ...defaultPacketFields,
  reqId: Schema_exports2.String,
  remainingHops: Schema_exports2.Array(Schema_exports2.String)
}) {
  static {
    __name(this, "DirectChannelResponseNoTransferables");
  }
};
var ProxyChannelRequest = class extends Schema_exports2.TaggedStruct("ProxyChannelRequest", {
  ...defaultPacketFields,
  remainingHops: remainingHopsUndefined,
  channelIdCandidate: Schema_exports2.String
}) {
  static {
    __name(this, "ProxyChannelRequest");
  }
};
var ProxyChannelResponseSuccess = class extends Schema_exports2.TaggedStruct("ProxyChannelResponseSuccess", {
  ...defaultPacketFields,
  reqId: Schema_exports2.String,
  remainingHops: Schema_exports2.Array(Schema_exports2.String),
  combinedChannelId: Schema_exports2.String,
  channelIdCandidate: Schema_exports2.String
}) {
  static {
    __name(this, "ProxyChannelResponseSuccess");
  }
};
var ProxyChannelPayload = class extends Schema_exports2.TaggedStruct("ProxyChannelPayload", {
  ...defaultPacketFields,
  remainingHops: remainingHopsUndefined,
  payload: Schema_exports2.Any,
  combinedChannelId: Schema_exports2.String
}) {
  static {
    __name(this, "ProxyChannelPayload");
  }
};
var ProxyChannelPayloadAck = class extends Schema_exports2.TaggedStruct("ProxyChannelPayloadAck", {
  ...defaultPacketFields,
  reqId: Schema_exports2.String,
  remainingHops: Schema_exports2.Array(Schema_exports2.String),
  combinedChannelId: Schema_exports2.String
}) {
  static {
    __name(this, "ProxyChannelPayloadAck");
  }
};
var NetworkEdgeAdded = class extends Schema_exports2.TaggedStruct("NetworkEdgeAdded", {
  id: id3,
  source: Schema_exports2.String,
  target: Schema_exports2.String
}) {
  static {
    __name(this, "NetworkEdgeAdded");
  }
};
var NetworkTopologyRequest = class extends Schema_exports2.TaggedStruct("NetworkTopologyRequest", {
  id: id3,
  hops: Schema_exports2.Array(Schema_exports2.String),
  /** Always fixed to who requested the topology */
  source: Schema_exports2.String,
  target: Schema_exports2.Literal("-")
}) {
  static {
    __name(this, "NetworkTopologyRequest");
  }
};
var NetworkTopologyResponse = class extends Schema_exports2.TaggedStruct("NetworkTopologyResponse", {
  id: id3,
  reqId: Schema_exports2.String,
  remainingHops: Schema_exports2.Array(Schema_exports2.String),
  nodeName: Schema_exports2.String,
  edges: Schema_exports2.Array(Schema_exports2.String),
  /** Always fixed to who requested the topology */
  source: Schema_exports2.String,
  target: Schema_exports2.Literal("-")
}) {
  static {
    __name(this, "NetworkTopologyResponse");
  }
};
var BroadcastChannelPacket = Schema_exports2.TaggedStruct("BroadcastChannelPacket", {
  id: id3,
  channelName: Schema_exports2.String,
  /**
   * The payload is expected to be encoded/decoded by the send/listen schema.
   * Transferables are not supported.
   */
  payload: Schema_exports2.Any,
  hops: Schema_exports2.Array(Schema_exports2.String),
  source: Schema_exports2.String,
  target: Schema_exports2.Literal("-")
});
var DirectChannelPacket = class extends Schema_exports2.Union(DirectChannelRequest, DirectChannelResponseSuccess, DirectChannelResponseNoTransferables) {
  static {
    __name(this, "DirectChannelPacket");
  }
};
var ProxyChannelPacket = class extends Schema_exports2.Union(ProxyChannelRequest, ProxyChannelResponseSuccess, ProxyChannelPayload, ProxyChannelPayloadAck) {
  static {
    __name(this, "ProxyChannelPacket");
  }
};
var Packet = class extends Schema_exports2.Union(DirectChannelPacket, ProxyChannelPacket, NetworkEdgeAdded, NetworkTopologyRequest, NetworkTopologyResponse, BroadcastChannelPacket) {
  static {
    __name(this, "Packet");
  }
};
var DirectChannelPing = class extends Schema_exports2.TaggedStruct("DirectChannelPing", {}) {
  static {
    __name(this, "DirectChannelPing");
  }
};
var DirectChannelPong = class extends Schema_exports2.TaggedStruct("DirectChannelPong", {}) {
  static {
    __name(this, "DirectChannelPong");
  }
};

// node_modules/.pnpm/@livestore+webmesh@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/webmesh/dist/node.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+webmesh@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/webmesh/dist/channel/direct-channel.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+webmesh@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/webmesh/dist/channel/direct-channel-internal.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeDeferredResult = Deferred_exports.make;
var makeDirectChannelInternal = /* @__PURE__ */ __name(({ nodeName, incomingPacketsQueue, target: target3, checkTransferableEdges, channelName, schema: schema_, sendPacket, channelVersion, scope: scope5, sourceId }) => Effect_exports2.gen(function* () {
  const deferred = yield* makeDeferredResult();
  const span4 = yield* OtelTracer_exports.currentOtelSpan.pipe(Effect_exports2.catchAll(() => Effect_exports2.succeed(void 0)));
  const schema4 = {
    send: Schema_exports2.Union(schema_.send, DirectChannelPing, DirectChannelPong),
    listen: Schema_exports2.Union(schema_.listen, DirectChannelPing, DirectChannelPong)
  };
  const channelStateRef = {
    current: { _tag: "Initial" }
  };
  const processMessagePacket = /* @__PURE__ */ __name(({ packet, respondToSender }) => Effect_exports2.gen(function* () {
    const channelState2 = channelStateRef.current;
    span4?.addEvent(`process:${packet._tag}`, {
      channelState: channelState2._tag,
      packetId: packet.id,
      packetReqId: packet.reqId,
      packetChannelVersion: Predicate_exports.hasProperty("channelVersion")(packet) ? packet.channelVersion : void 0
    });
    if (channelState2._tag === "Initial")
      return shouldNeverHappen();
    if (packet._tag === "DirectChannelResponseNoTransferables") {
      yield* Deferred_exports.fail(deferred, packet);
      return "close";
    }
    if (packet.channelVersion > channelVersion) {
      span4?.addEvent(`incoming packet has higher version (${packet.channelVersion}), closing channel`);
      yield* Scope_exports.close(scope5, Exit_exports.succeed("higher-version-expected"));
      return "close";
    }
    if (packet.channelVersion < channelVersion) {
      const newPacket = DirectChannelRequest.make({
        source: nodeName,
        sourceId,
        target: target3,
        channelName,
        channelVersion,
        hops: [],
        remainingHops: packet.hops,
        reqId: void 0
      });
      span4?.addEvent(`incoming packet has lower version (${packet.channelVersion}), sending request to reconnect (${newPacket.id})`);
      yield* sendPacket(newPacket);
      return;
    }
    if (channelState2._tag === "Established" && packet._tag === "DirectChannelRequest") {
      if (packet.sourceId === channelState2.otherSourceId) {
        return;
      } else {
        span4?.addEvent(`force-new-channel`);
        yield* Scope_exports.close(scope5, Exit_exports.succeed("force-new-channel"));
        return "close";
      }
    }
    switch (packet._tag) {
      // Assumption: Each side has sent an initial request and another request as a response for an incoming request
      case "DirectChannelRequest": {
        if (channelState2._tag !== "RequestSent") {
          return;
        }
        if (packet.reqId === channelState2.reqPacketId) {
        } else {
          const newRequestPacket = DirectChannelRequest.make({
            source: nodeName,
            sourceId,
            target: target3,
            channelName,
            channelVersion,
            hops: [],
            remainingHops: packet.hops,
            reqId: packet.id
          });
          span4?.addEvent(`Re-sending new request (${newRequestPacket.id}) for incoming request (${packet.id})`);
          yield* sendPacket(newRequestPacket);
        }
        const isWinner = nodeName > target3;
        if (isWinner) {
          span4?.addEvent(`winner side: creating direct channel and sending response`);
          const mc = new MessageChannel();
          const channel3 = yield* mod_exports.messagePortChannelWithAck({
            port: mc.port1,
            schema: schema4,
            debugId: channelVersion
          }).pipe(Effect_exports2.andThen(mod_exports.toOpenChannel));
          yield* respondToSender(DirectChannelResponseSuccess.make({
            reqId: packet.id,
            target: target3,
            source: nodeName,
            channelName: packet.channelName,
            hops: [],
            remainingHops: packet.hops.slice(0, -1),
            port: mc.port2,
            channelVersion
          }));
          channelStateRef.current = { _tag: "winner:ResponseSent", channel: channel3, otherSourceId: packet.sourceId };
          yield* channel3.listen.pipe(Stream_exports2.flatten(), Stream_exports2.filter(Schema_exports2.is(DirectChannelPing)), Stream_exports2.take(1), Stream_exports2.runDrain);
          yield* channel3.send(DirectChannelPong.make({}));
          span4?.addEvent(`winner side: established`);
          channelStateRef.current = { _tag: "Established", otherSourceId: packet.sourceId };
          yield* Deferred_exports.succeed(deferred, channel3);
        } else {
          span4?.addEvent(`loser side: waiting for response`);
          channelStateRef.current = { _tag: "loser:WaitingForResponse", otherSourceId: packet.sourceId };
        }
        break;
      }
      case "DirectChannelResponseSuccess": {
        if (channelState2._tag !== "loser:WaitingForResponse") {
          return shouldNeverHappen(`Expected to find direct channel response from ${target3}, but was in ${channelState2._tag} state`);
        }
        const channel3 = yield* mod_exports.messagePortChannelWithAck({
          port: packet.port,
          schema: schema4,
          debugId: channelVersion
        }).pipe(Effect_exports2.andThen(mod_exports.toOpenChannel));
        const waitForPongFiber = yield* channel3.listen.pipe(Stream_exports2.flatten(), Stream_exports2.filter(Schema_exports2.is(DirectChannelPong)), Stream_exports2.take(1), Stream_exports2.runDrain, Effect_exports2.fork);
        yield* channel3.send(DirectChannelPing.make({})).pipe(Effect_exports2.timeout(10), Effect_exports2.retry({ times: 2 }));
        yield* waitForPongFiber;
        span4?.addEvent(`loser side: established`);
        channelStateRef.current = { _tag: "Established", otherSourceId: channelState2.otherSourceId };
        yield* Deferred_exports.succeed(deferred, channel3);
        return;
      }
      default: {
        return casesHandled(packet);
      }
    }
  }).pipe(Effect_exports2.withSpan(`handleMessagePacket:${packet._tag}:${packet.source}\u2192${packet.target}`, {
    attributes: packetAsOtelAttributes(packet)
  })), "processMessagePacket");
  yield* Effect_exports2.gen(function* () {
    while (true) {
      const packet = yield* Queue_exports.take(incomingPacketsQueue);
      const res = yield* processMessagePacket(packet);
      if (res === "close") {
        return;
      }
    }
  }).pipe(Effect_exports2.interruptible, Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
  const channelState = channelStateRef.current;
  if (channelState._tag !== "Initial") {
    return shouldNeverHappen(`Expected channel to be in Initial state, but was in ${channelState._tag} state`);
  }
  const edgeRequest = Effect_exports2.gen(function* () {
    const packet = DirectChannelRequest.make({
      source: nodeName,
      sourceId,
      target: target3,
      channelName,
      channelVersion,
      hops: [],
      reqId: void 0
    });
    channelStateRef.current = { _tag: "RequestSent", reqPacketId: packet.id };
    const noTransferableResponse = checkTransferableEdges(packet);
    if (noTransferableResponse !== void 0) {
      yield* Effect_exports2.spanEvent(`No transferable edges found for ${packet.source}\u2192${packet.target}`);
      return yield* Effect_exports2.fail(noTransferableResponse);
    }
    yield* sendPacket(packet);
    span4?.addEvent(`initial edge request sent (${packet.id})`);
  });
  yield* edgeRequest;
  const channel2 = yield* deferred;
  return channel2;
}).pipe(Effect_exports2.withSpanScoped(`makeDirectChannel:${channelVersion}`)), "makeDirectChannelInternal");

// node_modules/.pnpm/@livestore+webmesh@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/webmesh/dist/channel/direct-channel.js
var makeDirectChannel = /* @__PURE__ */ __name(({ schema: schema4, newEdgeAvailablePubSub, channelName, checkTransferableEdges, nodeName, incomingPacketsQueue, target: target3, sendPacket }) => Effect_exports2.scopeWithCloseable((scope5) => Effect_exports2.gen(function* () {
  const sourceId = nanoid();
  const listenQueue = yield* Queue_exports.unbounded();
  const sendQueue = yield* TQueue_exports.unbounded();
  const initialEdgeDeferred = yield* Deferred_exports.make();
  const debugInfo = {
    pendingSends: 0,
    totalSends: 0,
    connectCounter: 0,
    isConnected: false,
    innerChannelRef: { current: void 0 }
  };
  yield* Effect_exports2.gen(function* () {
    const resultDeferred = yield* Deferred_exports.make();
    while (true) {
      debugInfo.connectCounter++;
      const channelVersion2 = debugInfo.connectCounter;
      yield* Effect_exports2.spanEvent(`Connecting#${channelVersion2}`);
      const makeDirectChannelScope2 = yield* Scope_exports.make();
      yield* Effect_exports2.addFinalizer((ex) => Scope_exports.close(makeDirectChannelScope2, ex));
      const waitForNewEdgeFiber = yield* Stream_exports2.fromPubSub(newEdgeAvailablePubSub).pipe(Stream_exports2.tap((edgeName) => Effect_exports2.spanEvent(`new-conn:${edgeName}`)), Stream_exports2.take(1), Stream_exports2.runDrain, Effect_exports2.as("new-edge"), Effect_exports2.fork);
      const makeChannel3 = makeDirectChannelInternal({
        nodeName,
        sourceId,
        incomingPacketsQueue,
        target: target3,
        checkTransferableEdges,
        channelName,
        schema: schema4,
        channelVersion: channelVersion2,
        newEdgeAvailablePubSub,
        sendPacket,
        scope: makeDirectChannelScope2
      }).pipe(
        Scope_exports.extend(makeDirectChannelScope2),
        Effect_exports2.forkIn(makeDirectChannelScope2),
        // Given we only call `Effect.exit` later when joining the fiber,
        // we don't want Effect to produce a "unhandled error" log message
        Effect_exports2.withUnhandledErrorLogLevel(Option_exports.none())
      );
      const raceResult = yield* Effect_exports2.raceFirst(makeChannel3, waitForNewEdgeFiber.pipe(Effect_exports2.disconnect));
      if (raceResult === "new-edge") {
        yield* Scope_exports.close(makeDirectChannelScope2, Exit_exports.fail("new-edge"));
      } else {
        const channelExit = yield* raceResult.pipe(Effect_exports2.exit);
        if (channelExit._tag === "Failure") {
          yield* Scope_exports.close(makeDirectChannelScope2, channelExit);
          if (Cause_exports.isFailType(channelExit.cause) && Schema_exports2.is(DirectChannelResponseNoTransferables)(channelExit.cause.error)) {
            yield* waitForNewEdgeFiber.pipe(Effect_exports2.exit);
          }
        } else {
          const channel3 = channelExit.value;
          yield* Deferred_exports.succeed(resultDeferred, { channel: channel3, makeDirectChannelScope: makeDirectChannelScope2, channelVersion: channelVersion2 });
          break;
        }
      }
    }
    const { channel: channel2, makeDirectChannelScope, channelVersion } = yield* resultDeferred;
    yield* Effect_exports2.spanEvent(`Connected#${channelVersion}`);
    debugInfo.isConnected = true;
    debugInfo.innerChannelRef.current = channel2;
    yield* Deferred_exports.succeed(initialEdgeDeferred, void 0);
    yield* channel2.listen.pipe(
      Stream_exports2.flatten(),
      // Stream.tap((msg) => Effect.log(`${target}${channelName}${nodeName}:message:${msg.message}`)),
      Stream_exports2.tapChunk((chunk4) => Queue_exports.offerAll(listenQueue, chunk4)),
      Stream_exports2.runDrain,
      Effect_exports2.tapCauseLogPretty,
      Effect_exports2.forkIn(makeDirectChannelScope)
    );
    yield* Effect_exports2.gen(function* () {
      while (true) {
        const [msg, deferred] = yield* TQueue_exports.peek(sendQueue);
        yield* channel2.send(msg);
        yield* Deferred_exports.succeed(deferred, void 0);
        yield* TQueue_exports.take(sendQueue);
      }
    }).pipe(Effect_exports2.forkIn(makeDirectChannelScope));
    yield* channel2.closedDeferred;
    yield* Scope_exports.close(makeDirectChannelScope, Exit_exports.succeed("channel-closed"));
    yield* Effect_exports2.spanEvent(`Disconnected#${channelVersion}`);
    debugInfo.isConnected = false;
    debugInfo.innerChannelRef.current = void 0;
  }).pipe(
    Effect_exports2.scoped,
    // Additionally scoping here to clean up finalizers after each loop run
    Effect_exports2.forever,
    Effect_exports2.tapCauseLogPretty,
    Effect_exports2.forkScoped
  );
  const parentSpan3 = yield* Effect_exports2.currentSpan.pipe(Effect_exports2.orDie);
  const send2 = /* @__PURE__ */ __name((message) => Effect_exports2.gen(function* () {
    const sentDeferred = yield* Deferred_exports.make();
    debugInfo.pendingSends++;
    debugInfo.totalSends++;
    yield* TQueue_exports.offer(sendQueue, [message, sentDeferred]);
    yield* sentDeferred;
    debugInfo.pendingSends--;
  }).pipe(Effect_exports2.scoped, Effect_exports2.withParentSpan(parentSpan3)), "send");
  const listen = Stream_exports2.fromQueue(listenQueue, { maxChunkSize: 1 }).pipe(Stream_exports2.map(Either_exports.right));
  const closedDeferred = yield* Deferred_exports.make().pipe(Effect_exports2.acquireRelease(Deferred_exports.done(Exit_exports.void)));
  const webChannel = {
    [mod_exports.WebChannelSymbol]: mod_exports.WebChannelSymbol,
    send: send2,
    listen,
    closedDeferred,
    supportsTransferables: true,
    schema: schema4,
    debugInfo,
    shutdown: Scope_exports.close(scope5, Exit_exports.succeed("shutdown"))
  };
  return {
    webChannel,
    initialEdgeDeferred
  };
})), "makeDirectChannel");

// node_modules/.pnpm/@livestore+webmesh@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/webmesh/dist/channel/proxy-channel.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeProxyChannel = /* @__PURE__ */ __name(({ queue, nodeName, newEdgeAvailablePubSub, sendPacket, target: target3, channelName, schema: schema4 }) => Effect_exports2.scopeWithCloseable((scope5) => Effect_exports2.gen(function* () {
  const channelStateRef = { current: { _tag: "Initial" } };
  const debugInfo = {
    kind: "proxy-channel",
    pendingSends: 0,
    totalSends: 0,
    connectCounter: 0,
    isConnected: false
  };
  const channelIdCandidate = nanoid(5);
  yield* Effect_exports2.annotateCurrentSpan({ channelIdCandidate });
  const channelSpan = yield* Effect_exports2.currentSpan.pipe(Effect_exports2.orDie);
  const connectedStateRef = yield* SubscriptionRef_exports2.make(false);
  const waitForEstablished = Effect_exports2.gen(function* () {
    const state2 = yield* SubscriptionRef_exports2.waitUntil(connectedStateRef, (state3) => state3 !== false);
    return state2;
  });
  const setStateToEstablished = /* @__PURE__ */ __name((channelId) => Effect_exports2.gen(function* () {
    yield* Effect_exports2.spanEvent(`Connected (${channelId})`).pipe(Effect_exports2.withParentSpan(channelSpan));
    channelStateRef.current = {
      _tag: "Established",
      listenSchema: schema4.listen,
      listenQueue,
      ackMap,
      combinedChannelId: channelId
    };
    yield* SubscriptionRef_exports2.set(connectedStateRef, channelStateRef.current);
    debugInfo.isConnected = true;
  }), "setStateToEstablished");
  const edgeRequest = Effect_exports2.suspend(() => sendPacket(ProxyChannelRequest.make({ channelName, hops: [], source: nodeName, target: target3, channelIdCandidate })));
  const getCombinedChannelId = /* @__PURE__ */ __name((otherSideChannelIdCandidate) => [channelIdCandidate, otherSideChannelIdCandidate].sort().join("_"), "getCombinedChannelId");
  const earlyPayloadBuffer = yield* Queue_exports.unbounded().pipe(Effect_exports2.acquireRelease(Queue_exports.shutdown));
  const processProxyPacket = /* @__PURE__ */ __name(({ packet, respondToSender }) => Effect_exports2.gen(function* () {
    const otherSideName = packet.source;
    const channelKey = `target:${otherSideName}, channelName:${packet.channelName}`;
    const channelState = channelStateRef.current;
    switch (packet._tag) {
      case "ProxyChannelRequest": {
        const combinedChannelId = getCombinedChannelId(packet.channelIdCandidate);
        if (channelState._tag === "Established") {
          if (channelState.combinedChannelId === combinedChannelId) {
          } else {
            yield* Effect_exports2.logWarning(`[${nodeName}] Received ProxyChannelRequest with different channel ID (${combinedChannelId}) while established with ${channelState.combinedChannelId}. Re-establishing.`);
            yield* SubscriptionRef_exports2.set(connectedStateRef, false);
            channelStateRef.current = { _tag: "Pending", initiatedVia: "incoming-request" };
            yield* Effect_exports2.spanEvent(`Reconnecting (received conflicting ProxyChannelRequest)`).pipe(Effect_exports2.withParentSpan(channelSpan));
            debugInfo.isConnected = false;
            debugInfo.connectCounter++;
            yield* edgeRequest;
          }
        } else if (channelState._tag === "Initial") {
          yield* SubscriptionRef_exports2.set(connectedStateRef, false);
          channelStateRef.current = { _tag: "Pending", initiatedVia: "incoming-request" };
          yield* Effect_exports2.spanEvent(`Connecting (received ProxyChannelRequest)`).pipe(Effect_exports2.withParentSpan(channelSpan));
          debugInfo.isConnected = false;
          debugInfo.connectCounter++;
        }
        yield* respondToSender(ProxyChannelResponseSuccess.make({
          reqId: packet.id,
          remainingHops: packet.hops,
          hops: [],
          target: target3,
          source: nodeName,
          channelName,
          combinedChannelId,
          channelIdCandidate
        }));
        return;
      }
      case "ProxyChannelResponseSuccess": {
        if (channelState._tag !== "Pending") {
          if (channelState._tag === "Established" && channelState.combinedChannelId !== packet.combinedChannelId) {
            return shouldNeverHappen(`ProxyChannel[${channelKey}]: Expected proxy channel to have the same combinedChannelId as the packet:
${channelState.combinedChannelId} (channel) === ${packet.combinedChannelId} (packet)`);
          } else if (channelState._tag === "Established") {
            return;
          } else {
            yield* Effect_exports2.logWarning(`[${nodeName}] Ignoring ResponseSuccess ${packet.id} received in unexpected state ${channelState._tag}`);
            return;
          }
        }
        const combinedChannelId = getCombinedChannelId(packet.channelIdCandidate);
        if (combinedChannelId !== packet.combinedChannelId) {
          return yield* Effect_exports2.die(`ProxyChannel[${channelKey}]: Expected proxy channel to have the same combinedChannelId as the packet:
${combinedChannelId} (channel) === ${packet.combinedChannelId} (packet)`);
        }
        yield* setStateToEstablished(packet.combinedChannelId);
        const establishedState = channelStateRef.current;
        if (establishedState._tag === "Established") {
          const bufferedPackets = yield* Queue_exports.takeAll(earlyPayloadBuffer);
          for (const bufferedPacket of bufferedPackets) {
            if (establishedState.combinedChannelId !== bufferedPacket.combinedChannelId) {
              yield* Effect_exports2.logWarning(`[${nodeName}] Discarding buffered payload ${bufferedPacket.id}: Combined channel ID mismatch during drain. Expected ${establishedState.combinedChannelId}, got ${bufferedPacket.combinedChannelId}`);
              continue;
            }
            const decodedMessage = yield* Schema_exports2.decodeUnknown(establishedState.listenSchema)(bufferedPacket.payload);
            yield* establishedState.listenQueue.pipe(Queue_exports.offer(decodedMessage));
          }
        } else {
          yield* Effect_exports2.logError(`[${nodeName}] State is not Established immediately after setStateToEstablished was called. Cannot drain buffer. State: ${establishedState._tag}`);
        }
        return;
      }
      case "ProxyChannelPayload": {
        if (channelState._tag === "Established" && channelState.combinedChannelId !== packet.combinedChannelId) {
          return yield* Effect_exports2.die(`ProxyChannel[${channelKey}]: Expected proxy channel to have the same combinedChannelId as the packet:
${channelState.combinedChannelId} (channel) === ${packet.combinedChannelId} (packet)`);
        }
        yield* respondToSender(ProxyChannelPayloadAck.make({
          reqId: packet.id,
          remainingHops: packet.hops,
          hops: [],
          target: target3,
          source: nodeName,
          channelName,
          combinedChannelId: channelState._tag === "Established" ? channelState.combinedChannelId : packet.combinedChannelId
        }));
        if (channelState._tag === "Established") {
          const decodedMessage = yield* Schema_exports2.decodeUnknown(channelState.listenSchema)(packet.payload);
          yield* channelState.listenQueue.pipe(Queue_exports.offer(decodedMessage));
        } else {
          yield* Queue_exports.offer(earlyPayloadBuffer, packet);
        }
        return;
      }
      case "ProxyChannelPayloadAck": {
        if (channelState._tag !== "Established") {
          yield* Effect_exports2.spanEvent(`Not yet connected to ${target3}. dropping message`);
          yield* Effect_exports2.logWarning(`[${nodeName}] Received Ack but not established (State: ${channelState._tag}). Dropping Ack for ${packet.reqId}`);
          return;
        }
        const ack = channelState.ackMap.get(packet.reqId) ?? shouldNeverHappen(`[ProxyChannel[${channelKey}]] Expected ack for ${packet.reqId}`);
        yield* Deferred_exports.succeed(ack, void 0);
        channelState.ackMap.delete(packet.reqId);
        return;
      }
      default: {
        return casesHandled(packet);
      }
    }
  }).pipe(Effect_exports2.withSpan(`handleProxyPacket:${packet._tag}:${packet.source}->${packet.target}`, {
    attributes: packetAsOtelAttributes(packet)
  })), "processProxyPacket");
  yield* Stream_exports2.fromQueue(queue).pipe(Stream_exports2.tap(processProxyPacket), Stream_exports2.runDrain, Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
  const listenQueue = yield* Queue_exports.unbounded();
  yield* Effect_exports2.spanEvent(`Connecting`);
  const ackMap = /* @__PURE__ */ new Map();
  {
    if (channelStateRef.current._tag !== "Initial") {
      return shouldNeverHappen("Expected proxy channel to be Initial");
    }
    channelStateRef.current = { _tag: "Pending", initiatedVia: "outgoing-request" };
    yield* edgeRequest;
    const retryOnNewEdgeFiber = yield* Stream_exports2.fromPubSub(newEdgeAvailablePubSub).pipe(Stream_exports2.tap(() => edgeRequest), Stream_exports2.runDrain, Effect_exports2.forkScoped);
    const { combinedChannelId: channelId } = yield* waitForEstablished;
    yield* Fiber_exports.interrupt(retryOnNewEdgeFiber);
    yield* setStateToEstablished(channelId);
  }
  const send2 = /* @__PURE__ */ __name((message) => Effect_exports2.gen(function* () {
    const payload = yield* Schema_exports2.encodeUnknown(schema4.send)(message);
    const sendFiberHandle = yield* FiberHandle_exports.make();
    const sentDeferred = yield* Deferred_exports.make();
    debugInfo.pendingSends++;
    debugInfo.totalSends++;
    const trySend = Effect_exports2.gen(function* () {
      const { combinedChannelId } = yield* SubscriptionRef_exports2.waitUntil(connectedStateRef, (channel2) => channel2 !== false);
      const innerSend = Effect_exports2.gen(function* () {
        const ack = yield* Deferred_exports.make();
        const packet = ProxyChannelPayload.make({
          channelName,
          payload,
          hops: [],
          source: nodeName,
          target: target3,
          combinedChannelId
        });
        ackMap.set(packet.id, ack);
        yield* sendPacket(packet);
        yield* ack;
        yield* Deferred_exports.succeed(sentDeferred, void 0);
        debugInfo.pendingSends--;
      });
      yield* innerSend.pipe(Effect_exports2.timeout(100), Effect_exports2.retry(Schedule_exports2.exponential(10)), Effect_exports2.orDie);
    }).pipe(Effect_exports2.tapErrorCause(Effect_exports2.logError));
    const rerunOnNewChannelFiber = yield* connectedStateRef.changes.pipe(Stream_exports2.filter((_) => _ === false), Stream_exports2.tap(() => FiberHandle_exports.run(sendFiberHandle, trySend)), Stream_exports2.runDrain, Effect_exports2.fork);
    yield* FiberHandle_exports.run(sendFiberHandle, trySend);
    yield* sentDeferred;
    yield* Fiber_exports.interrupt(rerunOnNewChannelFiber);
  }).pipe(Effect_exports2.scoped, Effect_exports2.withSpan(`sendAckWithRetry:ProxyChannelPayload`), Effect_exports2.withParentSpan(channelSpan)), "send");
  const listen = Stream_exports2.fromQueue(listenQueue).pipe(Stream_exports2.map(Either_exports.right));
  const closedDeferred = yield* Deferred_exports.make().pipe(Effect_exports2.acquireRelease(Deferred_exports.done(Exit_exports.void)));
  const runtime8 = yield* Effect_exports2.runtime();
  const webChannel = {
    [mod_exports.WebChannelSymbol]: mod_exports.WebChannelSymbol,
    send: send2,
    listen,
    closedDeferred,
    supportsTransferables: false,
    schema: schema4,
    shutdown: Scope_exports.close(scope5, Exit_exports.void),
    debugInfo,
    ...{
      debug: {
        ping: /* @__PURE__ */ __name((message = "ping") => send2(mod_exports.DebugPingMessage.make({ message })).pipe(Effect_exports2.provide(runtime8), Effect_exports2.tapCauseLogPretty, Effect_exports2.runFork), "ping")
      }
    }
  };
  return webChannel;
}).pipe(Effect_exports2.withSpanScoped("makeProxyChannel"))), "makeProxyChannel");

// node_modules/.pnpm/@livestore+webmesh@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/webmesh/dist/utils.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var TimeoutSet = class _TimeoutSet {
  static {
    __name(this, "TimeoutSet");
  }
  values = /* @__PURE__ */ new Map();
  timeoutHandle;
  timeoutMs;
  constructor({ timeout: timeout5 }) {
    this.timeoutMs = Duration_exports.toMillis(timeout5);
  }
  static make = /* @__PURE__ */ __name((timeout5) => Effect_exports2.gen(function* () {
    const timeoutSet = new _TimeoutSet({ timeout: timeout5 });
    yield* Effect_exports2.addFinalizer(() => Effect_exports2.sync(() => timeoutSet.onShutdown()));
    return timeoutSet;
  }), "make");
  add(value6) {
    this.values.set(value6, Date.now());
    this.scheduleCleanup();
  }
  has(value6) {
    return this.values.has(value6);
  }
  delete(value6) {
    this.values.delete(value6);
  }
  scheduleCleanup() {
    if (this.timeoutHandle === void 0) {
      this.timeoutHandle = setTimeout(() => {
        this.cleanup();
        this.timeoutHandle = void 0;
      }, this.timeoutMs);
    }
  }
  cleanup() {
    const now2 = Date.now();
    for (const [value6, timestamp] of this.values.entries()) {
      if (now2 - timestamp >= this.timeoutMs) {
        this.values.delete(value6);
      }
    }
  }
  onShutdown = /* @__PURE__ */ __name(() => clearTimeout(this.timeoutHandle), "onShutdown");
};

// node_modules/.pnpm/@livestore+webmesh@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/webmesh/dist/node.js
var makeMeshNode = /* @__PURE__ */ __name((nodeName) => Effect_exports2.gen(function* () {
  const edgeChannels = /* @__PURE__ */ new Map();
  const handledPacketIds = yield* TimeoutSet.make(Duration_exports.minutes(1));
  const newEdgeAvailablePubSub = yield* PubSub_exports.unbounded().pipe(Effect_exports2.acquireRelease(PubSub_exports.shutdown));
  const channelMap = /* @__PURE__ */ new Map();
  const channelRequestsQueue = yield* Queue_exports.unbounded().pipe(Effect_exports2.acquireRelease(Queue_exports.shutdown));
  const topologyRequestsMap = /* @__PURE__ */ new Map();
  const broadcastChannelListenQueueMap = /* @__PURE__ */ new Map();
  const checkTransferableEdges = /* @__PURE__ */ __name((packet) => {
    if (packet._tag === "DirectChannelRequest" && (edgeChannels.size === 0 || // Either if direct edge does not support transferables ...
    edgeChannels.get(packet.target)?.channel.supportsTransferables === false) || // ... or if no forward-edges support transferables
    ![...edgeChannels.values()].some((c) => c.channel.supportsTransferables === true)) {
      return DirectChannelResponseNoTransferables.make({
        reqId: packet.id,
        channelName: packet.channelName,
        // NOTE for now we're "pretending" that the message is coming from the target node
        // even though we're already handling it here.
        // TODO we should clean this up at some point
        source: packet.target,
        target: packet.source,
        remainingHops: packet.hops,
        hops: []
      });
    }
  }, "checkTransferableEdges");
  const sendPacket = /* @__PURE__ */ __name((packet) => Effect_exports2.gen(function* () {
    if (Schema_exports2.is(NetworkEdgeAdded)(packet)) {
      yield* Effect_exports2.spanEvent("NetworkEdgeAdded", { packet, nodeName });
      yield* PubSub_exports.publish(newEdgeAvailablePubSub, packet.target);
      const edgesToForwardTo = Array.from(edgeChannels).filter(([name]) => name !== packet.source).map(([_, con]) => con.channel);
      yield* Effect_exports2.forEach(edgesToForwardTo, (con) => con.send(packet), { concurrency: "unbounded" });
      return;
    }
    if (Schema_exports2.is(BroadcastChannelPacket)(packet)) {
      const edgesToForwardTo = Array.from(edgeChannels).filter(([name]) => !packet.hops.includes(name)).map(([_, con]) => con.channel);
      const adjustedPacket = {
        ...packet,
        hops: [...packet.hops, nodeName]
      };
      yield* Effect_exports2.forEach(edgesToForwardTo, (con) => con.send(adjustedPacket), { concurrency: "unbounded" });
      if (packet.source === nodeName) {
        return;
      }
      const queue = broadcastChannelListenQueueMap.get(packet.channelName);
      if (queue !== void 0) {
        yield* Queue_exports.offer(queue, packet);
      }
      return;
    }
    if (Schema_exports2.is(NetworkTopologyRequest)(packet)) {
      if (packet.source !== nodeName) {
        const backEdgeName = packet.hops.at(-1) ?? shouldNeverHappen(`${nodeName}: Expected hops for packet`, packet);
        const backEdgeChannel = edgeChannels.get(backEdgeName).channel;
        const response = NetworkTopologyResponse.make({
          reqId: packet.id,
          source: packet.source,
          target: packet.target,
          remainingHops: packet.hops.slice(0, -1),
          nodeName,
          edges: Array.from(edgeChannels.keys())
        });
        yield* backEdgeChannel.send(response);
      }
      const edgesToForwardTo = Array.from(edgeChannels).filter(([name]) => !packet.hops.includes(name)).map(([_, con]) => con.channel);
      const adjustedPacket = {
        ...packet,
        hops: [...packet.hops, nodeName]
      };
      yield* Effect_exports2.forEach(edgesToForwardTo, (con) => con.send(adjustedPacket), { concurrency: "unbounded" });
      return;
    }
    if (Schema_exports2.is(NetworkTopologyResponse)(packet)) {
      if (packet.source === nodeName) {
        const topologyRequestItem = topologyRequestsMap.get(packet.reqId);
        topologyRequestItem.set(packet.nodeName, new Set(packet.edges));
      } else {
        const remainingHops = packet.remainingHops;
        const routeBack = remainingHops.at(-1) ?? shouldNeverHappen(`${nodeName}: Expected remaining hops for packet`, packet);
        const edgeChannel = edgeChannels.get(routeBack)?.channel ?? shouldNeverHappen(`${nodeName}: Expected edge channel (${routeBack}) for packet`, packet, "Available edges:", Array.from(edgeChannels.keys()));
        yield* edgeChannel.send({ ...packet, remainingHops: packet.remainingHops.slice(0, -1) });
      }
      return;
    }
    if (edgeChannels.has(packet.target)) {
      const edgeChannel = edgeChannels.get(packet.target).channel;
      const hops = packet.source === nodeName ? [] : [...packet.hops, nodeName];
      yield* Effect_exports2.annotateCurrentSpan({ hasDirectEdge: true });
      yield* edgeChannel.send({ ...packet, hops });
    } else if (packet.remainingHops !== void 0) {
      const hopTarget = packet.remainingHops.at(-1) ?? shouldNeverHappen(`${nodeName}: Expected remaining hops for packet`, packet);
      const edgeChannel = edgeChannels.get(hopTarget)?.channel;
      if (edgeChannel === void 0) {
        yield* Effect_exports2.logWarning(`${nodeName}: Expected to find hop target ${hopTarget} in edges. Dropping packet.`, packet);
        return;
      }
      yield* edgeChannel.send({
        ...packet,
        remainingHops: packet.remainingHops.slice(0, -1),
        hops: [...packet.hops, nodeName]
      });
    } else {
      const hops = packet.source === nodeName ? [] : [...packet.hops, nodeName];
      const edgesToForwardTo = Array.from(edgeChannels).filter(([name]) => name !== packet.source).map(([name, con]) => ({ name, channel: con.channel }));
      if (hops.length === 0 && edgesToForwardTo.length === 0 && LS_DEV) {
        yield* Effect_exports2.logWarning(nodeName, "no route found to", packet.target, packet._tag, "TODO handle better");
      }
      const packetToSend = { ...packet, hops };
      yield* Effect_exports2.annotateCurrentSpan({ edgesToForwardTo: edgesToForwardTo.map(({ name }) => name) });
      yield* Effect_exports2.forEach(edgesToForwardTo, ({ channel: channel2 }) => channel2.send(packetToSend), {
        concurrency: "unbounded"
      });
    }
  }).pipe(Effect_exports2.withSpan(`sendPacket:${packet._tag}:${packet.source}\u2192${packet.target}`, {
    attributes: packetAsOtelAttributes(packet)
  }), Effect_exports2.orDie), "sendPacket");
  const addEdge = /* @__PURE__ */ __name(({ target: targetNodeName, edgeChannel, replaceIfExists = false }) => Effect_exports2.gen(function* () {
    if (edgeChannels.has(targetNodeName)) {
      if (replaceIfExists) {
        yield* removeEdge(targetNodeName).pipe(Effect_exports2.orDie);
      } else {
        return yield* new EdgeAlreadyExistsError({ target: targetNodeName });
      }
    }
    const listenFiber = yield* edgeChannel.listen.pipe(Stream_exports2.flatten(), Stream_exports2.tap((message) => Effect_exports2.gen(function* () {
      const packet = yield* Schema_exports2.decodeUnknown(Packet)(message);
      if (handledPacketIds.has(packet.id))
        return;
      handledPacketIds.add(packet.id);
      switch (packet._tag) {
        case "NetworkEdgeAdded":
        case "NetworkTopologyRequest":
        case "NetworkTopologyResponse": {
          yield* sendPacket(packet);
          break;
        }
        default: {
          if (packet.target === nodeName) {
            const channelKey = `target:${packet.source}, channelName:${packet.channelName}`;
            if (!channelMap.has(channelKey)) {
              const channelQueue2 = yield* Queue_exports.unbounded().pipe(Effect_exports2.acquireRelease(Queue_exports.shutdown));
              channelMap.set(channelKey, { queue: channelQueue2, debugInfo: void 0 });
            }
            const channelQueue = channelMap.get(channelKey).queue;
            const respondToSender = /* @__PURE__ */ __name((outgoingPacket) => edgeChannel.send(outgoingPacket).pipe(Effect_exports2.withSpan(`respondToSender:${outgoingPacket._tag}:${outgoingPacket.source}\u2192${outgoingPacket.target}`, { attributes: packetAsOtelAttributes(outgoingPacket) }), Effect_exports2.orDie), "respondToSender");
            if (Schema_exports2.is(ProxyChannelPacket)(packet)) {
              yield* Queue_exports.offer(channelQueue, { packet, respondToSender });
            } else if (Schema_exports2.is(DirectChannelPacket)(packet)) {
              yield* Queue_exports.offer(channelQueue, { packet, respondToSender });
            }
            if (packet._tag === "ProxyChannelRequest" || packet._tag === "DirectChannelRequest") {
              yield* Queue_exports.offer(channelRequestsQueue, {
                channelName: packet.channelName,
                source: packet.source,
                mode: packet._tag === "ProxyChannelRequest" ? "proxy" : "direct"
              });
            }
          } else {
            if (Schema_exports2.is(DirectChannelPacket)(packet)) {
              const noTransferableResponse = checkTransferableEdges(packet);
              if (noTransferableResponse !== void 0) {
                yield* Effect_exports2.spanEvent(`No transferable edges found for ${packet.source}\u2192${packet.target}`);
                return yield* edgeChannel.send(noTransferableResponse).pipe(Effect_exports2.withSpan(`sendNoTransferableResponse:${packet.source}\u2192${packet.target}`, {
                  attributes: packetAsOtelAttributes(noTransferableResponse)
                }));
              }
            }
            yield* sendPacket(packet);
          }
        }
      }
    })), Stream_exports2.runDrain, Effect_exports2.interruptible, Effect_exports2.orDie, Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
    edgeChannels.set(targetNodeName, { channel: edgeChannel, listenFiber });
    const edgeAddedPacket = NetworkEdgeAdded.make({
      source: nodeName,
      target: targetNodeName
    });
    yield* sendPacket(edgeAddedPacket).pipe(Effect_exports2.orDie);
  }).pipe(Effect_exports2.annotateLogs({ "addEdge:target": targetNodeName, nodeName }), Effect_exports2.withSpan(`addEdge:${nodeName}\u2192${targetNodeName}`, {
    attributes: { supportsTransferables: edgeChannel.supportsTransferables }
  })), "addEdge");
  const removeEdge = /* @__PURE__ */ __name((targetNodeName) => Effect_exports2.gen(function* () {
    if (!edgeChannels.has(targetNodeName)) {
      yield* new Cause_exports.NoSuchElementException(`No edge found for ${targetNodeName}`);
    }
    yield* Fiber_exports.interrupt(edgeChannels.get(targetNodeName).listenFiber);
    edgeChannels.delete(targetNodeName);
  }), "removeEdge");
  const hasChannel = /* @__PURE__ */ __name(({ target: target3, channelName }) => Effect_exports2.sync(() => channelMap.has(`target:${target3}, channelName:${channelName}`)), "hasChannel");
  const makeChannel3 = /* @__PURE__ */ __name(({
    target: target3,
    channelName,
    schema: inputSchema,
    // TODO in the future we could have a mode that prefers directs and then falls back to proxies if needed
    mode,
    timeout: timeout5 = Duration_exports.seconds(1),
    closeExisting = false
  }) => Effect_exports2.gen(function* () {
    const schema4 = mod_exports.mapSchema(inputSchema);
    const channelKey = `target:${target3}, channelName:${channelName}`;
    if (channelMap.has(channelKey)) {
      const existingChannel = channelMap.get(channelKey).debugInfo?.channel;
      if (existingChannel) {
        if (closeExisting) {
          yield* existingChannel.shutdown;
          channelMap.delete(channelKey);
        } else {
          shouldNeverHappen(`Channel ${channelKey} already exists`, existingChannel);
        }
      }
    }
    if (channelMap.has(channelKey) === false) {
      const channelQueue2 = yield* Queue_exports.unbounded().pipe(Effect_exports2.acquireRelease(Queue_exports.shutdown));
      channelMap.set(channelKey, { queue: channelQueue2, debugInfo: void 0 });
    }
    const channelQueue = channelMap.get(channelKey).queue;
    yield* Effect_exports2.addFinalizer(() => Effect_exports2.sync(() => channelMap.delete(channelKey)));
    if (mode === "direct") {
      const incomingPacketsQueue = yield* Queue_exports.unbounded().pipe(Effect_exports2.acquireRelease(Queue_exports.shutdown));
      yield* Queue_exports.takeBetween(channelQueue, 1, 10).pipe(Effect_exports2.tap((_) => Queue_exports.offerAll(incomingPacketsQueue, _)), Effect_exports2.forever, Effect_exports2.interruptible, Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
      const { webChannel, initialEdgeDeferred } = yield* makeDirectChannel({
        nodeName,
        incomingPacketsQueue,
        newEdgeAvailablePubSub,
        target: target3,
        channelName,
        schema: schema4,
        sendPacket,
        checkTransferableEdges
      });
      channelMap.set(channelKey, { queue: channelQueue, debugInfo: { channel: webChannel, target: target3 } });
      yield* initialEdgeDeferred;
      return webChannel;
    } else {
      const channel2 = yield* makeProxyChannel({
        nodeName,
        newEdgeAvailablePubSub,
        target: target3,
        channelName,
        schema: schema4,
        queue: channelQueue,
        sendPacket
      });
      channelMap.set(channelKey, { queue: channelQueue, debugInfo: { channel: channel2, target: target3 } });
      return channel2;
    }
  }).pipe(
    // Effect.timeout(timeout),
    Effect_exports2.withSpanScoped(`makeChannel:${nodeName}\u2192${target3}(${channelName})`, {
      attributes: { target: target3, channelName, mode, timeout: timeout5 }
    }),
    Effect_exports2.annotateLogs({ nodeName, target: target3, channelName })
  ), "makeChannel");
  let listenAlreadyStarted = false;
  const listenForChannel = Stream_exports2.suspend(() => {
    if (listenAlreadyStarted) {
      return shouldNeverHappen("listenForChannel already started");
    }
    listenAlreadyStarted = true;
    const hash5 = /* @__PURE__ */ __name((res) => `${res.channelName}:${res.source}:${res.mode}`, "hash");
    const seen = /* @__PURE__ */ new Set();
    return Stream_exports2.fromQueue(channelRequestsQueue).pipe(Stream_exports2.filter((res) => {
      const hashed = hash5(res);
      if (seen.has(hashed)) {
        return false;
      }
      seen.add(hashed);
      return true;
    }));
  });
  const makeBroadcastChannel = /* @__PURE__ */ __name(({ channelName, schema: schema4 }) => Effect_exports2.scopeWithCloseable((scope5) => Effect_exports2.gen(function* () {
    if (broadcastChannelListenQueueMap.has(channelName)) {
      return shouldNeverHappen(`Broadcast channel ${channelName} already exists`, broadcastChannelListenQueueMap.get(channelName));
    }
    const debugInfo = {};
    const queue = yield* Queue_exports.unbounded().pipe(Effect_exports2.acquireRelease(Queue_exports.shutdown));
    broadcastChannelListenQueueMap.set(channelName, queue);
    const send2 = /* @__PURE__ */ __name((message) => Effect_exports2.gen(function* () {
      const payload = yield* Schema_exports2.encode(schema4)(message);
      const packet = BroadcastChannelPacket.make({
        channelName,
        payload,
        source: nodeName,
        target: "-",
        hops: []
      });
      yield* sendPacket(packet);
    }), "send");
    const listen = Stream_exports2.fromQueue(queue).pipe(Stream_exports2.filter(Schema_exports2.is(BroadcastChannelPacket)), Stream_exports2.map((_) => Schema_exports2.decodeEither(schema4)(_.payload)));
    const closedDeferred = yield* Deferred_exports.make().pipe(Effect_exports2.acquireRelease(Deferred_exports.done(Exit_exports.void)));
    return {
      [mod_exports.WebChannelSymbol]: mod_exports.WebChannelSymbol,
      send: send2,
      listen,
      closedDeferred,
      supportsTransferables: false,
      schema: { listen: schema4, send: schema4 },
      shutdown: Scope_exports.close(scope5, Exit_exports.void),
      debugInfo
    };
  })), "makeBroadcastChannel");
  const edgeKeys = Effect_exports2.sync(() => new Set(edgeChannels.keys()));
  const runtime8 = yield* Effect_exports2.runtime();
  const debug4 = {
    print: /* @__PURE__ */ __name(() => {
      console.log("Webmesh debug info for node:", nodeName);
      console.log("Edges:", edgeChannels.size);
      for (const [key, value6] of edgeChannels) {
        console.log(`  ${key}: supportsTransferables=${value6.channel.supportsTransferables}`);
      }
      console.log("Channels:", channelMap.size);
      for (const [key, value6] of channelMap) {
        console.log(indent(key, 2), "\n", Object.entries({
          target: value6.debugInfo?.target,
          supportsTransferables: value6.debugInfo?.channel.supportsTransferables,
          ...value6.debugInfo?.channel.debugInfo
        }).map(([key2, value7]) => indent(`${key2}=${value7}`, 4)).join("\n"), "    ", value6.debugInfo?.channel, "\n", indent(`Queue: ${value6.queue.unsafeSize().pipe(Option_exports.getOrUndefined)}`, 4), value6.queue);
      }
      console.log("Broadcast channels:", broadcastChannelListenQueueMap.size);
      for (const [key, _value] of broadcastChannelListenQueueMap) {
        console.log(indent(key, 2));
      }
    }, "print"),
    ping: /* @__PURE__ */ __name((payload) => {
      Effect_exports2.gen(function* () {
        const msg = /* @__PURE__ */ __name((via) => mod_exports.DebugPingMessage.make({ message: `ping from ${nodeName} via ${via}`, payload }), "msg");
        for (const [channelName, con] of edgeChannels) {
          yield* Effect_exports2.logDebug(`sending ping via edge ${channelName}`);
          yield* con.channel.send(msg(`edge ${channelName}`));
        }
        for (const [channelKey, channel2] of channelMap) {
          if (channel2.debugInfo === void 0) {
            yield* Effect_exports2.logDebug(`channel ${channelKey} has no debug info`);
            continue;
          }
          yield* Effect_exports2.logDebug(`sending ping via channel ${channelKey}`);
          yield* channel2.debugInfo.channel.send(msg(`channel ${channelKey}`));
        }
      }).pipe(Effect_exports2.provide(runtime8), Effect_exports2.tapCauseLogPretty, Effect_exports2.runFork);
    }, "ping"),
    requestTopology: /* @__PURE__ */ __name((timeoutMs = 1e3) => Effect_exports2.gen(function* () {
      const packet = NetworkTopologyRequest.make({
        source: nodeName,
        target: "-",
        hops: []
      });
      const item = /* @__PURE__ */ new Map();
      item.set(nodeName, new Set(edgeChannels.keys()));
      topologyRequestsMap.set(packet.id, item);
      yield* sendPacket(packet);
      yield* Effect_exports2.logDebug(`Waiting ${timeoutMs}ms for topology response`);
      yield* Effect_exports2.sleep(timeoutMs);
      yield* Effect_exports2.logDebug(`Topology response (from ${nodeName}):`);
      for (const [key, value6] of item) {
        yield* Effect_exports2.logDebug(`  node '${key}' has edge to: ${Array.from(value6.values()).join(", ")}`);
      }
    }).pipe(Effect_exports2.provide(runtime8), Effect_exports2.tapCauseLogPretty, Effect_exports2.runPromise), "requestTopology")
  };
  return {
    nodeName,
    addEdge,
    removeEdge,
    hasChannel,
    makeChannel: makeChannel3,
    listenForChannel,
    makeBroadcastChannel,
    edgeKeys,
    debug: debug4
  };
}).pipe(Effect_exports2.withSpan(`makeMeshNode:${nodeName}`), Effect_exports2.annotateLogs({ "makeMeshNode.nodeName": nodeName })), "makeMeshNode");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/make-client-session.js
var makeClientSession = /* @__PURE__ */ __name(({ storeId: storeId2, clientId: clientId2, sessionId: sessionId2, isLeader, devtoolsEnabled, connectDevtoolsToStore: connectDevtoolsToStore2, lockStatus, leaderThread, schema: schema4, sqliteDb, shutdown: shutdown9, connectWebmeshNode, webmeshMode, registerBeforeUnload, debugInstanceId }) => Effect_exports2.gen(function* () {
  const devtools = devtoolsEnabled ? { enabled: true, pullLatch: yield* Effect_exports2.makeLatch(true), pushLatch: yield* Effect_exports2.makeLatch(true) } : { enabled: false };
  if (devtoolsEnabled) {
    yield* Effect_exports2.gen(function* () {
      const webmeshNode = yield* makeMeshNode(makeNodeName.client.session({ storeId: storeId2, clientId: clientId2, sessionId: sessionId2 }));
      globalThis.__debugWebmeshNode = webmeshNode;
      const schemaAlias = schema4.devtools.alias;
      const sessionInfo = devtools_sessioninfo_exports.SessionInfo.make({
        storeId: storeId2,
        clientId: clientId2,
        sessionId: sessionId2,
        schemaAlias,
        isLeader
      });
      yield* connectWebmeshNode({ webmeshNode, sessionInfo });
      const sessionInfoBroadcastChannel = yield* makeSessionInfoBroadcastChannel(webmeshNode);
      yield* devtools_sessioninfo_exports.provideSessionInfo({
        webChannel: sessionInfoBroadcastChannel,
        sessionInfo
      }).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
      yield* webmeshNode.listenForChannel.pipe(Stream_exports2.filter((res) => isChannelName.devtoolsClientSession(res.channelName, { storeId: storeId2, clientId: clientId2, sessionId: sessionId2 }) && res.mode === webmeshMode), Stream_exports2.tap(Effect_exports2.fnUntraced(function* ({ channelName, source }) {
        const clientSessionDevtoolsChannel = yield* webmeshNode.makeChannel({
          target: source,
          channelName,
          schema: { listen: devtools_messages_client_session_exports.MessageToApp, send: devtools_messages_client_session_exports.MessageFromApp },
          mode: webmeshMode
        });
        const sendDisconnect = clientSessionDevtoolsChannel.send(devtools_messages_client_session_exports.Disconnect.make({ clientId: clientId2, liveStoreVersion, sessionId: sessionId2 })).pipe(Effect_exports2.orDie);
        yield* Effect_exports2.addFinalizer(() => sendDisconnect);
        yield* Effect_exports2.acquireRelease(Effect_exports2.sync(() => registerBeforeUnload(() => sendDisconnect.pipe(Effect_exports2.runFork))), (unsub) => Effect_exports2.sync(() => unsub()));
        yield* connectDevtoolsToStore2(clientSessionDevtoolsChannel);
      }, Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped)), Stream_exports2.runDrain);
    }).pipe(Effect_exports2.withSpan("@livestore/common:make-client-session:devtools"), Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
  }
  return {
    sqliteDb,
    leaderThread,
    devtools,
    lockStatus,
    clientId: clientId2,
    sessionId: sessionId2,
    shutdown: shutdown9,
    debugInstanceId
  };
}).pipe(Effect_exports2.withSpan("@livestore/common:make-client-session")), "makeClientSession");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/materializer-helper.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var getExecStatementsFromMaterializer = /* @__PURE__ */ __name(({ eventDef, materializer, dbState, event }) => {
  const eventArgsDecoded = event.decoded === void 0 ? Schema_exports2.decodeUnknownSync(eventDef.schema)(event.encoded.args) : event.decoded.args;
  const eventArgsEncoded = isNil2(event.decoded?.args) ? void 0 : Schema_exports2.encodeUnknownSync(eventDef.schema)(event.decoded.args);
  const query = /* @__PURE__ */ __name((rawQueryOrQueryBuilder) => {
    if (isQueryBuilder(rawQueryOrQueryBuilder)) {
      const { query: query2, bindValues } = rawQueryOrQueryBuilder.asSql();
      const rawResults = dbState.select(query2, prepareBindValues(bindValues, query2));
      const resultSchema = getResultSchema(rawQueryOrQueryBuilder);
      return Schema_exports2.decodeSync(resultSchema)(rawResults);
    } else {
      const { query: query2, bindValues } = rawQueryOrQueryBuilder;
      return dbState.select(query2, prepareBindValues(bindValues, query2));
    }
  }, "query");
  const statementResults = fromMaterializerResult(materializer(eventArgsDecoded, {
    eventDef,
    query,
    // TODO properly implement this
    currentFacts: /* @__PURE__ */ new Map()
  }));
  return statementResults.map((statementRes) => {
    const statementSql = statementRes.sql;
    const bindValues = typeof statementRes === "string" ? eventArgsEncoded : statementRes.bindValues;
    const writeTables = typeof statementRes === "string" ? void 0 : statementRes.writeTables;
    return { statementSql, bindValues: prepareBindValues(bindValues ?? {}, statementSql), writeTables };
  });
}, "getExecStatementsFromMaterializer");
var makeMaterializerHash = /* @__PURE__ */ __name(({ schema: schema4, dbState }) => (event) => {
  if (isDevEnv()) {
    const { eventDef, materializer } = getEventDef(schema4, event.name);
    const materializerResults = getExecStatementsFromMaterializer({
      eventDef,
      materializer,
      dbState,
      event: { decoded: void 0, encoded: event }
    });
    return Option_exports.some(Hash_exports.string(JSON.stringify(materializerResults)));
  }
  return Option_exports.none();
}, "makeMaterializerHash");
var hashMaterializerResults = /* @__PURE__ */ __name((materializerResults) => Hash_exports.string(JSON.stringify(materializerResults)), "hashMaterializerResults");
var fromMaterializerResult = /* @__PURE__ */ __name((materializerResult) => {
  if (isReadonlyArray(materializerResult)) {
    return materializerResult.flatMap(fromMaterializerResult);
  }
  if (isQueryBuilder(materializerResult)) {
    const { query, bindValues, usedTables } = materializerResult.asSql();
    return [{ sql: query, bindValues, writeTables: usedTables }];
  } else if (typeof materializerResult === "string") {
    return [{ sql: materializerResult, bindValues: {}, writeTables: void 0 }];
  } else {
    return [
      {
        sql: materializerResult.sql,
        bindValues: materializerResult.bindValues,
        writeTables: materializerResult.writeTables
      }
    ];
  }
}, "fromMaterializerResult");
var replaceSessionIdSymbol = /* @__PURE__ */ __name((bindValues, sessionId2) => {
  deepReplaceValue(bindValues, SessionIdSymbol, sessionId2);
}, "replaceSessionIdSymbol");
var deepReplaceValue = /* @__PURE__ */ __name((input, searchValue, replaceValue) => {
  if (Array.isArray(input)) {
    for (const i in input) {
      if (input[i] === searchValue) {
        input[i] = replaceValue;
      } else {
        deepReplaceValue(input[i], searchValue, replaceValue);
      }
    }
  } else if (typeof input === "object" && input !== null) {
    for (const key in input) {
      if (input[key] === searchValue) {
        input[key] = replaceValue;
      } else {
        deepReplaceValue(input[key], searchValue, replaceValue);
      }
    }
  }
}, "deepReplaceValue");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/otel.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var otel = __toESM(require_src(), 1);
var provideOtel = /* @__PURE__ */ __name(({ otelTracer, parentSpanContext }) => (effect4) => {
  const OtelTracerLive = Layer_exports.succeed(OtelTracer_exports.OtelTracer, otelTracer ?? makeNoopTracer());
  const TracingLive = Layer_exports.unwrapEffect(Effect_exports2.map(OtelTracer_exports.make, Layer_exports.setTracer)).pipe(Layer_exports.provideMerge(OtelTracerLive));
  return effect4.pipe(parentSpanContext ? Effect_exports2.withParentSpan(OtelTracer_exports.makeExternalSpan(otel.trace.getSpanContext(parentSpanContext))) : identity, Effect_exports2.provide(TracingLive));
}, "provideOtel");
var getDurationMsFromSpan = /* @__PURE__ */ __name((span4) => {
  const durationHr = span4._duration;
  return durationHr[0] * 1e3 + durationHr[1] / 1e6;
}, "getDurationMsFromSpan");
var getStartTimeHighResFromSpan = /* @__PURE__ */ __name((span4) => span4._performanceStartTime, "getStartTimeHighResFromSpan");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/rematerialize-from-eventlog.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var rematerializeFromEventlog = /* @__PURE__ */ __name(({
  dbEventlog,
  // TODO re-use this db when bringing back the boot in-memory db implementation
  // db,
  schema: schema4,
  onProgress,
  materializeEvent
}) => Effect_exports2.gen(function* () {
  const eventsCount = dbEventlog.select(`SELECT COUNT(*) AS count FROM ${system_tables_exports.EVENTLOG_META_TABLE}`)[0].count;
  const hashEventDef = memoizeByRef((event) => Schema_exports2.hash(event.schema));
  const processEvent = /* @__PURE__ */ __name((row) => Effect_exports2.gen(function* () {
    const eventDef = getEventDef(schema4, row.name);
    if (hashEventDef(eventDef.eventDef) !== row.schemaHash) {
      yield* Effect_exports2.logWarning(`Schema hash mismatch for event definition ${row.name}. Trying to materialize event anyway.`);
    }
    const args2 = JSON.parse(row.argsJson);
    yield* Schema_exports2.decodeUnknown(eventDef.eventDef.schema)(args2).pipe(Effect_exports2.mapError((cause3) => UnexpectedError.make({
      cause: cause3,
      note: `There was an error during rematerializing from the eventlog while decoding
the persisted event args for event definition "${row.name}".
This likely means the schema has changed in an incompatible way.
`
    })));
    const eventEncoded = LiveStoreEvent_exports.EncodedWithMeta.make({
      seqNum: {
        global: row.seqNumGlobal,
        client: row.seqNumClient,
        rebaseGeneration: row.seqNumRebaseGeneration
      },
      parentSeqNum: {
        global: row.parentSeqNumGlobal,
        client: row.parentSeqNumClient,
        rebaseGeneration: row.parentSeqNumRebaseGeneration
      },
      name: row.name,
      args: args2,
      clientId: row.clientId,
      sessionId: row.sessionId
    });
    yield* materializeEvent(eventEncoded, { skipEventlog: true });
  }).pipe(Effect_exports2.withSpan(`@livestore/common:rematerializeFromEventlog:processEvent`)), "processEvent");
  const CHUNK_SIZE2 = 100;
  const stmt = dbEventlog.prepare(sql`\
SELECT * FROM ${system_tables_exports.EVENTLOG_META_TABLE} 
WHERE seqNumGlobal > $seqNumGlobal OR (seqNumGlobal = $seqNumGlobal AND seqNumClient > $seqNumClient)
ORDER BY seqNumGlobal ASC, seqNumClient ASC
LIMIT ${CHUNK_SIZE2}
`);
  let processedEvents = 0;
  yield* Stream_exports2.unfoldChunk({ _tag: "Initial" }, (item) => {
    if (Chunk_exports.isChunk(item) && item.length === 0)
      return Option_exports.none();
    const lastId = Chunk_exports.isChunk(item) ? Chunk_exports.last(item).pipe(Option_exports.map((_) => ({ global: _.seqNumGlobal, client: _.seqNumClient })), Option_exports.getOrElse(() => EventSequenceNumber_exports.ROOT)) : EventSequenceNumber_exports.ROOT;
    const nextItem = Chunk_exports.fromIterable(stmt.select({
      $seqNumGlobal: lastId?.global,
      $seqNumClient: lastId?.client
    }));
    const prevItem = Chunk_exports.isChunk(item) ? item : Chunk_exports.empty();
    return Option_exports.some([prevItem, nextItem]);
  }).pipe(Stream_exports2.bufferChunks({ capacity: 2 }), Stream_exports2.tap((row) => Effect_exports2.gen(function* () {
    yield* processEvent(row);
    processedEvents++;
    yield* onProgress({ done: processedEvents, total: eventsCount });
  })), Stream_exports2.runDrain);
}).pipe(Effect_exports2.withPerformanceMeasure("@livestore/common:rematerializeFromEventlog"), Effect_exports2.withSpan("@livestore/common:rematerializeFromEventlog")), "rematerializeFromEventlog");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema-management/migrations.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema-management/common.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var dbExecute = /* @__PURE__ */ __name((db, queryStr, bindValues) => {
  const stmt = db.prepare(queryStr);
  const preparedBindValues = bindValues ? prepareBindValues(bindValues, queryStr) : void 0;
  try {
    stmt.execute(preparedBindValues);
    stmt.finalize();
  } catch (cause3) {
    throw new SqliteError({
      cause: cause3,
      query: { sql: queryStr, bindValues: preparedBindValues ?? {} }
    });
  }
}, "dbExecute");
var dbSelect = /* @__PURE__ */ __name((db, queryStr, bindValues) => {
  const stmt = db.prepare(queryStr);
  const res = stmt.select(bindValues ? prepareBindValues(bindValues, queryStr) : void 0);
  stmt.finalize();
  return res;
}, "dbSelect");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema-management/validate-schema.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var validateSchema = /* @__PURE__ */ __name((schema4, schemaManager) => Effect_exports2.gen(function* () {
  const registeredEventDefInfos = schemaManager.getEventDefInfos();
  const missingEventDefs = registeredEventDefInfos.filter((registeredEventDefInfo) => !schema4.eventsDefsMap.has(registeredEventDefInfo.eventName));
  if (missingEventDefs.length > 0) {
    return yield* new UnexpectedError({
      cause: `Missing mutation definitions: ${missingEventDefs.map((info4) => info4.eventName).join(", ")}`
    });
  }
  for (const [, eventDef] of schema4.eventsDefsMap) {
    const registeredEventDefInfo = registeredEventDefInfos.find((info4) => info4.eventName === eventDef.name);
    validateEventDef(eventDef, schemaManager, registeredEventDefInfo);
  }
}), "validateSchema");
var validateEventDef = /* @__PURE__ */ __name((eventDef, schemaManager, registeredEventDefInfo) => {
  const schemaHash = Schema_exports2.hash(eventDef.schema);
  if (registeredEventDefInfo === void 0) {
    schemaManager.setEventDefInfo({
      schemaHash,
      eventName: eventDef.name
    });
    return;
  }
  if (schemaHash === registeredEventDefInfo.schemaHash)
    return;
  schemaManager.setEventDefInfo({
    schemaHash,
    eventName: eventDef.name
  });
}, "validateEventDef");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/schema-management/migrations.js
var getMemoizedTimestamp = memoizeByStringifyArgs(() => (/* @__PURE__ */ new Date()).toISOString());
var makeSchemaManager = /* @__PURE__ */ __name((db) => Effect_exports2.gen(function* () {
  yield* migrateTable({
    db,
    tableAst: schemaEventDefsMetaTable.sqliteDef.ast,
    behaviour: "create-if-not-exists"
  });
  return {
    getEventDefInfos: /* @__PURE__ */ __name(() => dbSelect(db, sql`SELECT * FROM ${SCHEMA_EVENT_DEFS_META_TABLE}`), "getEventDefInfos"),
    setEventDefInfo: /* @__PURE__ */ __name((info4) => {
      dbExecute(db, sql`INSERT OR REPLACE INTO ${SCHEMA_EVENT_DEFS_META_TABLE} (eventName, schemaHash, updatedAt) VALUES ($eventName, $schemaHash, $updatedAt)`, {
        eventName: info4.eventName,
        schemaHash: info4.schemaHash,
        updatedAt: (/* @__PURE__ */ new Date()).toISOString()
      });
    }, "setEventDefInfo")
  };
}), "makeSchemaManager");
var migrateDb = /* @__PURE__ */ __name(({ db, schema: schema4, onProgress }) => Effect_exports2.gen(function* () {
  for (const tableDef of stateSystemTables) {
    yield* migrateTable({
      db,
      tableAst: tableDef.sqliteDef.ast,
      behaviour: "create-if-not-exists"
    });
  }
  const schemaManager = yield* makeSchemaManager(db);
  yield* validateSchema(schema4, schemaManager);
  const schemaMetaRows = dbSelect(db, sql`SELECT * FROM ${SCHEMA_META_TABLE}`);
  const dbSchemaHashByTable = Object.fromEntries(schemaMetaRows.map(({ tableName, schemaHash }) => [tableName, schemaHash]));
  const tableDefs = [
    // NOTE it's important the `SCHEMA_META_TABLE` comes first since we're writing to it below
    ...stateSystemTables,
    ...Array.from(schema4.state.sqlite.tables.values()).filter((_) => !isStateSystemTable(_.sqliteDef.name))
  ];
  const tablesToMigrate = /* @__PURE__ */ new Set();
  const migrationsReportEntries = [];
  for (const tableDef of tableDefs) {
    const tableAst = tableDef.sqliteDef.ast;
    const tableName = tableAst.name;
    const dbSchemaHash = dbSchemaHashByTable[tableName];
    const schemaHash = sqlite_exports.hash(tableAst);
    if (schemaHash !== dbSchemaHash) {
      tablesToMigrate.add({ tableAst, schemaHash });
      migrationsReportEntries.push({
        tableName,
        hashes: { expected: schemaHash, actual: dbSchemaHash }
      });
    }
  }
  let processedTables = 0;
  const tablesCount = tablesToMigrate.size;
  for (const { tableAst, schemaHash } of tablesToMigrate) {
    yield* migrateTable({ db, tableAst, schemaHash, behaviour: "create-if-not-exists" });
    if (onProgress !== void 0) {
      processedTables++;
      yield* onProgress({ done: processedTables, total: tablesCount });
    }
  }
  return { migrations: migrationsReportEntries };
}), "migrateDb");
var migrateTable = /* @__PURE__ */ __name(({ db, tableAst, schemaHash = sqlite_exports.hash(tableAst), behaviour, skipMetaTable = false }) => Effect_exports2.gen(function* () {
  const tableName = tableAst.name;
  const columnSpec = makeColumnSpec(tableAst);
  if (behaviour === "drop-and-recreate") {
    dbExecute(db, sql`drop table if exists '${tableName}'`);
    dbExecute(db, sql`create table if not exists '${tableName}' (${columnSpec}) strict`);
  } else if (behaviour === "create-if-not-exists") {
    dbExecute(db, sql`create table if not exists '${tableName}' (${columnSpec}) strict`);
  }
  for (const index2 of tableAst.indexes) {
    dbExecute(db, createIndexFromDefinition(tableName, index2));
  }
  if (skipMetaTable !== true) {
    const updatedAt = getMemoizedTimestamp();
    dbExecute(db, sql`
      INSERT INTO ${SCHEMA_META_TABLE} (tableName, schemaHash, updatedAt) VALUES ($tableName, $schemaHash, $updatedAt)
        ON CONFLICT (tableName) DO UPDATE SET schemaHash = $schemaHash, updatedAt = $updatedAt;
    `, { tableName, schemaHash, updatedAt });
  }
}).pipe(Effect_exports2.withSpan("@livestore/common:migrateTable", {
  attributes: {
    "span.label": tableAst.name,
    tableName: tableAst.name
  }
})), "migrateTable");
var createIndexFromDefinition = /* @__PURE__ */ __name((tableName, index2) => {
  const uniqueStr = index2.unique ? "UNIQUE" : "";
  return sql`create ${uniqueStr} index if not exists '${index2.name}' on '${tableName}' (${index2.columns.map((col) => `'${col}'`).join(", ")})`;
}, "createIndexFromDefinition");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/sqlite-db-helper.js
var sqlite_db_helper_exports = {};
__export(sqlite_db_helper_exports, {
  makeExecute: () => makeExecute,
  makeExport: () => makeExport,
  makeSelect: () => makeSelect,
  validateSnapshot: () => validateSnapshot
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeExecute = /* @__PURE__ */ __name((execute4) => {
  return (...args2) => {
    const [queryStrOrQueryBuilder, bindValuesOrOptions, maybeOptions] = args2;
    if (isQueryBuilder(queryStrOrQueryBuilder)) {
      const { query, bindValues } = queryStrOrQueryBuilder.asSql();
      return execute4(query, bindValues, bindValuesOrOptions);
    } else {
      return execute4(queryStrOrQueryBuilder, bindValuesOrOptions, maybeOptions);
    }
  };
}, "makeExecute");
var makeSelect = /* @__PURE__ */ __name((select) => {
  return (...args2) => {
    const [queryStrOrQueryBuilder, maybeBindValues] = args2;
    if (isQueryBuilder(queryStrOrQueryBuilder)) {
      const { query, bindValues } = queryStrOrQueryBuilder.asSql();
      const resultSchema = getResultSchema(queryStrOrQueryBuilder);
      const results = select(query, bindValues);
      return Schema_exports2.decodeSync(resultSchema)(results);
    } else {
      return select(queryStrOrQueryBuilder, maybeBindValues);
    }
  };
}, "makeSelect");
var validateSnapshot = /* @__PURE__ */ __name((snapshot2) => {
  const headerBytes = new TextDecoder().decode(snapshot2.slice(0, 16));
  const hasValidHeader = headerBytes.startsWith("SQLite format 3");
  if (!hasValidHeader) {
    throw new SqliteError({
      cause: "Invalid SQLite header",
      note: `Expected header to start with 'SQLite format 3', but got: ${headerBytes}`
    });
  }
}, "validateSnapshot");
var makeExport = /* @__PURE__ */ __name((exportFn) => () => {
  const snapshot2 = exportFn();
  validateSnapshot(snapshot2);
  return snapshot2;
}, "makeExport");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/sync/ClientSessionSyncProcessor.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeClientSessionSyncProcessor = /* @__PURE__ */ __name(({ schema: schema4, clientSession, runtime: runtime8, materializeEvent, rollback: rollback2, refreshTables, span: span4, params: params2, confirmUnsavedChanges }) => {
  const eventSchema = makeEventDefSchemaMemo(schema4);
  const simSleep = /* @__PURE__ */ __name((key, key2) => Effect_exports2.sleep(params2.simulation?.[key]?.[key2] ?? 0), "simSleep");
  const syncStateRef = {
    // The initial state is identical to the leader's initial state
    current: new SyncState({
      localHead: clientSession.leaderThread.initialState.leaderHead,
      upstreamHead: clientSession.leaderThread.initialState.leaderHead,
      // Given we're starting with the leader's snapshot, we don't have any pending events intially
      pending: []
    })
  };
  const syncStateUpdateQueue = Queue_exports.unbounded().pipe(Effect_exports2.runSync);
  const isClientEvent = /* @__PURE__ */ __name((eventEncoded) => getEventDef(schema4, eventEncoded.name).eventDef.options.clientOnly, "isClientEvent");
  const leaderPushQueue = BucketQueue_exports.make().pipe(Effect_exports2.runSync);
  const push = Effect_exports2.fn("client-session-sync-processor:push")(function* (batch) {
    let baseEventSequenceNumber = syncStateRef.current.localHead;
    const encodedEventDefs = batch.map(({ name, args: args2 }) => {
      const eventDef = getEventDef(schema4, name);
      const nextNumPair = nextPair({
        seqNum: baseEventSequenceNumber,
        isClient: eventDef.eventDef.options.clientOnly
      });
      baseEventSequenceNumber = nextNumPair.seqNum;
      return new EncodedWithMeta(Schema_exports2.encodeUnknownSync(eventSchema)({
        name,
        args: args2,
        ...nextNumPair,
        clientId: clientSession.clientId,
        sessionId: clientSession.sessionId
      }));
    });
    const mergeResult = merge15({
      syncState: syncStateRef.current,
      payload: { _tag: "local-push", newEvents: encodedEventDefs },
      isClientEvent,
      isEqualEvent: isEqualEncoded
    });
    yield* Effect_exports2.annotateCurrentSpan({
      batchSize: encodedEventDefs.length,
      mergeResultTag: mergeResult._tag,
      eventCounts: encodedEventDefs.reduce((acc, event) => {
        acc[event.name] = (acc[event.name] ?? 0) + 1;
        return acc;
      }, {}),
      ...TRACE_VERBOSE && { mergeResult: JSON.stringify(mergeResult) }
    });
    if (mergeResult._tag === "unexpected-error") {
      return shouldNeverHappen("Unexpected error in client-session-sync-processor", mergeResult.message);
    }
    if (mergeResult._tag !== "advance") {
      return shouldNeverHappen(`Expected advance, got ${mergeResult._tag}`);
    }
    syncStateRef.current = mergeResult.newSyncState;
    yield* syncStateUpdateQueue.offer(mergeResult.newSyncState);
    const writeTables = /* @__PURE__ */ new Set();
    for (const event of mergeResult.newEvents) {
      const decodedEventDef = Schema_exports2.decodeSync(eventSchema)(event);
      const { writeTables: newWriteTables, sessionChangeset, materializerHash } = yield* materializeEvent(decodedEventDef, {
        withChangeset: true,
        materializerHashLeader: Option_exports.none()
      });
      for (const table7 of newWriteTables) {
        writeTables.add(table7);
      }
      event.meta.sessionChangeset = sessionChangeset;
      event.meta.materializerHashSession = materializerHash;
    }
    yield* BucketQueue_exports.offerAll(leaderPushQueue, encodedEventDefs);
    return { writeTables };
  });
  const debugInfo = {
    rebaseCount: 0,
    advanceCount: 0,
    rejectCount: 0
  };
  const boot = Effect_exports2.gen(function* () {
    if (confirmUnsavedChanges && typeof window !== "undefined" && typeof window.addEventListener === "function") {
      const onBeforeUnload = /* @__PURE__ */ __name((event) => {
        if (syncStateRef.current.pending.length > 0) {
          event.preventDefault();
        }
      }, "onBeforeUnload");
      yield* Effect_exports2.acquireRelease(Effect_exports2.sync(() => window.addEventListener("beforeunload", onBeforeUnload)), () => Effect_exports2.sync(() => window.removeEventListener("beforeunload", onBeforeUnload)));
    }
    const leaderPushingFiberHandle = yield* FiberHandle_exports.make();
    const backgroundLeaderPushing = Effect_exports2.gen(function* () {
      const batch = yield* BucketQueue_exports.takeBetween(leaderPushQueue, 1, params2.leaderPushBatchSize);
      yield* clientSession.leaderThread.events.push(batch).pipe(Effect_exports2.catchTag("LeaderAheadError", () => {
        debugInfo.rejectCount++;
        return BucketQueue_exports.clear(leaderPushQueue);
      }));
    }).pipe(Effect_exports2.forever, Effect_exports2.interruptible, Effect_exports2.tapCauseLogPretty);
    yield* FiberHandle_exports.run(leaderPushingFiberHandle, backgroundLeaderPushing);
    yield* Stream_exports2.suspend(() => clientSession.leaderThread.events.pull({ cursor: syncStateRef.current.upstreamHead })).pipe(
      Stream_exports2.tap(({ payload }) => Effect_exports2.gen(function* () {
        if (clientSession.devtools.enabled) {
          yield* clientSession.devtools.pullLatch.await;
        }
        const mergeResult = merge15({
          syncState: syncStateRef.current,
          payload,
          isClientEvent,
          isEqualEvent: isEqualEncoded
        });
        if (mergeResult._tag === "unexpected-error") {
          return yield* new SyncError({ cause: mergeResult.message });
        } else if (mergeResult._tag === "reject") {
          return shouldNeverHappen("Unexpected reject in client-session-sync-processor", mergeResult);
        }
        syncStateRef.current = mergeResult.newSyncState;
        yield* syncStateUpdateQueue.offer(mergeResult.newSyncState);
        if (mergeResult._tag === "rebase") {
          span4.addEvent("merge:pull:rebase", {
            payloadTag: payload._tag,
            payload: TRACE_VERBOSE ? JSON.stringify(payload) : void 0,
            newEventsCount: mergeResult.newEvents.length,
            rollbackCount: mergeResult.rollbackEvents.length,
            res: TRACE_VERBOSE ? JSON.stringify(mergeResult) : void 0
          });
          debugInfo.rebaseCount++;
          if (SIMULATION_ENABLED)
            yield* simSleep("pull", "1_before_leader_push_fiber_interrupt");
          yield* FiberHandle_exports.clear(leaderPushingFiberHandle);
          if (SIMULATION_ENABLED)
            yield* simSleep("pull", "2_before_leader_push_queue_clear");
          yield* BucketQueue_exports.clear(leaderPushQueue);
          if (SIMULATION_ENABLED)
            yield* simSleep("pull", "3_before_rebase_rollback");
          if (LS_DEV) {
            yield* Effect_exports2.logDebug("merge:pull:rebase: rollback", mergeResult.rollbackEvents.length, ...mergeResult.rollbackEvents.slice(0, 10).map((_) => _.toJSON()));
          }
          for (let i = mergeResult.rollbackEvents.length - 1; i >= 0; i--) {
            const event = mergeResult.rollbackEvents[i];
            if (event.meta.sessionChangeset._tag !== "no-op" && event.meta.sessionChangeset._tag !== "unset") {
              rollback2(event.meta.sessionChangeset.data);
              event.meta.sessionChangeset = { _tag: "unset" };
            }
          }
          if (SIMULATION_ENABLED)
            yield* simSleep("pull", "4_before_leader_push_queue_offer");
          yield* BucketQueue_exports.offerAll(leaderPushQueue, mergeResult.newSyncState.pending);
          if (SIMULATION_ENABLED)
            yield* simSleep("pull", "5_before_leader_push_fiber_run");
          yield* FiberHandle_exports.run(leaderPushingFiberHandle, backgroundLeaderPushing);
        } else {
          span4.addEvent("merge:pull:advance", {
            payloadTag: payload._tag,
            payload: TRACE_VERBOSE ? JSON.stringify(payload) : void 0,
            newEventsCount: mergeResult.newEvents.length,
            res: TRACE_VERBOSE ? JSON.stringify(mergeResult) : void 0
          });
          debugInfo.advanceCount++;
        }
        if (mergeResult.newEvents.length === 0)
          return;
        const writeTables = /* @__PURE__ */ new Set();
        for (const event of mergeResult.newEvents) {
          const decodedEventDef = Schema_exports2.decodeSync(eventSchema)(event);
          const { writeTables: newWriteTables, sessionChangeset, materializerHash } = yield* materializeEvent(decodedEventDef, {
            withChangeset: true,
            materializerHashLeader: event.meta.materializerHashLeader
          });
          for (const table7 of newWriteTables) {
            writeTables.add(table7);
          }
          event.meta.sessionChangeset = sessionChangeset;
          event.meta.materializerHashSession = materializerHash;
        }
        refreshTables(writeTables);
      }).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.catchAllCause((cause3) => clientSession.shutdown(Exit_exports.failCause(cause3))))),
      Stream_exports2.runDrain,
      Effect_exports2.forever,
      // NOTE Whenever the leader changes, we need to re-start the stream
      Effect_exports2.interruptible,
      Effect_exports2.withSpan("client-session-sync-processor:pull"),
      Effect_exports2.tapCauseLogPretty,
      Effect_exports2.forkScoped
    );
  });
  return {
    push,
    boot,
    syncState: Subscribable_exports2.make({
      get: Effect_exports2.gen(function* () {
        const syncState = syncStateRef.current;
        if (syncStateRef === void 0)
          return shouldNeverHappen("Not initialized");
        return syncState;
      }),
      changes: Stream_exports2.fromQueue(syncStateUpdateQueue)
    }),
    debug: {
      print: /* @__PURE__ */ __name(() => Effect_exports2.gen(function* () {
        console.log("debugInfo", debugInfo);
        console.log("syncState", syncStateRef.current);
        const pushQueueSize = yield* BucketQueue_exports.size(leaderPushQueue);
        console.log("pushQueueSize", pushQueueSize);
        const pushQueueItems = yield* BucketQueue_exports.peekAll(leaderPushQueue);
        console.log("pushQueueItems", pushQueueItems.map((_) => _.toJSON()));
      }).pipe(Effect_exports2.provide(runtime8), Effect_exports2.runSync), "print"),
      debugInfo: /* @__PURE__ */ __name(() => debugInfo, "debugInfo")
    }
  };
}, "makeClientSessionSyncProcessor");
var SIMULATION_ENABLED = true;
var ClientSessionSyncProcessorSimulationParams = Schema_exports2.Struct({
  pull: Schema_exports2.Struct({
    "1_before_leader_push_fiber_interrupt": Schema_exports2.Int.pipe(Schema_exports2.between(0, 25)),
    "2_before_leader_push_queue_clear": Schema_exports2.Int.pipe(Schema_exports2.between(0, 25)),
    "3_before_rebase_rollback": Schema_exports2.Int.pipe(Schema_exports2.between(0, 25)),
    "4_before_leader_push_queue_offer": Schema_exports2.Int.pipe(Schema_exports2.between(0, 25)),
    "5_before_leader_push_fiber_run": Schema_exports2.Int.pipe(Schema_exports2.between(0, 25))
  })
});

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/sync/sync-backend.js
var sync_backend_exports = {};
__export(sync_backend_exports, {
  PullResPageInfo: () => PullResPageInfo,
  cursorFromPullResItem: () => cursorFromPullResItem,
  of: () => of7,
  pageInfoMoreKnown: () => pageInfoMoreKnown,
  pageInfoMoreUnknown: () => pageInfoMoreUnknown,
  pageInfoNoMore: () => pageInfoNoMore,
  pullResItemEmpty: () => pullResItemEmpty
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PullResPageInfo = Schema_exports2.Union(Schema_exports2.TaggedStruct("MoreUnknown", {}), Schema_exports2.TaggedStruct("MoreKnown", {
  remaining: Schema_exports2.Number
}), Schema_exports2.TaggedStruct("NoMore", {}));
var pageInfoNoMore = { _tag: "NoMore" };
var pageInfoMoreUnknown = { _tag: "MoreUnknown" };
var pageInfoMoreKnown = /* @__PURE__ */ __name((remaining) => ({ _tag: "MoreKnown", remaining }), "pageInfoMoreKnown");
var pullResItemEmpty = /* @__PURE__ */ __name(() => ({
  batch: [],
  pageInfo: pageInfoNoMore
}), "pullResItemEmpty");
var of7 = /* @__PURE__ */ __name((obj) => obj, "of");
var cursorFromPullResItem = /* @__PURE__ */ __name((item) => {
  const lastEvent = item.batch.at(-1);
  if (!lastEvent) {
    return Option_exports.none();
  }
  return Option_exports.some({ cursor: lastEvent.eventEncoded.seqNum, metadata: lastEvent.metadata });
}, "cursorFromPullResItem");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/sync/sync.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/sync/errors.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var IsOfflineError = class extends Schema_exports2.TaggedError()("IsOfflineError", {
  cause: Schema_exports2.Defect
}) {
  static {
    __name(this, "IsOfflineError");
  }
};
var InvalidPushError = class extends Schema_exports2.TaggedError()("InvalidPushError", {
  reason: Schema_exports2.Union(Schema_exports2.TaggedStruct("Unexpected", {
    cause: Schema_exports2.Defect
  }), Schema_exports2.TaggedStruct("ServerAhead", {
    minimumExpectedNum: Schema_exports2.Number,
    providedNum: Schema_exports2.Number
  }))
}) {
  static {
    __name(this, "InvalidPushError");
  }
};
var InvalidPullError = class extends Schema_exports2.TaggedError()("InvalidPullError", {
  cause: Schema_exports2.Defect
}) {
  static {
    __name(this, "InvalidPullError");
  }
};
var LeaderAheadError = class extends Schema_exports2.TaggedError()("LeaderAheadError", {
  minimumExpectedNum: EventSequenceNumber_exports.EventSequenceNumber,
  providedNum: EventSequenceNumber_exports.EventSequenceNumber
  /** Generation number the client session should use for subsequent pushes */
  // nextGeneration: Schema.Number,
}) {
  static {
    __name(this, "LeaderAheadError");
  }
};

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/mod.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/connection.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var configureConnection = /* @__PURE__ */ __name((sqliteDb, { foreignKeys, lockingMode }) => execSql(
  sqliteDb,
  // We use the WAL journal mode is significantly faster in most scenarios than the traditional rollback journal mode.
  // It specifically significantly improves write performance. However, when using the WAL journal mode, transactions
  // that involve changes against multiple ATTACHed databases are atomic for each database but are not atomic
  // across all databases as a set. Additionally, it is not possible to change the page size after entering WAL mode,
  // whether on an empty database or by using VACUUM or the backup API. To change the page size, we must switch to the
  // rollback journal mode.
  //
  // When connected to an in-memory database, the WAL journal mode option is ignored because an in-memory database can
  // only be in either the MEMORY or OFF options. By default, an in-memory database is in the MEMORY option, which
  // means that it stores the rollback journal in volatile RAM. This saves disk I/O but at the expense of safety and
  // integrity. If the thread using SQLite crashes in the middle of a transaction, then the database file will very
  // likely go corrupt.
  sql`
    -- disable WAL until we have it working properly
    -- PRAGMA journal_mode=WAL;
    PRAGMA page_size=8192;
    PRAGMA foreign_keys=${foreignKeys ? "ON" : "OFF"};
    ${lockingMode === void 0 ? "" : sql`PRAGMA locking_mode=${lockingMode};`}
  `,
  {}
), "configureConnection");
var execSql = /* @__PURE__ */ __name((sqliteDb, sql2, bind11) => {
  const bindValues = prepareBindValues(bind11, sql2);
  return Effect_exports2.try({
    try: /* @__PURE__ */ __name(() => sqliteDb.execute(sql2, bindValues), "try"),
    catch: /* @__PURE__ */ __name((cause3) => new SqliteError({ cause: cause3, query: { bindValues, sql: sql2 }, code: cause3.code }), "catch")
  }).pipe(
    Effect_exports2.asVoid,
    // Effect.logDuration(`@livestore/common:execSql:${sql}`),
    Effect_exports2.withSpan(`@livestore/common:execSql`, {
      attributes: { "span.label": sql2, sql: sql2, bindValueKeys: Object.keys(bindValues) }
    })
  );
}, "execSql");
var execSqlPrepared = /* @__PURE__ */ __name((sqliteDb, sql2, bindValues) => {
  return Effect_exports2.try({
    try: /* @__PURE__ */ __name(() => sqliteDb.execute(sql2, bindValues), "try"),
    catch: /* @__PURE__ */ __name((cause3) => new SqliteError({ cause: cause3, query: { bindValues, sql: sql2 }, code: cause3.code }), "catch")
  }).pipe(
    Effect_exports2.asVoid,
    // Effect.logDuration(`@livestore/common:execSqlPrepared:${sql}`),
    Effect_exports2.withSpan(`@livestore/common:execSqlPrepared`, {
      attributes: {
        "span.label": sql2,
        sql: sql2,
        bindValueKeys: Object.keys(bindValues)
      }
    })
  );
}, "execSqlPrepared");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/eventlog.js
var eventlog_exports = {};
__export(eventlog_exports, {
  getBackendHeadFromDb: () => getBackendHeadFromDb,
  getClientHeadFromDb: () => getClientHeadFromDb,
  getEventsSince: () => getEventsSince,
  getSyncBackendCursorInfo: () => getSyncBackendCursorInfo,
  initEventlogDb: () => initEventlogDb,
  insertIntoEventlog: () => insertIntoEventlog,
  updateBackendHead: () => updateBackendHead,
  updateSyncMetadata: () => updateSyncMetadata
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/sql-queries/sql-queries.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/sql-queries/misc.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var objectEntries = /* @__PURE__ */ __name((obj) => Object.entries(obj), "objectEntries");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/sql-queries/types.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var isValidWhereOp = /* @__PURE__ */ __name((op) => {
  const validWhereOps = [">", "<", "="];
  return validWhereOps.includes(op);
}, "isValidWhereOp");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/sql-queries/sql-queries.js
var insertRow = /* @__PURE__ */ __name(({ tableName, columns, values: values6, options: options4 = { orReplace: false } }) => {
  const stmt = insertRowPrepared({
    tableName,
    columns,
    options: { orReplace: options4?.orReplace, keys: Object.keys(values6) }
  });
  return [stmt, makeBindValues({ columns, values: values6 })];
}, "insertRow");
var insertRowPrepared = /* @__PURE__ */ __name(({ tableName, columns, options: options4 = { orReplace: false } }) => {
  const keys6 = options4?.keys ?? Object.keys(columns);
  const keysStr = keys6.join(", ");
  const valuesStr = keys6.map((key) => `$${key}`).join(", ");
  return sql`INSERT ${options4.orReplace ? "OR REPLACE " : ""}INTO ${tableName} (${keysStr}) VALUES (${valuesStr})`;
}, "insertRowPrepared");
var updateRows = /* @__PURE__ */ __name(({ columns, tableName, updateValues: updateValues_, where }) => {
  const updateValues = filterUndefinedFields(updateValues_);
  if (Object.keys(updateValues).length === 0) {
    return [sql`select 1`, {}];
  }
  const updateValueStr = Object.keys(updateValues).map((columnName) => `${columnName} = $update_${columnName}`).join(", ");
  const bindValues = {
    ...makeBindValues({ columns, values: updateValues, variablePrefix: "update_" }),
    ...makeBindValues({ columns, values: where, variablePrefix: "where_", skipNil: true })
  };
  const whereSql = buildWhereSql({ where });
  const whereModifier = whereSql === "" ? "" : `WHERE ${whereSql}`;
  return [sql`UPDATE ${tableName} SET ${updateValueStr} ${whereModifier}`, bindValues];
}, "updateRows");
var makeBindValues = /* @__PURE__ */ __name(({ columns, values: values6, variablePrefix = "", skipNil }) => {
  const codecMap = pipe(columns, objectEntries, Array_exports.map(([columnName, columnDef]) => [
    columnName,
    (value6) => {
      if (columnDef.nullable === true && (value6 === null || value6 === void 0))
        return null;
      const res = Schema_exports2.encodeEither(columnDef.schema)(value6);
      if (res._tag === "Left") {
        const parseErrorStr = TreeFormatter.formatErrorSync(res.left);
        const expectedSchemaStr = String(columnDef.schema.ast);
        console.error(`Error making bind values for SQL query for column "${columnName}".

Expected schema: ${expectedSchemaStr}

Error: ${parseErrorStr}

Value:`, value6);
        debugger;
        throw res.left;
      } else {
        return res.right;
      }
    }
  ]), Object.fromEntries);
  return pipe(Object.entries(values6).filter(([, value6]) => skipNil !== true || value6 !== null && value6 !== void 0).flatMap(([columnName, value6]) => {
    const codec = codecMap[columnName] ?? shouldNeverHappen(`No codec found for column "${columnName}"`);
    if (typeof value6 === "object" && value6 !== null && "op" in value6) {
      switch (value6.op) {
        case "in": {
          return value6.val.map((value7, i) => [`${variablePrefix}${columnName}_${i}`, codec(value7)]);
        }
        case "=":
        case ">":
        case "<": {
          return [[`${variablePrefix}${columnName}`, codec(value6.val)]];
        }
        default: {
          throw new Error(`Unknown op: ${value6.op}`);
        }
      }
    } else {
      return [[`${variablePrefix}${columnName}`, codec(value6)]];
    }
  }), Object.fromEntries);
}, "makeBindValues");
var buildWhereSql = /* @__PURE__ */ __name(({ where }) => {
  const getWhereOp = /* @__PURE__ */ __name((columnName, value6) => {
    if (value6 === null) {
      return `IS NULL`;
    } else if (typeof value6 === "object" && typeof value6.op === "string" && isValidWhereOp(value6.op)) {
      return `${value6.op} $where_${columnName}`;
    } else if (typeof value6 === "object" && typeof value6.op === "string" && value6.op === "in") {
      return `in (${value6.val.map((_, i) => `$where_${columnName}_${i}`).join(", ")})`;
    } else {
      return `= $where_${columnName}`;
    }
  }, "getWhereOp");
  return pipe(where, objectEntries, Array_exports.map(([columnName, value6]) => `${columnName} ${getWhereOp(columnName, value6)}`), Array_exports.join(" AND "));
}, "buildWhereSql");
var filterUndefinedFields = /* @__PURE__ */ __name((obj) => {
  return Object.fromEntries(Object.entries(obj).filter(([, value6]) => value6 !== void 0));
}, "filterUndefinedFields");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/types.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var InitialSyncOptionsSkip = Schema_exports2.TaggedStruct("Skip", {});
var InitialSyncOptionsBlocking = Schema_exports2.TaggedStruct("Blocking", {
  timeout: Schema_exports2.Union(Schema_exports2.DurationFromMillis, Schema_exports2.Number)
});
var InitialSyncOptions = Schema_exports2.Union(InitialSyncOptionsSkip, InitialSyncOptionsBlocking);
var LeaderThreadCtx = class extends Context_exports.Tag("LeaderThreadCtx")() {
  static {
    __name(this, "LeaderThreadCtx");
  }
};

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/eventlog.js
var initEventlogDb = /* @__PURE__ */ __name((dbEventlog) => Effect_exports2.gen(function* () {
  for (const tableDef of eventlogSystemTables) {
    yield* migrateTable({
      db: dbEventlog,
      behaviour: "create-if-not-exists",
      tableAst: tableDef.sqliteDef.ast,
      skipMetaTable: true
    });
  }
  yield* execSql(dbEventlog, sql`INSERT INTO ${SYNC_STATUS_TABLE} (head)
          SELECT ${ROOT.global}
          WHERE NOT EXISTS (SELECT 1 FROM ${SYNC_STATUS_TABLE})`, {});
}), "initEventlogDb");
var getEventsSince = /* @__PURE__ */ __name(({ dbEventlog, dbState, since }) => {
  const pendingEvents = dbEventlog.select(eventlogMetaTable.where("seqNumGlobal", ">=", since.global));
  const sessionChangesetRowsDecoded = dbState.select(sessionChangesetMetaTable.where("seqNumGlobal", ">=", since.global));
  return pendingEvents.map((eventlogEvent) => {
    const sessionChangeset = sessionChangesetRowsDecoded.find((readModelEvent) => readModelEvent.seqNumGlobal === eventlogEvent.seqNumGlobal && readModelEvent.seqNumClient === eventlogEvent.seqNumClient);
    return EncodedWithMeta.make({
      name: eventlogEvent.name,
      args: eventlogEvent.argsJson,
      seqNum: {
        global: eventlogEvent.seqNumGlobal,
        client: eventlogEvent.seqNumClient,
        rebaseGeneration: eventlogEvent.seqNumRebaseGeneration
      },
      parentSeqNum: {
        global: eventlogEvent.parentSeqNumGlobal,
        client: eventlogEvent.parentSeqNumClient,
        rebaseGeneration: eventlogEvent.parentSeqNumRebaseGeneration
      },
      clientId: eventlogEvent.clientId,
      sessionId: eventlogEvent.sessionId,
      meta: {
        sessionChangeset: sessionChangeset && sessionChangeset.changeset !== null ? {
          _tag: "sessionChangeset",
          data: sessionChangeset.changeset,
          debug: sessionChangeset.debug
        } : { _tag: "unset" },
        syncMetadata: eventlogEvent.syncMetadataJson,
        materializerHashLeader: Option_exports.none(),
        materializerHashSession: Option_exports.none()
      }
    });
  }).filter((_) => compare2(_.seqNum, since) > 0).sort((a, b) => compare2(a.seqNum, b.seqNum));
}, "getEventsSince");
var getClientHeadFromDb = /* @__PURE__ */ __name((dbEventlog) => {
  const res = dbEventlog.select(sql`select seqNumGlobal, seqNumClient, seqNumRebaseGeneration from ${EVENTLOG_META_TABLE} order by seqNumGlobal DESC, seqNumClient DESC limit 1`)[0];
  return res ? { global: res.seqNumGlobal, client: res.seqNumClient, rebaseGeneration: res.seqNumRebaseGeneration } : ROOT;
}, "getClientHeadFromDb");
var getBackendHeadFromDb = /* @__PURE__ */ __name((dbEventlog) => dbEventlog.select(sql`select head from ${SYNC_STATUS_TABLE}`)[0]?.head ?? ROOT.global, "getBackendHeadFromDb");
var updateBackendHead = /* @__PURE__ */ __name((dbEventlog, head13) => dbEventlog.execute(sql`UPDATE ${SYNC_STATUS_TABLE} SET head = ${head13.global}`), "updateBackendHead");
var insertIntoEventlog = /* @__PURE__ */ __name((eventEncoded, dbEventlog, eventDefSchemaHash, clientId2, sessionId2) => Effect_exports2.gen(function* () {
  if (LS_DEV && eventEncoded.parentSeqNum.global !== ROOT.global) {
    const parentEventExists = dbEventlog.select(`SELECT COUNT(*) as count FROM ${EVENTLOG_META_TABLE} WHERE seqNumGlobal = ? AND seqNumClient = ?`, [eventEncoded.parentSeqNum.global, eventEncoded.parentSeqNum.client])[0].count === 1;
    if (parentEventExists === false) {
      shouldNeverHappen(`Parent mutation ${eventEncoded.parentSeqNum.global},${eventEncoded.parentSeqNum.client} does not exist`);
    }
  }
  yield* execSql(dbEventlog, ...insertRow({
    tableName: EVENTLOG_META_TABLE,
    columns: eventlogMetaTable.sqliteDef.columns,
    values: {
      seqNumGlobal: eventEncoded.seqNum.global,
      seqNumClient: eventEncoded.seqNum.client,
      seqNumRebaseGeneration: eventEncoded.seqNum.rebaseGeneration,
      parentSeqNumGlobal: eventEncoded.parentSeqNum.global,
      parentSeqNumClient: eventEncoded.parentSeqNum.client,
      parentSeqNumRebaseGeneration: eventEncoded.parentSeqNum.rebaseGeneration,
      name: eventEncoded.name,
      argsJson: eventEncoded.args ?? {},
      clientId: clientId2,
      sessionId: sessionId2,
      schemaHash: eventDefSchemaHash,
      syncMetadataJson: eventEncoded.meta.syncMetadata
    }
  }));
  dbEventlog.debug.head = eventEncoded.seqNum;
}), "insertIntoEventlog");
var updateSyncMetadata = /* @__PURE__ */ __name((items) => Effect_exports2.gen(function* () {
  const { dbEventlog } = yield* LeaderThreadCtx;
  for (let i = 0; i < items.length; i++) {
    const event = items[i];
    yield* execSql(dbEventlog, ...updateRows({
      tableName: EVENTLOG_META_TABLE,
      columns: eventlogMetaTable.sqliteDef.columns,
      where: { seqNumGlobal: event.seqNum.global, seqNumClient: event.seqNum.client },
      updateValues: { syncMetadataJson: event.meta.syncMetadata }
    }));
  }
}), "updateSyncMetadata");
var getSyncBackendCursorInfo = /* @__PURE__ */ __name(({ remoteHead }) => Effect_exports2.gen(function* () {
  const { dbEventlog } = yield* LeaderThreadCtx;
  if (remoteHead === ROOT.global)
    return Option_exports.none();
  const EventlogQuerySchema = Schema_exports2.Struct({
    syncMetadataJson: Schema_exports2.parseJson(Schema_exports2.Option(Schema_exports2.JsonValue))
  }).pipe(Schema_exports2.pluck("syncMetadataJson"), Schema_exports2.Array, Schema_exports2.head);
  const syncMetadataOption = yield* Effect_exports2.sync(() => dbEventlog.select(sql`SELECT syncMetadataJson FROM ${EVENTLOG_META_TABLE} WHERE seqNumGlobal = ${remoteHead} ORDER BY seqNumClient ASC LIMIT 1`)).pipe(Effect_exports2.andThen(Schema_exports2.decode(EventlogQuerySchema)), Effect_exports2.map(Option_exports.flatten), Effect_exports2.orDie);
  return Option_exports.some({
    cursor: remoteHead,
    metadata: syncMetadataOption
  });
}).pipe(Effect_exports2.withSpan("@livestore/common:eventlog:getSyncBackendCursorInfo", { attributes: { remoteHead } })), "getSyncBackendCursorInfo");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/leader-worker-devtools.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var bootDevtools = /* @__PURE__ */ __name((options4) => Effect_exports2.gen(function* () {
  if (options4.enabled === false) {
    return;
  }
  const { syncProcessor, extraIncomingMessagesQueue, clientId: clientId2, storeId: storeId2 } = yield* LeaderThreadCtx;
  yield* listenToDevtools({
    incomingMessages: Stream_exports2.fromQueue(extraIncomingMessagesQueue),
    sendMessage: /* @__PURE__ */ __name(() => Effect_exports2.void, "sendMessage")
  }).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
  const { node, persistenceInfo, mode } = yield* options4.boot;
  yield* node.listenForChannel.pipe(Stream_exports2.filter((res) => mod_exports5.isChannelName.devtoolsClientLeader(res.channelName, { storeId: storeId2, clientId: clientId2 }) && res.mode === mode), Stream_exports2.tap(({ channelName, source }) => Effect_exports2.gen(function* () {
    const channel2 = yield* node.makeChannel({
      target: source,
      channelName,
      schema: { listen: mod_exports5.Leader.MessageToApp, send: mod_exports5.Leader.MessageFromApp },
      mode
    });
    const sendMessage = /* @__PURE__ */ __name((message) => channel2.send(message).pipe(Effect_exports2.withSpan("@livestore/common:leader-thread:devtools:sendToDevtools"), Effect_exports2.interruptible, Effect_exports2.ignoreLogged), "sendMessage");
    const syncState = yield* syncProcessor.syncState;
    yield* syncProcessor.pull({ cursor: syncState.localHead }).pipe(Stream_exports2.tap(({ payload }) => sendMessage(mod_exports5.Leader.SyncPull.make({ payload, liveStoreVersion }))), Stream_exports2.runDrain, Effect_exports2.forkScoped);
    yield* listenToDevtools({
      incomingMessages: channel2.listen.pipe(Stream_exports2.flatten(), Stream_exports2.orDie),
      sendMessage,
      persistenceInfo
    });
  }).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped)), Stream_exports2.runDrain);
}).pipe(Effect_exports2.withSpan("@livestore/common:leader-thread:devtools:boot")), "bootDevtools");
var listenToDevtools = /* @__PURE__ */ __name(({ incomingMessages, sendMessage, persistenceInfo }) => Effect_exports2.gen(function* () {
  const { syncBackend, makeSqliteDb: makeSqliteDb2, dbState, dbEventlog, shutdownStateSubRef, shutdownChannel, syncProcessor, clientId: clientId2, devtools } = yield* LeaderThreadCtx;
  const subscriptionFiberMap = yield* FiberMap_exports.make();
  const handledRequestIds = /* @__PURE__ */ new Set();
  yield* incomingMessages.pipe(Stream_exports2.tap((decodedEvent) => Effect_exports2.gen(function* () {
    const { requestId: requestId2 } = decodedEvent;
    const reqPayload = { requestId: requestId2, liveStoreVersion, clientId: clientId2 };
    if (decodedEvent._tag === "LSD.Leader.Disconnect") {
      return;
    }
    if (handledRequestIds.has(requestId2)) {
      return;
    }
    handledRequestIds.add(requestId2);
    switch (decodedEvent._tag) {
      case "LSD.Leader.Ping": {
        yield* sendMessage(mod_exports5.Leader.Pong.make({ ...reqPayload }));
        return;
      }
      case "LSD.Leader.SnapshotReq": {
        const snapshot2 = dbState.export();
        yield* sendMessage(mod_exports5.Leader.SnapshotRes.make({ snapshot: snapshot2, ...reqPayload }));
        return;
      }
      case "LSD.Leader.LoadDatabaseFile.Request": {
        const { data } = decodedEvent;
        let tableNames;
        try {
          const tmpDb = yield* makeSqliteDb2({ _tag: "in-memory" });
          tmpDb.import(data);
          const tableNameResults = tmpDb.select(`select name from sqlite_master where type = 'table'`);
          tableNames = new Set(tableNameResults.map((_) => _.name));
          tmpDb.close();
        } catch (cause3) {
          yield* Effect_exports2.logError(`Error importing database file`, cause3);
          yield* sendMessage(mod_exports5.Leader.LoadDatabaseFile.Error.make({
            ...reqPayload,
            cause: { _tag: "unexpected-error", cause: cause3 }
          }));
          return;
        }
        try {
          if (tableNames.has(system_tables_exports.EVENTLOG_META_TABLE)) {
            yield* SubscriptionRef_exports2.set(shutdownStateSubRef, "shutting-down");
            dbEventlog.import(data);
            dbState.destroy();
          } else if (tableNames.has(system_tables_exports.SCHEMA_META_TABLE) && tableNames.has(system_tables_exports.SCHEMA_EVENT_DEFS_META_TABLE)) {
            yield* SubscriptionRef_exports2.set(shutdownStateSubRef, "shutting-down");
            dbState.import(data);
            dbEventlog.destroy();
          } else {
            yield* sendMessage(mod_exports5.Leader.LoadDatabaseFile.Error.make({
              ...reqPayload,
              cause: { _tag: "unsupported-database" }
            }));
            return;
          }
          yield* sendMessage(mod_exports5.Leader.LoadDatabaseFile.Success.make({ ...reqPayload }));
          yield* shutdownChannel.send(IntentionalShutdownCause.make({ reason: "devtools-import" })) ?? Effect_exports2.void;
          return;
        } catch (cause3) {
          yield* Effect_exports2.logError(`Error importing database file`, cause3);
          yield* sendMessage(mod_exports5.Leader.LoadDatabaseFile.Error.make({
            ...reqPayload,
            cause: { _tag: "unexpected-error", cause: cause3 }
          }));
          return;
        }
      }
      case "LSD.Leader.ResetAllData.Request": {
        const { mode } = decodedEvent;
        yield* SubscriptionRef_exports2.set(shutdownStateSubRef, "shutting-down");
        dbState.destroy();
        if (mode === "all-data") {
          dbEventlog.destroy();
        }
        yield* sendMessage(mod_exports5.Leader.ResetAllData.Success.make({ ...reqPayload }));
        yield* shutdownChannel.send(IntentionalShutdownCause.make({ reason: "devtools-reset" })) ?? Effect_exports2.void;
        return;
      }
      case "LSD.Leader.DatabaseFileInfoReq": {
        if (persistenceInfo === void 0) {
          console.log("[@livestore/common:leader-thread:devtools] persistenceInfo is required for this request");
          return;
        }
        const dbSizeQuery = `SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size();`;
        const dbFileSize = dbState.select(dbSizeQuery, void 0)[0].size;
        const eventlogFileSize = dbEventlog.select(dbSizeQuery, void 0)[0].size;
        yield* sendMessage(mod_exports5.Leader.DatabaseFileInfoRes.make({
          state: { fileSize: dbFileSize, persistenceInfo: persistenceInfo.state },
          eventlog: { fileSize: eventlogFileSize, persistenceInfo: persistenceInfo.eventlog },
          ...reqPayload
        }));
        return;
      }
      case "LSD.Leader.EventlogReq": {
        const eventlog = dbEventlog.export();
        yield* sendMessage(mod_exports5.Leader.EventlogRes.make({ eventlog, ...reqPayload }));
        return;
      }
      case "LSD.Leader.CommitEventReq": {
        yield* syncProcessor.pushPartial({
          event: decodedEvent.eventEncoded,
          clientId: `devtools-${clientId2}`,
          sessionId: `devtools-${clientId2}`
        });
        yield* sendMessage(mod_exports5.Leader.CommitEventRes.make({ ...reqPayload }));
        return;
      }
      case "LSD.Leader.SyncHistorySubscribe": {
        const { subscriptionId } = decodedEvent;
        if (syncBackend !== void 0) {
          yield* syncBackend.pull(Option_exports.none(), { live: true }).pipe(Stream_exports2.map((_) => _.batch), Stream_exports2.flattenIterables, Stream_exports2.tap(({ eventEncoded, metadata }) => sendMessage(mod_exports5.Leader.SyncHistoryRes.make({
            eventEncoded,
            metadata,
            subscriptionId,
            ...reqPayload,
            requestId: nanoid(10)
          }))), Stream_exports2.runDrain, Effect_exports2.interruptible, Effect_exports2.tapCauseLogPretty, FiberMap_exports.run(subscriptionFiberMap, subscriptionId));
        }
        return;
      }
      case "LSD.Leader.SyncHistoryUnsubscribe": {
        const { requestId: requestId3 } = decodedEvent;
        console.log("LSD.SyncHistoryUnsubscribe", requestId3);
        yield* FiberMap_exports.remove(subscriptionFiberMap, requestId3);
        return;
      }
      case "LSD.Leader.SyncingInfoReq": {
        const syncingInfo = mod_exports5.Leader.SyncingInfo.make({
          enabled: syncBackend !== void 0,
          metadata: syncBackend?.metadata ?? {}
        });
        yield* sendMessage(mod_exports5.Leader.SyncingInfoRes.make({ syncingInfo, ...reqPayload }));
        return;
      }
      case "LSD.Leader.NetworkStatusSubscribe": {
        if (syncBackend !== void 0) {
          const { subscriptionId } = decodedEvent;
          yield* Effect_exports2.sleep(1e3);
          yield* Stream_exports2.zipLatest(syncBackend.isConnected.changes, devtools.enabled ? devtools.syncBackendLatchState.changes : Stream_exports2.make({ latchClosed: false })).pipe(Stream_exports2.tap(([isConnected, { latchClosed }]) => sendMessage(mod_exports5.Leader.NetworkStatusRes.make({
            networkStatus: { isConnected, timestampMs: Date.now(), latchClosed },
            subscriptionId,
            ...reqPayload,
            requestId: nanoid(10)
          }))), Stream_exports2.runDrain, Effect_exports2.interruptible, Effect_exports2.tapCauseLogPretty, FiberMap_exports.run(subscriptionFiberMap, subscriptionId));
        }
        return;
      }
      case "LSD.Leader.NetworkStatusUnsubscribe": {
        const { requestId: requestId3 } = decodedEvent;
        yield* FiberMap_exports.remove(subscriptionFiberMap, requestId3);
        return;
      }
      case "LSD.Leader.SyncHeadSubscribe": {
        const { subscriptionId } = decodedEvent;
        yield* syncProcessor.syncState.changes.pipe(Stream_exports2.tap((syncState) => sendMessage(mod_exports5.Leader.SyncHeadRes.make({
          local: syncState.localHead,
          upstream: syncState.upstreamHead,
          subscriptionId,
          ...reqPayload,
          requestId: nanoid(10)
        }))), Stream_exports2.runDrain, Effect_exports2.interruptible, Effect_exports2.tapCauseLogPretty, FiberMap_exports.run(subscriptionFiberMap, subscriptionId));
        return;
      }
      case "LSD.Leader.SyncHeadUnsubscribe": {
        const { subscriptionId } = decodedEvent;
        yield* FiberMap_exports.remove(subscriptionFiberMap, subscriptionId);
        return;
      }
      case "LSD.Leader.SetSyncLatch.Request": {
        const { closeLatch } = decodedEvent;
        if (devtools.enabled === false)
          return;
        if (closeLatch === true) {
          yield* devtools.syncBackendLatch.close;
        } else {
          yield* devtools.syncBackendLatch.open;
        }
        yield* SubscriptionRef_exports2.set(devtools.syncBackendLatchState, { latchClosed: closeLatch });
        yield* sendMessage(mod_exports5.Leader.SetSyncLatch.Success.make({ ...reqPayload }));
        return;
      }
      default: {
        yield* Effect_exports2.logWarning(`TODO implement devtools message`, decodedEvent);
      }
    }
  }).pipe(Effect_exports2.withSpan(`@livestore/common:leader-thread:onDevtoolsMessage:${decodedEvent._tag}`))), UnexpectedError.mapToUnexpectedErrorStream, Stream_exports2.runDrain);
}), "listenToDevtools");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/make-leader-thread-layer.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/LeaderSyncProcessor.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/materialize-event.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeMaterializeEvent = /* @__PURE__ */ __name(({ schema: schema4, dbState, dbEventlog }) => Effect_exports2.gen(function* () {
  const eventDefSchemaHashMap = new Map(
    // TODO Running `Schema.hash` can be a bottleneck for larger schemas. There is an opportunity to run this
    // at build time and lookup the pre-computed hash at runtime.
    // Also see https://github.com/Effect-TS/effect/issues/2719
    [...schema4.eventsDefsMap.entries()].map(([k, v]) => [k, Schema_exports2.hash(v.schema)])
  );
  return (eventEncoded, options4) => Effect_exports2.gen(function* () {
    const skipEventlog = options4?.skipEventlog ?? false;
    const eventName = eventEncoded.name;
    const { eventDef, materializer } = getEventDef(schema4, eventName);
    const execArgsArr = getExecStatementsFromMaterializer({
      eventDef,
      materializer,
      dbState,
      event: { decoded: void 0, encoded: eventEncoded }
    });
    const materializerHash = isDevEnv() ? Option_exports.some(hashMaterializerResults(execArgsArr)) : Option_exports.none();
    if (materializerHash._tag === "Some" && eventEncoded.meta.materializerHashSession._tag === "Some" && eventEncoded.meta.materializerHashSession.value !== materializerHash.value) {
      yield* MaterializerHashMismatchError.make({ eventName: eventEncoded.name });
    }
    const session = dbState.session();
    for (const { statementSql, bindValues } of execArgsArr) {
      yield* execSqlPrepared(dbState, statementSql, bindValues);
    }
    dbState.debug.head = eventEncoded.seqNum;
    const changeset = session.changeset();
    session.finish();
    yield* execSql(dbState, ...insertRow({
      tableName: system_tables_exports.SESSION_CHANGESET_META_TABLE,
      columns: system_tables_exports.sessionChangesetMetaTable.sqliteDef.columns,
      values: {
        seqNumGlobal: eventEncoded.seqNum.global,
        seqNumClient: eventEncoded.seqNum.client,
        seqNumRebaseGeneration: eventEncoded.seqNum.rebaseGeneration,
        // NOTE the changeset will be empty (i.e. null) for no-op events
        changeset: changeset ?? null,
        debug: LS_DEV ? execArgsArr : null
      }
    }));
    if (skipEventlog === false) {
      const eventName2 = eventEncoded.name;
      const eventDefSchemaHash = eventDefSchemaHashMap.get(eventName2) ?? shouldNeverHappen(`Unknown event definition: ${eventName2}`);
      yield* insertIntoEventlog(eventEncoded, dbEventlog, eventDefSchemaHash, eventEncoded.clientId, eventEncoded.sessionId);
    } else {
    }
    return {
      sessionChangeset: changeset ? {
        _tag: "sessionChangeset",
        data: changeset,
        debug: LS_DEV ? execArgsArr : null
      } : { _tag: "no-op" },
      hash: materializerHash
    };
  }).pipe(Effect_exports2.withSpan(`@livestore/common:leader-thread:materializeEvent`, {
    attributes: {
      eventName: eventEncoded.name,
      eventNum: eventEncoded.seqNum,
      "span.label": `${EventSequenceNumber_exports.toString(eventEncoded.seqNum)} ${eventEncoded.name}`
    }
  }));
}), "makeMaterializeEvent");
var rollback = /* @__PURE__ */ __name(({ dbState, dbEventlog, eventNumsToRollback }) => Effect_exports2.gen(function* () {
  const rollbackEvents = dbState.select(sql`SELECT * FROM ${system_tables_exports.SESSION_CHANGESET_META_TABLE} WHERE (seqNumGlobal, seqNumClient) IN (${eventNumsToRollback.map((id4) => `(${id4.global}, ${id4.client})`).join(", ")})`).map((_) => ({
    seqNum: {
      global: _.seqNumGlobal,
      client: _.seqNumClient,
      rebaseGeneration: -1
      // unused in this code path
    },
    changeset: _.changeset,
    debug: _.debug
  })).toSorted((a, b) => EventSequenceNumber_exports.compare(a.seqNum, b.seqNum));
  for (let i = rollbackEvents.length - 1; i >= 0; i--) {
    const { changeset } = rollbackEvents[i];
    if (changeset !== null) {
      dbState.makeChangeset(changeset).invert().apply();
    }
  }
  const eventNumPairChunks = Array_exports.chunksOf(100)(eventNumsToRollback.map((seqNum) => `(${seqNum.global}, ${seqNum.client})`));
  for (const eventNumPairChunk of eventNumPairChunks) {
    dbState.execute(sql`DELETE FROM ${system_tables_exports.SESSION_CHANGESET_META_TABLE} WHERE (seqNumGlobal, seqNumClient) IN (${eventNumPairChunk.join(", ")})`);
  }
  for (const eventNumPairChunk of eventNumPairChunks) {
    dbEventlog.execute(sql`DELETE FROM ${system_tables_exports.EVENTLOG_META_TABLE} WHERE (seqNumGlobal, seqNumClient) IN (${eventNumPairChunk.join(", ")})`);
  }
}).pipe(Effect_exports2.withSpan("@livestore/common:LeaderSyncProcessor:rollback", {
  attributes: { count: eventNumsToRollback.length }
})), "rollback");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/LeaderSyncProcessor.js
var makeLeaderSyncProcessor = /* @__PURE__ */ __name(({ schema: schema4, dbState, initialBlockingSyncContext, initialSyncState, onError: onError5, livePull, params: params2, testing }) => Effect_exports2.gen(function* () {
  const syncBackendPushQueue = yield* BucketQueue_exports.make();
  const localPushBatchSize = params2.localPushBatchSize ?? 1;
  const backendPushBatchSize = params2.backendPushBatchSize ?? 2;
  const syncStateSref = yield* SubscriptionRef_exports2.make(void 0);
  const isClientEvent = /* @__PURE__ */ __name((eventEncoded) => {
    const { eventDef } = getEventDef(schema4, eventEncoded.name);
    return eventDef.options.clientOnly;
  }, "isClientEvent");
  const connectedClientSessionPullQueues = yield* makePullQueueSet;
  const ctxRef = {
    current: void 0
  };
  const localPushesQueue = yield* BucketQueue_exports.make();
  const localPushesLatch = yield* Effect_exports2.makeLatch(true);
  const pullLatch = yield* Effect_exports2.makeLatch(true);
  const pushHeadRef = { current: EventSequenceNumber_exports.ROOT };
  const advancePushHead = /* @__PURE__ */ __name((eventNum) => {
    pushHeadRef.current = EventSequenceNumber_exports.max(pushHeadRef.current, eventNum);
  }, "advancePushHead");
  const push = /* @__PURE__ */ __name((newEvents, options4) => Effect_exports2.gen(function* () {
    if (newEvents.length === 0)
      return;
    yield* validatePushBatch(newEvents, pushHeadRef.current);
    advancePushHead(newEvents.at(-1).seqNum);
    const waitForProcessing = options4?.waitForProcessing ?? false;
    if (waitForProcessing) {
      const deferreds = yield* Effect_exports2.forEach(newEvents, () => Deferred_exports.make());
      const items = newEvents.map((eventEncoded, i) => [eventEncoded, deferreds[i]]);
      yield* BucketQueue_exports.offerAll(localPushesQueue, items);
      yield* Effect_exports2.all(deferreds);
    } else {
      const items = newEvents.map((eventEncoded) => [eventEncoded, void 0]);
      yield* BucketQueue_exports.offerAll(localPushesQueue, items);
    }
  }).pipe(Effect_exports2.withSpan("@livestore/common:LeaderSyncProcessor:push", {
    attributes: {
      batchSize: newEvents.length,
      batch: TRACE_VERBOSE ? newEvents : void 0
    },
    links: ctxRef.current?.span ? [{ _tag: "SpanLink", span: ctxRef.current.span, attributes: {} }] : void 0
  })), "push");
  const pushPartial = /* @__PURE__ */ __name(({ event: { name, args: args2 }, clientId: clientId2, sessionId: sessionId2 }) => Effect_exports2.gen(function* () {
    const syncState2 = yield* syncStateSref;
    if (syncState2 === void 0)
      return shouldNeverHappen("Not initialized");
    const { eventDef } = getEventDef(schema4, name);
    const eventEncoded = new LiveStoreEvent_exports.EncodedWithMeta({
      name,
      args: args2,
      clientId: clientId2,
      sessionId: sessionId2,
      ...EventSequenceNumber_exports.nextPair({ seqNum: syncState2.localHead, isClient: eventDef.options.clientOnly })
    });
    yield* push([eventEncoded]);
  }).pipe(Effect_exports2.catchTag("LeaderAheadError", Effect_exports2.orDie)), "pushPartial");
  const boot = Effect_exports2.gen(function* () {
    const span4 = yield* Effect_exports2.currentSpan.pipe(Effect_exports2.orDie);
    const otelSpan = yield* OtelTracer_exports.currentOtelSpan.pipe(Effect_exports2.catchAll(() => Effect_exports2.succeed(void 0)));
    const { devtools, shutdownChannel } = yield* LeaderThreadCtx;
    const runtime8 = yield* Effect_exports2.runtime();
    ctxRef.current = {
      otelSpan,
      span: span4,
      devtoolsLatch: devtools.enabled ? devtools.syncBackendLatch : void 0,
      runtime: runtime8
    };
    yield* SubscriptionRef_exports2.set(syncStateSref, initialSyncState);
    if (initialSyncState.pending.length > 0) {
      const globalPendingEvents = initialSyncState.pending.filter((eventEncoded) => {
        const { eventDef } = getEventDef(schema4, eventEncoded.name);
        return eventDef.options.clientOnly === false;
      });
      if (globalPendingEvents.length > 0) {
        yield* BucketQueue_exports.offerAll(syncBackendPushQueue, globalPendingEvents);
      }
    }
    const shutdownOnError = /* @__PURE__ */ __name((cause3) => Effect_exports2.gen(function* () {
      if (onError5 === "ignore")
        return;
      const errorToSend = Cause_exports.isFailType(cause3) ? cause3.error : UnexpectedError.make({ cause: cause3 });
      yield* shutdownChannel.send(errorToSend);
      return yield* Effect_exports2.die(cause3);
    }), "shutdownOnError");
    yield* backgroundApplyLocalPushes({
      localPushesLatch,
      localPushesQueue,
      pullLatch,
      syncStateSref,
      syncBackendPushQueue,
      schema: schema4,
      isClientEvent,
      otelSpan,
      connectedClientSessionPullQueues,
      localPushBatchSize,
      testing: {
        delay: testing?.delays?.localPushProcessing
      }
    }).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.catchAllCause(shutdownOnError), Effect_exports2.forkScoped);
    const backendPushingFiberHandle = yield* FiberHandle_exports.make();
    const backendPushingEffect = backgroundBackendPushing({
      syncBackendPushQueue,
      otelSpan,
      devtoolsLatch: ctxRef.current?.devtoolsLatch,
      backendPushBatchSize
    }).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.catchAllCause(shutdownOnError));
    yield* FiberHandle_exports.run(backendPushingFiberHandle, backendPushingEffect);
    yield* backgroundBackendPulling({
      isClientEvent,
      restartBackendPushing: /* @__PURE__ */ __name((filteredRebasedPending) => Effect_exports2.gen(function* () {
        yield* FiberHandle_exports.clear(backendPushingFiberHandle);
        yield* BucketQueue_exports.clear(syncBackendPushQueue);
        yield* BucketQueue_exports.offerAll(syncBackendPushQueue, filteredRebasedPending);
        yield* FiberHandle_exports.run(backendPushingFiberHandle, backendPushingEffect);
      }), "restartBackendPushing"),
      syncStateSref,
      localPushesLatch,
      pullLatch,
      livePull,
      dbState,
      otelSpan,
      initialBlockingSyncContext,
      devtoolsLatch: ctxRef.current?.devtoolsLatch,
      connectedClientSessionPullQueues,
      advancePushHead
    }).pipe(
      Effect_exports2.retry({
        // We want to retry pulling if we've lost connection to the sync backend
        while: /* @__PURE__ */ __name((cause3) => cause3._tag === "IsOfflineError", "while")
      }),
      Effect_exports2.catchAllCause(shutdownOnError),
      // Needed to avoid `Fiber terminated with an unhandled error` logs which seem to happen because of the `Effect.retry` above.
      // This might be a bug in Effect. Only seems to happen in the browser.
      Effect_exports2.provide(Layer_exports.setUnhandledErrorLogLevel(Option_exports.none())),
      Effect_exports2.forkScoped
    );
    return { initialLeaderHead: initialSyncState.localHead };
  }).pipe(Effect_exports2.withSpanScoped("@livestore/common:LeaderSyncProcessor:boot"));
  const pull = /* @__PURE__ */ __name(({ cursor }) => Effect_exports2.gen(function* () {
    const queue = yield* pullQueue({ cursor });
    return Stream_exports2.fromQueue(queue);
  }).pipe(Stream_exports2.unwrapScoped), "pull");
  const pullQueue = /* @__PURE__ */ __name(({ cursor }) => {
    const runtime8 = ctxRef.current?.runtime ?? shouldNeverHappen("Not initialized");
    return connectedClientSessionPullQueues.makeQueue(cursor).pipe(Effect_exports2.provide(runtime8));
  }, "pullQueue");
  const syncState = Subscribable_exports2.make({
    get: Effect_exports2.gen(function* () {
      const syncState2 = yield* syncStateSref;
      if (syncState2 === void 0)
        return shouldNeverHappen("Not initialized");
      return syncState2;
    }),
    changes: syncStateSref.changes.pipe(Stream_exports2.filter(isNotUndefined2))
  });
  return {
    pull,
    pullQueue,
    push,
    pushPartial,
    boot,
    syncState
  };
}), "makeLeaderSyncProcessor");
var backgroundApplyLocalPushes = /* @__PURE__ */ __name(({ localPushesLatch, localPushesQueue, pullLatch, syncStateSref, syncBackendPushQueue, schema: schema4, isClientEvent, otelSpan, connectedClientSessionPullQueues, localPushBatchSize, testing }) => Effect_exports2.gen(function* () {
  while (true) {
    if (testing.delay !== void 0) {
      yield* testing.delay.pipe(Effect_exports2.withSpan("localPushProcessingDelay"));
    }
    const batchItems = yield* BucketQueue_exports.takeBetween(localPushesQueue, 1, localPushBatchSize);
    yield* localPushesLatch.await;
    yield* pullLatch.close;
    const syncState = yield* syncStateSref;
    if (syncState === void 0)
      return shouldNeverHappen("Not initialized");
    const currentRebaseGeneration = syncState.localHead.rebaseGeneration;
    const [newEvents, deferreds] = pipe(batchItems, Array_exports.filter(([eventEncoded]) => eventEncoded.seqNum.rebaseGeneration === currentRebaseGeneration), Array_exports.unzip);
    if (newEvents.length === 0) {
      yield* pullLatch.open;
      continue;
    }
    const mergeResult = merge15({
      syncState,
      payload: { _tag: "local-push", newEvents },
      isClientEvent,
      isEqualEvent: LiveStoreEvent_exports.isEqualEncoded
    });
    switch (mergeResult._tag) {
      case "unexpected-error": {
        otelSpan?.addEvent(`push:unexpected-error`, {
          batchSize: newEvents.length,
          newEvents: TRACE_VERBOSE ? JSON.stringify(newEvents) : void 0
        });
        return yield* new SyncError({ cause: mergeResult.message });
      }
      case "rebase": {
        return shouldNeverHappen("The leader thread should never have to rebase due to a local push");
      }
      case "reject": {
        otelSpan?.addEvent(`push:reject`, {
          batchSize: newEvents.length,
          mergeResult: TRACE_VERBOSE ? JSON.stringify(mergeResult) : void 0
        });
        const nextRebaseGeneration = currentRebaseGeneration + 1;
        const providedNum = newEvents.at(0).seqNum;
        const remainingEventsMatchingGeneration = yield* BucketQueue_exports.takeSplitWhere(localPushesQueue, ([eventEncoded]) => eventEncoded.seqNum.rebaseGeneration >= nextRebaseGeneration);
        if (LS_DEV && (yield* BucketQueue_exports.size(localPushesQueue)) > 0) {
          console.log("localPushesQueue is not empty", yield* BucketQueue_exports.size(localPushesQueue));
          debugger;
        }
        const allDeferredsToReject = [
          ...deferreds,
          ...remainingEventsMatchingGeneration.map(([_, deferred]) => deferred)
        ].filter(isNotUndefined2);
        yield* Effect_exports2.forEach(allDeferredsToReject, (deferred) => Deferred_exports.fail(deferred, LeaderAheadError.make({ minimumExpectedNum: mergeResult.expectedMinimumId, providedNum })));
        yield* pullLatch.open;
        continue;
      }
      case "advance": {
        break;
      }
      default: {
        casesHandled(mergeResult);
      }
    }
    yield* SubscriptionRef_exports2.set(syncStateSref, mergeResult.newSyncState);
    yield* connectedClientSessionPullQueues.offer({
      payload: PayloadUpstreamAdvance.make({ newEvents: mergeResult.newEvents }),
      leaderHead: mergeResult.newSyncState.localHead
    });
    otelSpan?.addEvent(`push:advance`, {
      batchSize: newEvents.length,
      mergeResult: TRACE_VERBOSE ? JSON.stringify(mergeResult) : void 0
    });
    const filteredBatch = mergeResult.newEvents.filter((eventEncoded) => {
      const { eventDef } = getEventDef(schema4, eventEncoded.name);
      return eventDef.options.clientOnly === false;
    });
    yield* BucketQueue_exports.offerAll(syncBackendPushQueue, filteredBatch);
    yield* materializeEventsBatch({ batchItems: mergeResult.newEvents, deferreds });
    yield* pullLatch.open;
  }
}), "backgroundApplyLocalPushes");
var materializeEventsBatch = /* @__PURE__ */ __name(({ batchItems, deferreds }) => Effect_exports2.gen(function* () {
  const { dbState: db, dbEventlog, materializeEvent } = yield* LeaderThreadCtx;
  db.execute("BEGIN TRANSACTION", void 0);
  dbEventlog.execute("BEGIN TRANSACTION", void 0);
  yield* Effect_exports2.addFinalizer((exit5) => Effect_exports2.gen(function* () {
    if (Exit_exports.isSuccess(exit5))
      return;
    db.execute("ROLLBACK", void 0);
    dbEventlog.execute("ROLLBACK", void 0);
  }));
  for (let i = 0; i < batchItems.length; i++) {
    const { sessionChangeset, hash: hash5 } = yield* materializeEvent(batchItems[i]);
    batchItems[i].meta.sessionChangeset = sessionChangeset;
    batchItems[i].meta.materializerHashLeader = hash5;
    if (deferreds?.[i] !== void 0) {
      yield* Deferred_exports.succeed(deferreds[i], void 0);
    }
  }
  db.execute("COMMIT", void 0);
  dbEventlog.execute("COMMIT", void 0);
}).pipe(Effect_exports2.uninterruptible, Effect_exports2.scoped, Effect_exports2.withSpan("@livestore/common:LeaderSyncProcessor:materializeEventItems", {
  attributes: { batchSize: batchItems.length }
}), Effect_exports2.tapCauseLogPretty), "materializeEventsBatch");
var backgroundBackendPulling = /* @__PURE__ */ __name(({ isClientEvent, restartBackendPushing, otelSpan, dbState, syncStateSref, localPushesLatch, livePull, pullLatch, devtoolsLatch, initialBlockingSyncContext, connectedClientSessionPullQueues, advancePushHead }) => Effect_exports2.gen(function* () {
  const { syncBackend, dbState: db, dbEventlog, schema: schema4 } = yield* LeaderThreadCtx;
  if (syncBackend === void 0)
    return;
  const onNewPullChunk = /* @__PURE__ */ __name((newEvents, pageInfo) => Effect_exports2.gen(function* () {
    if (newEvents.length === 0)
      return;
    if (devtoolsLatch !== void 0) {
      yield* devtoolsLatch.await;
    }
    yield* localPushesLatch.close;
    yield* pullLatch.await;
    const syncState2 = yield* syncStateSref;
    if (syncState2 === void 0)
      return shouldNeverHappen("Not initialized");
    const mergeResult = merge15({
      syncState: syncState2,
      payload: PayloadUpstreamAdvance.make({ newEvents }),
      isClientEvent,
      isEqualEvent: LiveStoreEvent_exports.isEqualEncoded,
      ignoreClientEvents: true
    });
    if (mergeResult._tag === "reject") {
      return shouldNeverHappen("The leader thread should never reject upstream advances");
    } else if (mergeResult._tag === "unexpected-error") {
      otelSpan?.addEvent(`pull:unexpected-error`, {
        newEventsCount: newEvents.length,
        newEvents: TRACE_VERBOSE ? JSON.stringify(newEvents) : void 0
      });
      return yield* new SyncError({ cause: mergeResult.message });
    }
    const newBackendHead = newEvents.at(-1).seqNum;
    updateBackendHead(dbEventlog, newBackendHead);
    if (mergeResult._tag === "rebase") {
      otelSpan?.addEvent(`pull:rebase[${mergeResult.newSyncState.localHead.rebaseGeneration}]`, {
        newEventsCount: newEvents.length,
        newEvents: TRACE_VERBOSE ? JSON.stringify(newEvents) : void 0,
        rollbackCount: mergeResult.rollbackEvents.length,
        mergeResult: TRACE_VERBOSE ? JSON.stringify(mergeResult) : void 0
      });
      const globalRebasedPendingEvents = mergeResult.newSyncState.pending.filter((event) => {
        const { eventDef } = getEventDef(schema4, event.name);
        return eventDef.options.clientOnly === false;
      });
      yield* restartBackendPushing(globalRebasedPendingEvents);
      if (mergeResult.rollbackEvents.length > 0) {
        yield* rollback({
          dbState: db,
          dbEventlog,
          eventNumsToRollback: mergeResult.rollbackEvents.map((_) => _.seqNum)
        });
      }
      yield* connectedClientSessionPullQueues.offer({
        payload: payloadFromMergeResult(mergeResult),
        leaderHead: mergeResult.newSyncState.localHead
      });
    } else {
      otelSpan?.addEvent(`pull:advance`, {
        newEventsCount: newEvents.length,
        mergeResult: TRACE_VERBOSE ? JSON.stringify(mergeResult) : void 0
      });
      yield* connectedClientSessionPullQueues.offer({
        payload: payloadFromMergeResult(mergeResult),
        leaderHead: mergeResult.newSyncState.localHead
      });
      if (mergeResult.confirmedEvents.length > 0) {
        const confirmedNewEvents = newEvents.filter((event) => mergeResult.confirmedEvents.some((confirmedEvent) => EventSequenceNumber_exports.isEqual(event.seqNum, confirmedEvent.seqNum)));
        yield* updateSyncMetadata(confirmedNewEvents);
      }
    }
    trimChangesetRows(db, newBackendHead);
    advancePushHead(mergeResult.newSyncState.localHead);
    yield* materializeEventsBatch({ batchItems: mergeResult.newEvents, deferreds: void 0 });
    yield* SubscriptionRef_exports2.set(syncStateSref, mergeResult.newSyncState);
    if (pageInfo._tag === "NoMore") {
      yield* localPushesLatch.open;
    }
  }), "onNewPullChunk");
  const syncState = yield* syncStateSref;
  if (syncState === void 0)
    return shouldNeverHappen("Not initialized");
  const cursorInfo = yield* getSyncBackendCursorInfo({ remoteHead: syncState.upstreamHead.global });
  const hashMaterializerResult = makeMaterializerHash({ schema: schema4, dbState });
  yield* syncBackend.pull(cursorInfo, { live: livePull }).pipe(
    // TODO only take from queue while connected
    Stream_exports2.tap(({ batch, pageInfo }) => Effect_exports2.gen(function* () {
      yield* SubscriptionRef_exports2.waitUntil(syncBackend.isConnected, (isConnected) => isConnected === true);
      yield* onNewPullChunk(batch.map((_) => LiveStoreEvent_exports.EncodedWithMeta.fromGlobal(_.eventEncoded, {
        syncMetadata: _.metadata,
        // TODO we can't really know the materializer result here yet beyond the first event batch item as we need to materialize it one by one first
        // This is a bug and needs to be fixed https://github.com/livestorejs/livestore/issues/503#issuecomment-3114533165
        materializerHashLeader: hashMaterializerResult(LiveStoreEvent_exports.encodedFromGlobal(_.eventEncoded)),
        materializerHashSession: Option_exports.none()
      })), pageInfo);
      yield* initialBlockingSyncContext.update({ processed: batch.length, pageInfo });
    })),
    Stream_exports2.runDrain,
    Effect_exports2.interruptible
  );
}).pipe(Effect_exports2.withSpan("@livestore/common:LeaderSyncProcessor:backend-pulling")), "backgroundBackendPulling");
var backgroundBackendPushing = /* @__PURE__ */ __name(({ syncBackendPushQueue, otelSpan, devtoolsLatch, backendPushBatchSize }) => Effect_exports2.gen(function* () {
  const { syncBackend } = yield* LeaderThreadCtx;
  if (syncBackend === void 0)
    return;
  while (true) {
    yield* SubscriptionRef_exports2.waitUntil(syncBackend.isConnected, (isConnected) => isConnected === true);
    const queueItems = yield* BucketQueue_exports.takeBetween(syncBackendPushQueue, 1, backendPushBatchSize);
    yield* SubscriptionRef_exports2.waitUntil(syncBackend.isConnected, (isConnected) => isConnected === true);
    if (devtoolsLatch !== void 0) {
      yield* devtoolsLatch.await;
    }
    otelSpan?.addEvent("backend-push", {
      batchSize: queueItems.length,
      batch: TRACE_VERBOSE ? JSON.stringify(queueItems) : void 0
    });
    const pushResult = yield* syncBackend.push(queueItems.map((_) => _.toGlobal())).pipe(Effect_exports2.either);
    if (pushResult._tag === "Left") {
      if (LS_DEV) {
        yield* Effect_exports2.logDebug("handled backend-push-error", { error: pushResult.left.toString() });
      }
      otelSpan?.addEvent("backend-push-error", { error: pushResult.left.toString() });
      return yield* Effect_exports2.never;
    }
  }
}).pipe(Effect_exports2.interruptible, Effect_exports2.withSpan("@livestore/common:LeaderSyncProcessor:backend-pushing")), "backgroundBackendPushing");
var trimChangesetRows = /* @__PURE__ */ __name((db, newHead) => {
  db.execute(sql`DELETE FROM ${system_tables_exports.SESSION_CHANGESET_META_TABLE} WHERE seqNumGlobal < ${newHead.global}`);
}, "trimChangesetRows");
var makePullQueueSet = Effect_exports2.gen(function* () {
  const set20 = /* @__PURE__ */ new Set();
  const cachedPayloads = /* @__PURE__ */ new Map();
  yield* Effect_exports2.addFinalizer(() => Effect_exports2.gen(function* () {
    for (const queue of set20) {
      yield* Queue_exports.shutdown(queue);
    }
    set20.clear();
  }));
  const makeQueue2 = /* @__PURE__ */ __name((cursor) => Effect_exports2.gen(function* () {
    const queue = yield* Queue_exports.unbounded().pipe(Effect_exports2.acquireRelease(Queue_exports.shutdown));
    yield* Effect_exports2.addFinalizer(() => Effect_exports2.sync(() => set20.delete(queue)));
    const payloadsSinceCursor = Array.from(cachedPayloads.entries()).flatMap(([seqNumStr, payloads]) => payloads.map((payload) => ({ payload, seqNum: EventSequenceNumber_exports.fromString(seqNumStr) }))).filter(({ seqNum }) => EventSequenceNumber_exports.isGreaterThan(seqNum, cursor)).toSorted((a, b) => EventSequenceNumber_exports.compare(a.seqNum, b.seqNum)).map(({ payload }) => {
      if (payload._tag === "upstream-advance") {
        return {
          payload: {
            _tag: "upstream-advance",
            newEvents: Array_exports.dropWhile(payload.newEvents, (eventEncoded) => EventSequenceNumber_exports.isGreaterThanOrEqual(cursor, eventEncoded.seqNum))
          }
        };
      } else {
        return { payload };
      }
    });
    yield* queue.offerAll(payloadsSinceCursor);
    set20.add(queue);
    return queue;
  }), "makeQueue");
  const offer7 = /* @__PURE__ */ __name((item) => Effect_exports2.gen(function* () {
    const seqNumStr = EventSequenceNumber_exports.toString(item.leaderHead);
    if (cachedPayloads.has(seqNumStr)) {
      cachedPayloads.get(seqNumStr).push(item.payload);
    } else {
      cachedPayloads.set(seqNumStr, [item.payload]);
    }
    if (item.payload._tag === "upstream-advance" && item.payload.newEvents.length === 0) {
      return;
    }
    for (const queue of set20) {
      yield* Queue_exports.offer(queue, item);
    }
  }), "offer");
  return {
    makeQueue: makeQueue2,
    offer: offer7
  };
});
var validatePushBatch = /* @__PURE__ */ __name((batch, pushHead) => Effect_exports2.gen(function* () {
  if (batch.length === 0) {
    return;
  }
  for (let i = 1; i < batch.length; i++) {
    if (EventSequenceNumber_exports.isGreaterThanOrEqual(batch[i - 1].seqNum, batch[i].seqNum)) {
      shouldNeverHappen(`Events must be ordered in monotonically ascending order by eventNum. Received: [${batch.map((e) => EventSequenceNumber_exports.toString(e.seqNum)).join(", ")}]`);
    }
  }
  if (EventSequenceNumber_exports.isGreaterThanOrEqual(pushHead, batch[0].seqNum)) {
    return yield* LeaderAheadError.make({
      minimumExpectedNum: pushHead,
      providedNum: batch[0].seqNum
    });
  }
}), "validatePushBatch");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/recreate-db.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var recreateDb = /* @__PURE__ */ __name(({ dbState, dbEventlog, schema: schema4, bootStatusQueue, materializeEvent }) => Effect_exports2.gen(function* () {
  const migrationOptions = schema4.state.sqlite.migrations;
  let migrationsReport;
  yield* Effect_exports2.addFinalizer(Effect_exports2.fn("recreateDb:finalizer")(function* (ex) {
    if (ex._tag === "Failure")
      dbState.destroy();
  }));
  const tmpDb = dbState;
  yield* configureConnection(tmpDb, { foreignKeys: true });
  const initDb = /* @__PURE__ */ __name((hooks) => Effect_exports2.gen(function* () {
    yield* Effect_exports2.tryAll(() => hooks?.init?.(tmpDb)).pipe(UnexpectedError.mapToUnexpectedError);
    const migrationsReport2 = yield* migrateDb({
      db: tmpDb,
      schema: schema4,
      onProgress: /* @__PURE__ */ __name(({ done: done12, total }) => Queue_exports.offer(bootStatusQueue, { stage: "migrating", progress: { done: done12, total } }), "onProgress")
    });
    yield* Effect_exports2.tryAll(() => hooks?.pre?.(tmpDb)).pipe(UnexpectedError.mapToUnexpectedError);
    return { migrationsReport: migrationsReport2, tmpDb };
  }), "initDb");
  switch (migrationOptions.strategy) {
    case "auto": {
      const hooks = migrationOptions.hooks;
      const initResult = yield* initDb(hooks);
      migrationsReport = initResult.migrationsReport;
      yield* rematerializeFromEventlog({
        // db: initResult.tmpDb,
        dbEventlog,
        schema: schema4,
        materializeEvent,
        onProgress: /* @__PURE__ */ __name(({ done: done12, total }) => Queue_exports.offer(bootStatusQueue, { stage: "rehydrating", progress: { done: done12, total } }), "onProgress")
      });
      yield* Effect_exports2.tryAll(() => hooks?.post?.(initResult.tmpDb)).pipe(UnexpectedError.mapToUnexpectedError);
      break;
    }
    case "manual": {
      const oldDbData = dbState.export();
      migrationsReport = { migrations: [] };
      const newDbData = yield* Effect_exports2.tryAll(() => migrationOptions.migrate(oldDbData)).pipe(UnexpectedError.mapToUnexpectedError);
      tmpDb.import(newDbData);
      break;
    }
    default: {
      casesHandled(migrationOptions);
    }
  }
  return { migrationsReport };
}).pipe(
  Effect_exports2.scoped,
  // NOTE we're closing the scope here so finalizers are called when the effect is done
  Effect_exports2.withSpan("@livestore/common:leader-thread:recreateDb"),
  Effect_exports2.withPerformanceMeasure("@livestore/common:leader-thread:recreateDb")
), "recreateDb");

// node_modules/.pnpm/@livestore+common@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_patch_hash=68_b9e27424d81d7b2abb0c20beeb8130ec/node_modules/@livestore/common/dist/leader-thread/make-leader-thread-layer.js
var makeLeaderThreadLayer = /* @__PURE__ */ __name(({ schema: schema4, storeId: storeId2, clientId: clientId2, syncPayload, makeSqliteDb: makeSqliteDb2, syncOptions, dbState, dbEventlog, devtoolsOptions, shutdownChannel, params: params2, testing }) => Effect_exports2.gen(function* () {
  const bootStatusQueue = yield* Queue_exports.unbounded().pipe(Effect_exports2.acquireRelease(Queue_exports.shutdown));
  const dbEventlogMissing = !hasEventlogTables(dbEventlog);
  const dbStateMissing = !hasStateTables(dbState);
  const syncBackend = syncOptions?.backend === void 0 ? void 0 : yield* syncOptions.backend({ storeId: storeId2, clientId: clientId2, payload: syncPayload });
  if (syncBackend !== void 0) {
    yield* syncBackend.connect.pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
  }
  const initialBlockingSyncContext = yield* makeInitialBlockingSyncContext({
    initialSyncOptions: syncOptions?.initialSyncOptions ?? { _tag: "Skip" },
    bootStatusQueue
  });
  yield* initEventlogDb(dbEventlog);
  const materializeEvent = yield* makeMaterializeEvent({ schema: schema4, dbState, dbEventlog });
  const { migrationsReport } = dbStateMissing ? yield* recreateDb({ dbState, dbEventlog, schema: schema4, bootStatusQueue, materializeEvent }) : { migrationsReport: { migrations: [] } };
  const syncProcessor = yield* makeLeaderSyncProcessor({
    schema: schema4,
    dbState,
    initialSyncState: getInitialSyncState({ dbEventlog, dbState, dbEventlogMissing }),
    initialBlockingSyncContext,
    onError: syncOptions?.onSyncError ?? "ignore",
    livePull: syncOptions?.livePull ?? true,
    params: {
      localPushBatchSize: params2?.localPushBatchSize,
      backendPushBatchSize: params2?.backendPushBatchSize
    },
    testing: {
      delays: testing?.syncProcessor?.delays
    }
  });
  const extraIncomingMessagesQueue = yield* Queue_exports.unbounded().pipe(Effect_exports2.acquireRelease(Queue_exports.shutdown));
  const devtoolsContext = devtoolsOptions.enabled ? {
    enabled: true,
    syncBackendLatch: yield* Effect_exports2.makeLatch(true),
    syncBackendLatchState: yield* SubscriptionRef_exports2.make({ latchClosed: false })
  } : { enabled: false };
  const ctx = {
    schema: schema4,
    bootStatusQueue,
    storeId: storeId2,
    clientId: clientId2,
    dbState,
    dbEventlog,
    makeSqliteDb: makeSqliteDb2,
    eventSchema: LiveStoreEvent_exports.makeEventDefSchema(schema4),
    shutdownStateSubRef: yield* SubscriptionRef_exports2.make("running"),
    shutdownChannel,
    syncBackend,
    syncProcessor,
    materializeEvent,
    extraIncomingMessagesQueue,
    devtools: devtoolsContext,
    // State will be set during `bootLeaderThread`
    initialState: {}
  };
  globalThis.__leaderThreadCtx = ctx;
  const layer14 = Layer_exports.succeed(LeaderThreadCtx, ctx);
  ctx.initialState = yield* bootLeaderThread({
    migrationsReport,
    initialBlockingSyncContext,
    devtoolsOptions
  }).pipe(Effect_exports2.provide(layer14));
  return layer14;
}).pipe(Effect_exports2.withSpan("@livestore/common:leader-thread:boot"), Effect_exports2.withSpanScoped("@livestore/common:leader-thread"), UnexpectedError.mapToUnexpectedError, Effect_exports2.tapCauseLogPretty, Layer_exports.unwrapScoped), "makeLeaderThreadLayer");
var hasEventlogTables = /* @__PURE__ */ __name((db) => {
  const tableNames = new Set(db.select(sql`select name from sqlite_master`).map((_) => _.name));
  const eventlogTables = new Set(system_tables_exports.eventlogSystemTables.map((_) => _.sqliteDef.name));
  return isSubsetOf(eventlogTables, tableNames);
}, "hasEventlogTables");
var hasStateTables = /* @__PURE__ */ __name((db) => {
  const tableNames = new Set(db.select(sql`select name from sqlite_master`).map((_) => _.name));
  const stateTables = new Set(system_tables_exports.stateSystemTables.map((_) => _.sqliteDef.name));
  return isSubsetOf(stateTables, tableNames);
}, "hasStateTables");
var isSubsetOf = /* @__PURE__ */ __name((a, b) => {
  for (const item of a) {
    if (!b.has(item)) {
      return false;
    }
  }
  return true;
}, "isSubsetOf");
var getInitialSyncState = /* @__PURE__ */ __name(({ dbEventlog, dbState, dbEventlogMissing }) => {
  const initialBackendHead = dbEventlogMissing ? EventSequenceNumber_exports.ROOT.global : getBackendHeadFromDb(dbEventlog);
  const initialLocalHead = dbEventlogMissing ? EventSequenceNumber_exports.ROOT : getClientHeadFromDb(dbEventlog);
  if (initialBackendHead > initialLocalHead.global) {
    return shouldNeverHappen(`During boot the backend head (${initialBackendHead}) should never be greater than the local head (${initialLocalHead.global})`);
  }
  return SyncState.make({
    localHead: initialLocalHead,
    upstreamHead: {
      global: initialBackendHead,
      client: EventSequenceNumber_exports.clientDefault,
      rebaseGeneration: EventSequenceNumber_exports.rebaseGenerationDefault
    },
    pending: dbEventlogMissing ? [] : getEventsSince({
      dbEventlog,
      dbState,
      since: {
        global: initialBackendHead,
        client: EventSequenceNumber_exports.clientDefault,
        rebaseGeneration: initialLocalHead.rebaseGeneration
      }
    })
  });
}, "getInitialSyncState");
var makeInitialBlockingSyncContext = /* @__PURE__ */ __name(({ initialSyncOptions, bootStatusQueue }) => Effect_exports2.gen(function* () {
  const ctx = {
    isDone: false,
    processedEvents: 0,
    total: -1
  };
  const blockingDeferred = initialSyncOptions._tag === "Blocking" ? yield* Deferred_exports.make() : void 0;
  if (blockingDeferred !== void 0 && initialSyncOptions._tag === "Blocking") {
    yield* Deferred_exports.succeed(blockingDeferred, void 0).pipe(Effect_exports2.delay(initialSyncOptions.timeout), Effect_exports2.forkScoped);
  }
  return {
    blockingDeferred,
    update: /* @__PURE__ */ __name(({ processed, pageInfo }) => Effect_exports2.gen(function* () {
      if (ctx.isDone === true)
        return;
      if (ctx.total === -1 && pageInfo._tag === "MoreKnown") {
        ctx.total = pageInfo.remaining + processed;
      }
      ctx.processedEvents += processed;
      yield* Queue_exports.offer(bootStatusQueue, {
        stage: "syncing",
        progress: { done: ctx.processedEvents, total: ctx.total }
      });
      if (pageInfo._tag === "NoMore" && blockingDeferred !== void 0) {
        yield* Deferred_exports.succeed(blockingDeferred, void 0);
        ctx.isDone = true;
      }
    }), "update")
  };
}), "makeInitialBlockingSyncContext");
var bootLeaderThread = /* @__PURE__ */ __name(({ migrationsReport, initialBlockingSyncContext, devtoolsOptions }) => Effect_exports2.gen(function* () {
  const { bootStatusQueue, syncProcessor } = yield* LeaderThreadCtx;
  const { initialLeaderHead } = yield* syncProcessor.boot;
  if (initialBlockingSyncContext.blockingDeferred !== void 0) {
    yield* Queue_exports.offer(bootStatusQueue, {
      stage: "syncing",
      progress: { done: 0, total: -1 }
    });
    yield* initialBlockingSyncContext.blockingDeferred.pipe(Effect_exports2.withSpan("@livestore/common:leader-thread:initial-sync-blocking"));
  }
  yield* Queue_exports.offer(bootStatusQueue, { stage: "done" });
  yield* bootDevtools(devtoolsOptions).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
  return { migrationsReport, leaderHead: initialLeaderHead };
}), "bootLeaderThread");

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/mod.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/live-queries/base-class.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/reactive.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var NOT_REFRESHED_YET = Symbol.for("NOT_REFRESHED_YET");
var isThunk = /* @__PURE__ */ __name((obj) => {
  return typeof obj === "object" && obj !== null && "_tag" in obj && obj._tag === "thunk";
}, "isThunk");
var unknownRefreshReason = /* @__PURE__ */ __name(() => {
  return { _tag: "unknown" };
}, "unknownRefreshReason");
var encodedOptionSome = /* @__PURE__ */ __name((value6) => ({ _tag: "Some", value: value6 }), "encodedOptionSome");
var encodedOptionNone = /* @__PURE__ */ __name(() => ({ _tag: "None" }), "encodedOptionNone");
var globalGraphIdCounter = 0;
var uniqueGraphId = /* @__PURE__ */ __name(() => `graph-${++globalGraphIdCounter}`, "uniqueGraphId");
var ReactiveGraph = class {
  static {
    __name(this, "ReactiveGraph");
  }
  id = uniqueGraphId();
  atoms = /* @__PURE__ */ new Set();
  effects = /* @__PURE__ */ new Set();
  context;
  debugRefreshInfos = new BoundArray(200);
  currentDebugRefresh;
  deferredEffects = /* @__PURE__ */ new Map();
  refreshCallbacks = /* @__PURE__ */ new Set();
  nodeIdCounter = 0;
  uniqueNodeId = /* @__PURE__ */ __name(() => `node-${++this.nodeIdCounter}`, "uniqueNodeId");
  refreshInfoIdCounter = 0;
  uniqueRefreshInfoId = /* @__PURE__ */ __name(() => `refresh-info-${++this.refreshInfoIdCounter}`, "uniqueRefreshInfoId");
  makeRef(val, options4) {
    const ref2 = {
      _tag: "ref",
      id: this.uniqueNodeId(),
      isDirty: false,
      isDestroyed: false,
      previousResult: val,
      computeResult: /* @__PURE__ */ __name(() => ref2.previousResult, "computeResult"),
      sub: /* @__PURE__ */ new Set(),
      super: /* @__PURE__ */ new Set(),
      label: options4?.label,
      meta: options4?.meta,
      equal: options4?.equal ?? deepEqual,
      refreshes: 0
    };
    this.atoms.add(ref2);
    return ref2;
  }
  makeThunk(getResult, options4) {
    const thunk = {
      _tag: "thunk",
      id: this.uniqueNodeId(),
      previousResult: NOT_REFRESHED_YET,
      isDirty: true,
      isDestroyed: false,
      computeResult: /* @__PURE__ */ __name((otelContext, debugRefreshReason) => {
        if (thunk.isDirty) {
          const neededCurrentRefresh = this.currentDebugRefresh === void 0;
          if (neededCurrentRefresh) {
            this.currentDebugRefresh = { refreshedAtoms: [], startMs: performance.now() };
          }
          thunk.sub = /* @__PURE__ */ new Set();
          const getAtom = /* @__PURE__ */ __name((atom, otelContext2) => {
            this.addEdge(thunk, atom);
            return compute(atom, otelContext2, debugRefreshReason);
          }, "getAtom");
          let debugInfo;
          const setDebugInfo = /* @__PURE__ */ __name((debugInfo_) => {
            debugInfo = debugInfo_;
          }, "setDebugInfo");
          const result = getResult(getAtom, setDebugInfo, this.context ?? throwContextNotSetError(this), otelContext, debugRefreshReason);
          const resultChanged = thunk.equal(thunk.previousResult, result) === false;
          const debugInfoForAtom = {
            atom: serializeAtom(thunk, false),
            resultChanged,
            debugInfo: debugInfo ?? unknownRefreshReason()
          };
          this.currentDebugRefresh.refreshedAtoms.push(debugInfoForAtom);
          thunk.isDirty = false;
          thunk.previousResult = result;
          thunk.recomputations++;
          if (neededCurrentRefresh) {
            const refreshedAtoms = this.currentDebugRefresh.refreshedAtoms;
            const durationMs = performance.now() - this.currentDebugRefresh.startMs;
            this.currentDebugRefresh = void 0;
            this.debugRefreshInfos.push({
              id: this.uniqueRefreshInfoId(),
              reason: debugRefreshReason ?? { _tag: "makeThunk", label: options4?.label },
              skippedRefresh: false,
              refreshedAtoms,
              durationMs,
              completedTimestamp: Date.now(),
              graphSnapshot: this.getSnapshot({ includeResults: false })
            });
          }
          return result;
        } else {
          return thunk.previousResult;
        }
      }, "computeResult"),
      sub: /* @__PURE__ */ new Set(),
      super: /* @__PURE__ */ new Set(),
      recomputations: 0,
      label: options4?.label,
      meta: options4?.meta,
      equal: options4?.equal ?? deepEqual,
      __getResult: getResult
    };
    this.atoms.add(thunk);
    return thunk;
  }
  destroyNode(node) {
    if (node._tag === "ref" || node._tag === "thunk") {
      for (const superComp of node.super) {
        this.destroyNode(superComp);
      }
    }
    if (node._tag !== "ref") {
      for (const subComp of node.sub) {
        this.removeEdge(node, subComp);
      }
    }
    if (node._tag === "effect") {
      this.deferredEffects.delete(node);
      this.effects.delete(node);
    } else {
      this.atoms.delete(node);
    }
    node.isDestroyed = true;
  }
  destroy() {
    for (const node of this.atoms) {
      this.destroyNode(node);
    }
  }
  makeEffect(doEffect, options4) {
    const effect4 = {
      _tag: "effect",
      id: this.uniqueNodeId(),
      isDestroyed: false,
      doEffect: /* @__PURE__ */ __name((otelContext, debugRefreshReason) => {
        effect4.invocations++;
        effect4.sub = /* @__PURE__ */ new Set();
        const getAtom = /* @__PURE__ */ __name((atom, otelContext2, debugRefreshReason2) => {
          this.addEdge(effect4, atom);
          return compute(atom, otelContext2, debugRefreshReason2);
        }, "getAtom");
        doEffect(getAtom, otelContext, debugRefreshReason);
      }, "doEffect"),
      sub: /* @__PURE__ */ new Set(),
      label: options4?.label,
      invocations: 0
    };
    this.effects.add(effect4);
    return effect4;
  }
  setRef(ref2, val, options4) {
    this.setRefs([[ref2, val]], options4);
  }
  setRefs(refs, options4) {
    const effectsToRefresh = /* @__PURE__ */ new Set();
    for (const [ref2, val] of refs) {
      ref2.previousResult = val;
      ref2.refreshes++;
      markSuperCompDirtyRec(ref2, effectsToRefresh);
    }
    if (options4?.skipRefresh) {
      for (const effect4 of effectsToRefresh) {
        if (this.deferredEffects.has(effect4) === false) {
          this.deferredEffects.set(effect4, /* @__PURE__ */ new Set());
        }
        if (options4?.debugRefreshReason !== void 0) {
          this.deferredEffects.get(effect4).add(options4.debugRefreshReason);
        }
      }
    } else {
      this.runEffects(effectsToRefresh, {
        debugRefreshReason: options4?.debugRefreshReason ?? unknownRefreshReason(),
        otelContext: options4?.otelContext
      });
    }
  }
  runEffects = /* @__PURE__ */ __name((effectsToRefresh, options4) => {
    const effectsWrapper = this.context?.effectsWrapper ?? ((runEffects) => runEffects());
    effectsWrapper(() => {
      this.currentDebugRefresh = { refreshedAtoms: [], startMs: performance.now() };
      for (const effect4 of effectsToRefresh) {
        effect4.doEffect(options4?.otelContext, options4.debugRefreshReason);
      }
      const refreshedAtoms = this.currentDebugRefresh.refreshedAtoms;
      const durationMs = performance.now() - this.currentDebugRefresh.startMs;
      this.currentDebugRefresh = void 0;
      const refreshDebugInfo = {
        id: this.uniqueRefreshInfoId(),
        reason: options4.debugRefreshReason,
        skippedRefresh: false,
        refreshedAtoms,
        durationMs,
        completedTimestamp: Date.now(),
        graphSnapshot: this.getSnapshot({ includeResults: false })
      };
      this.debugRefreshInfos.push(refreshDebugInfo);
      this.runRefreshCallbacks();
    });
  }, "runEffects");
  runDeferredEffects = /* @__PURE__ */ __name((options4) => {
    for (const [effect4, debugRefreshReasons] of this.deferredEffects) {
      this.runEffects(/* @__PURE__ */ new Set([effect4]), {
        debugRefreshReason: {
          _tag: "runDeferredEffects",
          originalRefreshReasons: Array.from(debugRefreshReasons),
          manualRefreshReason: options4?.debugRefreshReason
        },
        otelContext: options4?.otelContext
      });
    }
  }, "runDeferredEffects");
  runRefreshCallbacks = /* @__PURE__ */ __name(() => {
    for (const cb of this.refreshCallbacks) {
      cb();
    }
  }, "runRefreshCallbacks");
  addEdge(superComp, subComp) {
    superComp.sub.add(subComp);
    subComp.super.add(superComp);
    if (this.currentDebugRefresh === void 0) {
      this.runRefreshCallbacks();
    }
  }
  removeEdge(superComp, subComp) {
    superComp.sub.delete(subComp);
    const effectsToRefresh = /* @__PURE__ */ new Set();
    markSuperCompDirtyRec(subComp, effectsToRefresh);
    for (const effect4 of effectsToRefresh) {
      this.deferredEffects.set(effect4, /* @__PURE__ */ new Set());
    }
    subComp.super.delete(superComp);
    if (this.currentDebugRefresh === void 0) {
      this.runRefreshCallbacks();
    }
  }
  // NOTE This function is performance-optimized (i.e. not using `Array.from`)
  getSnapshot = /* @__PURE__ */ __name((opts) => {
    const { includeResults = false } = opts ?? {};
    const atoms = [];
    for (const atom of this.atoms) {
      atoms.push(serializeAtom(atom, includeResults));
    }
    const effects = [];
    for (const effect4 of this.effects) {
      effects.push(serializeEffect(effect4));
    }
    const deferredEffects = [];
    for (const [effect4] of this.deferredEffects) {
      deferredEffects.push(effect4.id);
    }
    return { atoms, effects, deferredEffects };
  }, "getSnapshot");
  subscribeToRefresh = /* @__PURE__ */ __name((cb) => {
    this.refreshCallbacks.add(cb);
    return () => {
      this.refreshCallbacks.delete(cb);
    };
  }, "subscribeToRefresh");
};
var compute = /* @__PURE__ */ __name((atom, otelContext, debugRefreshReason) => {
  if (atom.isDestroyed) {
    shouldNeverHappen(`LiveStore Error: Attempted to compute destroyed ${atom._tag} (${atom.id}): ${atom.label ?? ""}`);
  }
  if (atom.isDirty) {
    const result = atom.computeResult(otelContext, debugRefreshReason);
    atom.isDirty = false;
    atom.previousResult = result;
    return result;
  } else {
    return atom.previousResult;
  }
}, "compute");
var markSuperCompDirtyRec = /* @__PURE__ */ __name((atom, effectsToRefresh) => {
  for (const superComp of atom.super) {
    if (superComp._tag === "thunk") {
      superComp.isDirty = true;
      markSuperCompDirtyRec(superComp, effectsToRefresh);
    } else {
      effectsToRefresh.add(superComp);
    }
  }
}, "markSuperCompDirtyRec");
var throwContextNotSetError = /* @__PURE__ */ __name((graph) => {
  throw new Error(`LiveStore Error: \`context\` not set on ReactiveGraph (${graph.id})`);
}, "throwContextNotSetError");
var serializeAtom = /* @__PURE__ */ __name((atom, includeResult) => {
  const sub = [];
  for (const a of atom.sub) {
    sub.push(a.id);
  }
  const super_ = [];
  for (const a of atom.super) {
    super_.push(a.id);
  }
  const previousResult = includeResult ? encodedOptionSome(atom.previousResult === NOT_REFRESHED_YET ? '"SYMBOL_NOT_REFRESHED_YET"' : JSON.stringify(atom.previousResult)) : encodedOptionNone();
  if (atom._tag === "ref") {
    return {
      _tag: atom._tag,
      id: atom.id,
      label: atom.label,
      meta: atom.meta,
      isDirty: atom.isDirty,
      sub,
      super: super_,
      isDestroyed: atom.isDestroyed,
      refreshes: atom.refreshes,
      previousResult
    };
  }
  return {
    _tag: "thunk",
    id: atom.id,
    label: atom.label,
    meta: atom.meta,
    isDirty: atom.isDirty,
    sub,
    super: super_,
    isDestroyed: atom.isDestroyed,
    recomputations: atom.recomputations,
    previousResult
  };
}, "serializeAtom");
var serializeEffect = /* @__PURE__ */ __name((effect4) => {
  const sub = [];
  for (const a of effect4.sub) {
    sub.push(a.id);
  }
  return {
    _tag: effect4._tag,
    id: effect4.id,
    label: effect4.label,
    sub,
    invocations: effect4.invocations,
    isDestroyed: effect4.isDestroyed
  };
}, "serializeEffect");

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/live-queries/base-class.js
var makeReactivityGraph = /* @__PURE__ */ __name(() => new ReactiveGraph(), "makeReactivityGraph");
var queryIdCounter = 0;
var TypeId54 = Symbol.for("LiveQuery");
var depsToString = /* @__PURE__ */ __name((deps) => {
  if (typeof deps === "string" || typeof deps === "number") {
    return deps.toString();
  }
  return deps.filter(isNotNil).join(",");
}, "depsToString");
var LiveStoreQueryBase = class {
  static {
    __name(this, "LiveStoreQueryBase");
  }
  "__result!";
  id = queryIdCounter++;
  [TypeId54] = TypeId54;
  activeSubscriptions = /* @__PURE__ */ new Set();
  get runs() {
    if (this.results$._tag === "thunk") {
      return this.results$.recomputations;
    }
    return 0;
  }
  executionTimes = [];
  // TODO double check if this is needed
  isDestroyed = false;
  run = /* @__PURE__ */ __name((args2) => {
    return this.results$.computeResult(args2.otelContext, args2.debugRefreshReason);
  }, "run");
  dependencyQueriesRef = /* @__PURE__ */ new Set();
};
var makeGetAtomResult = /* @__PURE__ */ __name((get29, ctx, otelContext, dependencyQueriesRef) => {
  const getAtom = /* @__PURE__ */ __name((atom, _otelContext, debugRefreshReason) => {
    if (atom._tag === "thunk" || atom._tag === "ref")
      return get29(atom, otelContext, debugRefreshReason);
    if (atom._tag === "def" || atom._tag === "signal-def") {
      const query = atom.make(ctx);
      dependencyQueriesRef.add(query);
      return getAtom(query.value, _otelContext, debugRefreshReason);
    }
    if (atom._tag === "signal" && Predicate_exports.hasProperty(atom, "ref")) {
      return get29(atom.ref, otelContext, debugRefreshReason);
    }
    return get29(atom.results$, otelContext, debugRefreshReason);
  }, "getAtom");
  return getAtom;
}, "makeGetAtomResult");
var withRCMap = /* @__PURE__ */ __name((id4, make105) => {
  return (ctx, otelContext) => {
    let item = ctx.defRcMap.get(id4);
    if (item) {
      item.rc++;
      return item;
    }
    const query$ = make105(ctx, otelContext);
    item = {
      rc: 1,
      value: query$,
      deref: /* @__PURE__ */ __name(() => {
        item.rc--;
        if (item.rc === 0) {
          item.value.destroy();
          ctx.defRcMap.delete(id4);
        }
      }, "deref")
    };
    ctx.defRcMap.set(id4, item);
    return item;
  };
}, "withRCMap");

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/utils/function-string.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var REACT_NATIVE_BAD_FUNCTION_STRING = "function() { [bytecode] }";
var isValidFunctionString = /* @__PURE__ */ __name((fnStr) => {
  if (fnStr === REACT_NATIVE_BAD_FUNCTION_STRING) {
    return { _tag: "invalid", reason: "react-native" };
  }
  return { _tag: "valid" };
}, "isValidFunctionString");

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/live-queries/db-query.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var otel2 = __toESM(require_src(), 1);

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/live-queries/client-document-get-query.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var rowQueryLabel = /* @__PURE__ */ __name((table7, id4) => `${table7.sqliteDef.name}.get:${id4 === void 0 ? table7.default.id : id4 === SessionIdSymbol ? "sessionId" : id4}`, "rowQueryLabel");
var makeExecBeforeFirstRun = /* @__PURE__ */ __name(({ id: id4, explicitDefaultValues, table: table7, otelContext: otelContext_ }) => ({ store }) => {
  if (mod_exports4.SQLite.tableIsClientDocumentTable(table7) === false) {
    return shouldNeverHappen(`Cannot insert row for table "${table7.sqliteDef.name}" which does not have 'deriveEvents: true' set`);
  }
  const otelContext = otelContext_ ?? store.otel.queriesSpanContext;
  const idVal = id4 === SessionIdSymbol ? store.sessionId : id4;
  const rowExists = store.sqliteDbWrapper.cachedSelect(`SELECT 1 FROM '${table7.sqliteDef.name}' WHERE id = ?`, [idVal], { otelContext }).length === 1;
  if (rowExists)
    return;
  store.commit({ otelContext, skipRefresh: true, label: `${table7.sqliteDef.name}.set:${idVal}` }, table7.set(explicitDefaultValues, idVal));
}, "makeExecBeforeFirstRun");

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/live-queries/db-query.js
var isQueryInputRaw = /* @__PURE__ */ __name((value6) => Predicate_exports.hasProperty(value6, "query") && Predicate_exports.hasProperty(value6, "schema"), "isQueryInputRaw");
var queryDb = /* @__PURE__ */ __name((queryInput, options4) => {
  const { queryString, extraDeps } = getQueryStringAndExtraDeps(queryInput);
  const hash5 = [queryString, options4?.deps ? depsToString(options4.deps) : void 0, depsToString(extraDeps)].filter(Boolean).join("-");
  if (isValidFunctionString(hash5)._tag === "invalid") {
    throw new Error(`On Expo/React Native, db queries must provide a \`deps\` option`);
  }
  if (hash5.trim() === "") {
    return shouldNeverHappen(`Invalid query hash for query: ${queryInput}`);
  }
  const label = options4?.label ?? queryString;
  const def = {
    _tag: "def",
    make: withRCMap(hash5, (ctx, otelContext) => {
      return new LiveStoreDbQuery({
        reactivityGraph: ctx.reactivityGraph.deref(),
        queryInput,
        label,
        map: options4?.map,
        otelContext,
        def
      });
    }),
    label,
    hash: hash5,
    [Equal_exports.symbol](that) {
      return this.hash === that.hash;
    },
    [Hash_exports.symbol]() {
      return Hash_exports.string(this.hash);
    }
  };
  return def;
}, "queryDb");
var bindValuesToDepKey = /* @__PURE__ */ __name((bindValues) => {
  if (bindValues === void 0) {
    return [];
  }
  return Object.entries(bindValues).map(([key, value6]) => `${key}:${value6 === SessionIdSymbol ? "SessionIdSymbol" : value6}`).join(",");
}, "bindValuesToDepKey");
var getQueryStringAndExtraDeps = /* @__PURE__ */ __name((queryInput) => {
  if (isQueryBuilder(queryInput)) {
    const { query, bindValues } = queryInput.asSql();
    return { queryString: query, extraDeps: bindValuesToDepKey(bindValues) };
  }
  if (isQueryInputRaw(queryInput)) {
    return { queryString: queryInput.query, extraDeps: bindValuesToDepKey(queryInput.bindValues) };
  }
  if (typeof queryInput === "function") {
    return { queryString: queryInput.toString(), extraDeps: [] };
  }
  return shouldNeverHappen(`Invalid query input: ${queryInput}`);
}, "getQueryStringAndExtraDeps");
var LiveStoreDbQuery = class extends LiveStoreQueryBase {
  static {
    __name(this, "LiveStoreDbQuery");
  }
  _tag = "db";
  /** A reactive thunk representing the query text */
  queryInput$;
  /** A reactive thunk representing the query results */
  results$;
  label;
  reactivityGraph;
  mapResult;
  def;
  constructor({ queryInput, label: inputLabel, reactivityGraph, map: map38, otelContext, def }) {
    super();
    let label = inputLabel ?? "db(unknown)";
    this.reactivityGraph = reactivityGraph;
    this.def = def;
    this.mapResult = map38 === void 0 ? (rows) => rows : map38;
    const schemaRef = {
      current: typeof queryInput === "function" ? void 0 : isQueryBuilder(queryInput) ? void 0 : queryInput.schema
    };
    const execBeforeFirstRunRef = {
      current: void 0
    };
    let queryInputRaw$OrQueryInputRaw;
    const fromQueryBuilder = /* @__PURE__ */ __name((qb, otelContext2) => {
      try {
        const qbRes = qb.asSql();
        const schema4 = getResultSchema(qb);
        const ast = qb[QueryBuilderAstSymbol];
        return {
          queryInputRaw: {
            query: qbRes.query,
            schema: schema4,
            bindValues: qbRes.bindValues,
            queriedTables: /* @__PURE__ */ new Set([ast.tableDef.sqliteDef.name])
          },
          label: ast._tag === "RowQuery" ? rowQueryLabel(ast.tableDef, ast.id) : qb.toString(),
          execBeforeFirstRun: ast._tag === "RowQuery" ? makeExecBeforeFirstRun({
            table: ast.tableDef,
            explicitDefaultValues: ast.explicitDefaultValues,
            id: ast.id,
            otelContext: otelContext2
          }) : void 0
        };
      } catch (cause3) {
        throw new UnexpectedError({ cause: cause3, note: `Error building query for ${qb.toString()}`, payload: { qb } });
      }
    }, "fromQueryBuilder");
    if (typeof queryInput === "function") {
      queryInputRaw$OrQueryInputRaw = this.reactivityGraph.makeThunk((get29, setDebugInfo, ctx, otelContext2) => {
        const startMs = performance.now();
        const queryInputResult = queryInput(makeGetAtomResult(get29, ctx, otelContext2 ?? ctx.rootOtelContext, this.dependencyQueriesRef), ctx);
        const durationMs = performance.now() - startMs;
        let queryInputRaw;
        if (isQueryBuilder(queryInputResult)) {
          const res = fromQueryBuilder(queryInputResult, otelContext2);
          queryInputRaw = res.queryInputRaw;
          this.label = res.label;
          execBeforeFirstRunRef.current = res.execBeforeFirstRun;
        } else {
          queryInputRaw = queryInputResult;
        }
        setDebugInfo({ _tag: "computed", label: `${this.label}:queryInput`, query: queryInputRaw.query, durationMs });
        schemaRef.current = queryInputRaw.schema;
        return queryInputRaw;
      }, {
        label: `${label}:query`,
        meta: { liveStoreThunkType: "db.query" },
        // NOTE we're not checking the schema here as we assume the query string to always change when the schema might change
        equal: /* @__PURE__ */ __name((a, b) => a.query === b.query && deepEqual(a.bindValues, b.bindValues), "equal")
      });
      this.queryInput$ = queryInputRaw$OrQueryInputRaw;
    } else {
      let queryInputRaw;
      if (isQueryBuilder(queryInput)) {
        const res = fromQueryBuilder(queryInput, otelContext);
        queryInputRaw = res.queryInputRaw;
        label = res.label;
        execBeforeFirstRunRef.current = res.execBeforeFirstRun;
      } else {
        queryInputRaw = queryInput;
      }
      schemaRef.current = queryInputRaw.schema;
      queryInputRaw$OrQueryInputRaw = queryInputRaw;
      if (inputLabel === void 0 && isQueryBuilder(queryInput)) {
        const ast = queryInput[QueryBuilderAstSymbol];
        if (ast._tag === "RowQuery") {
          label = `db(${rowQueryLabel(ast.tableDef, ast.id)})`;
        }
      }
    }
    const queriedTablesRef = { current: void 0 };
    const makeResultsEqual = /* @__PURE__ */ __name((resultSchema) => {
      const eq = Schema_exports2.equivalence(resultSchema);
      return (a, b) => a === NOT_REFRESHED_YET || b === NOT_REFRESHED_YET ? false : eq(a, b);
    }, "makeResultsEqual");
    const resultsEqual = map38 === void 0 ? schemaRef.current === void 0 ? (a, b) => makeResultsEqual(schemaRef.current)(a, b) : makeResultsEqual(schemaRef.current) : void 0;
    const results$ = this.reactivityGraph.makeThunk((get29, setDebugInfo, queryContext, otelContext2, debugRefreshReason) => queryContext.otelTracer.startActiveSpan(
      "db:...",
      // NOTE span name will be overridden further down
      {
        attributes: {
          "livestore.debugRefreshReason": Predicate_exports.hasProperty(debugRefreshReason, "label") ? debugRefreshReason.label : debugRefreshReason?._tag
        }
      },
      otelContext2 ?? queryContext.rootOtelContext,
      (span4) => {
        const otelContext3 = otel2.trace.setSpan(otel2.context.active(), span4);
        const { store } = queryContext;
        if (execBeforeFirstRunRef.current !== void 0) {
          execBeforeFirstRunRef.current(queryContext, otelContext3);
          execBeforeFirstRunRef.current = void 0;
        }
        const queryInputResult = isThunk(queryInputRaw$OrQueryInputRaw) ? get29(queryInputRaw$OrQueryInputRaw, otelContext3, debugRefreshReason) : queryInputRaw$OrQueryInputRaw;
        const sqlString = queryInputResult.query;
        const bindValues = queryInputResult.bindValues;
        if (queriedTablesRef.current === void 0) {
          queriedTablesRef.current = store.sqliteDbWrapper.getTablesUsed(sqlString);
        }
        if (bindValues !== void 0) {
          replaceSessionIdSymbol(bindValues, store.clientSession.sessionId);
        }
        for (const tableName of queriedTablesRef.current) {
          const tableRef = store.tableRefs[tableName] ?? shouldNeverHappen(`No table ref found for ${tableName}`);
          get29(tableRef, otelContext3, debugRefreshReason);
        }
        span4.setAttribute("sql.query", sqlString);
        span4.updateName(`db:${sqlString.slice(0, 50)}`);
        const rawDbResults = store.sqliteDbWrapper.cachedSelect(sqlString, bindValues ? prepareBindValues(bindValues, sqlString) : void 0, {
          queriedTables: queriedTablesRef.current,
          otelContext: otelContext3
        });
        span4.setAttribute("sql.rowsCount", rawDbResults.length);
        const parsedResult = Schema_exports2.decodeEither(schemaRef.current)(rawDbResults);
        if (parsedResult._tag === "Left") {
          const parseErrorStr = TreeFormatter.formatErrorSync(parsedResult.left);
          const expectedSchemaStr = String(schemaRef.current.ast);
          const bindValuesStr = bindValues === void 0 ? "" : `
Bind values: ${JSON.stringify(bindValues)}`;
          return shouldNeverHappen(`Error parsing SQL query result (${label}).

Query: ${sqlString}${bindValuesStr}

Expected schema: ${expectedSchemaStr}

Error: ${parseErrorStr}

Result:`, rawDbResults, "\n");
        }
        const result = this.mapResult(parsedResult.right);
        span4.end();
        const durationMs = getDurationMsFromSpan(span4);
        this.executionTimes.push(durationMs);
        setDebugInfo({ _tag: "db", label: `${label}:results`, query: sqlString, durationMs });
        return result;
      }
    ), { label: `${label}:results`, meta: { liveStoreThunkType: "db.result" }, equal: resultsEqual });
    this.results$ = results$;
    this.label = label;
  }
  destroy = /* @__PURE__ */ __name(() => {
    this.isDestroyed = true;
    if (this.queryInput$ !== void 0) {
      this.reactivityGraph.destroyNode(this.queryInput$);
    }
    this.reactivityGraph.destroyNode(this.results$);
    for (const query of this.dependencyQueriesRef) {
      query.deref();
    }
  }, "destroy");
};

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/SqliteDbWrapper.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/QueryCache.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SymbolsBase = Symbol("base");
var SymbolsBrand = Symbol("brand");
var ignore5 = ["begin", "rollback", "commit", "savepoint", "release"];
var cacheSize = 200;
var QueryCache = class {
  static {
    __name(this, "QueryCache");
  }
  #entries = new BoundMap(cacheSize);
  #dependencies = /* @__PURE__ */ new Map();
  getKey = /* @__PURE__ */ __name((sql2, bindValues) => {
    if (bindValues == null) {
      return sql2;
    }
    const formatValue = /* @__PURE__ */ __name((value6) => value6 === SessionIdSymbol ? "SessionIdSymbol" : String(value6), "formatValue");
    if (Array.isArray(bindValues)) {
      return `${sql2}
${bindValues.map(formatValue).join("\n")}`;
    }
    return sql2 + "\n" + Object.entries(bindValues).map(([key, value6]) => `${key}:${formatValue(value6)}`).join("\n");
  }, "getKey");
  get = /* @__PURE__ */ __name((key) => {
    return this.#entries.get(key);
  }, "get");
  set = /* @__PURE__ */ __name((queriedTables, key, results) => {
    this.#entries.set(key, results);
    for (const table7 of queriedTables) {
      let keys6 = this.#dependencies.get(table7);
      if (keys6 == null) {
        keys6 = new BoundSet(cacheSize);
        keys6.onEvict = this.#dependencyTrackerEvicted;
        this.#dependencies.set(table7, keys6);
      }
      keys6.add(key);
    }
  }, "set");
  #dependencyTrackerEvicted = /* @__PURE__ */ __name((key) => {
    this.#entries.delete(key);
  }, "#dependencyTrackerEvicted");
  ignoreQuery = /* @__PURE__ */ __name((query) => {
    return ignore5.some((prefix) => query.startsWith(prefix));
  }, "ignoreQuery");
  // The next simplest step is to create a specific implementation for invalidating
  // the expensive track list queries only when constraints data in a write overlaps with read constraints.
  //
  // As well as either:
  // a. removeing the big view (since we'll have our cache)
  // b. incrementally updating the view on insert by the EventImporter
  //
  // We'll not try to tackle any generalized approach until we have a proof of concept working.
  invalidate = /* @__PURE__ */ __name((queriedTables) => {
    for (const table7 of queriedTables) {
      const keys6 = this.#dependencies.get(table7);
      if (keys6 == null) {
        continue;
      }
      for (const k of keys6) {
        this.#entries.delete(k);
      }
    }
  }, "invalidate");
};

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/SqliteDbWrapper.js
var emptyDebugInfo = /* @__PURE__ */ __name(() => ({
  slowQueries: new BoundArray(200),
  queryFrameDuration: 0,
  queryFrameCount: 0,
  events: new BoundArray(1e3)
}), "emptyDebugInfo");
var SqliteDbWrapper = class {
  static {
    __name(this, "SqliteDbWrapper");
  }
  _tag = "SqliteDb";
  // TODO: how many unique active statements are expected?
  cachedStmts = new BoundMap(200);
  tablesUsedCache = new BoundMap(200);
  resultCache = new QueryCache();
  db;
  otelTracer;
  otelRootSpanContext;
  tablesUsedStmt;
  debugInfo = emptyDebugInfo();
  constructor({ db, otel: otel5 }) {
    this.db = db;
    this.otelTracer = otel5.tracer;
    this.otelRootSpanContext = otel5.rootSpanContext;
    this.tablesUsedStmt = db.prepare(`SELECT tbl_name FROM tables_used(?) AS u JOIN sqlite_master ON sqlite_master.name = u.name WHERE u.schema = 'main';`);
    this.cachedStmts.onEvict = (_queryStr, stmt) => stmt.finalize();
    configureSQLite(this);
  }
  get debug() {
    return this.db.debug;
  }
  get metadata() {
    return this.db.metadata;
  }
  prepare(queryStr) {
    return this.db.prepare(queryStr);
  }
  import(data) {
    return this.db.import(data);
  }
  close() {
    this.db.close();
  }
  destroy() {
    this.db.destroy();
  }
  session() {
    return this.db.session();
  }
  makeChangeset(data) {
    return this.db.makeChangeset(data);
  }
  txn(callback) {
    this.execute(sql`begin transaction;`);
    let errored = false;
    let result;
    try {
      result = callback();
    } catch (e) {
      errored = true;
      this.execute(sql`rollback;`);
      throw e;
    }
    if (!errored) {
      this.execute(sql`commit;`);
    }
    return result;
  }
  withChangeset(callback) {
    const session = this.db.session();
    const result = callback();
    const changeset = session.changeset();
    session.finish();
    return {
      result,
      changeset: changeset ? { _tag: "sessionChangeset", data: changeset, debug: null } : { _tag: "no-op" }
    };
  }
  rollback(changeset) {
    const invertedChangeset = this.db.makeChangeset(changeset).invert();
    invertedChangeset.apply();
  }
  getTablesUsed(query) {
    const tableNameFromPlainDeleteQuery = tryGetTableNameFromPlainDeleteQuery(query);
    if (tableNameFromPlainDeleteQuery !== void 0) {
      return /* @__PURE__ */ new Set([tableNameFromPlainDeleteQuery]);
    }
    const cached4 = this.tablesUsedCache.get(query);
    if (cached4) {
      return cached4;
    }
    const stmt = this.tablesUsedStmt;
    const tablesUsed = /* @__PURE__ */ new Set();
    try {
      const results = stmt.select([query]);
      for (const row of results) {
        tablesUsed.add(row.tbl_name);
      }
    } catch (e) {
      console.error("Error getting tables used", e, "for query", query);
      return /* @__PURE__ */ new Set();
    }
    this.tablesUsedCache.set(query, tablesUsed);
    return tablesUsed;
  }
  cachedExecute(queryStr, bindValues, options4) {
    return this.otelTracer.startActiveSpan(
      "livestore.in-memory-db:execute",
      // TODO truncate query string
      { attributes: { "sql.query": queryStr } },
      options4?.otelContext ?? this.otelRootSpanContext,
      (span4) => {
        try {
          let stmt = this.cachedStmts.get(queryStr);
          if (stmt === void 0) {
            stmt = this.db.prepare(queryStr);
            this.cachedStmts.set(queryStr, stmt);
          }
          stmt.execute(bindValues);
          if (options4?.hasNoEffects !== true && !this.resultCache.ignoreQuery(queryStr)) {
            this.resultCache.invalidate(options4?.writeTables ?? this.getTablesUsed(queryStr));
          }
          span4.end();
          const durationMs = getDurationMsFromSpan(span4);
          this.debugInfo.queryFrameDuration += durationMs;
          this.debugInfo.queryFrameCount++;
          if (durationMs > 5 && isDevEnv()) {
            this.debugInfo.slowQueries.push({
              queryStr,
              bindValues,
              durationMs,
              rowsCount: void 0,
              queriedTables: /* @__PURE__ */ new Set(),
              startTimePerfNow: getStartTimeHighResFromSpan(span4)
            });
          }
          return { durationMs };
        } catch (cause3) {
          span4.recordException(cause3);
          span4.end();
          if (LS_DEV) {
            debugger;
          }
          throw new SqliteError({ cause: cause3, query: { bindValues: bindValues ?? {}, sql: queryStr } });
        }
      }
    );
  }
  execute = sqlite_db_helper_exports.makeExecute((queryStr, bindValues) => this.cachedExecute(queryStr, bindValues));
  select = sqlite_db_helper_exports.makeSelect((queryStr, bindValues) => this.cachedSelect(queryStr, bindValues));
  cachedSelect(queryStr, bindValues, options4) {
    const { queriedTables, skipCache = false, otelContext } = options4 ?? {};
    return this.otelTracer.startActiveSpan("sql-in-memory-select", {}, otelContext ?? this.otelRootSpanContext, (span4) => {
      try {
        span4.setAttribute("sql.query", queryStr);
        const key = this.resultCache.getKey(queryStr, bindValues);
        const cachedResult = this.resultCache.get(key);
        if (skipCache === false && cachedResult !== void 0) {
          span4.setAttribute("sql.rowsCount", cachedResult.length);
          span4.setAttribute("sql.cached", true);
          span4.end();
          return cachedResult;
        }
        let stmt = this.cachedStmts.get(queryStr);
        if (stmt === void 0) {
          stmt = this.db.prepare(queryStr);
          this.cachedStmts.set(queryStr, stmt);
        }
        const result = stmt.select(bindValues);
        span4.setAttribute("sql.rowsCount", result.length);
        span4.setAttribute("sql.cached", false);
        const queriedTables_ = queriedTables ?? this.getTablesUsed(queryStr);
        this.resultCache.set(queriedTables_, key, result);
        span4.end();
        const durationMs = getDurationMsFromSpan(span4);
        this.debugInfo.queryFrameDuration += durationMs;
        this.debugInfo.queryFrameCount++;
        if (durationMs > 5 && isDevEnv()) {
          this.debugInfo.slowQueries.push({
            queryStr,
            bindValues,
            durationMs,
            rowsCount: result.length,
            queriedTables: queriedTables_,
            startTimePerfNow: getStartTimeHighResFromSpan(span4)
          });
        }
        return result;
      } finally {
        span4.end();
      }
    });
  }
  export() {
    for (const key of this.cachedStmts.keys()) {
      this.cachedStmts.delete(key);
    }
    return this.db.export();
  }
};
var configureSQLite = /* @__PURE__ */ __name((db) => {
  db.execute(
    // TODO: revisit these tuning parameters for max performance
    sql`
      PRAGMA page_size=32768;
      PRAGMA cache_size=10000;
      PRAGMA synchronous='OFF';
      PRAGMA temp_store='MEMORY';
      PRAGMA foreign_keys='ON'; -- we want foreign key constraints to be enforced
    `
  );
}, "configureSQLite");
var tryGetTableNameFromPlainDeleteQuery = /* @__PURE__ */ __name((query) => {
  const [_, tableName] = query.trim().match(/^delete\s+from\s+(\w+)$/i) ?? [];
  return tableName;
}, "tryGetTableNameFromPlainDeleteQuery");

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/store/create-store.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var otel4 = __toESM(require_src(), 1);

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/store/devtools.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var requestNextTick = globalThis.requestAnimationFrame === void 0 ? (cb) => setTimeout(cb, 1e3) : globalThis.requestAnimationFrame;
var cancelTick = globalThis.cancelAnimationFrame === void 0 ? (id4) => clearTimeout(id4) : globalThis.cancelAnimationFrame;
var connectDevtoolsToStore = /* @__PURE__ */ __name(({ storeDevtoolsChannel, store }) => Effect_exports2.gen(function* () {
  const reactivityGraphSubcriptions = /* @__PURE__ */ new Map();
  const liveQueriesSubscriptions = /* @__PURE__ */ new Map();
  const debugInfoHistorySubscriptions = /* @__PURE__ */ new Map();
  const syncHeadClientSessionSubscriptions = /* @__PURE__ */ new Map();
  const { clientId: clientId2, sessionId: sessionId2 } = store.clientSession;
  yield* Effect_exports2.addFinalizer(() => Effect_exports2.sync(() => {
    for (const unsub of reactivityGraphSubcriptions.values())
      unsub();
    for (const unsub of liveQueriesSubscriptions.values())
      unsub();
    for (const unsub of debugInfoHistorySubscriptions.values())
      unsub();
    for (const unsub of syncHeadClientSessionSubscriptions.values())
      unsub();
  }));
  const handledRequestIds = /* @__PURE__ */ new Set();
  const sendToDevtools = /* @__PURE__ */ __name((message) => storeDevtoolsChannel.send(message).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.runFork), "sendToDevtools");
  const onMessage = /* @__PURE__ */ __name((decodedMessage) => {
    if (decodedMessage.clientId !== clientId2 || decodedMessage.sessionId !== sessionId2) {
      return;
    }
    if (decodedMessage._tag === "LSD.ClientSession.Disconnect") {
      return;
    }
    const requestId2 = decodedMessage.requestId;
    if (handledRequestIds.has(requestId2)) {
      return;
    }
    handledRequestIds.add(requestId2);
    const requestIdleCallback = globalThis.requestIdleCallback ?? ((cb) => cb());
    switch (decodedMessage._tag) {
      case "LSD.ClientSession.ReactivityGraphSubscribe": {
        const includeResults = decodedMessage.includeResults;
        const { subscriptionId } = decodedMessage;
        const send2 = /* @__PURE__ */ __name(() => (
          // In order to not add more work to the current tick, we use requestIdleCallback
          // to send the reactivity graph updates to the devtools
          requestIdleCallback(() => sendToDevtools(mod_exports5.ClientSession.ReactivityGraphRes.make({
            reactivityGraph: store.reactivityGraph.getSnapshot({ includeResults }),
            requestId: nanoid(10),
            clientId: clientId2,
            sessionId: sessionId2,
            liveStoreVersion,
            subscriptionId
          })), { timeout: 500 })
        ), "send");
        send2();
        const throttledSend = throttle3(send2, 20);
        reactivityGraphSubcriptions.set(subscriptionId, store.reactivityGraph.subscribeToRefresh(throttledSend));
        break;
      }
      case "LSD.ClientSession.DebugInfoReq": {
        sendToDevtools(mod_exports5.ClientSession.DebugInfoRes.make({
          debugInfo: store.sqliteDbWrapper.debugInfo,
          requestId: requestId2,
          clientId: clientId2,
          sessionId: sessionId2,
          liveStoreVersion
        }));
        break;
      }
      case "LSD.ClientSession.DebugInfoHistorySubscribe": {
        const { subscriptionId } = decodedMessage;
        const buffer4 = [];
        let hasStopped = false;
        let tickHandle;
        const tick3 = /* @__PURE__ */ __name(() => {
          buffer4.push(store.sqliteDbWrapper.debugInfo);
          store.sqliteDbWrapper.debugInfo = emptyDebugInfo();
          if (buffer4.length > 10) {
            sendToDevtools(mod_exports5.ClientSession.DebugInfoHistoryRes.make({
              debugInfoHistory: buffer4,
              requestId: nanoid(10),
              clientId: clientId2,
              sessionId: sessionId2,
              liveStoreVersion,
              subscriptionId
            }));
            buffer4.length = 0;
          }
          if (hasStopped === false) {
            tickHandle = requestNextTick(tick3);
          }
        }, "tick");
        tickHandle = requestNextTick(tick3);
        const unsub = /* @__PURE__ */ __name(() => {
          hasStopped = true;
          if (tickHandle !== void 0) {
            cancelTick(tickHandle);
            tickHandle = void 0;
          }
        }, "unsub");
        debugInfoHistorySubscriptions.set(subscriptionId, unsub);
        break;
      }
      case "LSD.ClientSession.DebugInfoHistoryUnsubscribe": {
        const { subscriptionId } = decodedMessage;
        debugInfoHistorySubscriptions.get(subscriptionId)?.();
        debugInfoHistorySubscriptions.delete(subscriptionId);
        break;
      }
      case "LSD.ClientSession.DebugInfoResetReq": {
        store.sqliteDbWrapper.debugInfo.slowQueries.clear();
        sendToDevtools(mod_exports5.ClientSession.DebugInfoResetRes.make({ requestId: requestId2, clientId: clientId2, sessionId: sessionId2, liveStoreVersion }));
        break;
      }
      case "LSD.ClientSession.DebugInfoRerunQueryReq": {
        const { queryStr, bindValues, queriedTables } = decodedMessage;
        store.sqliteDbWrapper.cachedSelect(queryStr, bindValues, { queriedTables, skipCache: true });
        sendToDevtools(mod_exports5.ClientSession.DebugInfoRerunQueryRes.make({ requestId: requestId2, clientId: clientId2, sessionId: sessionId2, liveStoreVersion }));
        break;
      }
      case "LSD.ClientSession.ReactivityGraphUnsubscribe": {
        const { subscriptionId } = decodedMessage;
        reactivityGraphSubcriptions.get(subscriptionId)?.();
        reactivityGraphSubcriptions.delete(subscriptionId);
        break;
      }
      case "LSD.ClientSession.LiveQueriesSubscribe": {
        const { subscriptionId } = decodedMessage;
        const send2 = /* @__PURE__ */ __name(() => requestIdleCallback(() => sendToDevtools(mod_exports5.ClientSession.LiveQueriesRes.make({
          liveQueries: [...store.activeQueries].map((q) => ({
            _tag: q._tag,
            id: q.id,
            label: q.label,
            hash: q.def.hash,
            runs: q.runs,
            executionTimes: q.executionTimes.map((_) => Number(_.toString().slice(0, 5))),
            lastestResult: q.results$.previousResult === NOT_REFRESHED_YET ? "SYMBOL_NOT_REFRESHED_YET" : q.results$.previousResult,
            activeSubscriptions: Array.from(q.activeSubscriptions)
          })),
          requestId: nanoid(10),
          liveStoreVersion,
          clientId: clientId2,
          sessionId: sessionId2,
          subscriptionId
        })), { timeout: 500 }), "send");
        send2();
        const throttledSend = throttle3(send2, 20);
        liveQueriesSubscriptions.set(subscriptionId, store.reactivityGraph.subscribeToRefresh(throttledSend));
        break;
      }
      case "LSD.ClientSession.LiveQueriesUnsubscribe": {
        const { subscriptionId } = decodedMessage;
        liveQueriesSubscriptions.get(subscriptionId)?.();
        liveQueriesSubscriptions.delete(subscriptionId);
        break;
      }
      case "LSD.ClientSession.SyncHeadSubscribe": {
        const { subscriptionId } = decodedMessage;
        const send2 = /* @__PURE__ */ __name((syncState) => sendToDevtools(mod_exports5.ClientSession.SyncHeadRes.make({
          local: syncState.localHead,
          upstream: syncState.upstreamHead,
          requestId: nanoid(10),
          clientId: clientId2,
          sessionId: sessionId2,
          liveStoreVersion,
          subscriptionId
        })), "send");
        send2(store.syncProcessor.syncState.pipe(Effect_exports2.runSync));
        syncHeadClientSessionSubscriptions.set(subscriptionId, store.syncProcessor.syncState.changes.pipe(Stream_exports2.tap((syncState) => send2(syncState)), Stream_exports2.runDrain, Effect_exports2.interruptible, Effect_exports2.tapCauseLogPretty, Effect_exports2.runCallback));
        break;
      }
      case "LSD.ClientSession.SyncHeadUnsubscribe": {
        const { subscriptionId } = decodedMessage;
        syncHeadClientSessionSubscriptions.get(subscriptionId)?.();
        syncHeadClientSessionSubscriptions.delete(subscriptionId);
        break;
      }
      case "LSD.ClientSession.Ping": {
        sendToDevtools(mod_exports5.ClientSession.Pong.make({ requestId: requestId2, clientId: clientId2, sessionId: sessionId2, liveStoreVersion }));
        break;
      }
      default: {
        console.warn(`[LSD.ClientSession] Unknown message`, decodedMessage);
      }
    }
  }, "onMessage");
  yield* storeDevtoolsChannel.listen.pipe(
    // Stream.tapLogWithLabel('@livestore/livestore:store:devtools:onMessage'),
    Stream_exports2.flatten(),
    Stream_exports2.tapSync((message) => onMessage(message)),
    Stream_exports2.runDrain,
    Effect_exports2.withSpan("LSD.devtools.onMessage")
  );
}).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports2.withSpan("LSD.devtools.connectStoreToDevtools")), "connectDevtoolsToStore");

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/store/store.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var otel3 = __toESM(require_src(), 1);

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/utils/data-structures.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var ReferenceCountedSet = class {
  static {
    __name(this, "ReferenceCountedSet");
  }
  map;
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add = /* @__PURE__ */ __name((key) => {
    const count7 = this.map.get(key) ?? 0;
    this.map.set(key, count7 + 1);
  }, "add");
  remove = /* @__PURE__ */ __name((key) => {
    const count7 = this.map.get(key) ?? 0;
    if (count7 === 1) {
      this.map.delete(key);
    } else {
      this.map.set(key, count7 - 1);
    }
  }, "remove");
  has = /* @__PURE__ */ __name((key) => {
    return this.map.has(key);
  }, "has");
  get size() {
    return this.map.size;
  }
  *[Symbol.iterator]() {
    for (const key of this.map.keys()) {
      yield key;
    }
  }
};

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/utils/dev.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var downloadBlob = /* @__PURE__ */ __name((data, fileName, mimeType = "application/octet-stream") => {
  const blob3 = data instanceof Blob ? data : new Blob([data], { type: mimeType });
  const url2 = window.URL.createObjectURL(blob3);
  downloadURL(url2, fileName);
  setTimeout(() => window.URL.revokeObjectURL(url2), 1e3);
}, "downloadBlob");
var downloadURL = /* @__PURE__ */ __name((data, fileName) => {
  const a = document.createElement("a");
  a.href = data;
  a.download = fileName;
  document.body.append(a);
  a.style.display = "none";
  a.click();
  a.remove();
}, "downloadURL");
var exposeDebugUtils = /* @__PURE__ */ __name(() => {
  globalThis.__debugLiveStoreUtils = {
    downloadBlob,
    runSync: /* @__PURE__ */ __name((effect4) => Effect_exports2.runSync(effect4), "runSync"),
    runFork: /* @__PURE__ */ __name((effect4) => Effect_exports2.runFork(effect4), "runFork"),
    dumpDb: /* @__PURE__ */ __name((db) => {
      const tables2 = db.select(`SELECT name FROM sqlite_master WHERE type='table'`);
      for (const table7 of tables2) {
        const rows = db.select(`SELECT * FROM ${table7.name}`);
        console.log(`Table: ${table7.name} (${prettyBytes(table7.name.length)}, ${rows.length} rows)`);
        console.table(rows);
      }
    }, "dumpDb")
  };
}, "exposeDebugUtils");

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/store/store.js
if (isDevEnv()) {
  exposeDebugUtils();
}
var Store = class extends Inspectable_exports.Class {
  static {
    __name(this, "Store");
  }
  storeId;
  reactivityGraph;
  sqliteDbWrapper;
  clientSession;
  schema;
  context;
  otel;
  /**
   * Note we're using `Ref<null>` here as we don't care about the value but only about *that* something has changed.
   * This only works in combination with `equal: () => false` which will always trigger a refresh.
   */
  tableRefs;
  /** Tracks whether the store has been shut down */
  isShutdown = false;
  effectContext;
  /** RC-based set to see which queries are currently subscribed to */
  activeQueries;
  // NOTE this is currently exposed for the Devtools databrowser to commit events
  __eventSchema;
  syncProcessor;
  boot;
  // #region constructor
  constructor({ clientSession, schema: schema4, otelOptions, context: context17, batchUpdates, storeId: storeId2, effectContext: effectContext2, params: params2, confirmUnsavedChanges, __runningInDevtools }) {
    super();
    this.storeId = storeId2;
    this.sqliteDbWrapper = new SqliteDbWrapper({ otel: otelOptions, db: clientSession.sqliteDb });
    this.clientSession = clientSession;
    this.schema = schema4;
    this.context = context17;
    this.effectContext = effectContext2;
    const reactivityGraph = makeReactivityGraph();
    const syncSpan = otelOptions.tracer.startSpan("LiveStore:sync", {}, otelOptions.rootSpanContext);
    this.syncProcessor = makeClientSessionSyncProcessor({
      schema: schema4,
      clientSession,
      runtime: effectContext2.runtime,
      materializeEvent: Effect_exports2.fn("client-session-sync-processor:materialize-event")((eventDecoded, { withChangeset, materializerHashLeader }) => (
        // We need to use `Effect.gen` (even though we're using `Effect.fn`) so that we can pass `this` to the function
        Effect_exports2.gen(this, function* () {
          const { eventDef, materializer } = getEventDef(schema4, eventDecoded.name);
          const execArgsArr = getExecStatementsFromMaterializer({
            eventDef,
            materializer,
            dbState: this.sqliteDbWrapper,
            event: { decoded: eventDecoded, encoded: void 0 }
          });
          const materializerHash = isDevEnv() ? Option_exports.some(hashMaterializerResults(execArgsArr)) : Option_exports.none();
          if (materializerHashLeader._tag === "Some" && materializerHash._tag === "Some" && materializerHashLeader.value !== materializerHash.value) {
            return yield* MaterializerHashMismatchError.make({ eventName: eventDecoded.name });
          }
          const span4 = yield* OtelTracer_exports.currentOtelSpan.pipe(Effect_exports2.orDie);
          const otelContext = otel3.trace.setSpan(otel3.context.active(), span4);
          const writeTablesForEvent = /* @__PURE__ */ new Set();
          const exec = /* @__PURE__ */ __name(() => {
            for (const { statementSql, bindValues, writeTables = this.sqliteDbWrapper.getTablesUsed(statementSql) } of execArgsArr) {
              try {
                this.sqliteDbWrapper.cachedExecute(statementSql, bindValues, { otelContext, writeTables });
              } catch (cause3) {
                throw UnexpectedError.make({
                  cause: cause3,
                  note: `Error executing materializer for event "${eventDecoded.name}".
Statement: ${statementSql}
Bind values: ${JSON.stringify(bindValues)}`
                });
              }
              for (const table7 of writeTables) {
                writeTablesForEvent.add(table7);
              }
              this.sqliteDbWrapper.debug.head = eventDecoded.seqNum;
            }
          }, "exec");
          let sessionChangeset = { _tag: "unset" };
          if (withChangeset === true) {
            sessionChangeset = this.sqliteDbWrapper.withChangeset(exec).changeset;
          } else {
            exec();
          }
          return { writeTables: writeTablesForEvent, sessionChangeset, materializerHash };
        })
      )),
      rollback: /* @__PURE__ */ __name((changeset) => {
        this.sqliteDbWrapper.rollback(changeset);
      }, "rollback"),
      refreshTables: /* @__PURE__ */ __name((tables2) => {
        const tablesToUpdate = [];
        for (const tableName of tables2) {
          const tableRef = this.tableRefs[tableName];
          assertNever(tableRef !== void 0, `No table ref found for ${tableName}`);
          tablesToUpdate.push([tableRef, null]);
        }
        reactivityGraph.setRefs(tablesToUpdate);
      }, "refreshTables"),
      span: syncSpan,
      params: {
        leaderPushBatchSize: params2.leaderPushBatchSize,
        simulation: params2.simulation?.clientSessionSyncProcessor
      },
      confirmUnsavedChanges
    });
    this.__eventSchema = LiveStoreEvent_exports.makeEventDefSchemaMemo(schema4);
    this.tableRefs = {};
    this.activeQueries = new ReferenceCountedSet();
    const commitsSpan = otelOptions.tracer.startSpan("LiveStore:commits", {}, otelOptions.rootSpanContext);
    const otelMuationsSpanContext = otel3.trace.setSpan(otel3.context.active(), commitsSpan);
    const queriesSpan = otelOptions.tracer.startSpan("LiveStore:queries", {}, otelOptions.rootSpanContext);
    const otelQueriesSpanContext = otel3.trace.setSpan(otel3.context.active(), queriesSpan);
    this.reactivityGraph = reactivityGraph;
    this.reactivityGraph.context = {
      store: this,
      defRcMap: /* @__PURE__ */ new Map(),
      reactivityGraph: new WeakRef(reactivityGraph),
      otelTracer: otelOptions.tracer,
      rootOtelContext: otelQueriesSpanContext,
      effectsWrapper: batchUpdates
    };
    this.otel = {
      tracer: otelOptions.tracer,
      rootSpanContext: otelOptions.rootSpanContext,
      commitsSpanContext: otelMuationsSpanContext,
      queriesSpanContext: otelQueriesSpanContext
    };
    const allTableNames = new Set(
      // NOTE we're excluding the LiveStore schema and events tables as they are not user-facing
      // unless LiveStore is running in the devtools
      __runningInDevtools ? this.schema.state.sqlite.tables.keys() : Array.from(this.schema.state.sqlite.tables.keys()).filter((_) => !system_tables_exports.isStateSystemTable(_))
    );
    const existingTableRefs = new Map(Array.from(this.reactivityGraph.atoms.values()).filter((_) => _._tag === "ref" && _.label?.startsWith("tableRef:") === true).map((_) => [_.label.slice("tableRef:".length), _]));
    for (const tableName of allTableNames) {
      this.tableRefs[tableName] = existingTableRefs.get(tableName) ?? this.reactivityGraph.makeRef(null, {
        equal: /* @__PURE__ */ __name(() => false, "equal"),
        label: `tableRef:${tableName}`,
        meta: { liveStoreRefType: "table" }
      });
    }
    this.boot = Effect_exports2.gen(this, function* () {
      yield* Effect_exports2.addFinalizer(() => Effect_exports2.sync(() => {
        for (const tableRef of Object.values(this.tableRefs)) {
          for (const superComp of tableRef.super) {
            this.reactivityGraph.removeEdge(superComp, tableRef);
          }
        }
        syncSpan.end();
        commitsSpan.end();
        queriesSpan.end();
      }));
      yield* this.syncProcessor.boot;
    });
  }
  // #endregion constructor
  get sessionId() {
    return this.clientSession.sessionId;
  }
  get clientId() {
    return this.clientSession.clientId;
  }
  checkShutdown = /* @__PURE__ */ __name((operation) => {
    if (this.isShutdown) {
      throw new UnexpectedError({
        cause: `Store has been shut down (while performing "${operation}").`,
        note: `You cannot perform this operation after the store has been shut down.`
      });
    }
  }, "checkShutdown");
  /**
   * Subscribe to the results of a query
   * Returns a function to cancel the subscription.
   *
   * @example
   * ```ts
   * const unsubscribe = store.subscribe(query$, { onUpdate: (result) => console.log(result) })
   * ```
   */
  subscribe = /* @__PURE__ */ __name((query, options4) => {
    this.checkShutdown("subscribe");
    return this.otel.tracer.startActiveSpan(`LiveStore.subscribe`, { attributes: { label: options4?.label, queryLabel: isQueryBuilder(query) ? query.toString() : query.label } }, options4?.otelContext ?? this.otel.queriesSpanContext, (span4) => {
      const otelContext = otel3.trace.setSpan(otel3.context.active(), span4);
      const queryRcRef = isQueryBuilder(query) ? queryDb(query).make(this.reactivityGraph.context) : query._tag === "def" || query._tag === "signal-def" ? query.make(this.reactivityGraph.context) : {
        value: query,
        deref: /* @__PURE__ */ __name(() => {
        }, "deref")
      };
      const query$ = queryRcRef.value;
      const label = `subscribe:${options4?.label}`;
      const effect4 = this.reactivityGraph.makeEffect((get29, _otelContext, debugRefreshReason) => options4.onUpdate(get29(query$.results$, otelContext, debugRefreshReason)), { label });
      if (options4?.stackInfo) {
        query$.activeSubscriptions.add(options4.stackInfo);
      }
      options4?.onSubscribe?.(query$);
      this.activeQueries.add(query$);
      if (options4?.skipInitialRun !== true && !query$.isDestroyed) {
        effect4.doEffect(otelContext, { _tag: "subscribe.initial", label: `subscribe-initial-run:${options4?.label}` });
      }
      const unsubscribe = /* @__PURE__ */ __name(() => {
        try {
          this.reactivityGraph.destroyNode(effect4);
          this.activeQueries.remove(query$);
          if (options4?.stackInfo) {
            query$.activeSubscriptions.delete(options4.stackInfo);
          }
          queryRcRef.deref();
          options4?.onUnsubsubscribe?.();
        } finally {
          span4.end();
        }
      }, "unsubscribe");
      return unsubscribe;
    });
  }, "subscribe");
  subscribeStream = /* @__PURE__ */ __name((query$, options4) => Stream_exports2.asyncPush((emit3) => Effect_exports2.gen(this, function* () {
    const otelSpan = yield* OtelTracer_exports.currentOtelSpan.pipe(Effect_exports2.catchTag("NoSuchElementException", () => Effect_exports2.succeed(void 0)));
    const otelContext = otelSpan ? otel3.trace.setSpan(otel3.context.active(), otelSpan) : otel3.context.active();
    yield* Effect_exports2.acquireRelease(Effect_exports2.sync(() => this.subscribe(query$, {
      onUpdate: /* @__PURE__ */ __name((result) => emit3.single(result), "onUpdate"),
      otelContext,
      label: options4?.label
    })), (unsub) => Effect_exports2.sync(() => unsub()));
  })), "subscribeStream");
  /**
   * Synchronously queries the database without creating a LiveQuery.
   * This is useful for queries that don't need to be reactive.
   *
   * Example: Query builder
   * ```ts
   * const completedTodos = store.query(tables.todo.where({ complete: true }))
   * ```
   *
   * Example: Raw SQL query
   * ```ts
   * const completedTodos = store.query({ query: 'SELECT * FROM todo WHERE complete = 1', bindValues: {} })
   * ```
   */
  query = /* @__PURE__ */ __name((query, options4) => {
    this.checkShutdown("query");
    if (typeof query === "object" && "query" in query && "bindValues" in query) {
      const res = this.sqliteDbWrapper.cachedSelect(query.query, prepareBindValues(query.bindValues, query.query), {
        otelContext: options4?.otelContext
      });
      if (query.schema) {
        return Schema_exports2.decodeSync(query.schema)(res);
      }
      return res;
    } else if (isQueryBuilder(query)) {
      const ast = query[QueryBuilderAstSymbol];
      if (ast._tag === "RowQuery") {
        makeExecBeforeFirstRun({
          table: ast.tableDef,
          id: ast.id,
          explicitDefaultValues: ast.explicitDefaultValues,
          otelContext: options4?.otelContext
        })(this.reactivityGraph.context);
      }
      const sqlRes = query.asSql();
      const schema4 = getResultSchema(query);
      if (sqlRes.bindValues) {
        replaceSessionIdSymbol(sqlRes.bindValues, this.clientSession.sessionId);
      }
      const rawRes = this.sqliteDbWrapper.cachedSelect(sqlRes.query, sqlRes.bindValues, {
        otelContext: options4?.otelContext,
        queriedTables: /* @__PURE__ */ new Set([query[QueryBuilderAstSymbol].tableDef.sqliteDef.name])
      });
      return Schema_exports2.decodeSync(schema4)(rawRes);
    } else if (query._tag === "def") {
      const query$ = query.make(this.reactivityGraph.context);
      const result = this.query(query$.value, options4);
      query$.deref();
      return result;
    } else if (query._tag === "signal-def") {
      const signal$ = query.make(this.reactivityGraph.context);
      return signal$.value.get();
    } else {
      return query.run({ otelContext: options4?.otelContext, debugRefreshReason: options4?.debugRefreshReason });
    }
  }, "query");
  /**
   * Set the value of a signal
   *
   * @example
   * ```ts
   * const count$ = signal(0, { label: 'count$' })
   * store.setSignal(count$, 2)
   * ```
   *
   * @example
   * ```ts
   * const count$ = signal(0, { label: 'count$' })
   * store.setSignal(count$, (prev) => prev + 1)
   * ```
   */
  setSignal = /* @__PURE__ */ __name((signalDef, value6) => {
    this.checkShutdown("setSignal");
    const signalRef = signalDef.make(this.reactivityGraph.context);
    const newValue = typeof value6 === "function" ? value6(signalRef.value.get()) : value6;
    signalRef.value.set(newValue);
    if (signalRef.rc > 1) {
      signalRef.deref();
    }
  }, "setSignal");
  // #region commit
  /**
   * Commit a list of events to the store which will immediately update the local database
   * and sync the events across other clients (similar to a `git commit`).
   *
   * @example
   * ```ts
   * store.commit(events.todoCreated({ id: nanoid(), text: 'Make coffee' }))
   * ```
   *
   * You can call `commit` with multiple events to apply them in a single database transaction.
   *
   * @example
   * ```ts
   * const todoId = nanoid()
   * store.commit(
   *   events.todoCreated({ id: todoId, text: 'Make coffee' }),
   *   events.todoCompleted({ id: todoId }))
   * ```
   *
   * For more advanced transaction scenarios, you can pass a synchronous function to `commit` which will receive a callback
   * to which you can pass multiple events to be committed in the same database transaction.
   * Under the hood this will simply collect all events and apply them in a single database transaction.
   *
   * @example
   * ```ts
   * store.commit((commit) => {
   *   const todoId = nanoid()
   *   if (Math.random() > 0.5) {
   *     commit(events.todoCreated({ id: todoId, text: 'Make coffee' }))
   *   } else {
   *     commit(events.todoCompleted({ id: todoId }))
   *   }
   * })
   * ```
   *
   * When committing a large batch of events, you can also skip the database refresh to improve performance
   * and call `store.manualRefresh()` after all events have been committed.
   *
   * @example
   * ```ts
   * const todos = [
   *   { id: nanoid(), text: 'Make coffee' },
   *   { id: nanoid(), text: 'Buy groceries' },
   *   // ... 1000 more todos
   * ]
   * for (const todo of todos) {
   *   store.commit({ skipRefresh: true }, events.todoCreated({ id: todo.id, text: todo.text }))
   * }
   * store.manualRefresh()
   * ```
   */
  commit = /* @__PURE__ */ __name((firstEventOrTxnFnOrOptions, ...restEvents) => {
    this.checkShutdown("commit");
    const { events: events2, options: options4 } = this.getCommitArgs(firstEventOrTxnFnOrOptions, restEvents);
    Effect_exports2.gen(this, function* () {
      const commitsSpan = otel3.trace.getSpan(this.otel.commitsSpanContext);
      commitsSpan?.addEvent("commit");
      const currentSpan3 = yield* OtelTracer_exports.currentOtelSpan.pipe(Effect_exports2.orDie);
      commitsSpan?.addLink({ context: currentSpan3.spanContext() });
      for (const event of events2) {
        replaceSessionIdSymbol(event.args, this.clientSession.sessionId);
      }
      if (events2.length === 0)
        return;
      const localRuntime = yield* Effect_exports2.runtime();
      const materializeEventsTx = Effect_exports2.try({
        try: /* @__PURE__ */ __name(() => {
          const runMaterializeEvents = /* @__PURE__ */ __name(() => {
            return this.syncProcessor.push(events2).pipe(Runtime_exports.runSync(localRuntime));
          }, "runMaterializeEvents");
          if (events2.length > 1) {
            return this.sqliteDbWrapper.txn(runMaterializeEvents);
          } else {
            return runMaterializeEvents();
          }
        }, "try"),
        catch: /* @__PURE__ */ __name((cause3) => UnexpectedError.make({ cause: cause3 }), "catch")
      });
      const { writeTables } = yield* materializeEventsTx;
      const tablesToUpdate = [];
      for (const tableName of writeTables) {
        const tableRef = this.tableRefs[tableName];
        assertNever(tableRef !== void 0, `No table ref found for ${tableName}`);
        tablesToUpdate.push([tableRef, null]);
      }
      const debugRefreshReason = {
        _tag: "commit",
        events: events2,
        writeTables: Array.from(writeTables)
      };
      const skipRefresh = options4?.skipRefresh ?? false;
      this.reactivityGraph.setRefs(tablesToUpdate, {
        debugRefreshReason,
        skipRefresh,
        otelContext: otel3.trace.setSpan(otel3.context.active(), currentSpan3)
      });
    }).pipe(Effect_exports2.withSpan("LiveStore:commit", {
      root: true,
      attributes: {
        "livestore.eventsCount": events2.length,
        "livestore.eventTags": events2.map((_) => _.name),
        ...options4?.label && { "livestore.commitLabel": options4.label }
      },
      links: [
        // Span link to LiveStore:commits
        OtelTracer_exports.makeSpanLink({ context: otel3.trace.getSpanContext(this.otel.commitsSpanContext) }),
        // User-provided span links
        ...options4?.spanLinks?.map(OtelTracer_exports.makeSpanLink) ?? []
      ]
    }), Effect_exports2.tapErrorCause(Effect_exports2.logError), Effect_exports2.catchAllCause((cause3) => Effect_exports2.fork(this.shutdown(cause3))), Runtime_exports.runSync(this.effectContext.runtime));
  }, "commit");
  // #endregion commit
  /**
   * Returns an async iterable of events.
   *
   * @example
   * ```ts
   * for await (const event of store.events()) {
   *   console.log(event)
   * }
   * ```
   *
   * @example
   * ```ts
   * // Get all events from the beginning of time
   * for await (const event of store.events({ cursor: EventSequenceNumber.ROOT })) {
   *   console.log(event)
   * }
   * ```
   */
  events = /* @__PURE__ */ __name((_options) => {
    this.checkShutdown("events");
    return notYetImplemented(`store.events() is not yet implemented but planned soon`);
  }, "events");
  eventsStream = /* @__PURE__ */ __name((_options) => {
    this.checkShutdown("eventsStream");
    return notYetImplemented(`store.eventsStream() is not yet implemented but planned soon`);
  }, "eventsStream");
  /**
   * This can be used in combination with `skipRefresh` when committing events.
   * We might need a better solution for this. Let's see.
   */
  manualRefresh = /* @__PURE__ */ __name((options4) => {
    this.checkShutdown("manualRefresh");
    const { label } = options4 ?? {};
    this.otel.tracer.startActiveSpan("LiveStore:manualRefresh", { attributes: { "livestore.manualRefreshLabel": label } }, this.otel.commitsSpanContext, (span4) => {
      const otelContext = otel3.trace.setSpan(otel3.context.active(), span4);
      this.reactivityGraph.runDeferredEffects({ otelContext });
      span4.end();
    });
  }, "manualRefresh");
  /**
   * Shuts down the store and closes the client session.
   *
   * This is called automatically when the store was created using the React or Effect API.
   */
  shutdownPromise = /* @__PURE__ */ __name(async (cause3) => {
    this.checkShutdown("shutdownPromise");
    this.isShutdown = true;
    await this.shutdown(cause3 ? Cause_exports.fail(cause3) : void 0).pipe(this.runEffectFork, Fiber_exports.join, Effect_exports2.runPromise);
  }, "shutdownPromise");
  /**
   * Shuts down the store and closes the client session.
   *
   * This is called automatically when the store was created using the React or Effect API.
   */
  shutdown = /* @__PURE__ */ __name((cause3) => {
    this.isShutdown = true;
    return this.clientSession.shutdown(cause3 ? Exit_exports.failCause(cause3) : Exit_exports.succeed(IntentionalShutdownCause.make({ reason: "manual" })));
  }, "shutdown");
  /**
   * Helper methods useful during development
   *
   * @internal
   */
  _dev = {
    downloadDb: /* @__PURE__ */ __name((source = "local") => {
      Effect_exports2.gen(this, function* () {
        const data = source === "local" ? this.sqliteDbWrapper.export() : yield* this.clientSession.leaderThread.export;
        downloadBlob(data, `livestore-${Date.now()}.db`);
      }).pipe(this.runEffectFork);
    }, "downloadDb"),
    downloadEventlogDb: /* @__PURE__ */ __name(() => {
      Effect_exports2.gen(this, function* () {
        const data = yield* this.clientSession.leaderThread.getEventlogData;
        downloadBlob(data, `livestore-eventlog-${Date.now()}.db`);
      }).pipe(this.runEffectFork);
    }, "downloadEventlogDb"),
    hardReset: /* @__PURE__ */ __name((mode = "all-data") => {
      Effect_exports2.gen(this, function* () {
        const clientId2 = this.clientSession.clientId;
        yield* this.clientSession.leaderThread.sendDevtoolsMessage(mod_exports5.Leader.ResetAllData.Request.make({ liveStoreVersion, mode, requestId: nanoid(), clientId: clientId2 }));
      }).pipe(this.runEffectFork);
    }, "hardReset"),
    overrideNetworkStatus: /* @__PURE__ */ __name((status3) => {
      const clientId2 = this.clientSession.clientId;
      this.clientSession.leaderThread.sendDevtoolsMessage(mod_exports5.Leader.SetSyncLatch.Request.make({
        clientId: clientId2,
        closeLatch: status3 === "offline",
        liveStoreVersion,
        requestId: nanoid()
      })).pipe(this.runEffectFork);
    }, "overrideNetworkStatus"),
    syncStates: /* @__PURE__ */ __name(() => {
      Effect_exports2.gen(this, function* () {
        const session = yield* this.syncProcessor.syncState;
        console.log("Session sync state:", session.toJSON());
        const leader = yield* this.clientSession.leaderThread.getSyncState;
        console.log("Leader sync state:", leader.toJSON());
      }).pipe(this.runEffectFork);
    }, "syncStates"),
    version: liveStoreVersion,
    otel: {
      rootSpanContext: /* @__PURE__ */ __name(() => otel3.trace.getSpan(this.otel.rootSpanContext)?.spanContext(), "rootSpanContext")
    }
  };
  // NOTE This is needed because when booting a Store via Effect it seems to call `toJSON` in the error path
  toJSON = /* @__PURE__ */ __name(() => ({
    _tag: "livestore.Store",
    reactivityGraph: this.reactivityGraph.getSnapshot({ includeResults: true })
  }), "toJSON");
  runEffectFork = /* @__PURE__ */ __name((effect4) => effect4.pipe(Effect_exports2.forkIn(this.effectContext.lifetimeScope), Effect_exports2.tapCauseLogPretty, Runtime_exports.runFork(this.effectContext.runtime)), "runEffectFork");
  getCommitArgs = /* @__PURE__ */ __name((firstEventOrTxnFnOrOptions, restEvents) => {
    let events2;
    let options4;
    if (typeof firstEventOrTxnFnOrOptions === "function") {
      events2 = firstEventOrTxnFnOrOptions((arg) => events2.push(arg));
    } else if (firstEventOrTxnFnOrOptions?.label !== void 0 || firstEventOrTxnFnOrOptions?.skipRefresh !== void 0 || firstEventOrTxnFnOrOptions?.otelContext !== void 0 || firstEventOrTxnFnOrOptions?.spanLinks !== void 0) {
      options4 = firstEventOrTxnFnOrOptions;
      events2 = restEvents;
    } else if (firstEventOrTxnFnOrOptions === void 0) {
      events2 = [];
    } else {
      events2 = [firstEventOrTxnFnOrOptions, ...restEvents];
    }
    return { events: events2, options: options4 };
  }, "getCommitArgs");
};

// node_modules/.pnpm/@livestore+livestore@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_941780767bf1436505dfba8c7da355c3/node_modules/@livestore/livestore/dist/store/create-store.js
var DEFAULT_PARAMS = {
  leaderPushBatchSize: 100
};
var LiveStoreContextRunning = class _LiveStoreContextRunning extends Context_exports.Tag("@livestore/livestore/effect/LiveStoreContextRunning")() {
  static {
    __name(this, "LiveStoreContextRunning");
  }
  static fromDeferred = Effect_exports2.gen(function* () {
    const deferred = yield* DeferredStoreContext;
    const ctx = yield* deferred;
    return Layer_exports.succeed(_LiveStoreContextRunning, ctx);
  }).pipe(Layer_exports.unwrapScoped);
};
var DeferredStoreContext = class extends Context_exports.Tag("@livestore/livestore/effect/DeferredStoreContext")() {
  static {
    __name(this, "DeferredStoreContext");
  }
};
var createStore = /* @__PURE__ */ __name(({ schema: schema4, adapter: adapter5, storeId: storeId2, context: context17 = {}, boot, batchUpdates, disableDevtools, onBootStatus, shutdownDeferred, params: params2, debug: debug4, confirmUnsavedChanges = true, syncPayload }) => Effect_exports2.gen(function* () {
  const lifetimeScope = yield* Scope_exports.make();
  yield* validateStoreId(storeId2);
  yield* Effect_exports2.addFinalizer((_) => Scope_exports.close(lifetimeScope, _));
  const debugInstanceId = debug4?.instanceId ?? nanoid(10);
  return yield* Effect_exports2.gen(function* () {
    const span4 = yield* OtelTracer_exports.currentOtelSpan.pipe(Effect_exports2.orDie);
    const otelRootSpanContext = otel4.trace.setSpan(otel4.context.active(), span4);
    const otelTracer = yield* OtelTracer_exports.OtelTracer;
    const bootStatusQueue = yield* Queue_exports.unbounded().pipe(Effect_exports2.acquireRelease(Queue_exports.shutdown));
    yield* Queue_exports.take(bootStatusQueue).pipe(Effect_exports2.tapSync((status3) => onBootStatus?.(status3)), Effect_exports2.tap((status3) => status3.stage === "done" ? Queue_exports.shutdown(bootStatusQueue) : Effect_exports2.void), Effect_exports2.forever, Effect_exports2.tapCauseLogPretty, Effect_exports2.forkScoped);
    const storeDeferred = yield* Deferred_exports.make();
    const connectDevtoolsToStore_ = /* @__PURE__ */ __name((storeDevtoolsChannel) => Effect_exports2.gen(function* () {
      const store2 = yield* storeDeferred;
      yield* connectDevtoolsToStore({ storeDevtoolsChannel, store: store2 });
    }), "connectDevtoolsToStore_");
    const runtime8 = yield* Effect_exports2.runtime();
    const shutdown9 = /* @__PURE__ */ __name((exit5) => Effect_exports2.gen(function* () {
      yield* Scope_exports.close(lifetimeScope, exit5).pipe(Effect_exports2.logWarnIfTakesLongerThan({ label: "@livestore/livestore:shutdown", duration: 500 }), Effect_exports2.timeout(1e3), Effect_exports2.catchTag("TimeoutException", () => Effect_exports2.logError("@livestore/livestore:shutdown: Timed out after 1 second")));
      if (shutdownDeferred) {
        yield* Deferred_exports.done(shutdownDeferred, exit5);
      }
      yield* Effect_exports2.logDebug("LiveStore shutdown complete");
    }).pipe(
      Effect_exports2.withSpan("@livestore/livestore:shutdown"),
      Effect_exports2.provide(runtime8),
      Effect_exports2.tapCauseLogPretty,
      // Given that the shutdown flow might also interrupt the effect that is calling the shutdown,
      // we want to detach the shutdown effect so it's not interrupted by itself
      Effect_exports2.runFork,
      Fiber_exports.join
    ), "shutdown");
    const clientSession = yield* adapter5({
      schema: schema4,
      storeId: storeId2,
      devtoolsEnabled: getDevtoolsEnabled(disableDevtools),
      bootStatusQueue,
      shutdown: shutdown9,
      connectDevtoolsToStore: connectDevtoolsToStore_,
      debugInstanceId,
      syncPayload
    }).pipe(Effect_exports2.withPerformanceMeasure("livestore:makeAdapter"), Effect_exports2.withSpan("createStore:makeAdapter"));
    if (LS_DEV && clientSession.leaderThread.initialState.migrationsReport.migrations.length > 0) {
      yield* Effect_exports2.logDebug("[@livestore/livestore:createStore] migrationsReport", ...clientSession.leaderThread.initialState.migrationsReport.migrations.map((m) => m.hashes.actual === void 0 ? `Table '${m.tableName}' doesn't exist yet. Creating table...` : `Schema hash mismatch for table '${m.tableName}' (DB: ${m.hashes.actual}, expected: ${m.hashes.expected}), migrating table...`));
    }
    const store = new Store({
      clientSession,
      schema: schema4,
      context: context17,
      otelOptions: { tracer: otelTracer, rootSpanContext: otelRootSpanContext },
      effectContext: { lifetimeScope, runtime: runtime8 },
      // TODO find a better way to detect if we're running LiveStore in the LiveStore devtools
      // But for now this is a good enough approximation with little downsides
      __runningInDevtools: getDevtoolsEnabled(disableDevtools) === false,
      confirmUnsavedChanges,
      // NOTE during boot we're not yet executing events in a batched context
      // but only set the provided `batchUpdates` function after boot
      batchUpdates: /* @__PURE__ */ __name((run10) => run10(), "batchUpdates"),
      storeId: storeId2,
      params: {
        leaderPushBatchSize: params2?.leaderPushBatchSize ?? DEFAULT_PARAMS.leaderPushBatchSize,
        simulation: params2?.simulation
      }
    });
    yield* store.boot;
    if (boot !== void 0) {
      yield* Effect_exports2.tryAll(() => boot(store, { migrationsReport: clientSession.leaderThread.initialState.migrationsReport, parentSpan: span4 })).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports2.provide(Layer_exports.succeed(LiveStoreContextRunning, { stage: "running", store })), Effect_exports2.withSpan("createStore:boot"));
    }
    yield* Effect_exports2.yieldNow();
    if (batchUpdates !== void 0) {
      store.reactivityGraph.context.effectsWrapper = batchUpdates;
    }
    yield* Deferred_exports.succeed(storeDeferred, store);
    return store;
  }).pipe(Effect_exports2.withSpan("createStore", { attributes: { debugInstanceId, storeId: storeId2 } }), Effect_exports2.annotateLogs({ debugInstanceId, storeId: storeId2 }), LS_DEV ? TaskTracing_exports.withAsyncTaggingTracing((name) => console.createTask(name)) : identity, Scope_exports.extend(lifetimeScope));
}), "createStore");
var validateStoreId = /* @__PURE__ */ __name((storeId2) => Effect_exports2.gen(function* () {
  const validChars = /^[a-zA-Z0-9_-]+$/;
  if (!validChars.test(storeId2)) {
    return yield* UnexpectedError.make({
      cause: `Invalid storeId: ${storeId2}. Only alphanumeric characters, underscores, and hyphens are allowed.`,
      payload: { storeId: storeId2 }
    });
  }
}), "validateStoreId");
var getDevtoolsEnabled = /* @__PURE__ */ __name((disableDevtools) => {
  if (disableDevtools === true || disableDevtools === false) {
    return !disableDevtools;
  }
  if (isDevEnv() === true) {
    return true;
  }
  return false;
}, "getDevtoolsEnabled");

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/cf/mod.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/in-memory-vfs.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+wa-sqlite@1.0.8-dev.4/node_modules/@livestore/wa-sqlite/src/examples/MemoryVFS.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+wa-sqlite@1.0.8-dev.4/node_modules/@livestore/wa-sqlite/src/FacadeVFS.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+wa-sqlite@1.0.8-dev.4/node_modules/@livestore/wa-sqlite/src/VFS.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+wa-sqlite@1.0.8-dev.4/node_modules/@livestore/wa-sqlite/src/sqlite-constants.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SQLITE_OK = 0;
var SQLITE_ERROR = 1;
var SQLITE_IOERR = 10;
var SQLITE_NOTFOUND = 12;
var SQLITE_CANTOPEN = 14;
var SQLITE_MISUSE = 21;
var SQLITE_RANGE = 25;
var SQLITE_NOTICE = 27;
var SQLITE_ROW = 100;
var SQLITE_DONE = 101;
var SQLITE_IOERR_SHORT_READ = 522;
var SQLITE_IOERR_WRITE = 778;
var SQLITE_OPEN_READWRITE = 2;
var SQLITE_OPEN_CREATE = 4;
var SQLITE_OPEN_DELETEONCLOSE = 8;
var SQLITE_OPEN_URI = 64;
var SQLITE_OPEN_MAIN_DB = 256;
var SQLITE_OPEN_TEMP_DB = 512;
var SQLITE_OPEN_TRANSIENT_DB = 1024;
var SQLITE_OPEN_MAIN_JOURNAL = 2048;
var SQLITE_OPEN_TEMP_JOURNAL = 4096;
var SQLITE_OPEN_SUBJOURNAL = 8192;
var SQLITE_OPEN_SUPER_JOURNAL = 16384;
var SQLITE_OPEN_WAL = 524288;
var SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN = 2048;
var SQLITE_INTEGER = 1;
var SQLITE_FLOAT = 2;
var SQLITE_TEXT = 3;
var SQLITE_BLOB = 4;
var SQLITE_NULL = 5;

// node_modules/.pnpm/@livestore+wa-sqlite@1.0.8-dev.4/node_modules/@livestore/wa-sqlite/src/VFS.js
var DEFAULT_SECTOR_SIZE = 512;
var Base3 = class {
  static {
    __name(this, "Base");
  }
  name;
  mxPathname = 64;
  _module;
  /**
   * @param {string} name 
   * @param {object} module 
   */
  constructor(name, module) {
    this.name = name;
    this._module = module;
  }
  /**
   * @returns {void|Promise<void>} 
   */
  close() {
  }
  /**
   * @returns {boolean|Promise<boolean>}
   */
  isReady() {
    return true;
  }
  /**
   * Overload in subclasses to indicate which methods are asynchronous.
   * @param {string} methodName 
   * @returns {boolean}
   */
  hasAsyncMethod(methodName) {
    return false;
  }
  /**
   * @param {number} pVfs 
   * @param {number} zName 
   * @param {number} pFile 
   * @param {number} flags 
   * @param {number} pOutFlags 
   * @returns {number|Promise<number>}
   */
  xOpen(pVfs, zName, pFile, flags, pOutFlags) {
    return SQLITE_CANTOPEN;
  }
  /**
   * @param {number} pVfs 
   * @param {number} zName 
   * @param {number} syncDir 
   * @returns {number|Promise<number>}
   */
  xDelete(pVfs, zName, syncDir) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pVfs 
   * @param {number} zName 
   * @param {number} flags 
   * @param {number} pResOut 
   * @returns {number|Promise<number>}
   */
  xAccess(pVfs, zName, flags, pResOut) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pVfs 
   * @param {number} zName 
   * @param {number} nOut 
   * @param {number} zOut 
   * @returns {number|Promise<number>}
   */
  xFullPathname(pVfs, zName, nOut, zOut) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pVfs 
   * @param {number} nBuf 
   * @param {number} zBuf 
   * @returns {number|Promise<number>}
   */
  xGetLastError(pVfs, nBuf, zBuf) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @returns {number|Promise<number>}
   */
  xClose(pFile) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} pData 
   * @param {number} iAmt 
   * @param {number} iOffsetLo 
   * @param {number} iOffsetHi 
   * @returns {number|Promise<number>}
   */
  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} pData 
   * @param {number} iAmt 
   * @param {number} iOffsetLo 
   * @param {number} iOffsetHi 
   * @returns {number|Promise<number>}
   */
  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} sizeLo 
   * @param {number} sizeHi 
   * @returns {number|Promise<number>}
   */
  xTruncate(pFile, sizeLo, sizeHi) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} flags 
   * @returns {number|Promise<number>}
   */
  xSync(pFile, flags) {
    return SQLITE_OK;
  }
  /**
   * 
   * @param {number} pFile 
   * @param {number} pSize 
   * @returns {number|Promise<number>}
   */
  xFileSize(pFile, pSize) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} lockType 
   * @returns {number|Promise<number>}
   */
  xLock(pFile, lockType) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} lockType 
   * @returns {number|Promise<number>}
   */
  xUnlock(pFile, lockType) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} pResOut 
   * @returns {number|Promise<number>}
   */
  xCheckReservedLock(pFile, pResOut) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} op 
   * @param {number} pArg 
   * @returns {number|Promise<number>}
   */
  xFileControl(pFile, op, pArg) {
    return SQLITE_NOTFOUND;
  }
  /**
   * @param {number} pFile 
   * @returns {number|Promise<number>}
   */
  xSectorSize(pFile) {
    return DEFAULT_SECTOR_SIZE;
  }
  /**
   * @param {number} pFile 
   * @returns {number|Promise<number>}
   */
  xDeviceCharacteristics(pFile) {
    return 0;
  }
};
var FILE_TYPE_MASK = [
  SQLITE_OPEN_MAIN_DB,
  SQLITE_OPEN_MAIN_JOURNAL,
  SQLITE_OPEN_TEMP_DB,
  SQLITE_OPEN_TEMP_JOURNAL,
  SQLITE_OPEN_TRANSIENT_DB,
  SQLITE_OPEN_SUBJOURNAL,
  SQLITE_OPEN_SUPER_JOURNAL,
  SQLITE_OPEN_WAL
].reduce((mask, element2) => mask | element2);

// node_modules/.pnpm/@livestore+wa-sqlite@1.0.8-dev.4/node_modules/@livestore/wa-sqlite/src/FacadeVFS.js
var AsyncFunction = Object.getPrototypeOf(async function() {
}).constructor;
var FacadeVFS = class extends Base3 {
  static {
    __name(this, "FacadeVFS");
  }
  /**
   * @param {string} name 
   * @param {object} module 
   */
  constructor(name, module) {
    super(name, module);
  }
  /**
   * Override to indicate which methods are asynchronous.
   * @param {string} methodName 
   * @returns {boolean}
   */
  hasAsyncMethod(methodName) {
    const jMethodName = `j${methodName.slice(1)}`;
    return this[jMethodName] instanceof AsyncFunction;
  }
  /**
   * Return the filename for a file id for use by mixins.
   * @param {number} pFile 
   * @returns {string}
   */
  getFilename(pFile) {
    throw new Error("unimplemented");
  }
  /**
   * @param {string?} filename 
   * @param {number} pFile 
   * @param {number} flags 
   * @param {DataView} pOutFlags 
   * @returns {number|Promise<number>}
   */
  jOpen(filename, pFile, flags, pOutFlags) {
    return SQLITE_CANTOPEN;
  }
  /**
   * @param {string} filename 
   * @param {number} syncDir 
   * @returns {number|Promise<number>}
   */
  jDelete(filename, syncDir) {
    return SQLITE_OK;
  }
  /**
   * @param {string} filename 
   * @param {number} flags 
   * @param {DataView} pResOut 
   * @returns {number|Promise<number>}
   */
  jAccess(filename, flags, pResOut) {
    return SQLITE_OK;
  }
  /**
   * @param {string} filename 
   * @param {Uint8Array} zOut 
   * @returns {number|Promise<number>}
   */
  jFullPathname(filename, zOut) {
    const { read: read4, written } = new TextEncoder().encodeInto(filename, zOut);
    if (read4 < filename.length) return SQLITE_IOERR;
    if (written >= zOut.length) return SQLITE_IOERR;
    zOut[written] = 0;
    return SQLITE_OK;
  }
  /**
   * @param {Uint8Array} zBuf 
   * @returns {number|Promise<number>}
   */
  jGetLastError(zBuf) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @returns {number|Promise<number>}
   */
  jClose(pFile) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {Uint8Array} pData 
   * @param {number} iOffset 
   * @returns {number|Promise<number>}
   */
  jRead(pFile, pData, iOffset) {
    pData.fill(0);
    return SQLITE_IOERR_SHORT_READ;
  }
  /**
   * @param {number} pFile 
   * @param {Uint8Array} pData 
   * @param {number} iOffset 
   * @returns {number|Promise<number>}
   */
  jWrite(pFile, pData, iOffset) {
    return SQLITE_IOERR_WRITE;
  }
  /**
   * @param {number} pFile 
   * @param {number} size 
   * @returns {number|Promise<number>}
   */
  jTruncate(pFile, size22) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} flags 
   * @returns {number|Promise<number>}
   */
  jSync(pFile, flags) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {DataView} pSize
   * @returns {number|Promise<number>}
   */
  jFileSize(pFile, pSize) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} lockType 
   * @returns {number|Promise<number>}
   */
  jLock(pFile, lockType) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {number} lockType 
   * @returns {number|Promise<number>}
   */
  jUnlock(pFile, lockType) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile 
   * @param {DataView} pResOut 
   * @returns {number|Promise<number>}
   */
  jCheckReservedLock(pFile, pResOut) {
    pResOut.setInt32(0, 0, true);
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile
   * @param {number} op
   * @param {DataView} pArg
   * @returns {number|Promise<number>}
   */
  jFileControl(pFile, op, pArg) {
    return SQLITE_NOTFOUND;
  }
  /**
   * @param {number} pFile
   * @returns {number|Promise<number>}
   */
  jSectorSize(pFile) {
    return super.xSectorSize(pFile);
  }
  /**
   * @param {number} pFile
   * @returns {number|Promise<number>}
   */
  jDeviceCharacteristics(pFile) {
    return 0;
  }
  /**
   * @param {number} pVfs 
   * @param {number} zName 
   * @param {number} pFile 
   * @param {number} flags 
   * @param {number} pOutFlags 
   * @returns {number|Promise<number>}
   */
  xOpen(pVfs, zName, pFile, flags, pOutFlags) {
    const filename = this.#decodeFilename(zName, flags);
    const pOutFlagsView = this.#makeTypedDataView("Int32", pOutFlags);
    this["log"]?.("jOpen", filename, pFile, "0x" + flags.toString(16));
    return this.jOpen(filename, pFile, flags, pOutFlagsView);
  }
  /**
   * @param {number} pVfs 
   * @param {number} zName 
   * @param {number} syncDir 
   * @returns {number|Promise<number>}
   */
  xDelete(pVfs, zName, syncDir) {
    const filename = this._module.UTF8ToString(zName);
    this["log"]?.("jDelete", filename, syncDir);
    return this.jDelete(filename, syncDir);
  }
  /**
   * @param {number} pVfs 
   * @param {number} zName 
   * @param {number} flags 
   * @param {number} pResOut 
   * @returns {number|Promise<number>}
   */
  xAccess(pVfs, zName, flags, pResOut) {
    const filename = this._module.UTF8ToString(zName);
    const pResOutView = this.#makeTypedDataView("Int32", pResOut);
    this["log"]?.("jAccess", filename, flags);
    return this.jAccess(filename, flags, pResOutView);
  }
  /**
   * @param {number} pVfs 
   * @param {number} zName 
   * @param {number} nOut 
   * @param {number} zOut 
   * @returns {number|Promise<number>}
   */
  xFullPathname(pVfs, zName, nOut, zOut) {
    const filename = this._module.UTF8ToString(zName);
    const zOutArray = this._module.HEAPU8.subarray(zOut, zOut + nOut);
    this["log"]?.("jFullPathname", filename, nOut);
    return this.jFullPathname(filename, zOutArray);
  }
  /**
   * @param {number} pVfs 
   * @param {number} nBuf 
   * @param {number} zBuf 
   * @returns {number|Promise<number>}
   */
  xGetLastError(pVfs, nBuf, zBuf) {
    const zBufArray = this._module.HEAPU8.subarray(zBuf, zBuf + nBuf);
    this["log"]?.("jGetLastError", nBuf);
    return this.jGetLastError(zBufArray);
  }
  /**
   * @param {number} pFile 
   * @returns {number|Promise<number>}
   */
  xClose(pFile) {
    this["log"]?.("jClose", pFile);
    return this.jClose(pFile);
  }
  /**
   * @param {number} pFile 
   * @param {number} pData 
   * @param {number} iAmt 
   * @param {number} iOffsetLo 
   * @param {number} iOffsetHi 
   * @returns {number|Promise<number>}
   */
  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
    const pDataArray = this.#makeDataArray(pData, iAmt);
    const iOffset = delegalize(iOffsetLo, iOffsetHi);
    this["log"]?.("jRead", pFile, iAmt, iOffset);
    return this.jRead(pFile, pDataArray, iOffset);
  }
  /**
   * @param {number} pFile 
   * @param {number} pData 
   * @param {number} iAmt 
   * @param {number} iOffsetLo 
   * @param {number} iOffsetHi 
   * @returns {number|Promise<number>}
   */
  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
    const pDataArray = this.#makeDataArray(pData, iAmt);
    const iOffset = delegalize(iOffsetLo, iOffsetHi);
    this["log"]?.("jWrite", pFile, pDataArray, iOffset);
    return this.jWrite(pFile, pDataArray, iOffset);
  }
  /**
   * @param {number} pFile 
   * @param {number} sizeLo 
   * @param {number} sizeHi 
   * @returns {number|Promise<number>}
   */
  xTruncate(pFile, sizeLo, sizeHi) {
    const size22 = delegalize(sizeLo, sizeHi);
    this["log"]?.("jTruncate", pFile, size22);
    return this.jTruncate(pFile, size22);
  }
  /**
   * @param {number} pFile 
   * @param {number} flags 
   * @returns {number|Promise<number>}
   */
  xSync(pFile, flags) {
    this["log"]?.("jSync", pFile, flags);
    return this.jSync(pFile, flags);
  }
  /**
   * 
   * @param {number} pFile 
   * @param {number} pSize 
   * @returns {number|Promise<number>}
   */
  xFileSize(pFile, pSize) {
    const pSizeView = this.#makeTypedDataView("BigInt64", pSize);
    this["log"]?.("jFileSize", pFile);
    return this.jFileSize(pFile, pSizeView);
  }
  /**
   * @param {number} pFile 
   * @param {number} lockType 
   * @returns {number|Promise<number>}
   */
  xLock(pFile, lockType) {
    this["log"]?.("jLock", pFile, lockType);
    return this.jLock(pFile, lockType);
  }
  /**
   * @param {number} pFile 
   * @param {number} lockType 
   * @returns {number|Promise<number>}
   */
  xUnlock(pFile, lockType) {
    this["log"]?.("jUnlock", pFile, lockType);
    return this.jUnlock(pFile, lockType);
  }
  /**
   * @param {number} pFile 
   * @param {number} pResOut 
   * @returns {number|Promise<number>}
   */
  xCheckReservedLock(pFile, pResOut) {
    const pResOutView = this.#makeTypedDataView("Int32", pResOut);
    this["log"]?.("jCheckReservedLock", pFile);
    return this.jCheckReservedLock(pFile, pResOutView);
  }
  /**
   * @param {number} pFile 
   * @param {number} op 
   * @param {number} pArg 
   * @returns {number|Promise<number>}
   */
  xFileControl(pFile, op, pArg) {
    const pArgView = new DataView(
      this._module.HEAPU8.buffer,
      this._module.HEAPU8.byteOffset + pArg
    );
    this["log"]?.("jFileControl", pFile, op, pArgView);
    return this.jFileControl(pFile, op, pArgView);
  }
  /**
   * @param {number} pFile 
   * @returns {number|Promise<number>}
   */
  xSectorSize(pFile) {
    this["log"]?.("jSectorSize", pFile);
    return this.jSectorSize(pFile);
  }
  /**
   * @param {number} pFile 
   * @returns {number|Promise<number>}
   */
  xDeviceCharacteristics(pFile) {
    this["log"]?.("jDeviceCharacteristics", pFile);
    return this.jDeviceCharacteristics(pFile);
  }
  /**
   * Wrapped DataView for pointer arguments.
   * Pointers to a single value are passed using a DataView-like class.
   * This wrapper class prevents use of incorrect type or endianness, and
   * reacquires the underlying buffer when the WebAssembly memory is resized.
   * @param {'Int32'|'BigInt64'} type 
   * @param {number} byteOffset 
   * @returns {DataView}
   */
  #makeTypedDataView(type3, byteOffset) {
    return new DataViewProxy(this._module, byteOffset, type3);
  }
  /**
   * Wrapped Uint8Array for buffer arguments.
   * Memory blocks are passed as a Uint8Array-like class. This wrapper
   * class reacquires the underlying buffer when the WebAssembly memory
   * is resized.
   * @param {number} byteOffset 
   * @param {number} byteLength 
   * @returns {Uint8Array}
   */
  #makeDataArray(byteOffset, byteLength) {
    return new Uint8ArrayProxy(this._module, byteOffset, byteLength);
  }
  #decodeFilename(zName, flags) {
    if (flags & SQLITE_OPEN_URI) {
      let pName = zName;
      let state2 = 1;
      const charCodes = [];
      while (state2) {
        const charCode = this._module.HEAPU8[pName++];
        if (charCode) {
          charCodes.push(charCode);
        } else {
          if (!this._module.HEAPU8[pName]) state2 = null;
          switch (state2) {
            case 1:
              charCodes.push("?".charCodeAt(0));
              state2 = 2;
              break;
            case 2:
              charCodes.push("=".charCodeAt(0));
              state2 = 3;
              break;
            case 3:
              charCodes.push("&".charCodeAt(0));
              state2 = 2;
              break;
          }
        }
      }
      return new TextDecoder().decode(new Uint8Array(charCodes));
    }
    return zName ? this._module.UTF8ToString(zName) : null;
  }
};
function delegalize(lo32, hi32) {
  return hi32 * 4294967296 + lo32 + (lo32 < 0 ? 2 ** 32 : 0);
}
__name(delegalize, "delegalize");
var Uint8ArrayProxy = class {
  static {
    __name(this, "Uint8ArrayProxy");
  }
  #module;
  #_array = new Uint8Array();
  get #array() {
    if (this.#_array.buffer.byteLength === 0) {
      this.#_array = this.#module.HEAPU8.subarray(
        this.byteOffset,
        this.byteOffset + this.byteLength
      );
    }
    return this.#_array;
  }
  /**
   * @param {*} module
   * @param {number} byteOffset 
   * @param {number} byteLength 
   */
  constructor(module, byteOffset, byteLength) {
    this.#module = module;
    this.byteOffset = byteOffset;
    this.length = this.byteLength = byteLength;
  }
  get buffer() {
    return this.#array.buffer;
  }
  at(index2) {
    return this.#array.at(index2);
  }
  copyWithin(target3, start3, end6) {
    this.#array.copyWithin(target3, start3, end6);
  }
  entries() {
    return this.#array.entries();
  }
  every(predicate) {
    return this.#array.every(predicate);
  }
  fill(value6, start3, end6) {
    this.#array.fill(value6, start3, end6);
  }
  filter(predicate) {
    return this.#array.filter(predicate);
  }
  find(predicate) {
    return this.#array.find(predicate);
  }
  findIndex(predicate) {
    return this.#array.findIndex(predicate);
  }
  findLast(predicate) {
    return this.#array.findLast(predicate);
  }
  findLastIndex(predicate) {
    return this.#array.findLastIndex(predicate);
  }
  forEach(callback) {
    this.#array.forEach(callback);
  }
  includes(value6, start3) {
    return this.#array.includes(value6, start3);
  }
  indexOf(value6, start3) {
    return this.#array.indexOf(value6, start3);
  }
  join(separator) {
    return this.#array.join(separator);
  }
  keys() {
    return this.#array.keys();
  }
  lastIndexOf(value6, start3) {
    return this.#array.lastIndexOf(value6, start3);
  }
  map(callback) {
    return this.#array.map(callback);
  }
  reduce(callback, initialValue) {
    return this.#array.reduce(callback, initialValue);
  }
  reduceRight(callback, initialValue) {
    return this.#array.reduceRight(callback, initialValue);
  }
  reverse() {
    this.#array.reverse();
  }
  set(array7, offset) {
    this.#array.set(array7, offset);
  }
  slice(start3, end6) {
    return this.#array.slice(start3, end6);
  }
  some(predicate) {
    return this.#array.some(predicate);
  }
  sort(compareFn) {
    this.#array.sort(compareFn);
  }
  subarray(begin, end6) {
    return this.#array.subarray(begin, end6);
  }
  toLocaleString(locales, options4) {
    return this.#array.toLocaleString(locales, options4);
  }
  toReversed() {
    return this.#array.toReversed();
  }
  toSorted(compareFn) {
    return this.#array.toSorted(compareFn);
  }
  toString() {
    return this.#array.toString();
  }
  values() {
    return this.#array.values();
  }
  with(index2, value6) {
    return this.#array.with(index2, value6);
  }
  [Symbol.iterator]() {
    return this.#array[Symbol.iterator]();
  }
};
var DataViewProxy = class {
  static {
    __name(this, "DataViewProxy");
  }
  #module;
  #type;
  #_view = new DataView(new ArrayBuffer(0));
  get #view() {
    if (this.#_view.buffer.byteLength === 0) {
      this.#_view = new DataView(
        this.#module.HEAPU8.buffer,
        this.#module.HEAPU8.byteOffset + this.byteOffset
      );
    }
    return this.#_view;
  }
  /**
   * @param {*} module
   * @param {number} byteOffset 
   * @param {'Int32'|'BigInt64'} type
   */
  constructor(module, byteOffset, type3) {
    this.#module = module;
    this.byteOffset = byteOffset;
    this.#type = type3;
  }
  get buffer() {
    return this.#view.buffer;
  }
  get byteLength() {
    return this.#type === "Int32" ? 4 : 8;
  }
  getInt32(byteOffset, littleEndian) {
    if (this.#type !== "Int32") {
      throw new Error("invalid type");
    }
    if (!littleEndian) throw new Error("must be little endian");
    return this.#view.getInt32(byteOffset, littleEndian);
  }
  setInt32(byteOffset, value6, littleEndian) {
    if (this.#type !== "Int32") {
      throw new Error("invalid type");
    }
    if (!littleEndian) throw new Error("must be little endian");
    this.#view.setInt32(byteOffset, value6, littleEndian);
  }
  getBigInt64(byteOffset, littleEndian) {
    if (this.#type !== "BigInt64") {
      throw new Error("invalid type");
    }
    if (!littleEndian) throw new Error("must be little endian");
    return this.#view.getBigInt64(byteOffset, littleEndian);
  }
  setBigInt64(byteOffset, value6, littleEndian) {
    if (this.#type !== "BigInt64") {
      throw new Error("invalid type");
    }
    if (!littleEndian) throw new Error("must be little endian");
    this.#view.setBigInt64(byteOffset, value6, littleEndian);
  }
};

// node_modules/.pnpm/@livestore+wa-sqlite@1.0.8-dev.4/node_modules/@livestore/wa-sqlite/src/examples/MemoryVFS.js
var MemoryVFS = class _MemoryVFS extends FacadeVFS {
  static {
    __name(this, "MemoryVFS");
  }
  // Map of existing files, keyed by filename.
  mapNameToFile = /* @__PURE__ */ new Map();
  // Map of open files, keyed by id (sqlite3_file pointer).
  mapIdToFile = /* @__PURE__ */ new Map();
  static async create(name, module) {
    const vfs = new _MemoryVFS(name, module);
    await vfs.isReady();
    return vfs;
  }
  constructor(name, module) {
    super(name, module);
  }
  close() {
    for (const fileId of this.mapIdToFile.keys()) {
      this.jClose(fileId);
    }
  }
  /**
   * @param {string?} filename 
   * @param {number} fileId 
   * @param {number} flags 
   * @param {DataView} pOutFlags 
   * @returns {number|Promise<number>}
   */
  jOpen(filename, fileId, flags, pOutFlags) {
    const url2 = new URL(filename || Math.random().toString(36).slice(2), "file://");
    const pathname = url2.pathname;
    let file3 = this.mapNameToFile.get(pathname);
    if (!file3) {
      if (flags & SQLITE_OPEN_CREATE) {
        file3 = {
          pathname,
          flags,
          size: 0,
          data: new ArrayBuffer(0)
        };
        this.mapNameToFile.set(pathname, file3);
      } else {
        return SQLITE_CANTOPEN;
      }
    }
    this.mapIdToFile.set(fileId, file3);
    pOutFlags.setInt32(0, flags, true);
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @returns {number|Promise<number>}
   */
  jClose(fileId) {
    const file3 = this.mapIdToFile.get(fileId);
    this.mapIdToFile.delete(fileId);
    if (file3.flags & SQLITE_OPEN_DELETEONCLOSE) {
      this.mapNameToFile.delete(file3.pathname);
    }
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @param {Uint8Array} pData 
   * @param {number} iOffset
   * @returns {number|Promise<number>}
   */
  jRead(fileId, pData, iOffset) {
    const file3 = this.mapIdToFile.get(fileId);
    const bgn = Math.min(iOffset, file3.size);
    const end6 = Math.min(iOffset + pData.byteLength, file3.size);
    const nBytes = end6 - bgn;
    if (nBytes) {
      pData.set(new Uint8Array(file3.data, bgn, nBytes));
    }
    if (nBytes < pData.byteLength) {
      pData.fill(0, nBytes);
      return SQLITE_IOERR_SHORT_READ;
    }
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @param {Uint8Array} pData 
   * @param {number} iOffset
   * @returns {number|Promise<number>}
   */
  jWrite(fileId, pData, iOffset) {
    const file3 = this.mapIdToFile.get(fileId);
    if (iOffset + pData.byteLength > file3.data.byteLength) {
      const newSize = Math.max(iOffset + pData.byteLength, 2 * file3.data.byteLength);
      const data = new ArrayBuffer(newSize);
      new Uint8Array(data).set(new Uint8Array(file3.data, 0, file3.size));
      file3.data = data;
    }
    new Uint8Array(file3.data, iOffset, pData.byteLength).set(pData.subarray());
    file3.size = Math.max(file3.size, iOffset + pData.byteLength);
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @param {number} iSize 
   * @returns {number|Promise<number>}
   */
  jTruncate(fileId, iSize) {
    const file3 = this.mapIdToFile.get(fileId);
    file3.size = Math.min(file3.size, iSize);
    return SQLITE_OK;
  }
  /**
   * @param {number} fileId 
   * @param {DataView} pSize64 
   * @returns {number|Promise<number>}
   */
  jFileSize(fileId, pSize64) {
    const file3 = this.mapIdToFile.get(fileId);
    pSize64.setBigInt64(0, BigInt(file3.size), true);
    return SQLITE_OK;
  }
  /**
   * @param {string} name 
   * @param {number} syncDir 
   * @returns {number|Promise<number>}
   */
  jDelete(name, syncDir) {
    const url2 = new URL(name, "file://");
    const pathname = url2.pathname;
    this.mapNameToFile.delete(pathname);
    return SQLITE_OK;
  }
  /**
   * @param {string} name 
   * @param {number} flags 
   * @param {DataView} pResOut 
   * @returns {number|Promise<number>}
   */
  jAccess(name, flags, pResOut) {
    const url2 = new URL(name, "file://");
    const pathname = url2.pathname;
    const file3 = this.mapNameToFile.get(pathname);
    pResOut.setInt32(0, file3 ? 1 : 0, true);
    return SQLITE_OK;
  }
};

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/in-memory-vfs.js
var cachedMemoryVfs;
var makeInMemoryDb = /* @__PURE__ */ __name((sqlite3) => {
  if (sqlite3.vfs_registered.has("memory-vfs") === false) {
    const vfs2 = new MemoryVFS("memory-vfs", sqlite3.module);
    sqlite3.vfs_register(vfs2, false);
    cachedMemoryVfs = vfs2;
  }
  const dbPointer = sqlite3.open_v2Sync(":memory:", void 0, "memory-vfs");
  const vfs = cachedMemoryVfs;
  return { dbPointer, vfs };
}, "makeInMemoryDb");

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/make-sqlite-db.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeSqliteDb = /* @__PURE__ */ __name(({ sqlite3, metadata }) => {
  const preparedStmts = [];
  const { dbPointer } = metadata;
  let isClosed = false;
  const sqliteDb = {
    _tag: "SqliteDb",
    metadata,
    debug: {
      // Setting initially to root but will be set to correct value shortly after
      head: EventSequenceNumber_exports.ROOT
    },
    prepare: /* @__PURE__ */ __name((queryStr) => {
      try {
        const stmts = sqlite3.statements(dbPointer, queryStr.trim(), { unscoped: true });
        let isFinalized = false;
        const preparedStmt = {
          execute: /* @__PURE__ */ __name((bindValues, options4) => {
            for (const stmt of stmts) {
              if (bindValues !== void 0 && Object.keys(bindValues).length > 0) {
                sqlite3.bind_collection(stmt, bindValues);
              }
              try {
                sqlite3.step(stmt);
              } finally {
                if (options4?.onRowsChanged) {
                  options4.onRowsChanged(sqlite3.changes(dbPointer));
                }
                sqlite3.reset(stmt);
              }
            }
          }, "execute"),
          select: /* @__PURE__ */ __name((bindValues) => {
            if (stmts.length !== 1) {
              throw new SqliteError({
                query: { bindValues, sql: queryStr },
                code: -1,
                cause: "Expected only one statement when using `select`"
              });
            }
            const stmt = stmts[0];
            if (bindValues !== void 0 && Object.keys(bindValues).length > 0) {
              sqlite3.bind_collection(stmt, bindValues);
            }
            const results = [];
            try {
              let columns;
              try {
                columns = sqlite3.column_names(stmt);
              } catch (_e) {
              }
              while (sqlite3.step(stmt) === SQLITE_ROW) {
                if (columns !== void 0) {
                  const obj = {};
                  for (let i = 0; i < columns.length; i++) {
                    obj[columns[i]] = sqlite3.column(stmt, i);
                  }
                  results.push(obj);
                }
              }
            } catch (e) {
              throw new SqliteError({
                query: { bindValues, sql: queryStr },
                code: e.code,
                cause: e
              });
            } finally {
              sqlite3.reset(stmt);
            }
            return results;
          }, "select"),
          finalize: /* @__PURE__ */ __name(() => {
            if (isFinalized) {
              return;
            }
            isFinalized = true;
            for (const stmt of stmts) {
              sqlite3.finalize(stmt);
            }
          }, "finalize"),
          sql: queryStr
        };
        preparedStmts.push(preparedStmt);
        return preparedStmt;
      } catch (e) {
        throw new SqliteError({
          query: { sql: queryStr, bindValues: {} },
          code: e.code,
          cause: e
        });
      }
    }, "prepare"),
    export: sqlite_db_helper_exports.makeExport(() => sqlite3.serialize(dbPointer, "main")),
    execute: sqlite_db_helper_exports.makeExecute((queryStr, bindValues, options4) => {
      const stmt = sqliteDb.prepare(queryStr);
      stmt.execute(bindValues, options4);
      stmt.finalize();
    }),
    select: sqlite_db_helper_exports.makeSelect((queryStr, bindValues) => {
      const stmt = sqliteDb.prepare(queryStr);
      const results = stmt.select(bindValues);
      stmt.finalize();
      return results;
    }),
    destroy: /* @__PURE__ */ __name(() => {
      sqliteDb.close();
      metadata.deleteDb();
    }, "destroy"),
    close: /* @__PURE__ */ __name(() => {
      if (isClosed) {
        return;
      }
      for (const stmt of preparedStmts) {
        stmt.finalize();
      }
      sqlite3.close(dbPointer);
      isClosed = true;
    }, "close"),
    import: /* @__PURE__ */ __name((source) => {
      const FREE_ON_CLOSE = 1;
      const RESIZEABLE = 2;
      if (source instanceof Uint8Array) {
        const tmpDb = makeInMemoryDb(sqlite3);
        sqlite3.deserialize(tmpDb.dbPointer, "main", source, source.length, source.length, FREE_ON_CLOSE | RESIZEABLE);
        sqlite3.backup(dbPointer, "main", tmpDb.dbPointer, "main");
        sqlite3.close(tmpDb.dbPointer);
      } else {
        sqlite3.backup(dbPointer, "main", source.metadata.dbPointer, "main");
      }
      metadata.configureDb(sqliteDb);
    }, "import"),
    session: /* @__PURE__ */ __name(() => {
      const sessionPointer = sqlite3.session_create(dbPointer, "main");
      sqlite3.session_attach(sessionPointer, null);
      return {
        changeset: /* @__PURE__ */ __name(() => {
          const res = sqlite3.session_changeset(sessionPointer);
          return res.changeset ?? void 0;
        }, "changeset"),
        finish: /* @__PURE__ */ __name(() => {
          sqlite3.session_delete(sessionPointer);
        }, "finish")
      };
    }, "session"),
    makeChangeset: /* @__PURE__ */ __name((data) => {
      const changeset = {
        invert: /* @__PURE__ */ __name(() => {
          const inverted = sqlite3.changeset_invert(data);
          return sqliteDb.makeChangeset(inverted);
        }, "invert"),
        apply: /* @__PURE__ */ __name(() => {
          try {
            sqlite3.changeset_apply(dbPointer, data);
            data = void 0;
          } catch (cause3) {
            throw new SqliteError({
              code: cause3.code ?? -1,
              cause: cause3,
              note: `Failed calling makeChangeset.apply`
            });
          }
        }, "apply")
      };
      return changeset;
    }, "makeChangeset")
  };
  metadata.configureDb(sqliteDb);
  return sqliteDb;
}, "makeSqliteDb");

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/cf/CloudflareSqlVFS.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/FacadeVFS.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var AsyncFunction2 = Object.getPrototypeOf(async () => {
}).constructor;
var FacadeVFS2 = class extends Base3 {
  static {
    __name(this, "FacadeVFS");
  }
  /**
   * @param {string} name
   * @param {object} module
   */
  constructor(name, module) {
    super(name, module);
  }
  /**
   * Override to indicate which methods are asynchronous.
   * @param {string} methodName
   * @returns {boolean}
   */
  hasAsyncMethod(methodName) {
    const jMethodName = `j${methodName.slice(1)}`;
    return this[jMethodName] instanceof AsyncFunction2;
  }
  /**
   * Return the filename for a file id for use by mixins.
   * @param {number} pFile
   * @returns {string}
   */
  getFilename(pFile) {
    throw new Error("unimplemented");
  }
  /**
   * @param {string?} filename
   * @param {number} pFile
   * @param {number} flags
   * @param {DataView} pOutFlags
   * @returns {number|Promise<number>}
   */
  jOpen(filename, pFile, flags, pOutFlags) {
    return SQLITE_CANTOPEN;
  }
  /**
   * @param {string} filename
   * @param {number} syncDir
   * @returns {number|Promise<number>}
   */
  jDelete(filename, syncDir) {
    return SQLITE_OK;
  }
  /**
   * @param {string} filename
   * @param {number} flags
   * @param {DataView} pResOut
   * @returns {number|Promise<number>}
   */
  jAccess(filename, flags, pResOut) {
    return SQLITE_OK;
  }
  /**
   * @param {string} filename
   * @param {Uint8Array} zOut
   * @returns {number|Promise<number>}
   */
  jFullPathname(filename, zOut) {
    const { read: read4, written } = new TextEncoder().encodeInto(filename, zOut);
    if (read4 < filename.length)
      return SQLITE_IOERR;
    if (written >= zOut.length)
      return SQLITE_IOERR;
    zOut[written] = 0;
    return SQLITE_OK;
  }
  /**
   * @param {Uint8Array} zBuf
   * @returns {number|Promise<number>}
   */
  jGetLastError(zBuf) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile
   * @returns {number|Promise<number>}
   */
  jClose(pFile) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile
   * @param {Uint8Array} pData
   * @param {number} iOffset
   * @returns {number|Promise<number>}
   */
  jRead(pFile, pData, iOffset) {
    pData.fill(0);
    return SQLITE_IOERR_SHORT_READ;
  }
  /**
   * @param {number} pFile
   * @param {Uint8Array} pData
   * @param {number} iOffset
   * @returns {number|Promise<number>}
   */
  jWrite(pFile, pData, iOffset) {
    return SQLITE_IOERR_WRITE;
  }
  /**
   * @param {number} pFile
   * @param {number} size
   * @returns {number|Promise<number>}
   */
  jTruncate(pFile, size22) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile
   * @param {number} flags
   * @returns {number|Promise<number>}
   */
  jSync(pFile, flags) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile
   * @param {DataView} pSize
   * @returns {number|Promise<number>}
   */
  jFileSize(pFile, pSize) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile
   * @param {number} lockType
   * @returns {number|Promise<number>}
   */
  jLock(pFile, lockType) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile
   * @param {number} lockType
   * @returns {number|Promise<number>}
   */
  jUnlock(pFile, lockType) {
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile
   * @param {DataView} pResOut
   * @returns {number|Promise<number>}
   */
  jCheckReservedLock(pFile, pResOut) {
    pResOut.setInt32(0, 0, true);
    return SQLITE_OK;
  }
  /**
   * @param {number} pFile
   * @param {number} op
   * @param {DataView} pArg
   * @returns {number|Promise<number>}
   */
  jFileControl(pFile, op, pArg) {
    return SQLITE_NOTFOUND;
  }
  /**
   * @param {number} pFile
   * @returns {number|Promise<number>}
   */
  jSectorSize(pFile) {
    return super.xSectorSize(pFile);
  }
  /**
   * @param {number} pFile
   * @returns {number|Promise<number>}
   */
  jDeviceCharacteristics(pFile) {
    return 0;
  }
  /**
   * @param {number} pVfs
   * @param {number} zName
   * @param {number} pFile
   * @param {number} flags
   * @param {number} pOutFlags
   * @returns {number|Promise<number>}
   */
  xOpen(pVfs, zName, pFile, flags, pOutFlags) {
    const filename = this.#decodeFilename(zName, flags);
    const pOutFlagsView = this.#makeTypedDataView("Int32", pOutFlags);
    this["log"]?.("jOpen", filename, pFile, `0x${flags.toString(16)}`);
    return this.jOpen(filename, pFile, flags, pOutFlagsView);
  }
  /**
   * @param {number} pVfs
   * @param {number} zName
   * @param {number} syncDir
   * @returns {number|Promise<number>}
   */
  xDelete(pVfs, zName, syncDir) {
    const filename = this._module.UTF8ToString(zName);
    this["log"]?.("jDelete", filename, syncDir);
    return this.jDelete(filename, syncDir);
  }
  /**
   * @param {number} pVfs
   * @param {number} zName
   * @param {number} flags
   * @param {number} pResOut
   * @returns {number|Promise<number>}
   */
  xAccess(pVfs, zName, flags, pResOut) {
    const filename = this._module.UTF8ToString(zName);
    const pResOutView = this.#makeTypedDataView("Int32", pResOut);
    this["log"]?.("jAccess", filename, flags);
    return this.jAccess(filename, flags, pResOutView);
  }
  /**
   * @param {number} pVfs
   * @param {number} zName
   * @param {number} nOut
   * @param {number} zOut
   * @returns {number|Promise<number>}
   */
  xFullPathname(pVfs, zName, nOut, zOut) {
    const filename = this._module.UTF8ToString(zName);
    const zOutArray = this._module.HEAPU8.subarray(zOut, zOut + nOut);
    this["log"]?.("jFullPathname", filename, nOut);
    return this.jFullPathname(filename, zOutArray);
  }
  /**
   * @param {number} pVfs
   * @param {number} nBuf
   * @param {number} zBuf
   * @returns {number|Promise<number>}
   */
  xGetLastError(pVfs, nBuf, zBuf) {
    const zBufArray = this._module.HEAPU8.subarray(zBuf, zBuf + nBuf);
    this["log"]?.("jGetLastError", nBuf);
    return this.jGetLastError(zBufArray);
  }
  /**
   * @param {number} pFile
   * @returns {number|Promise<number>}
   */
  xClose(pFile) {
    this["log"]?.("jClose", pFile);
    return this.jClose(pFile);
  }
  /**
   * @param {number} pFile
   * @param {number} pData
   * @param {number} iAmt
   * @param {number} iOffsetLo
   * @param {number} iOffsetHi
   * @returns {number|Promise<number>}
   */
  xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
    const pDataArray = this.#makeDataArray(pData, iAmt);
    const iOffset = delegalize2(iOffsetLo, iOffsetHi);
    this["log"]?.("jRead", pFile, iAmt, iOffset);
    return this.jRead(pFile, pDataArray, iOffset);
  }
  /**
   * @param {number} pFile
   * @param {number} pData
   * @param {number} iAmt
   * @param {number} iOffsetLo
   * @param {number} iOffsetHi
   * @returns {number|Promise<number>}
   */
  xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
    const pDataArray = this.#makeDataArray(pData, iAmt);
    const iOffset = delegalize2(iOffsetLo, iOffsetHi);
    this["log"]?.("jWrite", pFile, pDataArray, iOffset);
    return this.jWrite(pFile, pDataArray, iOffset);
  }
  /**
   * @param {number} pFile
   * @param {number} sizeLo
   * @param {number} sizeHi
   * @returns {number|Promise<number>}
   */
  xTruncate(pFile, sizeLo, sizeHi) {
    const size22 = delegalize2(sizeLo, sizeHi);
    this["log"]?.("jTruncate", pFile, size22);
    return this.jTruncate(pFile, size22);
  }
  /**
   * @param {number} pFile
   * @param {number} flags
   * @returns {number|Promise<number>}
   */
  xSync(pFile, flags) {
    this["log"]?.("jSync", pFile, flags);
    return this.jSync(pFile, flags);
  }
  /**
   *
   * @param {number} pFile
   * @param {number} pSize
   * @returns {number|Promise<number>}
   */
  xFileSize(pFile, pSize) {
    const pSizeView = this.#makeTypedDataView("BigInt64", pSize);
    this["log"]?.("jFileSize", pFile);
    return this.jFileSize(pFile, pSizeView);
  }
  /**
   * @param {number} pFile
   * @param {number} lockType
   * @returns {number|Promise<number>}
   */
  xLock(pFile, lockType) {
    this["log"]?.("jLock", pFile, lockType);
    return this.jLock(pFile, lockType);
  }
  /**
   * @param {number} pFile
   * @param {number} lockType
   * @returns {number|Promise<number>}
   */
  xUnlock(pFile, lockType) {
    this["log"]?.("jUnlock", pFile, lockType);
    return this.jUnlock(pFile, lockType);
  }
  /**
   * @param {number} pFile
   * @param {number} pResOut
   * @returns {number|Promise<number>}
   */
  xCheckReservedLock(pFile, pResOut) {
    const pResOutView = this.#makeTypedDataView("Int32", pResOut);
    this["log"]?.("jCheckReservedLock", pFile);
    return this.jCheckReservedLock(pFile, pResOutView);
  }
  /**
   * @param {number} pFile
   * @param {number} op
   * @param {number} pArg
   * @returns {number|Promise<number>}
   */
  xFileControl(pFile, op, pArg) {
    const pArgView = new DataView(this._module.HEAPU8.buffer, this._module.HEAPU8.byteOffset + pArg);
    this["log"]?.("jFileControl", pFile, op, pArgView);
    return this.jFileControl(pFile, op, pArgView);
  }
  /**
   * @param {number} pFile
   * @returns {number|Promise<number>}
   */
  xSectorSize(pFile) {
    this["log"]?.("jSectorSize", pFile);
    return this.jSectorSize(pFile);
  }
  /**
   * @param {number} pFile
   * @returns {number|Promise<number>}
   */
  xDeviceCharacteristics(pFile) {
    this["log"]?.("jDeviceCharacteristics", pFile);
    return this.jDeviceCharacteristics(pFile);
  }
  /**
   * Wrapped DataView for pointer arguments.
   * Pointers to a single value are passed using DataView. A Proxy
   * wrapper prevents use of incorrect type or endianness.
   * @param {'Int32'|'BigInt64'} type
   * @param {number} byteOffset
   * @returns {DataView}
   */
  #makeTypedDataView(type3, byteOffset) {
    const byteLength = type3 === "Int32" ? 4 : 8;
    const getter = `get${type3}`;
    const setter = `set${type3}`;
    const makeDataView = /* @__PURE__ */ __name(() => new DataView(this._module.HEAPU8.buffer, this._module.HEAPU8.byteOffset + byteOffset, byteLength), "makeDataView");
    let dataView3 = makeDataView();
    return new Proxy(dataView3, {
      get(_, prop) {
        if (dataView3.buffer.byteLength === 0) {
          dataView3 = makeDataView();
        }
        if (prop === getter) {
          return (byteOffset2, littleEndian) => {
            if (!littleEndian)
              throw new Error("must be little endian");
            return dataView3[prop](byteOffset2, littleEndian);
          };
        }
        if (prop === setter) {
          return (byteOffset2, value6, littleEndian) => {
            if (!littleEndian)
              throw new Error("must be little endian");
            return dataView3[prop](byteOffset2, value6, littleEndian);
          };
        }
        if (typeof prop === "string" && /^(get)|(set)/.test(prop)) {
          throw new Error("invalid type");
        }
        const result = dataView3[prop];
        return typeof result === "function" ? result.bind(dataView3) : result;
      }
    });
  }
  /**
   * @param {number} byteOffset
   * @param {number} byteLength
   */
  #makeDataArray(byteOffset, byteLength) {
    let target3 = this._module.HEAPU8.subarray(byteOffset, byteOffset + byteLength);
    return new Proxy(target3, {
      get: /* @__PURE__ */ __name((_, prop, receiver) => {
        if (target3.buffer.byteLength === 0) {
          target3 = this._module.HEAPU8.subarray(byteOffset, byteOffset + byteLength);
        }
        const result = target3[prop];
        return typeof result === "function" ? result.bind(target3) : result;
      }, "get")
    });
  }
  #decodeFilename(zName, flags) {
    if (flags & SQLITE_OPEN_URI) {
      let pName = zName;
      let state2 = 1;
      const charCodes = [];
      while (state2) {
        const charCode = this._module.HEAPU8[pName++];
        if (charCode) {
          charCodes.push(charCode);
        } else {
          if (!this._module.HEAPU8[pName])
            state2 = null;
          switch (state2) {
            case 1: {
              charCodes.push("?".charCodeAt(0));
              state2 = 2;
              break;
            }
            case 2: {
              charCodes.push("=".charCodeAt(0));
              state2 = 3;
              break;
            }
            case 3: {
              charCodes.push("&".charCodeAt(0));
              state2 = 2;
              break;
            }
          }
        }
      }
      return new TextDecoder().decode(new Uint8Array(charCodes));
    }
    return zName ? this._module.UTF8ToString(zName) : null;
  }
};
function delegalize2(lo32, hi32) {
  return hi32 * 4294967296 + lo32 + (lo32 < 0 ? 2 ** 32 : 0);
}
__name(delegalize2, "delegalize");

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/cf/BlockManager.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var BlockManager = class {
  static {
    __name(this, "BlockManager");
  }
  blockSize;
  constructor(blockSize = 64 * 1024) {
    this.blockSize = blockSize;
  }
  /**
   * Calculate which blocks are needed for a given file operation
   */
  calculateBlockRange(offset, length5) {
    const startBlock = Math.floor(offset / this.blockSize);
    const endBlock = Math.floor((offset + length5 - 1) / this.blockSize);
    const startOffset = offset % this.blockSize;
    const endOffset = (offset + length5 - 1) % this.blockSize + 1;
    return {
      startBlock,
      endBlock,
      startOffset,
      endOffset
    };
  }
  /**
   * Read blocks from SQL storage and return as a Map
   */
  readBlocks(sql2, filePath, blockIds) {
    const blocks = /* @__PURE__ */ new Map();
    if (blockIds.length === 0) {
      return blocks;
    }
    const placeholders = blockIds.map(() => "?").join(",");
    const query = `
      SELECT block_id, block_data 
      FROM vfs_blocks 
      WHERE file_path = ? AND block_id IN (${placeholders})
      ORDER BY block_id
    `;
    const cursor = sql2.exec(query, filePath, ...blockIds);
    for (const row of cursor) {
      blocks.set(row.block_id, new Uint8Array(row.block_data));
    }
    return blocks;
  }
  /**
   * Write blocks to SQL storage using exec for now (prepared statements later)
   */
  writeBlocks(sql2, filePath, blocks) {
    if (blocks.size === 0) {
      return;
    }
    for (const [blockId, data] of blocks) {
      sql2.exec("INSERT OR REPLACE INTO vfs_blocks (file_path, block_id, block_data) VALUES (?, ?, ?)", filePath, blockId, data);
    }
  }
  /**
   * Delete blocks at or after the specified block ID (used for truncation)
   */
  deleteBlocksAfter(sql2, filePath, startBlockId) {
    sql2.exec("DELETE FROM vfs_blocks WHERE file_path = ? AND block_id >= ?", filePath, startBlockId);
  }
  /**
   * Split write data into blocks, handling partial blocks at boundaries
   */
  splitIntoBlocks(data, offset) {
    const blocks = /* @__PURE__ */ new Map();
    let remainingData = data;
    let currentOffset = offset;
    while (remainingData.length > 0) {
      const blockId = Math.floor(currentOffset / this.blockSize);
      const blockOffset = currentOffset % this.blockSize;
      const bytesToWrite = Math.min(remainingData.length, this.blockSize - blockOffset);
      const blockData = remainingData.slice(0, bytesToWrite);
      blocks.set(blockId, {
        blockId,
        blockOffset,
        data: blockData
      });
      remainingData = remainingData.slice(bytesToWrite);
      currentOffset += bytesToWrite;
    }
    return blocks;
  }
  /**
   * Assemble read data from blocks into a continuous buffer
   */
  assembleBlocks(blocks, range5, requestedLength) {
    const result = new Uint8Array(requestedLength);
    let resultOffset = 0;
    for (let blockId = range5.startBlock; blockId <= range5.endBlock; blockId++) {
      const blockData = blocks.get(blockId);
      if (!blockData) {
        const zeroLength = Math.min(this.blockSize, requestedLength - resultOffset);
        resultOffset += zeroLength;
        continue;
      }
      const blockStartOffset = blockId === range5.startBlock ? range5.startOffset : 0;
      const blockEndOffset = blockId === range5.endBlock ? range5.endOffset : blockData.length;
      const sliceLength = blockEndOffset - blockStartOffset;
      if (sliceLength > 0) {
        const slice = blockData.slice(blockStartOffset, blockEndOffset);
        result.set(slice, resultOffset);
        resultOffset += sliceLength;
      }
    }
    return result;
  }
  /**
   * Handle partial block writes by reading existing block, modifying, and returning complete block
   */
  mergePartialBlock(sql2, filePath, blockId, blockOffset, newData) {
    const existingBlocks = this.readBlocks(sql2, filePath, [blockId]);
    const existingBlock = existingBlocks.get(blockId) || new Uint8Array(this.blockSize);
    const mergedBlock = new Uint8Array(this.blockSize);
    mergedBlock.set(existingBlock);
    mergedBlock.set(newData, blockOffset);
    return mergedBlock;
  }
  /**
   * Get statistics about block usage for a file
   */
  getBlockStats(sql2, filePath) {
    const blockStatsCursor = sql2.exec(`SELECT 
        COUNT(*) as stored_blocks,
        COALESCE(SUM(LENGTH(block_data)), 0) as total_bytes
      FROM vfs_blocks 
      WHERE file_path = ?`, filePath);
    const result = blockStatsCursor.one();
    const fileSizeCursor = sql2.exec("SELECT file_size FROM vfs_files WHERE file_path = ?", filePath);
    let fileSize = 0;
    try {
      const fileSizeResult = fileSizeCursor.one();
      fileSize = fileSizeResult.file_size;
    } catch {
    }
    const totalBlocks = Math.ceil(fileSize / this.blockSize);
    return {
      totalBlocks,
      storedBlocks: result.stored_blocks,
      totalBytes: result.total_bytes
    };
  }
  getBlockSize() {
    return this.blockSize;
  }
};

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/cf/CloudflareSqlVFS.js
var SECTOR_SIZE = 4096;
var BLOCK_SIZE = 64 * 1024;
var DEFAULT_MAX_FILES = 100;
var PERSISTENT_FILE_TYPES = SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_MAIN_JOURNAL | SQLITE_OPEN_SUPER_JOURNAL | SQLITE_OPEN_WAL;
var CloudflareSqlVFS = class _CloudflareSqlVFS extends FacadeVFS2 {
  static {
    __name(this, "CloudflareSqlVFS");
  }
  log = null;
  #sql;
  #initialized = false;
  #blockManager;
  // File management
  #openFiles = /* @__PURE__ */ new Map();
  #maxFiles;
  static async create(name, sql2, module, options4 = {}) {
    const vfs = new _CloudflareSqlVFS(name, sql2, module, options4);
    await vfs.isReady();
    return vfs;
  }
  constructor(name, sql2, module, options4 = {}) {
    super(name, module);
    this.#sql = sql2;
    this.#maxFiles = options4.maxFiles || DEFAULT_MAX_FILES;
    this.#blockManager = new BlockManager(options4.blockSize || BLOCK_SIZE);
  }
  /**
   * Initialize the VFS by setting up SQL schema
   */
  async isReady() {
    if (this.#initialized) {
      return true;
    }
    try {
      this.#initializeSchema();
      this.#cleanupNonPersistentFiles();
      this.#initialized = true;
      return true;
    } catch (error5) {
      console.error("CloudflareSqlVFS initialization failed:", error5);
      return false;
    }
  }
  /**
   * Initialize the SQL schema for the VFS
   */
  #initializeSchema() {
    const statements = [
      `CREATE TABLE IF NOT EXISTS vfs_files (
        file_path TEXT PRIMARY KEY,
        file_size INTEGER NOT NULL DEFAULT 0,
        flags INTEGER NOT NULL DEFAULT 0,
        created_at INTEGER NOT NULL DEFAULT (unixepoch()),
        modified_at INTEGER NOT NULL DEFAULT (unixepoch())
      )`,
      `CREATE TABLE IF NOT EXISTS vfs_blocks (
        file_path TEXT NOT NULL,
        block_id INTEGER NOT NULL,
        block_data BLOB NOT NULL,
        created_at INTEGER NOT NULL DEFAULT (unixepoch()),
        PRIMARY KEY (file_path, block_id),
        FOREIGN KEY (file_path) REFERENCES vfs_files(file_path) ON DELETE CASCADE
      )`,
      `CREATE INDEX IF NOT EXISTS idx_vfs_blocks_range ON vfs_blocks(file_path, block_id)`,
      `CREATE INDEX IF NOT EXISTS idx_vfs_files_modified ON vfs_files(modified_at)`,
      `CREATE TRIGGER IF NOT EXISTS trg_vfs_files_update_modified 
        AFTER UPDATE OF file_size ON vfs_files
        BEGIN
          UPDATE vfs_files SET modified_at = unixepoch() WHERE file_path = NEW.file_path;
        END`
    ];
    for (const statement of statements) {
      try {
        this.#sql.exec(statement);
      } catch (error5) {
        console.error("Failed to execute schema statement:", statement);
        throw error5;
      }
    }
  }
  /**
   * Clean up non-persistent files from previous sessions
   */
  #cleanupNonPersistentFiles() {
    try {
      const cursor = this.#sql.exec("SELECT file_path, flags FROM vfs_files");
      const filesToDelete = [];
      for (const row of cursor) {
        if (!(row.flags & PERSISTENT_FILE_TYPES)) {
          filesToDelete.push(row.file_path);
        }
      }
      for (const filePath of filesToDelete) {
        this.#sql.exec("DELETE FROM vfs_files WHERE file_path = ?", filePath);
      }
    } catch (error5) {
      console.warn("Error during cleanup:", error5);
    }
  }
  // VFS Interface Implementation
  jOpen(path, fileId, flags, pOutFlags) {
    try {
      if (this.#openFiles.size >= this.#maxFiles) {
        return SQLITE_CANTOPEN;
      }
      const existingFile = this.#getFileMetadata(path);
      if (!existingFile && !(flags & SQLITE_OPEN_CREATE)) {
        return SQLITE_CANTOPEN;
      }
      let metadata;
      if (existingFile) {
        metadata = existingFile;
      } else {
        const now2 = Math.floor(Date.now() / 1e3);
        metadata = {
          path,
          size: 0,
          flags,
          created: now2,
          modified: now2
        };
        this.#sql.exec("INSERT INTO vfs_files (file_path, file_size, flags, created_at, modified_at) VALUES (?, ?, ?, ?, ?)", path, 0, flags, now2, now2);
      }
      this.#openFiles.set(fileId, {
        path,
        flags,
        metadata
      });
      pOutFlags.setInt32(0, flags, true);
      return SQLITE_OK;
    } catch (error5) {
      console.error("jOpen error:", error5);
      return SQLITE_CANTOPEN;
    }
  }
  jClose(fileId) {
    this.#openFiles.delete(fileId);
    return SQLITE_OK;
  }
  jRead(fileId, buffer4, offset) {
    try {
      const handle = this.#openFiles.get(fileId);
      if (!handle) {
        return SQLITE_IOERR;
      }
      const range5 = this.#blockManager.calculateBlockRange(offset, buffer4.length);
      const blockIds = [];
      for (let i = range5.startBlock; i <= range5.endBlock; i++) {
        blockIds.push(i);
      }
      const blocks = this.#blockManager.readBlocks(this.#sql, handle.path, blockIds);
      const data = this.#blockManager.assembleBlocks(blocks, range5, buffer4.length);
      buffer4.set(data);
      return SQLITE_OK;
    } catch (error5) {
      console.error("jRead error:", error5);
      return SQLITE_IOERR;
    }
  }
  jWrite(fileId, data, offset) {
    try {
      const handle = this.#openFiles.get(fileId);
      if (!handle) {
        return SQLITE_IOERR;
      }
      const writeBlocks = this.#blockManager.splitIntoBlocks(data, offset);
      const finalBlocks = /* @__PURE__ */ new Map();
      for (const [blockId, blockInfo] of writeBlocks) {
        let blockData;
        if (blockInfo.blockOffset === 0 && blockInfo.data.length === this.#blockManager.getBlockSize()) {
          blockData = blockInfo.data;
        } else {
          blockData = this.#blockManager.mergePartialBlock(this.#sql, handle.path, blockInfo.blockId, blockInfo.blockOffset, blockInfo.data);
        }
        finalBlocks.set(blockId, blockData);
      }
      this.#blockManager.writeBlocks(this.#sql, handle.path, finalBlocks);
      const newSize = Math.max(handle.metadata.size, offset + data.length);
      if (newSize !== handle.metadata.size) {
        this.#sql.exec("UPDATE vfs_files SET file_size = ? WHERE file_path = ?", newSize, handle.path);
        handle.metadata.size = newSize;
      }
      return SQLITE_OK;
    } catch (error5) {
      console.error("jWrite error:", error5);
      return SQLITE_IOERR;
    }
  }
  jTruncate(fileId, size22) {
    try {
      const handle = this.#openFiles.get(fileId);
      if (!handle) {
        return SQLITE_IOERR;
      }
      const lastBlockId = Math.floor(size22 / this.#blockManager.getBlockSize());
      this.#blockManager.deleteBlocksAfter(this.#sql, handle.path, lastBlockId + 1);
      if (size22 % this.#blockManager.getBlockSize() !== 0) {
        const existingBlocks = this.#blockManager.readBlocks(this.#sql, handle.path, [lastBlockId]);
        const blockData = existingBlocks.get(lastBlockId);
        if (blockData) {
          const truncatedBlock = blockData.slice(0, size22 % this.#blockManager.getBlockSize());
          const paddedBlock = new Uint8Array(this.#blockManager.getBlockSize());
          paddedBlock.set(truncatedBlock);
          const blocksToWrite = /* @__PURE__ */ new Map([[lastBlockId, paddedBlock]]);
          this.#blockManager.writeBlocks(this.#sql, handle.path, blocksToWrite);
        }
      }
      this.#sql.exec("UPDATE vfs_files SET file_size = ? WHERE file_path = ?", size22, handle.path);
      handle.metadata.size = size22;
      return SQLITE_OK;
    } catch (error5) {
      console.error("jTruncate error:", error5);
      return SQLITE_IOERR;
    }
  }
  jSync(fileId, _flags) {
    const handle = this.#openFiles.get(fileId);
    if (!handle) {
      return SQLITE_IOERR;
    }
    return SQLITE_OK;
  }
  jFileSize(fileId, pSize64) {
    try {
      const handle = this.#openFiles.get(fileId);
      if (!handle) {
        return SQLITE_IOERR;
      }
      pSize64.setBigInt64(0, BigInt(handle.metadata.size), true);
      return SQLITE_OK;
    } catch (error5) {
      console.error("jFileSize error:", error5);
      return SQLITE_IOERR;
    }
  }
  jDelete(path, _syncDir) {
    try {
      this.#sql.exec("DELETE FROM vfs_files WHERE file_path = ?", path);
      return SQLITE_OK;
    } catch (error5) {
      console.error("jDelete error:", error5);
      return SQLITE_IOERR;
    }
  }
  jAccess(path, _flags, pResOut) {
    try {
      const metadata = this.#getFileMetadata(path);
      pResOut.setInt32(0, metadata ? 1 : 0, true);
      return SQLITE_OK;
    } catch (error5) {
      console.error("jAccess error:", error5);
      return SQLITE_IOERR;
    }
  }
  jSectorSize(_fileId) {
    return SECTOR_SIZE;
  }
  jDeviceCharacteristics(_fileId) {
    return SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
  }
  // Helper methods
  #getFileMetadata(path) {
    try {
      const cursor = this.#sql.exec("SELECT file_path, file_size, flags, created_at, modified_at FROM vfs_files WHERE file_path = ?", path);
      const row = cursor.one();
      return {
        path: row.file_path,
        size: row.file_size,
        flags: row.flags,
        created: row.created_at,
        modified: row.modified_at
      };
    } catch {
      return void 0;
    }
  }
  // Statistics and debugging
  getStats() {
    try {
      const cursor = this.#sql.exec("SELECT COUNT(*) as total_files, COALESCE(SUM(LENGTH(block_data)), 0) as total_bytes FROM vfs_files LEFT JOIN vfs_blocks USING (file_path)");
      const stats = cursor.one();
      return {
        activeFiles: stats.total_files,
        openFiles: this.#openFiles.size,
        maxFiles: this.#maxFiles,
        blockSize: this.#blockManager.getBlockSize(),
        totalStoredBytes: stats.total_bytes
      };
    } catch {
      return {
        activeFiles: 0,
        openFiles: this.#openFiles.size,
        maxFiles: this.#maxFiles,
        blockSize: this.#blockManager.getBlockSize(),
        totalStoredBytes: 0
      };
    }
  }
};

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/cf/CloudflareWorkerVFS.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var CHUNK_SIZE = 64 * 1024;
var PERSISTENT_FILE_TYPES2 = SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_MAIN_JOURNAL | SQLITE_OPEN_SUPER_JOURNAL | SQLITE_OPEN_WAL;

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/cf/mod.js
var sqliteDbFactory = /* @__PURE__ */ __name(({ sqlite3 }) => (input) => Effect_exports2.gen(function* () {
  if (input._tag === "in-memory") {
    const { dbPointer: dbPointer2, vfs: vfs2 } = makeInMemoryDb(sqlite3);
    return makeSqliteDb({
      sqlite3,
      metadata: {
        _tag: "in-memory",
        vfs: vfs2,
        dbPointer: dbPointer2,
        persistenceInfo: { fileName: ":memory:" },
        deleteDb: /* @__PURE__ */ __name(() => {
        }, "deleteDb"),
        configureDb: input.configureDb ?? (() => {
        })
      }
    });
  }
  const { dbPointer, vfs } = yield* makeCloudflareFsDb({
    sqlite3,
    fileName: input.fileName,
    // directory: input.directory,
    storage: input.storage
  });
  return makeSqliteDb({
    sqlite3,
    metadata: {
      _tag: "storage",
      vfs,
      dbPointer,
      persistenceInfo: { fileName: input.fileName },
      // deleteDb: () => vfs.deleteDb(filePath),
      // TODO: implement deleteDb
      deleteDb: /* @__PURE__ */ __name(() => {
      }, "deleteDb"),
      configureDb: input.configureDb ?? (() => {
      })
    }
  });
}), "sqliteDbFactory");
var makeCloudflareFsDb = /* @__PURE__ */ __name(({
  sqlite3,
  fileName,
  // directory,
  storage
}) => Effect_exports2.gen(function* () {
  const vfsName = `cf-do-sqlite-${fileName}`;
  if (sqlite3.vfs_registered.has(vfsName) === false) {
    const nodeFsVfs = new CloudflareSqlVFS(vfsName, storage.sql, sqlite3.module);
    const isReady = yield* Effect_exports2.promise(() => nodeFsVfs.isReady());
    if (!isReady) {
      throw new Error(`Failed to initialize CloudflareSqlVFS for ${vfsName}`);
    }
    sqlite3.vfs_register(nodeFsVfs, false);
  }
  const FILE_NAME_MAX_LENGTH = 56;
  if (fileName.length > FILE_NAME_MAX_LENGTH) {
    throw new Error(`File name ${fileName} is too long. Maximum length is ${FILE_NAME_MAX_LENGTH} characters.`);
  }
  const dbPointer = sqlite3.open_v2Sync(fileName, void 0, vfsName);
  return { dbPointer, vfs: {} };
}).pipe(UnexpectedError.mapToUnexpectedError), "makeCloudflareFsDb");

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/load-wasm/mod.workerd.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+wa-sqlite@1.0.8-dev.4/node_modules/@livestore/wa-sqlite/src/sqlite-api.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var MAX_INT64 = 0x7fffffffffffffffn;
var MIN_INT64 = -0x8000000000000000n;
var SQLiteError = class extends Error {
  static {
    __name(this, "SQLiteError");
  }
  constructor(message, code) {
    super(message);
    this.code = code;
  }
};
var async3 = false;
function Factory(Module3) {
  const sqlite3 = {};
  Module3.retryOps = [];
  const sqliteFreeAddress = Module3._getSqliteFree();
  const tmp = Module3._malloc(8);
  const tmpPtr = [tmp, tmp + 4];
  const textEncoder3 = new TextEncoder();
  function createUTF8(s) {
    if (typeof s !== "string") return 0;
    const utf8 = textEncoder3.encode(s);
    const zts = Module3._sqlite3_malloc(utf8.byteLength + 1);
    Module3.HEAPU8.set(utf8, zts);
    Module3.HEAPU8[zts + utf8.byteLength] = 0;
    return zts;
  }
  __name(createUTF8, "createUTF8");
  function cvt32x2ToBigInt(lo32, hi32) {
    return BigInt(hi32) << 32n | BigInt(lo32) & 0xffffffffn;
  }
  __name(cvt32x2ToBigInt, "cvt32x2ToBigInt");
  const cvt32x2AsSafe = (function() {
    const hiMax = BigInt(Number.MAX_SAFE_INTEGER) >> 32n;
    const hiMin = BigInt(Number.MIN_SAFE_INTEGER) >> 32n;
    return function(lo32, hi32) {
      if (hi32 > hiMax || hi32 < hiMin) {
        return cvt32x2ToBigInt(lo32, hi32);
      } else {
        return hi32 * 4294967296 + (lo32 & 2147483647) - (lo32 & 2147483648);
      }
    };
  })();
  const databases = /* @__PURE__ */ new Set();
  function verifyDatabase(db) {
    if (!databases.has(db)) {
      throw new SQLiteError("not a database", SQLITE_MISUSE);
    }
  }
  __name(verifyDatabase, "verifyDatabase");
  const mapStmtToDB = /* @__PURE__ */ new Map();
  function verifyStatement(stmt) {
    if (!mapStmtToDB.has(stmt)) {
      throw new SQLiteError("not a statement", SQLITE_MISUSE);
    }
  }
  __name(verifyStatement, "verifyStatement");
  sqlite3.bind_collection = function(stmt, bindings) {
    verifyStatement(stmt);
    const isArray2 = Array.isArray(bindings);
    const nBindings = sqlite3.bind_parameter_count(stmt);
    for (let i = 1; i <= nBindings; ++i) {
      const key = isArray2 ? i - 1 : sqlite3.bind_parameter_name(stmt, i);
      const value6 = bindings[key];
      if (value6 !== void 0) {
        sqlite3.bind(stmt, i, value6);
      }
    }
    return SQLITE_OK;
  };
  sqlite3.bind = function(stmt, i, value6) {
    verifyStatement(stmt);
    switch (typeof value6) {
      case "number":
        if (value6 === (value6 | 0)) {
          return sqlite3.bind_int(stmt, i, value6);
        } else {
          return sqlite3.bind_double(stmt, i, value6);
        }
      case "string":
        return sqlite3.bind_text(stmt, i, value6);
      case "boolean":
        return sqlite3.bind_int(stmt, i, value6 ? 1 : 0);
      default:
        if (value6 instanceof Uint8Array || Array.isArray(value6)) {
          return sqlite3.bind_blob(stmt, i, value6);
        } else if (value6 === null) {
          return sqlite3.bind_null(stmt, i);
        } else if (typeof value6 === "bigint") {
          return sqlite3.bind_int64(stmt, i, value6);
        } else if (value6 === void 0) {
          return SQLITE_NOTICE;
        } else {
          console.warn("unknown binding converted to null", value6);
          return sqlite3.bind_null(stmt, i);
        }
    }
  };
  sqlite3.bind_blob = (function() {
    const fname = "sqlite3_bind_blob";
    const f = Module3.cwrap(fname, ...decl("nnnnn:n"));
    return function(stmt, i, value6) {
      verifyStatement(stmt);
      const byteLength = value6.byteLength ?? value6.length;
      const ptr = Module3._sqlite3_malloc(byteLength);
      Module3.HEAPU8.subarray(ptr).set(value6);
      const result = f(stmt, i, ptr, byteLength, sqliteFreeAddress);
      return check6(fname, result, mapStmtToDB.get(stmt));
    };
  })();
  sqlite3.bind_parameter_count = (function() {
    const fname = "sqlite3_bind_parameter_count";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  })();
  sqlite3.bind_double = (function() {
    const fname = "sqlite3_bind_double";
    const f = Module3.cwrap(fname, ...decl("nnn:n"));
    return function(stmt, i, value6) {
      verifyStatement(stmt);
      const result = f(stmt, i, value6);
      return check6(fname, result, mapStmtToDB.get(stmt));
    };
  })();
  sqlite3.bind_int = (function() {
    const fname = "sqlite3_bind_int";
    const f = Module3.cwrap(fname, ...decl("nnn:n"));
    return function(stmt, i, value6) {
      verifyStatement(stmt);
      if (value6 > 2147483647 || value6 < -2147483648) return SQLITE_RANGE;
      const result = f(stmt, i, value6);
      return check6(fname, result, mapStmtToDB.get(stmt));
    };
  })();
  sqlite3.bind_int64 = (function() {
    const fname = "sqlite3_bind_int64";
    const f = Module3.cwrap(fname, ...decl("nnnn:n"));
    return function(stmt, i, value6) {
      verifyStatement(stmt);
      if (value6 > MAX_INT64 || value6 < MIN_INT64) return SQLITE_RANGE;
      const lo32 = value6 & 0xffffffffn;
      const hi32 = value6 >> 32n;
      const result = f(stmt, i, Number(lo32), Number(hi32));
      return check6(fname, result, mapStmtToDB.get(stmt));
    };
  })();
  sqlite3.bind_null = (function() {
    const fname = "sqlite3_bind_null";
    const f = Module3.cwrap(fname, ...decl("nn:n"));
    return function(stmt, i) {
      verifyStatement(stmt);
      const result = f(stmt, i);
      return check6(fname, result, mapStmtToDB.get(stmt));
    };
  })();
  sqlite3.bind_parameter_name = (function() {
    const fname = "sqlite3_bind_parameter_name";
    const f = Module3.cwrap(fname, ...decl("n:s"));
    return function(stmt, i) {
      verifyStatement(stmt);
      const result = f(stmt, i);
      return result;
    };
  })();
  sqlite3.bind_text = (function() {
    const fname = "sqlite3_bind_text";
    const f = Module3.cwrap(fname, ...decl("nnnnn:n"));
    return function(stmt, i, value6) {
      verifyStatement(stmt);
      const ptr = createUTF8(value6);
      const result = f(stmt, i, ptr, -1, sqliteFreeAddress);
      return check6(fname, result, mapStmtToDB.get(stmt));
    };
  })();
  sqlite3.changes = (function() {
    const fname = "sqlite3_changes";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(db) {
      verifyDatabase(db);
      const result = f(db);
      return result;
    };
  })();
  sqlite3.deserialize = (function() {
    const fname = "sqlite3_deserialize";
    const f = Module3.cwrap(fname, ...decl("nnnnnn:n"));
    return function(db, schema4, data, szDb, szBuf, flags) {
      verifyDatabase(db);
      const ptr = Module3._sqlite3_malloc(szDb);
      Module3.HEAPU8.subarray(ptr).set(data);
      const result = f(db, schema4, ptr, szDb, szBuf, flags);
      return result;
    };
  })();
  const SQLITE_SERIALIZE_NOCOPY = 1;
  sqlite3.serialize = (function() {
    const fname = "sqlite3_serialize";
    const f = Module3.cwrap(fname, ...decl("nsnn:n"));
    return function(db, schema4) {
      verifyDatabase(db);
      const piSize = tmpPtr[0];
      let address = f(db, schema4, piSize, 0);
      if (address === 0) {
        address = f(db, schema4, piSize, SQLITE_SERIALIZE_NOCOPY);
        const size22 = Module3.getValue(piSize, "*");
        const result = Module3.HEAPU8.subarray(address, address + size22);
        return new Uint8Array(result.slice());
      } else {
        const size22 = Module3.getValue(piSize, "*");
        const result = Module3.HEAPU8.subarray(address, address + size22);
        const copy4 = new Uint8Array(result);
        Module3._sqlite3_free(address);
        return copy4;
      }
    };
  })();
  sqlite3.backup = (function() {
    const fInit = Module3.cwrap("sqlite3_backup_init", ...decl("nsns:n"));
    const fStep = Module3.cwrap("sqlite3_backup_step", ...decl("nn:n"));
    const fFinish = Module3.cwrap("sqlite3_backup_finish", ...decl("n:n"));
    return function(dest, destName, source, sourceName) {
      verifyDatabase(dest);
      verifyDatabase(source);
      const backup = fInit(dest, destName, source, sourceName);
      if (backup === 0) {
        const errMsg = Module3.ccall("sqlite3_errmsg", "string", ["number"], [dest]);
        throw new SQLiteError(`backup failed: ${errMsg}`, SQLITE_ERROR);
      }
      fStep(backup, -1);
      return fFinish(backup);
    };
  })();
  sqlite3.clear_bindings = (function() {
    const fname = "sqlite3_clear_bindings";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return check6(fname, result, mapStmtToDB.get(stmt));
    };
  })();
  sqlite3.close = (function() {
    const fname = "sqlite3_close";
    const f = Module3.cwrap(fname, ...decl("n:n"), { async: async3 });
    return function(db) {
      verifyDatabase(db);
      const result = f(db);
      databases.delete(db);
      return check6(fname, result, db);
    };
  })();
  sqlite3.column = function(stmt, iCol) {
    verifyStatement(stmt);
    const type3 = sqlite3.column_type(stmt, iCol);
    switch (type3) {
      case SQLITE_BLOB:
        return sqlite3.column_blob(stmt, iCol);
      case SQLITE_FLOAT:
        return sqlite3.column_double(stmt, iCol);
      case SQLITE_INTEGER:
        const lo32 = sqlite3.column_int(stmt, iCol);
        const hi32 = Module3.getTempRet0();
        return cvt32x2AsSafe(lo32, hi32);
      case SQLITE_NULL:
        return null;
      case SQLITE_TEXT:
        return sqlite3.column_text(stmt, iCol);
      default:
        throw new SQLiteError("unknown type", type3);
    }
  };
  sqlite3.column_blob = (function() {
    const fname = "sqlite3_column_blob";
    const f = Module3.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const nBytes = sqlite3.column_bytes(stmt, iCol);
      const address = f(stmt, iCol);
      if (address === 0) {
        return null;
      }
      const result = Module3.HEAPU8.subarray(address, address + nBytes);
      return new Uint8Array(result);
    };
  })();
  sqlite3.column_bytes = (function() {
    const fname = "sqlite3_column_bytes";
    const f = Module3.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();
  sqlite3.column_count = (function() {
    const fname = "sqlite3_column_count";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  })();
  sqlite3.column_double = (function() {
    const fname = "sqlite3_column_double";
    const f = Module3.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();
  sqlite3.column_int = (function() {
    const fname = "sqlite3_column_int64";
    const f = Module3.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();
  sqlite3.column_int64 = (function() {
    const fname = "sqlite3_column_int64";
    const f = Module3.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const lo32 = f(stmt, iCol);
      const hi32 = Module3.getTempRet0();
      const result = cvt32x2ToBigInt(lo32, hi32);
      return result;
    };
  })();
  sqlite3.column_name = (function() {
    const fname = "sqlite3_column_name";
    const f = Module3.cwrap(fname, ...decl("nn:s"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();
  sqlite3.column_names = function(stmt) {
    const columns = [];
    const nColumns = sqlite3.column_count(stmt);
    for (let i = 0; i < nColumns; ++i) {
      columns.push(sqlite3.column_name(stmt, i));
    }
    return columns;
  };
  sqlite3.column_text = (function() {
    const fname = "sqlite3_column_text";
    const f = Module3.cwrap(fname, ...decl("nn:s"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();
  sqlite3.column_type = (function() {
    const fname = "sqlite3_column_type";
    const f = Module3.cwrap(fname, ...decl("nn:n"));
    return function(stmt, iCol) {
      verifyStatement(stmt);
      const result = f(stmt, iCol);
      return result;
    };
  })();
  sqlite3.create_function = function(db, zFunctionName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
    verifyDatabase(db);
    function adapt(f) {
      return ((ctx, n, values6) => f(ctx, Module3.HEAP32.subarray(values6 / 4, values6 / 4 + n)));
    }
    __name(adapt, "adapt");
    const result = Module3.create_function(
      db,
      zFunctionName,
      nArg,
      eTextRep,
      pApp,
      xFunc && adapt(xFunc),
      xStep && adapt(xStep),
      xFinal
    );
    return check6("sqlite3_create_function", result, db);
  };
  sqlite3.data_count = (function() {
    const fname = "sqlite3_data_count";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  })();
  sqlite3.exec = function(db, sql2, callback) {
    const stmts = sqlite3.statements(db, sql2, { unscoped: true });
    for (const stmt of stmts) {
      let columns;
      while (sqlite3.step(stmt) === SQLITE_ROW) {
        if (callback) {
          columns = columns ?? sqlite3.column_names(stmt);
          const row = sqlite3.row(stmt);
          callback(row, columns);
        }
      }
    }
    for (const stmt of stmts) {
      sqlite3.finalize(stmt);
    }
    return SQLITE_OK;
  };
  sqlite3.finalize = (function() {
    const fname = "sqlite3_finalize";
    const f = Module3.cwrap(fname, ...decl("n:n"), { async: async3 });
    return function(stmt) {
      const result = f(stmt);
      mapStmtToDB.delete(stmt);
      return result;
    };
  })();
  sqlite3.get_autocommit = (function() {
    const fname = "sqlite3_get_autocommit";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(db) {
      const result = f(db);
      return result;
    };
  })();
  sqlite3.libversion = (function() {
    const fname = "sqlite3_libversion";
    const f = Module3.cwrap(fname, ...decl(":s"));
    return function() {
      const result = f();
      return result;
    };
  })();
  sqlite3.libversion_number = (function() {
    const fname = "sqlite3_libversion_number";
    const f = Module3.cwrap(fname, ...decl(":n"));
    return function() {
      const result = f();
      return result;
    };
  })();
  sqlite3.limit = (function() {
    const fname = "sqlite3_limit";
    const f = Module3.cwrap(fname, ...decl("nnn:n"));
    return function(db, id4, newVal) {
      const result = f(db, id4, newVal);
      return result;
    };
  })();
  sqlite3.open_v2 = (function() {
    const fname = "sqlite3_open_v2";
    const f = Module3.cwrap(fname, ...decl("snnn:n"), { async: async3 });
    return async function(zFilename, flags, zVfs) {
      flags = flags || SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE;
      zVfs = createUTF8(zVfs);
      try {
        const rc = await retry10(() => f(zFilename, tmpPtr[0], flags, zVfs));
        const db = Module3.getValue(tmpPtr[0], "*");
        databases.add(db);
        Module3.ccall("RegisterExtensionFunctions", "void", ["number"], [db]);
        check6(fname, rc, db);
        return db;
      } finally {
        Module3._sqlite3_free(zVfs);
      }
    };
  })();
  sqlite3.open_v2Sync = (function() {
    const fname = "sqlite3_open_v2";
    const f = Module3.cwrap(fname, ...decl("snnn:n"), { async: async3 });
    return function(zFilename, flags, zVfs) {
      flags = flags || SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE;
      zVfs = createUTF8(zVfs);
      try {
        const rc = f(zFilename, tmpPtr[0], flags, zVfs);
        const db = Module3.getValue(tmpPtr[0], "*");
        databases.add(db);
        Module3.ccall("RegisterExtensionFunctions", "void", ["number"], [db]);
        check6(fname, rc, db);
        return db;
      } finally {
        Module3._sqlite3_free(zVfs);
      }
    };
  })();
  sqlite3.progress_handler = function(db, nProgressOps, handler, userData) {
    verifyDatabase(db);
    Module3.progress_handler(db, nProgressOps, handler, userData);
  };
  ;
  sqlite3.reset = (function() {
    const fname = "sqlite3_reset";
    const f = Module3.cwrap(fname, ...decl("n:n"), { async: async3 });
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return check6(fname, result, mapStmtToDB.get(stmt));
    };
  })();
  sqlite3.result = function(context17, value6) {
    switch (typeof value6) {
      case "number":
        if (value6 === (value6 | 0)) {
          sqlite3.result_int(context17, value6);
        } else {
          sqlite3.result_double(context17, value6);
        }
        break;
      case "string":
        sqlite3.result_text(context17, value6);
        break;
      default:
        if (value6 instanceof Uint8Array || Array.isArray(value6)) {
          sqlite3.result_blob(context17, value6);
        } else if (value6 === null) {
          sqlite3.result_null(context17);
        } else if (typeof value6 === "bigint") {
          return sqlite3.result_int64(context17, value6);
        } else {
          console.warn("unknown result converted to null", value6);
          sqlite3.result_null(context17);
        }
        break;
    }
  };
  sqlite3.result_blob = (function() {
    const fname = "sqlite3_result_blob";
    const f = Module3.cwrap(fname, ...decl("nnnn:n"));
    return function(context17, value6) {
      const byteLength = value6.byteLength ?? value6.length;
      const ptr = Module3._sqlite3_malloc(byteLength);
      Module3.HEAPU8.subarray(ptr).set(value6);
      f(context17, ptr, byteLength, sqliteFreeAddress);
    };
  })();
  sqlite3.result_double = (function() {
    const fname = "sqlite3_result_double";
    const f = Module3.cwrap(fname, ...decl("nn:n"));
    return function(context17, value6) {
      f(context17, value6);
    };
  })();
  sqlite3.result_int = (function() {
    const fname = "sqlite3_result_int";
    const f = Module3.cwrap(fname, ...decl("nn:n"));
    return function(context17, value6) {
      f(context17, value6);
    };
  })();
  sqlite3.result_int64 = (function() {
    const fname = "sqlite3_result_int64";
    const f = Module3.cwrap(fname, ...decl("nnn:n"));
    return function(context17, value6) {
      if (value6 > MAX_INT64 || value6 < MIN_INT64) return SQLITE_RANGE;
      const lo32 = value6 & 0xffffffffn;
      const hi32 = value6 >> 32n;
      f(context17, Number(lo32), Number(hi32));
    };
  })();
  sqlite3.result_null = (function() {
    const fname = "sqlite3_result_null";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(context17) {
      f(context17);
    };
  })();
  sqlite3.result_text = (function() {
    const fname = "sqlite3_result_text";
    const f = Module3.cwrap(fname, ...decl("nnnn:n"));
    return function(context17, value6) {
      const ptr = createUTF8(value6);
      f(context17, ptr, -1, sqliteFreeAddress);
    };
  })();
  sqlite3.row = function(stmt) {
    const row = [];
    const nColumns = sqlite3.data_count(stmt);
    for (let i = 0; i < nColumns; ++i) {
      const value6 = sqlite3.column(stmt, i);
      row.push(value6?.buffer === Module3.HEAPU8.buffer ? value6.slice() : value6);
    }
    return row;
  };
  sqlite3.set_authorizer = function(db, xAuth, pApp) {
    verifyDatabase(db);
    function cvtArgs(_, iAction, p3, p4, p5, p6) {
      return [
        _,
        iAction,
        Module3.UTF8ToString(p3),
        Module3.UTF8ToString(p4),
        Module3.UTF8ToString(p5),
        Module3.UTF8ToString(p6)
      ];
    }
    __name(cvtArgs, "cvtArgs");
    ;
    function adapt(f) {
      return ((_, iAction, p3, p4, p5, p6) => f(...cvtArgs(_, iAction, p3, p4, p5, p6)));
    }
    __name(adapt, "adapt");
    const result = Module3.set_authorizer(db, adapt(xAuth), pApp);
    return check6("sqlite3_set_authorizer", result, db);
  };
  ;
  sqlite3.sql = (function() {
    const fname = "sqlite3_sql";
    const f = Module3.cwrap(fname, ...decl("n:s"));
    return function(stmt) {
      verifyStatement(stmt);
      const result = f(stmt);
      return result;
    };
  })();
  sqlite3.statements = function(db, sql2, options4 = {}) {
    const prepare = Module3.cwrap(
      "sqlite3_prepare_v3",
      "number",
      ["number", "number", "number", "number", "number", "number"],
      // { async: true });
      { async: false }
    );
    const stmts = [];
    const onFinally = [];
    const utf8 = textEncoder3.encode(sql2);
    const allocSize = utf8.byteLength - utf8.byteLength % 4 + 12;
    const pzHead = Module3._sqlite3_malloc(allocSize);
    const pzEnd = pzHead + utf8.byteLength + 1;
    onFinally.push(() => Module3._sqlite3_free(pzHead));
    Module3.HEAPU8.set(utf8, pzHead);
    Module3.HEAPU8[pzEnd - 1] = 0;
    const pStmt = pzHead + allocSize - 8;
    const pzTail = pzHead + allocSize - 4;
    let stmt;
    function maybeFinalize() {
      if (stmt && !options4.unscoped) {
        sqlite3.finalize(stmt);
      }
      stmt = 0;
    }
    __name(maybeFinalize, "maybeFinalize");
    onFinally.push(maybeFinalize);
    Module3.setValue(pzTail, pzHead, "*");
    do {
      maybeFinalize();
      const zTail = Module3.getValue(pzTail, "*");
      const rc = prepare(
        db,
        zTail,
        pzEnd - pzTail,
        options4.flags || 0,
        pStmt,
        pzTail
      );
      if (rc !== SQLITE_OK) {
        check6("sqlite3_prepare_v3", rc, db);
      }
      stmt = Module3.getValue(pStmt, "*");
      if (stmt) {
        mapStmtToDB.set(stmt, db);
        stmts.push(stmt);
      }
    } while (stmt);
    return stmts;
  };
  sqlite3.step = (function() {
    const fname = "sqlite3_step";
    const f = Module3.cwrap(fname, ...decl("n:n"), { async: async3 });
    return function(stmt) {
      verifyStatement(stmt);
      const rc = f(stmt);
      return check6(fname, rc, mapStmtToDB.get(stmt), [SQLITE_ROW, SQLITE_DONE]);
    };
  })();
  sqlite3.commit_hook = function(db, xCommitHook) {
    verifyDatabase(db);
    Module3.commit_hook(db, xCommitHook);
  };
  sqlite3.update_hook = function(db, xUpdateHook) {
    verifyDatabase(db);
    function cvtArgs(iUpdateType, dbName, tblName, lo32, hi32) {
      return [
        iUpdateType,
        Module3.UTF8ToString(dbName),
        Module3.UTF8ToString(tblName),
        cvt32x2ToBigInt(lo32, hi32)
      ];
    }
    __name(cvtArgs, "cvtArgs");
    ;
    function adapt(f) {
      return ((iUpdateType, dbName, tblName, lo32, hi32) => f(...cvtArgs(iUpdateType, dbName, tblName, lo32, hi32)));
    }
    __name(adapt, "adapt");
    Module3.update_hook(db, adapt(xUpdateHook));
  };
  ;
  sqlite3.session_create = (function() {
    const fname = "sqlite3session_create";
    const f = Module3.cwrap(fname, ...decl("nsn:n"));
    return function(db, zDb) {
      verifyDatabase(db);
      const ppSession = Module3._malloc(4);
      const result = f(db, zDb, ppSession);
      if (result !== SQLITE_OK) {
        check6(fname, result, db);
      }
      const pSession = Module3.getValue(ppSession, "i32");
      return pSession;
    };
  })();
  sqlite3.session_attach = (function() {
    const fname = "sqlite3session_attach";
    const f = Module3.cwrap(fname, ...decl("ns:n"));
    return function(pSession, zTab) {
      if (typeof pSession !== "number") {
        throw new SQLiteError("Invalid session object", SQLITE_MISUSE);
      }
      const result = f(pSession, zTab);
      return check6(fname, result);
    };
  })();
  sqlite3.session_enable = (function() {
    const fname = "sqlite3session_enable";
    const f = Module3.cwrap(fname, ...decl("nn:n"));
    return function(pSession, enableBool) {
      const enable4 = enableBool ? 1 : 0;
      if (typeof pSession !== "number") {
        throw new SQLiteError("Invalid session object", SQLITE_MISUSE);
      }
      const result = f(pSession, enable4);
      if (result !== enable4) {
        throw new SQLiteError("Failed to enable session", SQLITE_MISUSE);
      }
    };
  })();
  sqlite3.session_changeset = (function() {
    const fname = "sqlite3session_changeset";
    const f = Module3.cwrap(fname, ...decl("nnn:n"));
    return function(pSession) {
      if (typeof pSession !== "number") {
        throw new SQLiteError("Invalid session object", SQLITE_MISUSE);
      }
      const sizePtr = Module3._malloc(4);
      const changesetPtrPtr = Module3._malloc(4);
      try {
        const result = f(pSession, sizePtr, changesetPtrPtr);
        if (result === SQLITE_OK) {
          const size22 = Module3.getValue(sizePtr, "i32");
          const changesetPtr = Module3.getValue(changesetPtrPtr, "i32");
          if (changesetPtr === 0) {
            return {
              result,
              size: 0,
              changeset: null
            };
          }
          const changeset = new Uint8Array(Module3.HEAPU8.subarray(changesetPtr, changesetPtr + size22));
          Module3._sqlite3_free(changesetPtr);
          return {
            result,
            size: size22,
            changeset
          };
        }
        return check6(fname, result);
      } finally {
        Module3._free(sizePtr);
        Module3._free(changesetPtrPtr);
      }
    };
  })();
  sqlite3.session_delete = (function() {
    const fname = "sqlite3session_delete";
    const f = Module3.cwrap(fname, ...decl("n:v"));
    return function(pSession) {
      if (typeof pSession !== "number") {
        throw new SQLiteError("Invalid session object", SQLITE_MISUSE);
      }
      const result = f(pSession);
      return result;
    };
  })();
  sqlite3.changeset_start = (function() {
    const fname = "sqlite3changeset_start";
    const f = Module3.cwrap(fname, ...decl("nnn:n"));
    return function(changesetData) {
      const inPtr = Module3._sqlite3_malloc(changesetData.length);
      Module3.HEAPU8.subarray(inPtr).set(changesetData);
      const ppIter = Module3._malloc(4);
      try {
        const result = f(ppIter, changesetData.length, inPtr);
        if (result !== SQLITE_OK) {
          check6(fname, result);
        }
        const pIter = Module3.getValue(ppIter, "i32");
        return pIter;
      } finally {
        Module3._sqlite3_free(inPtr);
        Module3._free(ppIter);
      }
    };
  })();
  sqlite3.changeset_finalize = (function() {
    const fname = "sqlite3changeset_finalize";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(pIter) {
      const result = f(pIter);
      return result;
    };
  })();
  sqlite3.changeset_invert = (function() {
    const fname = "sqlite3changeset_invert";
    const f = Module3.cwrap(fname, ...decl("nn:nn"));
    return function(changesetData) {
      const inPtr = Module3._sqlite3_malloc(changesetData.length);
      Module3.HEAPU8.subarray(inPtr).set(changesetData);
      const outLengthPtr = Module3._malloc(4);
      const outPtrPtr = Module3._malloc(4);
      const result = f(changesetData.length, inPtr, outLengthPtr, outPtrPtr);
      if (result !== SQLITE_OK) {
        check6(fname, result);
      }
      const outLength = Module3.getValue(outLengthPtr, "i32");
      const changesetOutPtr = Module3.getValue(outPtrPtr, "i32");
      const changesetOut = new Uint8Array(Module3.HEAPU8.buffer, changesetOutPtr, outLength).slice();
      Module3._sqlite3_free(inPtr);
      Module3._sqlite3_free(changesetOutPtr);
      return changesetOut;
    };
  })();
  sqlite3.session_changeset_inverted = (function() {
    const fnameChangeset = "sqlite3session_changeset";
    const fChangeset = Module3.cwrap(fnameChangeset, ...decl("nnn:n"));
    const fnameInvert = "sqlite3changeset_invert";
    const fInvert = Module3.cwrap(fnameInvert, ...decl("nn:nn"));
    return function(pSession) {
      if (typeof pSession !== "number") {
        throw new SQLiteError("Invalid session object", SQLITE_MISUSE);
      }
      const sizePtr = Module3._malloc(4);
      const changesetPtrPtr = Module3._malloc(4);
      const sizePtrInvert = Module3._malloc(4);
      const changesetPtrPtrInvert = Module3._malloc(4);
      try {
        const changesetResult = fChangeset(pSession, sizePtr, changesetPtrPtr);
        if (changesetResult !== SQLITE_OK) {
          return check6(fnameChangeset, changesetResult);
        }
        const size22 = Module3.getValue(sizePtr, "i32");
        const changesetPtr = Module3.getValue(changesetPtrPtr, "i32");
        const invertedResult = fInvert(size22, changesetPtr, sizePtrInvert, changesetPtrPtrInvert);
        if (invertedResult !== SQLITE_OK) {
          return check6(fnameInvert, invertedResult);
        }
        const sizeInvert = Module3.getValue(sizePtrInvert, "i32");
        const changesetPtrInvert = Module3.getValue(changesetPtrPtrInvert, "i32");
        const changesetInvert = new Uint8Array(Module3.HEAPU8.buffer, changesetPtrInvert, sizeInvert);
        Module3._sqlite3_free(changesetPtr);
        Module3._sqlite3_free(changesetPtrInvert);
        return {
          result: changesetResult,
          size: size22,
          changeset: new Uint8Array(changesetInvert)
        };
      } finally {
        Module3._free(sizePtr);
        Module3._free(changesetPtrPtr);
        Module3._free(sizePtrInvert);
        Module3._free(changesetPtrPtrInvert);
      }
    };
  })();
  sqlite3.changeset_apply = (function() {
    const fname = "sqlite3changeset_apply";
    const f = Module3.cwrap(fname, ...decl("nnnnnn:n"));
    return function(db, changesetData, options4) {
      const inPtr = Module3._sqlite3_malloc(changesetData.length);
      Module3.HEAPU8.subarray(inPtr).set(changesetData);
      const SQLITE_CHANGESET_REPLACE = 1;
      const onConflict = /* @__PURE__ */ __name(() => {
        return SQLITE_CHANGESET_REPLACE;
      }, "onConflict");
      const result = f(db, changesetData.length, inPtr, null, onConflict, null);
      Module3._sqlite3_free(inPtr);
      if (result !== SQLITE_OK) {
        check6(fname, result);
      }
      return result;
    };
  })();
  sqlite3.value = function(pValue) {
    const type3 = sqlite3.value_type(pValue);
    switch (type3) {
      case SQLITE_BLOB:
        return sqlite3.value_blob(pValue);
      case SQLITE_FLOAT:
        return sqlite3.value_double(pValue);
      case SQLITE_INTEGER:
        const lo32 = sqlite3.value_int(pValue);
        const hi32 = Module3.getTempRet0();
        return cvt32x2AsSafe(lo32, hi32);
      case SQLITE_NULL:
        return null;
      case SQLITE_TEXT:
        return sqlite3.value_text(pValue);
      default:
        throw new SQLiteError("unknown type", type3);
    }
  };
  sqlite3.value_blob = (function() {
    const fname = "sqlite3_value_blob";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const nBytes = sqlite3.value_bytes(pValue);
      const address = f(pValue);
      const result = Module3.HEAPU8.subarray(address, address + nBytes);
      return result;
    };
  })();
  sqlite3.value_bytes = (function() {
    const fname = "sqlite3_value_bytes";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  })();
  sqlite3.value_double = (function() {
    const fname = "sqlite3_value_double";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  })();
  sqlite3.value_int = (function() {
    const fname = "sqlite3_value_int64";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  })();
  sqlite3.value_int64 = (function() {
    const fname = "sqlite3_value_int64";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const lo32 = f(pValue);
      const hi32 = Module3.getTempRet0();
      const result = cvt32x2ToBigInt(lo32, hi32);
      return result;
    };
  })();
  sqlite3.value_text = (function() {
    const fname = "sqlite3_value_text";
    const f = Module3.cwrap(fname, ...decl("n:s"));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  })();
  sqlite3.value_type = (function() {
    const fname = "sqlite3_value_type";
    const f = Module3.cwrap(fname, ...decl("n:n"));
    return function(pValue) {
      const result = f(pValue);
      return result;
    };
  })();
  const registeredVfs = /* @__PURE__ */ new Set();
  sqlite3.vfs_register = function(vfs, makeDefault) {
    if (registeredVfs.has(vfs.name)) return;
    const result = Module3.vfs_register(vfs, makeDefault);
    const res = check6("sqlite3_vfs_register", result);
    registeredVfs.add(vfs.name);
    return res;
  };
  sqlite3.vfs_registered = registeredVfs;
  function check6(fname, result, db = null, allowed = [SQLITE_OK]) {
    if (allowed.includes(result)) return result;
    const message = db ? Module3.ccall("sqlite3_errmsg", "string", ["number"], [db]) : fname;
    throw new SQLiteError(message, result);
  }
  __name(check6, "check");
  async function retry10(f) {
    let rc;
    do {
      if (Module3.retryOps.length) {
        await Promise.all(Module3.retryOps);
        Module3.retryOps = [];
      }
      rc = await f();
    } while (rc && Module3.retryOps.length);
    return rc;
  }
  __name(retry10, "retry");
  return sqlite3;
}
__name(Factory, "Factory");
function decl(s) {
  const result = [];
  const m = s.match(/([ns@]*):([nsv@])/);
  switch (m[2]) {
    case "n":
      result.push("number");
      break;
    case "s":
      result.push("string");
      break;
    case "v":
      result.push(null);
      break;
  }
  const args2 = [];
  for (let c of m[1]) {
    switch (c) {
      case "n":
        args2.push("number");
        break;
      case "s":
        args2.push("string");
        break;
    }
  }
  result.push(args2);
  return result;
}
__name(decl, "decl");

// node_modules/.pnpm/@livestore+wa-sqlite@1.0.8-dev.4/node_modules/@livestore/wa-sqlite/dist/wa-sqlite.mjs
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var Module2 = (() => {
  var _scriptName = import.meta.url;
  return (function(moduleArg = {}) {
    var moduleRtn;
    var Module3 = moduleArg;
    var readyPromiseResolve, readyPromiseReject;
    var readyPromise = new Promise((resolve3, reject3) => {
      readyPromiseResolve = resolve3;
      readyPromiseReject = reject3;
    });
    var ENVIRONMENT_IS_WEB = typeof window == "object";
    var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != "undefined";
    var ENVIRONMENT_IS_NODE = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
    var moduleOverrides = Object.assign({}, Module3);
    var arguments_ = [];
    var thisProgram = "./this.program";
    var quit_ = /* @__PURE__ */ __name((status3, toThrow) => {
      throw toThrow;
    }, "quit_");
    var scriptDirectory = "";
    function locateFile(path) {
      if (Module3["locateFile"]) {
        return Module3["locateFile"](path, scriptDirectory);
      }
      return scriptDirectory + path;
    }
    __name(locateFile, "locateFile");
    var readAsync, readBinary;
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
      if (ENVIRONMENT_IS_WORKER) {
        scriptDirectory = self.location && self.location.href || "";
      } else if (typeof document != "undefined" && document.currentScript) {
        scriptDirectory = document.currentScript.src;
      }
      if (_scriptName) {
        scriptDirectory = _scriptName;
      }
      if (scriptDirectory.startsWith("blob:")) {
        scriptDirectory = "";
      } else {
        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
      }
      {
        if (ENVIRONMENT_IS_WORKER) {
          readBinary = /* @__PURE__ */ __name((url2) => {
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url2, false);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
            return new Uint8Array(xhr.response);
          }, "readBinary");
        }
        readAsync = /* @__PURE__ */ __name((url2) => fetch(url2, { credentials: "same-origin" }).then((response) => {
          if (response.ok) {
            return response.arrayBuffer();
          }
          return Promise.reject(new Error(response.status + " : " + response.url));
        }), "readAsync");
      }
    } else {
    }
    var out = Module3["print"] || console.log.bind(console);
    var err = Module3["printErr"] || console.error.bind(console);
    Object.assign(Module3, moduleOverrides);
    moduleOverrides = null;
    if (Module3["arguments"]) arguments_ = Module3["arguments"];
    if (Module3["thisProgram"]) thisProgram = Module3["thisProgram"];
    var wasmBinary = Module3["wasmBinary"];
    var wasmMemory;
    var ABORT = false;
    var EXITSTATUS;
    var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
    function updateMemoryViews() {
      var b = wasmMemory.buffer;
      Module3["HEAP8"] = HEAP8 = new Int8Array(b);
      Module3["HEAP16"] = HEAP16 = new Int16Array(b);
      Module3["HEAPU8"] = HEAPU8 = new Uint8Array(b);
      Module3["HEAPU16"] = HEAPU16 = new Uint16Array(b);
      Module3["HEAP32"] = HEAP32 = new Int32Array(b);
      Module3["HEAPU32"] = HEAPU32 = new Uint32Array(b);
      Module3["HEAPF32"] = HEAPF32 = new Float32Array(b);
      Module3["HEAPF64"] = HEAPF64 = new Float64Array(b);
    }
    __name(updateMemoryViews, "updateMemoryViews");
    var __ATPRERUN__ = [];
    var __ATINIT__ = [];
    var __ATMAIN__ = [];
    var __ATPOSTRUN__ = [];
    var runtimeInitialized = false;
    function preRun() {
      if (Module3["preRun"]) {
        if (typeof Module3["preRun"] == "function") Module3["preRun"] = [Module3["preRun"]];
        while (Module3["preRun"].length) {
          addOnPreRun(Module3["preRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPRERUN__);
    }
    __name(preRun, "preRun");
    function initRuntime() {
      runtimeInitialized = true;
      if (!Module3["noFSInit"] && !FS.initialized) FS.init();
      FS.ignorePermissions = false;
      TTY.init();
      callRuntimeCallbacks(__ATINIT__);
    }
    __name(initRuntime, "initRuntime");
    function preMain() {
      callRuntimeCallbacks(__ATMAIN__);
    }
    __name(preMain, "preMain");
    function postRun() {
      if (Module3["postRun"]) {
        if (typeof Module3["postRun"] == "function") Module3["postRun"] = [Module3["postRun"]];
        while (Module3["postRun"].length) {
          addOnPostRun(Module3["postRun"].shift());
        }
      }
      callRuntimeCallbacks(__ATPOSTRUN__);
    }
    __name(postRun, "postRun");
    function addOnPreRun(cb) {
      __ATPRERUN__.unshift(cb);
    }
    __name(addOnPreRun, "addOnPreRun");
    function addOnInit(cb) {
      __ATINIT__.unshift(cb);
    }
    __name(addOnInit, "addOnInit");
    function addOnPostRun(cb) {
      __ATPOSTRUN__.unshift(cb);
    }
    __name(addOnPostRun, "addOnPostRun");
    var runDependencies = 0;
    var runDependencyWatcher = null;
    var dependenciesFulfilled = null;
    function getUniqueRunDependency(id4) {
      return id4;
    }
    __name(getUniqueRunDependency, "getUniqueRunDependency");
    function addRunDependency(id4) {
      runDependencies++;
      Module3["monitorRunDependencies"]?.(runDependencies);
    }
    __name(addRunDependency, "addRunDependency");
    function removeRunDependency(id4) {
      runDependencies--;
      Module3["monitorRunDependencies"]?.(runDependencies);
      if (runDependencies == 0) {
        if (runDependencyWatcher !== null) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
        }
        if (dependenciesFulfilled) {
          var callback = dependenciesFulfilled;
          dependenciesFulfilled = null;
          callback();
        }
      }
    }
    __name(removeRunDependency, "removeRunDependency");
    function abort2(what) {
      Module3["onAbort"]?.(what);
      what = "Aborted(" + what + ")";
      err(what);
      ABORT = true;
      what += ". Build with -sASSERTIONS for more info.";
      var e = new WebAssembly.RuntimeError(what);
      readyPromiseReject(e);
      throw e;
    }
    __name(abort2, "abort");
    var dataURIPrefix = "data:application/octet-stream;base64,";
    var isDataURI = /* @__PURE__ */ __name((filename) => filename.startsWith(dataURIPrefix), "isDataURI");
    function findWasmBinary() {
      if (Module3["locateFile"]) {
        var f = "wa-sqlite.wasm";
        if (!isDataURI(f)) {
          return locateFile(f);
        }
        return f;
      }
      return new URL("wa-sqlite.wasm", import.meta.url).href;
    }
    __name(findWasmBinary, "findWasmBinary");
    var wasmBinaryFile;
    function getBinarySync(file3) {
      if (file3 == wasmBinaryFile && wasmBinary) {
        return new Uint8Array(wasmBinary);
      }
      if (readBinary) {
        return readBinary(file3);
      }
      throw "both async and sync fetching of the wasm failed";
    }
    __name(getBinarySync, "getBinarySync");
    function getBinaryPromise(binaryFile) {
      if (!wasmBinary) {
        return readAsync(binaryFile).then((response) => new Uint8Array(response), () => getBinarySync(binaryFile));
      }
      return Promise.resolve().then(() => getBinarySync(binaryFile));
    }
    __name(getBinaryPromise, "getBinaryPromise");
    function instantiateArrayBuffer(binaryFile, imports, receiver) {
      return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
        err(`failed to asynchronously prepare wasm: ${reason}`);
        abort2(reason);
      });
    }
    __name(instantiateArrayBuffer, "instantiateArrayBuffer");
    function instantiateAsync(binary, binaryFile, imports, callback) {
      if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && typeof fetch == "function") {
        return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
          var result = WebAssembly.instantiateStreaming(response, imports);
          return result.then(callback, function(reason) {
            err(`wasm streaming compile failed: ${reason}`);
            err("falling back to ArrayBuffer instantiation");
            return instantiateArrayBuffer(binaryFile, imports, callback);
          });
        });
      }
      return instantiateArrayBuffer(binaryFile, imports, callback);
    }
    __name(instantiateAsync, "instantiateAsync");
    function getWasmImports() {
      return { a: wasmImports };
    }
    __name(getWasmImports, "getWasmImports");
    function createWasm() {
      function receiveInstance(instance, module) {
        wasmExports = instance.exports;
        wasmMemory = wasmExports["la"];
        updateMemoryViews();
        wasmTable = wasmExports["of"];
        addOnInit(wasmExports["ma"]);
        removeRunDependency("wasm-instantiate");
        return wasmExports;
      }
      __name(receiveInstance, "receiveInstance");
      addRunDependency("wasm-instantiate");
      function receiveInstantiationResult(result) {
        receiveInstance(result["instance"]);
      }
      __name(receiveInstantiationResult, "receiveInstantiationResult");
      var info4 = getWasmImports();
      if (Module3["instantiateWasm"]) {
        try {
          return Module3["instantiateWasm"](info4, receiveInstance);
        } catch (e) {
          err(`Module.instantiateWasm callback failed with error: ${e}`);
          readyPromiseReject(e);
        }
      }
      wasmBinaryFile ??= findWasmBinary();
      instantiateAsync(wasmBinary, wasmBinaryFile, info4, receiveInstantiationResult).catch(readyPromiseReject);
      return {};
    }
    __name(createWasm, "createWasm");
    var tempDouble;
    var tempI64;
    class ExitStatus {
      static {
        __name(this, "ExitStatus");
      }
      name = "ExitStatus";
      constructor(status3) {
        this.message = `Program terminated with exit(${status3})`;
        this.status = status3;
      }
    }
    var callRuntimeCallbacks = /* @__PURE__ */ __name((callbacks) => {
      while (callbacks.length > 0) {
        callbacks.shift()(Module3);
      }
    }, "callRuntimeCallbacks");
    function getValue(ptr, type3 = "i8") {
      if (type3.endsWith("*")) type3 = "*";
      switch (type3) {
        case "i1":
          return HEAP8[ptr];
        case "i8":
          return HEAP8[ptr];
        case "i16":
          return HEAP16[ptr >> 1];
        case "i32":
          return HEAP32[ptr >> 2];
        case "i64":
          abort2("to do getValue(i64) use WASM_BIGINT");
        case "float":
          return HEAPF32[ptr >> 2];
        case "double":
          return HEAPF64[ptr >> 3];
        case "*":
          return HEAPU32[ptr >> 2];
        default:
          abort2(`invalid type for getValue: ${type3}`);
      }
    }
    __name(getValue, "getValue");
    var noExitRuntime = Module3["noExitRuntime"] || true;
    function setValue(ptr, value6, type3 = "i8") {
      if (type3.endsWith("*")) type3 = "*";
      switch (type3) {
        case "i1":
          HEAP8[ptr] = value6;
          break;
        case "i8":
          HEAP8[ptr] = value6;
          break;
        case "i16":
          HEAP16[ptr >> 1] = value6;
          break;
        case "i32":
          HEAP32[ptr >> 2] = value6;
          break;
        case "i64":
          abort2("to do setValue(i64) use WASM_BIGINT");
        case "float":
          HEAPF32[ptr >> 2] = value6;
          break;
        case "double":
          HEAPF64[ptr >> 3] = value6;
          break;
        case "*":
          HEAPU32[ptr >> 2] = value6;
          break;
        default:
          abort2(`invalid type for setValue: ${type3}`);
      }
    }
    __name(setValue, "setValue");
    var stackRestore = /* @__PURE__ */ __name((val) => __emscripten_stack_restore(val), "stackRestore");
    var stackSave = /* @__PURE__ */ __name(() => _emscripten_stack_get_current(), "stackSave");
    var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
    var UTF8ArrayToString = /* @__PURE__ */ __name((heapOrArray, idx = 0, maxBytesToRead = NaN) => {
      var endIdx = idx + maxBytesToRead;
      var endPtr = idx;
      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
      }
      var str = "";
      while (idx < endPtr) {
        var u0 = heapOrArray[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = heapOrArray[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u2 = heapOrArray[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u2;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
      return str;
    }, "UTF8ArrayToString");
    var UTF8ToString = /* @__PURE__ */ __name((ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "", "UTF8ToString");
    var ___assert_fail = /* @__PURE__ */ __name((condition, filename, line, func2) => abort2(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func2 ? UTF8ToString(func2) : "unknown function"]), "___assert_fail");
    var PATH = { isAbs: /* @__PURE__ */ __name((path) => path.charAt(0) === "/", "isAbs"), splitPath: /* @__PURE__ */ __name((filename) => {
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      return splitPathRe.exec(filename).slice(1);
    }, "splitPath"), normalizeArray: /* @__PURE__ */ __name((parts2, allowAboveRoot) => {
      var up = 0;
      for (var i = parts2.length - 1; i >= 0; i--) {
        var last5 = parts2[i];
        if (last5 === ".") {
          parts2.splice(i, 1);
        } else if (last5 === "..") {
          parts2.splice(i, 1);
          up++;
        } else if (up) {
          parts2.splice(i, 1);
          up--;
        }
      }
      if (allowAboveRoot) {
        for (; up; up--) {
          parts2.unshift("..");
        }
      }
      return parts2;
    }, "normalizeArray"), normalize: /* @__PURE__ */ __name((path) => {
      var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
      path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
      if (!path && !isAbsolute) {
        path = ".";
      }
      if (path && trailingSlash) {
        path += "/";
      }
      return (isAbsolute ? "/" : "") + path;
    }, "normalize"), dirname: /* @__PURE__ */ __name((path) => {
      var result = PATH.splitPath(path), root = result[0], dir4 = result[1];
      if (!root && !dir4) {
        return ".";
      }
      if (dir4) {
        dir4 = dir4.substr(0, dir4.length - 1);
      }
      return root + dir4;
    }, "dirname"), basename: /* @__PURE__ */ __name((path) => {
      if (path === "/") return "/";
      path = PATH.normalize(path);
      path = path.replace(/\/$/, "");
      var lastSlash = path.lastIndexOf("/");
      if (lastSlash === -1) return path;
      return path.substr(lastSlash + 1);
    }, "basename"), join: /* @__PURE__ */ __name((...paths) => PATH.normalize(paths.join("/")), "join"), join2: /* @__PURE__ */ __name((l, r) => PATH.normalize(l + "/" + r), "join2") };
    var initRandomFill = /* @__PURE__ */ __name(() => {
      if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
        return (view) => crypto.getRandomValues(view);
      } else abort2("initRandomDevice");
    }, "initRandomFill");
    var randomFill = /* @__PURE__ */ __name((view) => (randomFill = initRandomFill())(view), "randomFill");
    var PATH_FS = { resolve: /* @__PURE__ */ __name((...args2) => {
      var resolvedPath = "", resolvedAbsolute = false;
      for (var i = args2.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = i >= 0 ? args2[i] : FS.cwd();
        if (typeof path != "string") {
          throw new TypeError("Arguments to path.resolve must be strings");
        } else if (!path) {
          return "";
        }
        resolvedPath = path + "/" + resolvedPath;
        resolvedAbsolute = PATH.isAbs(path);
      }
      resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
      return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
    }, "resolve"), relative: /* @__PURE__ */ __name((from, to) => {
      from = PATH_FS.resolve(from).substr(1);
      to = PATH_FS.resolve(to).substr(1);
      function trim(arr) {
        var start3 = 0;
        for (; start3 < arr.length; start3++) {
          if (arr[start3] !== "") break;
        }
        var end6 = arr.length - 1;
        for (; end6 >= 0; end6--) {
          if (arr[end6] !== "") break;
        }
        if (start3 > end6) return [];
        return arr.slice(start3, end6 - start3 + 1);
      }
      __name(trim, "trim");
      var fromParts = trim(from.split("/"));
      var toParts2 = trim(to.split("/"));
      var length5 = Math.min(fromParts.length, toParts2.length);
      var samePartsLength = length5;
      for (var i = 0; i < length5; i++) {
        if (fromParts[i] !== toParts2[i]) {
          samePartsLength = i;
          break;
        }
      }
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push("..");
      }
      outputParts = outputParts.concat(toParts2.slice(samePartsLength));
      return outputParts.join("/");
    }, "relative") };
    var FS_stdin_getChar_buffer = [];
    var lengthBytesUTF8 = /* @__PURE__ */ __name((str) => {
      var len = 0;
      for (var i = 0; i < str.length; ++i) {
        var c = str.charCodeAt(i);
        if (c <= 127) {
          len++;
        } else if (c <= 2047) {
          len += 2;
        } else if (c >= 55296 && c <= 57343) {
          len += 4;
          ++i;
        } else {
          len += 3;
        }
      }
      return len;
    }, "lengthBytesUTF8");
    var stringToUTF8Array = /* @__PURE__ */ __name((str, heap, outIdx, maxBytesToWrite) => {
      if (!(maxBytesToWrite > 0)) return 0;
      var startIdx = outIdx;
      var endIdx = outIdx + maxBytesToWrite - 1;
      for (var i = 0; i < str.length; ++i) {
        var u = str.charCodeAt(i);
        if (u >= 55296 && u <= 57343) {
          var u1 = str.charCodeAt(++i);
          u = 65536 + ((u & 1023) << 10) | u1 & 1023;
        }
        if (u <= 127) {
          if (outIdx >= endIdx) break;
          heap[outIdx++] = u;
        } else if (u <= 2047) {
          if (outIdx + 1 >= endIdx) break;
          heap[outIdx++] = 192 | u >> 6;
          heap[outIdx++] = 128 | u & 63;
        } else if (u <= 65535) {
          if (outIdx + 2 >= endIdx) break;
          heap[outIdx++] = 224 | u >> 12;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        } else {
          if (outIdx + 3 >= endIdx) break;
          heap[outIdx++] = 240 | u >> 18;
          heap[outIdx++] = 128 | u >> 12 & 63;
          heap[outIdx++] = 128 | u >> 6 & 63;
          heap[outIdx++] = 128 | u & 63;
        }
      }
      heap[outIdx] = 0;
      return outIdx - startIdx;
    }, "stringToUTF8Array");
    function intArrayFromString(stringy, dontAddNull, length5) {
      var len = length5 > 0 ? length5 : lengthBytesUTF8(stringy) + 1;
      var u8array = new Array(len);
      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
      if (dontAddNull) u8array.length = numBytesWritten;
      return u8array;
    }
    __name(intArrayFromString, "intArrayFromString");
    var FS_stdin_getChar = /* @__PURE__ */ __name(() => {
      if (!FS_stdin_getChar_buffer.length) {
        var result = null;
        if (typeof window != "undefined" && typeof window.prompt == "function") {
          result = window.prompt("Input: ");
          if (result !== null) {
            result += "\n";
          }
        } else {
        }
        if (!result) {
          return null;
        }
        FS_stdin_getChar_buffer = intArrayFromString(result, true);
      }
      return FS_stdin_getChar_buffer.shift();
    }, "FS_stdin_getChar");
    var TTY = { ttys: [], init() {
    }, shutdown() {
    }, register(dev, ops) {
      TTY.ttys[dev] = { input: [], output: [], ops };
      FS.registerDevice(dev, TTY.stream_ops);
    }, stream_ops: { open(stream6) {
      var tty = TTY.ttys[stream6.node.rdev];
      if (!tty) {
        throw new FS.ErrnoError(43);
      }
      stream6.tty = tty;
      stream6.seekable = false;
    }, close(stream6) {
      stream6.tty.ops.fsync(stream6.tty);
    }, fsync(stream6) {
      stream6.tty.ops.fsync(stream6.tty);
    }, read(stream6, buffer4, offset, length5, pos) {
      if (!stream6.tty || !stream6.tty.ops.get_char) {
        throw new FS.ErrnoError(60);
      }
      var bytesRead = 0;
      for (var i = 0; i < length5; i++) {
        var result;
        try {
          result = stream6.tty.ops.get_char(stream6.tty);
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (result === void 0 && bytesRead === 0) {
          throw new FS.ErrnoError(6);
        }
        if (result === null || result === void 0) break;
        bytesRead++;
        buffer4[offset + i] = result;
      }
      if (bytesRead) {
        stream6.node.timestamp = Date.now();
      }
      return bytesRead;
    }, write(stream6, buffer4, offset, length5, pos) {
      if (!stream6.tty || !stream6.tty.ops.put_char) {
        throw new FS.ErrnoError(60);
      }
      try {
        for (var i = 0; i < length5; i++) {
          stream6.tty.ops.put_char(stream6.tty, buffer4[offset + i]);
        }
      } catch (e) {
        throw new FS.ErrnoError(29);
      }
      if (length5) {
        stream6.node.timestamp = Date.now();
      }
      return i;
    } }, default_tty_ops: { get_char(tty) {
      return FS_stdin_getChar();
    }, put_char(tty, val) {
      if (val === null || val === 10) {
        out(UTF8ArrayToString(tty.output));
        tty.output = [];
      } else {
        if (val != 0) tty.output.push(val);
      }
    }, fsync(tty) {
      if (tty.output && tty.output.length > 0) {
        out(UTF8ArrayToString(tty.output));
        tty.output = [];
      }
    }, ioctl_tcgets(tty) {
      return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
    }, ioctl_tcsets(tty, optional_actions, data) {
      return 0;
    }, ioctl_tiocgwinsz(tty) {
      return [24, 80];
    } }, default_tty1_ops: { put_char(tty, val) {
      if (val === null || val === 10) {
        err(UTF8ArrayToString(tty.output));
        tty.output = [];
      } else {
        if (val != 0) tty.output.push(val);
      }
    }, fsync(tty) {
      if (tty.output && tty.output.length > 0) {
        err(UTF8ArrayToString(tty.output));
        tty.output = [];
      }
    } } };
    var zeroMemory = /* @__PURE__ */ __name((address, size22) => {
      HEAPU8.fill(0, address, address + size22);
    }, "zeroMemory");
    var alignMemory = /* @__PURE__ */ __name((size22, alignment) => Math.ceil(size22 / alignment) * alignment, "alignMemory");
    var mmapAlloc = /* @__PURE__ */ __name((size22) => {
      size22 = alignMemory(size22, 65536);
      var ptr = _emscripten_builtin_memalign(65536, size22);
      if (ptr) zeroMemory(ptr, size22);
      return ptr;
    }, "mmapAlloc");
    var MEMFS = { ops_table: null, mount(mount2) {
      return MEMFS.createNode(null, "/", 16895, 0);
    }, createNode(parent, name, mode, dev) {
      if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
        throw new FS.ErrnoError(63);
      }
      MEMFS.ops_table ||= { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
      var node = FS.createNode(parent, name, mode, dev);
      if (FS.isDir(node.mode)) {
        node.node_ops = MEMFS.ops_table.dir.node;
        node.stream_ops = MEMFS.ops_table.dir.stream;
        node.contents = {};
      } else if (FS.isFile(node.mode)) {
        node.node_ops = MEMFS.ops_table.file.node;
        node.stream_ops = MEMFS.ops_table.file.stream;
        node.usedBytes = 0;
        node.contents = null;
      } else if (FS.isLink(node.mode)) {
        node.node_ops = MEMFS.ops_table.link.node;
        node.stream_ops = MEMFS.ops_table.link.stream;
      } else if (FS.isChrdev(node.mode)) {
        node.node_ops = MEMFS.ops_table.chrdev.node;
        node.stream_ops = MEMFS.ops_table.chrdev.stream;
      }
      node.timestamp = Date.now();
      if (parent) {
        parent.contents[name] = node;
        parent.timestamp = node.timestamp;
      }
      return node;
    }, getFileDataAsTypedArray(node) {
      if (!node.contents) return new Uint8Array(0);
      if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
      return new Uint8Array(node.contents);
    }, expandFileStorage(node, newCapacity) {
      var prevCapacity = node.contents ? node.contents.length : 0;
      if (prevCapacity >= newCapacity) return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
      var oldContents = node.contents;
      node.contents = new Uint8Array(newCapacity);
      if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
    }, resizeFileStorage(node, newSize) {
      if (node.usedBytes == newSize) return;
      if (newSize == 0) {
        node.contents = null;
        node.usedBytes = 0;
      } else {
        var oldContents = node.contents;
        node.contents = new Uint8Array(newSize);
        if (oldContents) {
          node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
        }
        node.usedBytes = newSize;
      }
    }, node_ops: { getattr(node) {
      var attr = {};
      attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
      attr.ino = node.id;
      attr.mode = node.mode;
      attr.nlink = 1;
      attr.uid = 0;
      attr.gid = 0;
      attr.rdev = node.rdev;
      if (FS.isDir(node.mode)) {
        attr.size = 4096;
      } else if (FS.isFile(node.mode)) {
        attr.size = node.usedBytes;
      } else if (FS.isLink(node.mode)) {
        attr.size = node.link.length;
      } else {
        attr.size = 0;
      }
      attr.atime = new Date(node.timestamp);
      attr.mtime = new Date(node.timestamp);
      attr.ctime = new Date(node.timestamp);
      attr.blksize = 4096;
      attr.blocks = Math.ceil(attr.size / attr.blksize);
      return attr;
    }, setattr(node, attr) {
      if (attr.mode !== void 0) {
        node.mode = attr.mode;
      }
      if (attr.timestamp !== void 0) {
        node.timestamp = attr.timestamp;
      }
      if (attr.size !== void 0) {
        MEMFS.resizeFileStorage(node, attr.size);
      }
    }, lookup(parent, name) {
      throw MEMFS.doesNotExistError;
    }, mknod(parent, name, mode, dev) {
      return MEMFS.createNode(parent, name, mode, dev);
    }, rename(old_node, new_dir, new_name) {
      if (FS.isDir(old_node.mode)) {
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (new_node) {
          for (var i in new_node.contents) {
            throw new FS.ErrnoError(55);
          }
        }
      }
      delete old_node.parent.contents[old_node.name];
      old_node.parent.timestamp = Date.now();
      old_node.name = new_name;
      new_dir.contents[new_name] = old_node;
      new_dir.timestamp = old_node.parent.timestamp;
    }, unlink(parent, name) {
      delete parent.contents[name];
      parent.timestamp = Date.now();
    }, rmdir(parent, name) {
      var node = FS.lookupNode(parent, name);
      for (var i in node.contents) {
        throw new FS.ErrnoError(55);
      }
      delete parent.contents[name];
      parent.timestamp = Date.now();
    }, readdir(node) {
      var entries3 = [".", ".."];
      for (var key of Object.keys(node.contents)) {
        entries3.push(key);
      }
      return entries3;
    }, symlink(parent, newname, oldpath) {
      var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
      node.link = oldpath;
      return node;
    }, readlink(node) {
      if (!FS.isLink(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      return node.link;
    } }, stream_ops: { read(stream6, buffer4, offset, length5, position5) {
      var contents = stream6.node.contents;
      if (position5 >= stream6.node.usedBytes) return 0;
      var size22 = Math.min(stream6.node.usedBytes - position5, length5);
      if (size22 > 8 && contents.subarray) {
        buffer4.set(contents.subarray(position5, position5 + size22), offset);
      } else {
        for (var i = 0; i < size22; i++) buffer4[offset + i] = contents[position5 + i];
      }
      return size22;
    }, write(stream6, buffer4, offset, length5, position5, canOwn) {
      if (buffer4.buffer === HEAP8.buffer) {
        canOwn = false;
      }
      if (!length5) return 0;
      var node = stream6.node;
      node.timestamp = Date.now();
      if (buffer4.subarray && (!node.contents || node.contents.subarray)) {
        if (canOwn) {
          node.contents = buffer4.subarray(offset, offset + length5);
          node.usedBytes = length5;
          return length5;
        } else if (node.usedBytes === 0 && position5 === 0) {
          node.contents = buffer4.slice(offset, offset + length5);
          node.usedBytes = length5;
          return length5;
        } else if (position5 + length5 <= node.usedBytes) {
          node.contents.set(buffer4.subarray(offset, offset + length5), position5);
          return length5;
        }
      }
      MEMFS.expandFileStorage(node, position5 + length5);
      if (node.contents.subarray && buffer4.subarray) {
        node.contents.set(buffer4.subarray(offset, offset + length5), position5);
      } else {
        for (var i = 0; i < length5; i++) {
          node.contents[position5 + i] = buffer4[offset + i];
        }
      }
      node.usedBytes = Math.max(node.usedBytes, position5 + length5);
      return length5;
    }, llseek(stream6, offset, whence) {
      var position5 = offset;
      if (whence === 1) {
        position5 += stream6.position;
      } else if (whence === 2) {
        if (FS.isFile(stream6.node.mode)) {
          position5 += stream6.node.usedBytes;
        }
      }
      if (position5 < 0) {
        throw new FS.ErrnoError(28);
      }
      return position5;
    }, allocate(stream6, offset, length5) {
      MEMFS.expandFileStorage(stream6.node, offset + length5);
      stream6.node.usedBytes = Math.max(stream6.node.usedBytes, offset + length5);
    }, mmap(stream6, length5, position5, prot, flags) {
      if (!FS.isFile(stream6.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      var ptr;
      var allocated;
      var contents = stream6.node.contents;
      if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
        allocated = false;
        ptr = contents.byteOffset;
      } else {
        allocated = true;
        ptr = mmapAlloc(length5);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        if (contents) {
          if (position5 > 0 || position5 + length5 < contents.length) {
            if (contents.subarray) {
              contents = contents.subarray(position5, position5 + length5);
            } else {
              contents = Array.prototype.slice.call(contents, position5, position5 + length5);
            }
          }
          HEAP8.set(contents, ptr);
        }
      }
      return { ptr, allocated };
    }, msync(stream6, buffer4, offset, length5, mmapFlags) {
      MEMFS.stream_ops.write(stream6, buffer4, 0, length5, offset, false);
      return 0;
    } } };
    var asyncLoad = /* @__PURE__ */ __name((url2, onload, onerror, noRunDep) => {
      var dep = !noRunDep ? getUniqueRunDependency(`al ${url2}`) : "";
      readAsync(url2).then((arrayBuffer) => {
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, (err2) => {
        if (onerror) {
          onerror();
        } else {
          throw `Loading data file "${url2}" failed.`;
        }
      });
      if (dep) addRunDependency(dep);
    }, "asyncLoad");
    var FS_createDataFile = /* @__PURE__ */ __name((parent, name, fileData, canRead, canWrite, canOwn) => {
      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
    }, "FS_createDataFile");
    var preloadPlugins = Module3["preloadPlugins"] || [];
    var FS_handledByPreloadPlugin = /* @__PURE__ */ __name((byteArray, fullname, finish, onerror) => {
      if (typeof Browser != "undefined") Browser.init();
      var handled = false;
      preloadPlugins.forEach((plugin) => {
        if (handled) return;
        if (plugin["canHandle"](fullname)) {
          plugin["handle"](byteArray, fullname, finish, onerror);
          handled = true;
        }
      });
      return handled;
    }, "FS_handledByPreloadPlugin");
    var FS_createPreloadedFile = /* @__PURE__ */ __name((parent, name, url2, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
      var dep = getUniqueRunDependency(`cp ${fullname}`);
      function processData(byteArray) {
        function finish(byteArray2) {
          preFinish?.();
          if (!dontCreateFile) {
            FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
          }
          onload?.();
          removeRunDependency(dep);
        }
        __name(finish, "finish");
        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
          onerror?.();
          removeRunDependency(dep);
        })) {
          return;
        }
        finish(byteArray);
      }
      __name(processData, "processData");
      addRunDependency(dep);
      if (typeof url2 == "string") {
        asyncLoad(url2, processData, onerror);
      } else {
        processData(url2);
      }
    }, "FS_createPreloadedFile");
    var FS_modeStringToFlags = /* @__PURE__ */ __name((str) => {
      var flagModes = { r: 0, "r+": 2, w: 512 | 64 | 1, "w+": 512 | 64 | 2, a: 1024 | 64 | 1, "a+": 1024 | 64 | 2 };
      var flags = flagModes[str];
      if (typeof flags == "undefined") {
        throw new Error(`Unknown file open mode: ${str}`);
      }
      return flags;
    }, "FS_modeStringToFlags");
    var FS_getMode = /* @__PURE__ */ __name((canRead, canWrite) => {
      var mode = 0;
      if (canRead) mode |= 292 | 73;
      if (canWrite) mode |= 146;
      return mode;
    }, "FS_getMode");
    var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: class {
      static {
        __name(this, "ErrnoError");
      }
      name = "ErrnoError";
      constructor(errno) {
        this.errno = errno;
      }
    }, filesystems: null, syncFSRequests: 0, readFiles: {}, FSStream: class {
      static {
        __name(this, "FSStream");
      }
      shared = {};
      get object() {
        return this.node;
      }
      set object(val) {
        this.node = val;
      }
      get isRead() {
        return (this.flags & 2097155) !== 1;
      }
      get isWrite() {
        return (this.flags & 2097155) !== 0;
      }
      get isAppend() {
        return this.flags & 1024;
      }
      get flags() {
        return this.shared.flags;
      }
      set flags(val) {
        this.shared.flags = val;
      }
      get position() {
        return this.shared.position;
      }
      set position(val) {
        this.shared.position = val;
      }
    }, FSNode: class {
      static {
        __name(this, "FSNode");
      }
      node_ops = {};
      stream_ops = {};
      readMode = 292 | 73;
      writeMode = 146;
      mounted = null;
      constructor(parent, name, mode, rdev) {
        if (!parent) {
          parent = this;
        }
        this.parent = parent;
        this.mount = parent.mount;
        this.id = FS.nextInode++;
        this.name = name;
        this.mode = mode;
        this.rdev = rdev;
      }
      get read() {
        return (this.mode & this.readMode) === this.readMode;
      }
      set read(val) {
        val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
      }
      get write() {
        return (this.mode & this.writeMode) === this.writeMode;
      }
      set write(val) {
        val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
      }
      get isFolder() {
        return FS.isDir(this.mode);
      }
      get isDevice() {
        return FS.isChrdev(this.mode);
      }
    }, lookupPath(path, opts = {}) {
      path = PATH_FS.resolve(path);
      if (!path) return { path: "", node: null };
      var defaults = { follow_mount: true, recurse_count: 0 };
      opts = Object.assign(defaults, opts);
      if (opts.recurse_count > 8) {
        throw new FS.ErrnoError(32);
      }
      var parts2 = path.split("/").filter((p) => !!p);
      var current2 = FS.root;
      var current_path = "/";
      for (var i = 0; i < parts2.length; i++) {
        var islast = i === parts2.length - 1;
        if (islast && opts.parent) {
          break;
        }
        current2 = FS.lookupNode(current2, parts2[i]);
        current_path = PATH.join2(current_path, parts2[i]);
        if (FS.isMountpoint(current2)) {
          if (!islast || islast && opts.follow_mount) {
            current2 = current2.mounted.root;
          }
        }
        if (!islast || opts.follow) {
          var count7 = 0;
          while (FS.isLink(current2.mode)) {
            var link = FS.readlink(current_path);
            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
            var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
            current2 = lookup.node;
            if (count7++ > 40) {
              throw new FS.ErrnoError(32);
            }
          }
        }
      }
      return { path: current_path, node: current2 };
    }, getPath(node) {
      var path;
      while (true) {
        if (FS.isRoot(node)) {
          var mount2 = node.mount.mountpoint;
          if (!path) return mount2;
          return mount2[mount2.length - 1] !== "/" ? `${mount2}/${path}` : mount2 + path;
        }
        path = path ? `${node.name}/${path}` : node.name;
        node = node.parent;
      }
    }, hashName(parentid, name) {
      var hash5 = 0;
      for (var i = 0; i < name.length; i++) {
        hash5 = (hash5 << 5) - hash5 + name.charCodeAt(i) | 0;
      }
      return (parentid + hash5 >>> 0) % FS.nameTable.length;
    }, hashAddNode(node) {
      var hash5 = FS.hashName(node.parent.id, node.name);
      node.name_next = FS.nameTable[hash5];
      FS.nameTable[hash5] = node;
    }, hashRemoveNode(node) {
      var hash5 = FS.hashName(node.parent.id, node.name);
      if (FS.nameTable[hash5] === node) {
        FS.nameTable[hash5] = node.name_next;
      } else {
        var current2 = FS.nameTable[hash5];
        while (current2) {
          if (current2.name_next === node) {
            current2.name_next = node.name_next;
            break;
          }
          current2 = current2.name_next;
        }
      }
    }, lookupNode(parent, name) {
      var errCode = FS.mayLookup(parent);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      var hash5 = FS.hashName(parent.id, name);
      for (var node = FS.nameTable[hash5]; node; node = node.name_next) {
        var nodeName = node.name;
        if (node.parent.id === parent.id && nodeName === name) {
          return node;
        }
      }
      return FS.lookup(parent, name);
    }, createNode(parent, name, mode, rdev) {
      var node = new FS.FSNode(parent, name, mode, rdev);
      FS.hashAddNode(node);
      return node;
    }, destroyNode(node) {
      FS.hashRemoveNode(node);
    }, isRoot(node) {
      return node === node.parent;
    }, isMountpoint(node) {
      return !!node.mounted;
    }, isFile(mode) {
      return (mode & 61440) === 32768;
    }, isDir(mode) {
      return (mode & 61440) === 16384;
    }, isLink(mode) {
      return (mode & 61440) === 40960;
    }, isChrdev(mode) {
      return (mode & 61440) === 8192;
    }, isBlkdev(mode) {
      return (mode & 61440) === 24576;
    }, isFIFO(mode) {
      return (mode & 61440) === 4096;
    }, isSocket(mode) {
      return (mode & 49152) === 49152;
    }, flagsToPermissionString(flag) {
      var perms = ["r", "w", "rw"][flag & 3];
      if (flag & 512) {
        perms += "w";
      }
      return perms;
    }, nodePermissions(node, perms) {
      if (FS.ignorePermissions) {
        return 0;
      }
      if (perms.includes("r") && !(node.mode & 292)) {
        return 2;
      } else if (perms.includes("w") && !(node.mode & 146)) {
        return 2;
      } else if (perms.includes("x") && !(node.mode & 73)) {
        return 2;
      }
      return 0;
    }, mayLookup(dir4) {
      if (!FS.isDir(dir4.mode)) return 54;
      var errCode = FS.nodePermissions(dir4, "x");
      if (errCode) return errCode;
      if (!dir4.node_ops.lookup) return 2;
      return 0;
    }, mayCreate(dir4, name) {
      var node;
      try {
        node = FS.lookupNode(dir4, name);
        return 20;
      } catch (e) {
      }
      return FS.nodePermissions(dir4, "wx");
    }, mayDelete(dir4, name, isdir) {
      var node;
      try {
        node = FS.lookupNode(dir4, name);
      } catch (e) {
        return e.errno;
      }
      var errCode = FS.nodePermissions(dir4, "wx");
      if (errCode) {
        return errCode;
      }
      if (isdir) {
        if (!FS.isDir(node.mode)) {
          return 54;
        }
        if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
          return 10;
        }
      } else {
        if (FS.isDir(node.mode)) {
          return 31;
        }
      }
      return 0;
    }, mayOpen(node, flags) {
      if (!node) {
        return 44;
      }
      if (FS.isLink(node.mode)) {
        return 32;
      } else if (FS.isDir(node.mode)) {
        if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
          return 31;
        }
      }
      return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
    }, MAX_OPEN_FDS: 4096, nextfd() {
      for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
        if (!FS.streams[fd]) {
          return fd;
        }
      }
      throw new FS.ErrnoError(33);
    }, getStreamChecked(fd) {
      var stream6 = FS.getStream(fd);
      if (!stream6) {
        throw new FS.ErrnoError(8);
      }
      return stream6;
    }, getStream: /* @__PURE__ */ __name((fd) => FS.streams[fd], "getStream"), createStream(stream6, fd = -1) {
      stream6 = Object.assign(new FS.FSStream(), stream6);
      if (fd == -1) {
        fd = FS.nextfd();
      }
      stream6.fd = fd;
      FS.streams[fd] = stream6;
      return stream6;
    }, closeStream(fd) {
      FS.streams[fd] = null;
    }, dupStream(origStream, fd = -1) {
      var stream6 = FS.createStream(origStream, fd);
      stream6.stream_ops?.dup?.(stream6);
      return stream6;
    }, chrdev_stream_ops: { open(stream6) {
      var device = FS.getDevice(stream6.node.rdev);
      stream6.stream_ops = device.stream_ops;
      stream6.stream_ops.open?.(stream6);
    }, llseek() {
      throw new FS.ErrnoError(70);
    } }, major: /* @__PURE__ */ __name((dev) => dev >> 8, "major"), minor: /* @__PURE__ */ __name((dev) => dev & 255, "minor"), makedev: /* @__PURE__ */ __name((ma, mi) => ma << 8 | mi, "makedev"), registerDevice(dev, ops) {
      FS.devices[dev] = { stream_ops: ops };
    }, getDevice: /* @__PURE__ */ __name((dev) => FS.devices[dev], "getDevice"), getMounts(mount2) {
      var mounts = [];
      var check6 = [mount2];
      while (check6.length) {
        var m = check6.pop();
        mounts.push(m);
        check6.push(...m.mounts);
      }
      return mounts;
    }, syncfs(populate, callback) {
      if (typeof populate == "function") {
        callback = populate;
        populate = false;
      }
      FS.syncFSRequests++;
      if (FS.syncFSRequests > 1) {
        err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
      }
      var mounts = FS.getMounts(FS.root.mount);
      var completed = 0;
      function doCallback(errCode) {
        FS.syncFSRequests--;
        return callback(errCode);
      }
      __name(doCallback, "doCallback");
      function done12(errCode) {
        if (errCode) {
          if (!done12.errored) {
            done12.errored = true;
            return doCallback(errCode);
          }
          return;
        }
        if (++completed >= mounts.length) {
          doCallback(null);
        }
      }
      __name(done12, "done");
      mounts.forEach((mount2) => {
        if (!mount2.type.syncfs) {
          return done12(null);
        }
        mount2.type.syncfs(mount2, populate, done12);
      });
    }, mount(type3, opts, mountpoint) {
      var root = mountpoint === "/";
      var pseudo = !mountpoint;
      var node;
      if (root && FS.root) {
        throw new FS.ErrnoError(10);
      } else if (!root && !pseudo) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        mountpoint = lookup.path;
        node = lookup.node;
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        if (!FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
      }
      var mount2 = { type: type3, opts, mountpoint, mounts: [] };
      var mountRoot = type3.mount(mount2);
      mountRoot.mount = mount2;
      mount2.root = mountRoot;
      if (root) {
        FS.root = mountRoot;
      } else if (node) {
        node.mounted = mount2;
        if (node.mount) {
          node.mount.mounts.push(mount2);
        }
      }
      return mountRoot;
    }, unmount(mountpoint) {
      var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
      if (!FS.isMountpoint(lookup.node)) {
        throw new FS.ErrnoError(28);
      }
      var node = lookup.node;
      var mount2 = node.mounted;
      var mounts = FS.getMounts(mount2);
      Object.keys(FS.nameTable).forEach((hash5) => {
        var current2 = FS.nameTable[hash5];
        while (current2) {
          var next4 = current2.name_next;
          if (mounts.includes(current2.mount)) {
            FS.destroyNode(current2);
          }
          current2 = next4;
        }
      });
      node.mounted = null;
      var idx = node.mount.mounts.indexOf(mount2);
      node.mount.mounts.splice(idx, 1);
    }, lookup(parent, name) {
      return parent.node_ops.lookup(parent, name);
    }, mknod(path, mode, dev) {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      var name = PATH.basename(path);
      if (!name || name === "." || name === "..") {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.mayCreate(parent, name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.mknod) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.mknod(parent, name, mode, dev);
    }, statfs(path) {
      var rtn = { bsize: 4096, frsize: 4096, blocks: 1e6, bfree: 5e5, bavail: 5e5, files: FS.nextInode, ffree: FS.nextInode - 1, fsid: 42, flags: 2, namelen: 255 };
      var parent = FS.lookupPath(path, { follow: true }).node;
      if (parent?.node_ops.statfs) {
        Object.assign(rtn, parent.node_ops.statfs(parent.mount.opts.root));
      }
      return rtn;
    }, create(path, mode = 438) {
      mode &= 4095;
      mode |= 32768;
      return FS.mknod(path, mode, 0);
    }, mkdir(path, mode = 511) {
      mode &= 511 | 512;
      mode |= 16384;
      return FS.mknod(path, mode, 0);
    }, mkdirTree(path, mode) {
      var dirs = path.split("/");
      var d = "";
      for (var i = 0; i < dirs.length; ++i) {
        if (!dirs[i]) continue;
        d += "/" + dirs[i];
        try {
          FS.mkdir(d, mode);
        } catch (e) {
          if (e.errno != 20) throw e;
        }
      }
    }, mkdev(path, mode, dev) {
      if (typeof dev == "undefined") {
        dev = mode;
        mode = 438;
      }
      mode |= 8192;
      return FS.mknod(path, mode, dev);
    }, symlink(oldpath, newpath) {
      if (!PATH_FS.resolve(oldpath)) {
        throw new FS.ErrnoError(44);
      }
      var lookup = FS.lookupPath(newpath, { parent: true });
      var parent = lookup.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var newname = PATH.basename(newpath);
      var errCode = FS.mayCreate(parent, newname);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.symlink) {
        throw new FS.ErrnoError(63);
      }
      return parent.node_ops.symlink(parent, newname, oldpath);
    }, rename(old_path, new_path) {
      var old_dirname = PATH.dirname(old_path);
      var new_dirname = PATH.dirname(new_path);
      var old_name = PATH.basename(old_path);
      var new_name = PATH.basename(new_path);
      var lookup, old_dir, new_dir;
      lookup = FS.lookupPath(old_path, { parent: true });
      old_dir = lookup.node;
      lookup = FS.lookupPath(new_path, { parent: true });
      new_dir = lookup.node;
      if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
      if (old_dir.mount !== new_dir.mount) {
        throw new FS.ErrnoError(75);
      }
      var old_node = FS.lookupNode(old_dir, old_name);
      var relative = PATH_FS.relative(old_path, new_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(28);
      }
      relative = PATH_FS.relative(new_path, old_dirname);
      if (relative.charAt(0) !== ".") {
        throw new FS.ErrnoError(55);
      }
      var new_node;
      try {
        new_node = FS.lookupNode(new_dir, new_name);
      } catch (e) {
      }
      if (old_node === new_node) {
        return;
      }
      var isdir = FS.isDir(old_node.mode);
      var errCode = FS.mayDelete(old_dir, old_name, isdir);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!old_dir.node_ops.rename) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
        throw new FS.ErrnoError(10);
      }
      if (new_dir !== old_dir) {
        errCode = FS.nodePermissions(old_dir, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      FS.hashRemoveNode(old_node);
      try {
        old_dir.node_ops.rename(old_node, new_dir, new_name);
        old_node.parent = new_dir;
      } catch (e) {
        throw e;
      } finally {
        FS.hashAddNode(old_node);
      }
    }, rmdir(path) {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, true);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.rmdir) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.rmdir(parent, name);
      FS.destroyNode(node);
    }, readdir(path) {
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      if (!node.node_ops.readdir) {
        throw new FS.ErrnoError(54);
      }
      return node.node_ops.readdir(node);
    }, unlink(path) {
      var lookup = FS.lookupPath(path, { parent: true });
      var parent = lookup.node;
      if (!parent) {
        throw new FS.ErrnoError(44);
      }
      var name = PATH.basename(path);
      var node = FS.lookupNode(parent, name);
      var errCode = FS.mayDelete(parent, name, false);
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      if (!parent.node_ops.unlink) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isMountpoint(node)) {
        throw new FS.ErrnoError(10);
      }
      parent.node_ops.unlink(parent, name);
      FS.destroyNode(node);
    }, readlink(path) {
      var lookup = FS.lookupPath(path);
      var link = lookup.node;
      if (!link) {
        throw new FS.ErrnoError(44);
      }
      if (!link.node_ops.readlink) {
        throw new FS.ErrnoError(28);
      }
      return link.node_ops.readlink(link);
    }, stat(path, dontFollow) {
      var lookup = FS.lookupPath(path, { follow: !dontFollow });
      var node = lookup.node;
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (!node.node_ops.getattr) {
        throw new FS.ErrnoError(63);
      }
      return node.node_ops.getattr(node);
    }, lstat(path) {
      return FS.stat(path, true);
    }, chmod(path, mode, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
    }, lchmod(path, mode) {
      FS.chmod(path, mode, true);
    }, fchmod(fd, mode) {
      var stream6 = FS.getStreamChecked(fd);
      FS.chmod(stream6.node, mode);
    }, chown(path, uid, gid, dontFollow) {
      var node;
      if (typeof path == "string") {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      node.node_ops.setattr(node, { timestamp: Date.now() });
    }, lchown(path, uid, gid) {
      FS.chown(path, uid, gid, true);
    }, fchown(fd, uid, gid) {
      var stream6 = FS.getStreamChecked(fd);
      FS.chown(stream6.node, uid, gid);
    }, truncate(path, len) {
      if (len < 0) {
        throw new FS.ErrnoError(28);
      }
      var node;
      if (typeof path == "string") {
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
      } else {
        node = path;
      }
      if (!node.node_ops.setattr) {
        throw new FS.ErrnoError(63);
      }
      if (FS.isDir(node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!FS.isFile(node.mode)) {
        throw new FS.ErrnoError(28);
      }
      var errCode = FS.nodePermissions(node, "w");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
    }, ftruncate(fd, len) {
      var stream6 = FS.getStreamChecked(fd);
      if ((stream6.flags & 2097155) === 0) {
        throw new FS.ErrnoError(28);
      }
      FS.truncate(stream6.node, len);
    }, utime(path, atime, mtime) {
      var lookup = FS.lookupPath(path, { follow: true });
      var node = lookup.node;
      node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
    }, open(path, flags, mode = 438) {
      if (path === "") {
        throw new FS.ErrnoError(44);
      }
      flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
      if (flags & 64) {
        mode = mode & 4095 | 32768;
      } else {
        mode = 0;
      }
      var node;
      if (typeof path == "object") {
        node = path;
      } else {
        path = PATH.normalize(path);
        try {
          var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
          node = lookup.node;
        } catch (e) {
        }
      }
      var created = false;
      if (flags & 64) {
        if (node) {
          if (flags & 128) {
            throw new FS.ErrnoError(20);
          }
        } else {
          node = FS.mknod(path, mode, 0);
          created = true;
        }
      }
      if (!node) {
        throw new FS.ErrnoError(44);
      }
      if (FS.isChrdev(node.mode)) {
        flags &= ~512;
      }
      if (flags & 65536 && !FS.isDir(node.mode)) {
        throw new FS.ErrnoError(54);
      }
      if (!created) {
        var errCode = FS.mayOpen(node, flags);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
      }
      if (flags & 512 && !created) {
        FS.truncate(node, 0);
      }
      flags &= ~(128 | 512 | 131072);
      var stream6 = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false });
      if (stream6.stream_ops.open) {
        stream6.stream_ops.open(stream6);
      }
      if (Module3["logReadFiles"] && !(flags & 1)) {
        if (!(path in FS.readFiles)) {
          FS.readFiles[path] = 1;
        }
      }
      return stream6;
    }, close(stream6) {
      if (FS.isClosed(stream6)) {
        throw new FS.ErrnoError(8);
      }
      if (stream6.getdents) stream6.getdents = null;
      try {
        if (stream6.stream_ops.close) {
          stream6.stream_ops.close(stream6);
        }
      } catch (e) {
        throw e;
      } finally {
        FS.closeStream(stream6.fd);
      }
      stream6.fd = null;
    }, isClosed(stream6) {
      return stream6.fd === null;
    }, llseek(stream6, offset, whence) {
      if (FS.isClosed(stream6)) {
        throw new FS.ErrnoError(8);
      }
      if (!stream6.seekable || !stream6.stream_ops.llseek) {
        throw new FS.ErrnoError(70);
      }
      if (whence != 0 && whence != 1 && whence != 2) {
        throw new FS.ErrnoError(28);
      }
      stream6.position = stream6.stream_ops.llseek(stream6, offset, whence);
      stream6.ungotten = [];
      return stream6.position;
    }, read(stream6, buffer4, offset, length5, position5) {
      if (length5 < 0 || position5 < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream6)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream6.flags & 2097155) === 1) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream6.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream6.stream_ops.read) {
        throw new FS.ErrnoError(28);
      }
      var seeking = typeof position5 != "undefined";
      if (!seeking) {
        position5 = stream6.position;
      } else if (!stream6.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesRead = stream6.stream_ops.read(stream6, buffer4, offset, length5, position5);
      if (!seeking) stream6.position += bytesRead;
      return bytesRead;
    }, write(stream6, buffer4, offset, length5, position5, canOwn) {
      if (length5 < 0 || position5 < 0) {
        throw new FS.ErrnoError(28);
      }
      if (FS.isClosed(stream6)) {
        throw new FS.ErrnoError(8);
      }
      if ((stream6.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (FS.isDir(stream6.node.mode)) {
        throw new FS.ErrnoError(31);
      }
      if (!stream6.stream_ops.write) {
        throw new FS.ErrnoError(28);
      }
      if (stream6.seekable && stream6.flags & 1024) {
        FS.llseek(stream6, 0, 2);
      }
      var seeking = typeof position5 != "undefined";
      if (!seeking) {
        position5 = stream6.position;
      } else if (!stream6.seekable) {
        throw new FS.ErrnoError(70);
      }
      var bytesWritten = stream6.stream_ops.write(stream6, buffer4, offset, length5, position5, canOwn);
      if (!seeking) stream6.position += bytesWritten;
      return bytesWritten;
    }, allocate(stream6, offset, length5) {
      if (FS.isClosed(stream6)) {
        throw new FS.ErrnoError(8);
      }
      if (offset < 0 || length5 <= 0) {
        throw new FS.ErrnoError(28);
      }
      if ((stream6.flags & 2097155) === 0) {
        throw new FS.ErrnoError(8);
      }
      if (!FS.isFile(stream6.node.mode) && !FS.isDir(stream6.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (!stream6.stream_ops.allocate) {
        throw new FS.ErrnoError(138);
      }
      stream6.stream_ops.allocate(stream6, offset, length5);
    }, mmap(stream6, length5, position5, prot, flags) {
      if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream6.flags & 2097155) !== 2) {
        throw new FS.ErrnoError(2);
      }
      if ((stream6.flags & 2097155) === 1) {
        throw new FS.ErrnoError(2);
      }
      if (!stream6.stream_ops.mmap) {
        throw new FS.ErrnoError(43);
      }
      if (!length5) {
        throw new FS.ErrnoError(28);
      }
      return stream6.stream_ops.mmap(stream6, length5, position5, prot, flags);
    }, msync(stream6, buffer4, offset, length5, mmapFlags) {
      if (!stream6.stream_ops.msync) {
        return 0;
      }
      return stream6.stream_ops.msync(stream6, buffer4, offset, length5, mmapFlags);
    }, ioctl(stream6, cmd, arg) {
      if (!stream6.stream_ops.ioctl) {
        throw new FS.ErrnoError(59);
      }
      return stream6.stream_ops.ioctl(stream6, cmd, arg);
    }, readFile(path, opts = {}) {
      opts.flags = opts.flags || 0;
      opts.encoding = opts.encoding || "binary";
      if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
        throw new Error(`Invalid encoding type "${opts.encoding}"`);
      }
      var ret;
      var stream6 = FS.open(path, opts.flags);
      var stat = FS.stat(path);
      var length5 = stat.size;
      var buf = new Uint8Array(length5);
      FS.read(stream6, buf, 0, length5, 0);
      if (opts.encoding === "utf8") {
        ret = UTF8ArrayToString(buf);
      } else if (opts.encoding === "binary") {
        ret = buf;
      }
      FS.close(stream6);
      return ret;
    }, writeFile(path, data, opts = {}) {
      opts.flags = opts.flags || 577;
      var stream6 = FS.open(path, opts.flags, opts.mode);
      if (typeof data == "string") {
        var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
        var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
        FS.write(stream6, buf, 0, actualNumBytes, void 0, opts.canOwn);
      } else if (ArrayBuffer.isView(data)) {
        FS.write(stream6, data, 0, data.byteLength, void 0, opts.canOwn);
      } else {
        throw new Error("Unsupported data type");
      }
      FS.close(stream6);
    }, cwd: /* @__PURE__ */ __name(() => FS.currentPath, "cwd"), chdir(path) {
      var lookup = FS.lookupPath(path, { follow: true });
      if (lookup.node === null) {
        throw new FS.ErrnoError(44);
      }
      if (!FS.isDir(lookup.node.mode)) {
        throw new FS.ErrnoError(54);
      }
      var errCode = FS.nodePermissions(lookup.node, "x");
      if (errCode) {
        throw new FS.ErrnoError(errCode);
      }
      FS.currentPath = lookup.path;
    }, createDefaultDirectories() {
      FS.mkdir("/tmp");
      FS.mkdir("/home");
      FS.mkdir("/home/web_user");
    }, createDefaultDevices() {
      FS.mkdir("/dev");
      FS.registerDevice(FS.makedev(1, 3), { read: /* @__PURE__ */ __name(() => 0, "read"), write: /* @__PURE__ */ __name((stream6, buffer4, offset, length5, pos) => length5, "write"), llseek: /* @__PURE__ */ __name(() => 0, "llseek") });
      FS.mkdev("/dev/null", FS.makedev(1, 3));
      TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
      TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
      FS.mkdev("/dev/tty", FS.makedev(5, 0));
      FS.mkdev("/dev/tty1", FS.makedev(6, 0));
      var randomBuffer = new Uint8Array(1024), randomLeft = 0;
      var randomByte = /* @__PURE__ */ __name(() => {
        if (randomLeft === 0) {
          randomLeft = randomFill(randomBuffer).byteLength;
        }
        return randomBuffer[--randomLeft];
      }, "randomByte");
      FS.createDevice("/dev", "random", randomByte);
      FS.createDevice("/dev", "urandom", randomByte);
      FS.mkdir("/dev/shm");
      FS.mkdir("/dev/shm/tmp");
    }, createSpecialDirectories() {
      FS.mkdir("/proc");
      var proc_self = FS.mkdir("/proc/self");
      FS.mkdir("/proc/self/fd");
      FS.mount({ mount() {
        var node = FS.createNode(proc_self, "fd", 16895, 73);
        node.node_ops = { lookup(parent, name) {
          var fd = +name;
          var stream6 = FS.getStreamChecked(fd);
          var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: /* @__PURE__ */ __name(() => stream6.path, "readlink") } };
          ret.parent = ret;
          return ret;
        } };
        return node;
      } }, {}, "/proc/self/fd");
    }, createStandardStreams(input, output, error5) {
      if (input) {
        FS.createDevice("/dev", "stdin", input);
      } else {
        FS.symlink("/dev/tty", "/dev/stdin");
      }
      if (output) {
        FS.createDevice("/dev", "stdout", null, output);
      } else {
        FS.symlink("/dev/tty", "/dev/stdout");
      }
      if (error5) {
        FS.createDevice("/dev", "stderr", null, error5);
      } else {
        FS.symlink("/dev/tty1", "/dev/stderr");
      }
      var stdin2 = FS.open("/dev/stdin", 0);
      var stdout2 = FS.open("/dev/stdout", 1);
      var stderr2 = FS.open("/dev/stderr", 1);
    }, staticInit() {
      FS.nameTable = new Array(4096);
      FS.mount(MEMFS, {}, "/");
      FS.createDefaultDirectories();
      FS.createDefaultDevices();
      FS.createSpecialDirectories();
      FS.filesystems = { MEMFS };
    }, init(input, output, error5) {
      FS.initialized = true;
      input ??= Module3["stdin"];
      output ??= Module3["stdout"];
      error5 ??= Module3["stderr"];
      FS.createStandardStreams(input, output, error5);
    }, quit() {
      FS.initialized = false;
      for (var i = 0; i < FS.streams.length; i++) {
        var stream6 = FS.streams[i];
        if (!stream6) {
          continue;
        }
        FS.close(stream6);
      }
    }, findObject(path, dontResolveLastLink) {
      var ret = FS.analyzePath(path, dontResolveLastLink);
      if (!ret.exists) {
        return null;
      }
      return ret.object;
    }, analyzePath(path, dontResolveLastLink) {
      try {
        var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
        path = lookup.path;
      } catch (e) {
      }
      var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
      try {
        var lookup = FS.lookupPath(path, { parent: true });
        ret.parentExists = true;
        ret.parentPath = lookup.path;
        ret.parentObject = lookup.node;
        ret.name = PATH.basename(path);
        lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
        ret.exists = true;
        ret.path = lookup.path;
        ret.object = lookup.node;
        ret.name = lookup.node.name;
        ret.isRoot = lookup.path === "/";
      } catch (e) {
        ret.error = e.errno;
      }
      return ret;
    }, createPath(parent, path, canRead, canWrite) {
      parent = typeof parent == "string" ? parent : FS.getPath(parent);
      var parts2 = path.split("/").reverse();
      while (parts2.length) {
        var part = parts2.pop();
        if (!part) continue;
        var current2 = PATH.join2(parent, part);
        try {
          FS.mkdir(current2);
        } catch (e) {
        }
        parent = current2;
      }
      return current2;
    }, createFile(parent, name, properties, canRead, canWrite) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(canRead, canWrite);
      return FS.create(path, mode);
    }, createDataFile(parent, name, data, canRead, canWrite, canOwn) {
      var path = name;
      if (parent) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        path = name ? PATH.join2(parent, name) : parent;
      }
      var mode = FS_getMode(canRead, canWrite);
      var node = FS.create(path, mode);
      if (data) {
        if (typeof data == "string") {
          var arr = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
          data = arr;
        }
        FS.chmod(node, mode | 146);
        var stream6 = FS.open(node, 577);
        FS.write(stream6, data, 0, data.length, 0, canOwn);
        FS.close(stream6);
        FS.chmod(node, mode);
      }
    }, createDevice(parent, name, input, output) {
      var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
      var mode = FS_getMode(!!input, !!output);
      FS.createDevice.major ??= 64;
      var dev = FS.makedev(FS.createDevice.major++, 0);
      FS.registerDevice(dev, { open(stream6) {
        stream6.seekable = false;
      }, close(stream6) {
        if (output?.buffer?.length) {
          output(10);
        }
      }, read(stream6, buffer4, offset, length5, pos) {
        var bytesRead = 0;
        for (var i = 0; i < length5; i++) {
          var result;
          try {
            result = input();
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0) break;
          bytesRead++;
          buffer4[offset + i] = result;
        }
        if (bytesRead) {
          stream6.node.timestamp = Date.now();
        }
        return bytesRead;
      }, write(stream6, buffer4, offset, length5, pos) {
        for (var i = 0; i < length5; i++) {
          try {
            output(buffer4[offset + i]);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
        if (length5) {
          stream6.node.timestamp = Date.now();
        }
        return i;
      } });
      return FS.mkdev(path, mode, dev);
    }, forceLoadFile(obj) {
      if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
      if (typeof XMLHttpRequest != "undefined") {
        throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
      } else {
        try {
          obj.contents = readBinary(obj.url);
          obj.usedBytes = obj.contents.length;
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
      }
    }, createLazyFile(parent, name, url2, canRead, canWrite) {
      class LazyUint8Array {
        static {
          __name(this, "LazyUint8Array");
        }
        lengthKnown = false;
        chunks = [];
        get(idx) {
          if (idx > this.length - 1 || idx < 0) {
            return void 0;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = idx / this.chunkSize | 0;
          return this.getter(chunkNum)[chunkOffset];
        }
        setDataGetter(getter) {
          this.getter = getter;
        }
        cacheLength() {
          var xhr = new XMLHttpRequest();
          xhr.open("HEAD", url2, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url2 + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
          var chunkSize = 1024 * 1024;
          if (!hasByteServing) chunkSize = datalength;
          var doXHR = /* @__PURE__ */ __name((from, to) => {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
            var xhr2 = new XMLHttpRequest();
            xhr2.open("GET", url2, false);
            if (datalength !== chunkSize) xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
            xhr2.responseType = "arraybuffer";
            if (xhr2.overrideMimeType) {
              xhr2.overrideMimeType("text/plain; charset=x-user-defined");
            }
            xhr2.send(null);
            if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304)) throw new Error("Couldn't load " + url2 + ". Status: " + xhr2.status);
            if (xhr2.response !== void 0) {
              return new Uint8Array(xhr2.response || []);
            }
            return intArrayFromString(xhr2.responseText || "", true);
          }, "doXHR");
          var lazyArray2 = this;
          lazyArray2.setDataGetter((chunkNum) => {
            var start3 = chunkNum * chunkSize;
            var end6 = (chunkNum + 1) * chunkSize - 1;
            end6 = Math.min(end6, datalength - 1);
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
              lazyArray2.chunks[chunkNum] = doXHR(start3, end6);
            }
            if (typeof lazyArray2.chunks[chunkNum] == "undefined") throw new Error("doXHR failed!");
            return lazyArray2.chunks[chunkNum];
          });
          if (usesGzip || !datalength) {
            chunkSize = datalength = 1;
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        get length() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._length;
        }
        get chunkSize() {
          if (!this.lengthKnown) {
            this.cacheLength();
          }
          return this._chunkSize;
        }
      }
      if (typeof XMLHttpRequest != "undefined") {
        if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var lazyArray = new LazyUint8Array();
        var properties = { isDevice: false, contents: lazyArray };
      } else {
        var properties = { isDevice: false, url: url2 };
      }
      var node = FS.createFile(parent, name, properties, canRead, canWrite);
      if (properties.contents) {
        node.contents = properties.contents;
      } else if (properties.url) {
        node.contents = null;
        node.url = properties.url;
      }
      Object.defineProperties(node, { usedBytes: { get: /* @__PURE__ */ __name(function() {
        return this.contents.length;
      }, "get") } });
      var stream_ops = {};
      var keys6 = Object.keys(node.stream_ops);
      keys6.forEach((key) => {
        var fn2 = node.stream_ops[key];
        stream_ops[key] = (...args2) => {
          FS.forceLoadFile(node);
          return fn2(...args2);
        };
      });
      function writeChunks(stream6, buffer4, offset, length5, position5) {
        var contents = stream6.node.contents;
        if (position5 >= contents.length) return 0;
        var size22 = Math.min(contents.length - position5, length5);
        if (contents.slice) {
          for (var i = 0; i < size22; i++) {
            buffer4[offset + i] = contents[position5 + i];
          }
        } else {
          for (var i = 0; i < size22; i++) {
            buffer4[offset + i] = contents.get(position5 + i);
          }
        }
        return size22;
      }
      __name(writeChunks, "writeChunks");
      stream_ops.read = (stream6, buffer4, offset, length5, position5) => {
        FS.forceLoadFile(node);
        return writeChunks(stream6, buffer4, offset, length5, position5);
      };
      stream_ops.mmap = (stream6, length5, position5, prot, flags) => {
        FS.forceLoadFile(node);
        var ptr = mmapAlloc(length5);
        if (!ptr) {
          throw new FS.ErrnoError(48);
        }
        writeChunks(stream6, HEAP8, ptr, length5, position5);
        return { ptr, allocated: true };
      };
      node.stream_ops = stream_ops;
      return node;
    } };
    var SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt(dirfd, path, allowEmpty) {
      if (PATH.isAbs(path)) {
        return path;
      }
      var dir4;
      if (dirfd === -100) {
        dir4 = FS.cwd();
      } else {
        var dirstream = SYSCALLS.getStreamFromFD(dirfd);
        dir4 = dirstream.path;
      }
      if (path.length == 0) {
        if (!allowEmpty) {
          throw new FS.ErrnoError(44);
        }
        return dir4;
      }
      return PATH.join2(dir4, path);
    }, doStat(func2, path, buf) {
      var stat = func2(path);
      HEAP32[buf >> 2] = stat.dev;
      HEAP32[buf + 4 >> 2] = stat.mode;
      HEAPU32[buf + 8 >> 2] = stat.nlink;
      HEAP32[buf + 12 >> 2] = stat.uid;
      HEAP32[buf + 16 >> 2] = stat.gid;
      HEAP32[buf + 20 >> 2] = stat.rdev;
      tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
      HEAP32[buf + 32 >> 2] = 4096;
      HEAP32[buf + 36 >> 2] = stat.blocks;
      var atime = stat.atime.getTime();
      var mtime = stat.mtime.getTime();
      var ctime = stat.ctime.getTime();
      tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
      HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
      tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
      HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
      tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
      HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
      tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
      return 0;
    }, doMsync(addr, stream6, len, flags, offset) {
      if (!FS.isFile(stream6.node.mode)) {
        throw new FS.ErrnoError(43);
      }
      if (flags & 2) {
        return 0;
      }
      var buffer4 = HEAPU8.slice(addr, addr + len);
      FS.msync(stream6, buffer4, offset, len, flags);
    }, getStreamFromFD(fd) {
      var stream6 = FS.getStreamChecked(fd);
      return stream6;
    }, varargs: void 0, getStr(ptr) {
      var ret = UTF8ToString(ptr);
      return ret;
    } };
    function ___syscall_chmod(path, mode) {
      try {
        path = SYSCALLS.getStr(path);
        FS.chmod(path, mode);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_chmod, "___syscall_chmod");
    function ___syscall_faccessat(dirfd, path, amode, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (amode & ~7) {
          return -28;
        }
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = "";
        if (amode & 4) perms += "r";
        if (amode & 2) perms += "w";
        if (amode & 1) perms += "x";
        if (perms && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_faccessat, "___syscall_faccessat");
    function ___syscall_fchmod(fd, mode) {
      try {
        FS.fchmod(fd, mode);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_fchmod, "___syscall_fchmod");
    function ___syscall_fchown32(fd, owner, group5) {
      try {
        FS.fchown(fd, owner, group5);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_fchown32, "___syscall_fchown32");
    var syscallGetVarargI = /* @__PURE__ */ __name(() => {
      var ret = HEAP32[+SYSCALLS.varargs >> 2];
      SYSCALLS.varargs += 4;
      return ret;
    }, "syscallGetVarargI");
    var syscallGetVarargP = syscallGetVarargI;
    function ___syscall_fcntl64(fd, cmd, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        var stream6 = SYSCALLS.getStreamFromFD(fd);
        switch (cmd) {
          case 0: {
            var arg = syscallGetVarargI();
            if (arg < 0) {
              return -28;
            }
            while (FS.streams[arg]) {
              arg++;
            }
            var newStream;
            newStream = FS.dupStream(stream6, arg);
            return newStream.fd;
          }
          case 1:
          case 2:
            return 0;
          case 3:
            return stream6.flags;
          case 4: {
            var arg = syscallGetVarargI();
            stream6.flags |= arg;
            return 0;
          }
          case 12: {
            var arg = syscallGetVarargP();
            var offset = 0;
            HEAP16[arg + offset >> 1] = 2;
            return 0;
          }
          case 13:
          case 14:
            return 0;
        }
        return -28;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_fcntl64, "___syscall_fcntl64");
    function ___syscall_fstat64(fd, buf) {
      try {
        var stream6 = SYSCALLS.getStreamFromFD(fd);
        return SYSCALLS.doStat(FS.stat, stream6.path, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_fstat64, "___syscall_fstat64");
    var convertI32PairToI53Checked = /* @__PURE__ */ __name((lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN, "convertI32PairToI53Checked");
    function ___syscall_ftruncate64(fd, length_low, length_high) {
      var length5 = convertI32PairToI53Checked(length_low, length_high);
      try {
        if (isNaN(length5)) return 61;
        FS.ftruncate(fd, length5);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_ftruncate64, "___syscall_ftruncate64");
    var stringToUTF8 = /* @__PURE__ */ __name((str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite), "stringToUTF8");
    function ___syscall_getcwd(buf, size22) {
      try {
        if (size22 === 0) return -28;
        var cwd2 = FS.cwd();
        var cwdLengthInBytes = lengthBytesUTF8(cwd2) + 1;
        if (size22 < cwdLengthInBytes) return -68;
        stringToUTF8(cwd2, buf, size22);
        return cwdLengthInBytes;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_getcwd, "___syscall_getcwd");
    function ___syscall_lstat64(path, buf) {
      try {
        path = SYSCALLS.getStr(path);
        return SYSCALLS.doStat(FS.lstat, path, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_lstat64, "___syscall_lstat64");
    function ___syscall_mkdirat(dirfd, path, mode) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        path = PATH.normalize(path);
        if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
        FS.mkdir(path, mode, 0);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_mkdirat, "___syscall_mkdirat");
    function ___syscall_newfstatat(dirfd, path, buf, flags) {
      try {
        path = SYSCALLS.getStr(path);
        var nofollow = flags & 256;
        var allowEmpty = flags & 4096;
        flags = flags & ~6400;
        path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
        return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_newfstatat, "___syscall_newfstatat");
    function ___syscall_openat(dirfd, path, flags, varargs) {
      SYSCALLS.varargs = varargs;
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        var mode = varargs ? syscallGetVarargI() : 0;
        return FS.open(path, flags, mode).fd;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_openat, "___syscall_openat");
    function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf + len];
        stringToUTF8(ret, buf, bufsize + 1);
        HEAP8[buf + len] = endChar;
        return len;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_readlinkat, "___syscall_readlinkat");
    function ___syscall_rmdir(path) {
      try {
        path = SYSCALLS.getStr(path);
        FS.rmdir(path);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_rmdir, "___syscall_rmdir");
    function ___syscall_stat64(path, buf) {
      try {
        path = SYSCALLS.getStr(path);
        return SYSCALLS.doStat(FS.stat, path, buf);
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_stat64, "___syscall_stat64");
    function ___syscall_unlinkat(dirfd, path, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path);
        if (flags === 0) {
          FS.unlink(path);
        } else if (flags === 512) {
          FS.rmdir(path);
        } else {
          abort2("Invalid flags passed to unlinkat");
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_unlinkat, "___syscall_unlinkat");
    var readI53FromI64 = /* @__PURE__ */ __name((ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296, "readI53FromI64");
    function ___syscall_utimensat(dirfd, path, times2, flags) {
      try {
        path = SYSCALLS.getStr(path);
        path = SYSCALLS.calculateAt(dirfd, path, true);
        var now2 = Date.now(), atime, mtime;
        if (!times2) {
          atime = now2;
          mtime = now2;
        } else {
          var seconds2 = readI53FromI64(times2);
          var nanoseconds = HEAP32[times2 + 8 >> 2];
          if (nanoseconds == 1073741823) {
            atime = now2;
          } else if (nanoseconds == 1073741822) {
            atime = -1;
          } else {
            atime = seconds2 * 1e3 + nanoseconds / (1e3 * 1e3);
          }
          times2 += 16;
          seconds2 = readI53FromI64(times2);
          nanoseconds = HEAP32[times2 + 8 >> 2];
          if (nanoseconds == 1073741823) {
            mtime = now2;
          } else if (nanoseconds == 1073741822) {
            mtime = -1;
          } else {
            mtime = seconds2 * 1e3 + nanoseconds / (1e3 * 1e3);
          }
        }
        if (mtime != -1 || atime != -1) {
          FS.utime(path, atime, mtime);
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(___syscall_utimensat, "___syscall_utimensat");
    var isLeapYear = /* @__PURE__ */ __name((year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0), "isLeapYear");
    var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var ydayFromDate = /* @__PURE__ */ __name((date4) => {
      var leap = isLeapYear(date4.getFullYear());
      var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
      var yday = monthDaysCumulative[date4.getMonth()] + date4.getDate() - 1;
      return yday;
    }, "ydayFromDate");
    function __localtime_js(time_low, time_high, tmPtr) {
      var time4 = convertI32PairToI53Checked(time_low, time_high);
      var date4 = new Date(time4 * 1e3);
      HEAP32[tmPtr >> 2] = date4.getSeconds();
      HEAP32[tmPtr + 4 >> 2] = date4.getMinutes();
      HEAP32[tmPtr + 8 >> 2] = date4.getHours();
      HEAP32[tmPtr + 12 >> 2] = date4.getDate();
      HEAP32[tmPtr + 16 >> 2] = date4.getMonth();
      HEAP32[tmPtr + 20 >> 2] = date4.getFullYear() - 1900;
      HEAP32[tmPtr + 24 >> 2] = date4.getDay();
      var yday = ydayFromDate(date4) | 0;
      HEAP32[tmPtr + 28 >> 2] = yday;
      HEAP32[tmPtr + 36 >> 2] = -(date4.getTimezoneOffset() * 60);
      var start3 = new Date(date4.getFullYear(), 0, 1);
      var summerOffset = new Date(date4.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start3.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date4.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
      HEAP32[tmPtr + 32 >> 2] = dst;
    }
    __name(__localtime_js, "__localtime_js");
    function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
      var offset = convertI32PairToI53Checked(offset_low, offset_high);
      try {
        if (isNaN(offset)) return 61;
        var stream6 = SYSCALLS.getStreamFromFD(fd);
        var res = FS.mmap(stream6, len, offset, prot, flags);
        var ptr = res.ptr;
        HEAP32[allocated >> 2] = res.allocated;
        HEAPU32[addr >> 2] = ptr;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(__mmap_js, "__mmap_js");
    function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
      var offset = convertI32PairToI53Checked(offset_low, offset_high);
      try {
        var stream6 = SYSCALLS.getStreamFromFD(fd);
        if (prot & 2) {
          SYSCALLS.doMsync(addr, stream6, len, flags, offset);
        }
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return -e.errno;
      }
    }
    __name(__munmap_js, "__munmap_js");
    var __tzset_js = /* @__PURE__ */ __name((timezone, daylight, std_name, dst_name) => {
      var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      var winterOffset = winter.getTimezoneOffset();
      var summerOffset = summer.getTimezoneOffset();
      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
      var extractZone = /* @__PURE__ */ __name((timezoneOffset) => {
        var sign2 = timezoneOffset >= 0 ? "-" : "+";
        var absOffset = Math.abs(timezoneOffset);
        var hours2 = String(Math.floor(absOffset / 60)).padStart(2, "0");
        var minutes2 = String(absOffset % 60).padStart(2, "0");
        return `UTC${sign2}${hours2}${minutes2}`;
      }, "extractZone");
      var winterName = extractZone(winterOffset);
      var summerName = extractZone(summerOffset);
      if (summerOffset < winterOffset) {
        stringToUTF8(winterName, std_name, 17);
        stringToUTF8(summerName, dst_name, 17);
      } else {
        stringToUTF8(winterName, dst_name, 17);
        stringToUTF8(summerName, std_name, 17);
      }
    }, "__tzset_js");
    var _emscripten_date_now = /* @__PURE__ */ __name(() => Date.now(), "_emscripten_date_now");
    var _emscripten_get_now = /* @__PURE__ */ __name(() => performance.now(), "_emscripten_get_now");
    var getHeapMax = /* @__PURE__ */ __name(() => 2147483648, "getHeapMax");
    var growMemory = /* @__PURE__ */ __name((size22) => {
      var b = wasmMemory.buffer;
      var pages = (size22 - b.byteLength + 65535) / 65536 | 0;
      try {
        wasmMemory.grow(pages);
        updateMemoryViews();
        return 1;
      } catch (e) {
      }
    }, "growMemory");
    var _emscripten_resize_heap = /* @__PURE__ */ __name((requestedSize) => {
      var oldSize = HEAPU8.length;
      requestedSize >>>= 0;
      var maxHeapSize = getHeapMax();
      if (requestedSize > maxHeapSize) {
        return false;
      }
      for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
        var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
        var replacement = growMemory(newSize);
        if (replacement) {
          return true;
        }
      }
      return false;
    }, "_emscripten_resize_heap");
    var ENV = {};
    var getExecutableName = /* @__PURE__ */ __name(() => thisProgram || "./this.program", "getExecutableName");
    var getEnvStrings = /* @__PURE__ */ __name(() => {
      if (!getEnvStrings.strings) {
        var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
        var env3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: lang, _: getExecutableName() };
        for (var x in ENV) {
          if (ENV[x] === void 0) delete env3[x];
          else env3[x] = ENV[x];
        }
        var strings3 = [];
        for (var x in env3) {
          strings3.push(`${x}=${env3[x]}`);
        }
        getEnvStrings.strings = strings3;
      }
      return getEnvStrings.strings;
    }, "getEnvStrings");
    var stringToAscii = /* @__PURE__ */ __name((str, buffer4) => {
      for (var i = 0; i < str.length; ++i) {
        HEAP8[buffer4++] = str.charCodeAt(i);
      }
      HEAP8[buffer4] = 0;
    }, "stringToAscii");
    var _environ_get = /* @__PURE__ */ __name((__environ, environ_buf) => {
      var bufSize = 0;
      getEnvStrings().forEach((string7, i) => {
        var ptr = environ_buf + bufSize;
        HEAPU32[__environ + i * 4 >> 2] = ptr;
        stringToAscii(string7, ptr);
        bufSize += string7.length + 1;
      });
      return 0;
    }, "_environ_get");
    var _environ_sizes_get = /* @__PURE__ */ __name((penviron_count, penviron_buf_size) => {
      var strings3 = getEnvStrings();
      HEAPU32[penviron_count >> 2] = strings3.length;
      var bufSize = 0;
      strings3.forEach((string7) => bufSize += string7.length + 1);
      HEAPU32[penviron_buf_size >> 2] = bufSize;
      return 0;
    }, "_environ_sizes_get");
    function _fd_close(fd) {
      try {
        var stream6 = SYSCALLS.getStreamFromFD(fd);
        FS.close(stream6);
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    __name(_fd_close, "_fd_close");
    function _fd_fdstat_get(fd, pbuf) {
      try {
        var rightsBase = 0;
        var rightsInheriting = 0;
        var flags = 0;
        {
          var stream6 = SYSCALLS.getStreamFromFD(fd);
          var type3 = stream6.tty ? 2 : FS.isDir(stream6.mode) ? 3 : FS.isLink(stream6.mode) ? 7 : 4;
        }
        HEAP8[pbuf] = type3;
        HEAP16[pbuf + 2 >> 1] = flags;
        tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
        tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    __name(_fd_fdstat_get, "_fd_fdstat_get");
    var doReadv = /* @__PURE__ */ __name((stream6, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.read(stream6, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) break;
        if (typeof offset != "undefined") {
          offset += curr;
        }
      }
      return ret;
    }, "doReadv");
    function _fd_read(fd, iov, iovcnt, pnum) {
      try {
        var stream6 = SYSCALLS.getStreamFromFD(fd);
        var num = doReadv(stream6, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    __name(_fd_read, "_fd_read");
    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
      var offset = convertI32PairToI53Checked(offset_low, offset_high);
      try {
        if (isNaN(offset)) return 61;
        var stream6 = SYSCALLS.getStreamFromFD(fd);
        FS.llseek(stream6, offset, whence);
        tempI64 = [stream6.position >>> 0, (tempDouble = stream6.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
        if (stream6.getdents && offset === 0 && whence === 0) stream6.getdents = null;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    __name(_fd_seek, "_fd_seek");
    function _fd_sync(fd) {
      try {
        var stream6 = SYSCALLS.getStreamFromFD(fd);
        if (stream6.stream_ops?.fsync) {
          return stream6.stream_ops.fsync(stream6);
        }
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    __name(_fd_sync, "_fd_sync");
    var doWritev = /* @__PURE__ */ __name((stream6, iov, iovcnt, offset) => {
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAPU32[iov >> 2];
        var len = HEAPU32[iov + 4 >> 2];
        iov += 8;
        var curr = FS.write(stream6, HEAP8, ptr, len, offset);
        if (curr < 0) return -1;
        ret += curr;
        if (curr < len) {
          break;
        }
        if (typeof offset != "undefined") {
          offset += curr;
        }
      }
      return ret;
    }, "doWritev");
    function _fd_write(fd, iov, iovcnt, pnum) {
      try {
        var stream6 = SYSCALLS.getStreamFromFD(fd);
        var num = doWritev(stream6, iov, iovcnt);
        HEAPU32[pnum >> 2] = num;
        return 0;
      } catch (e) {
        if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
        return e.errno;
      }
    }
    __name(_fd_write, "_fd_write");
    var adapters_support = /* @__PURE__ */ __name(function() {
      const handleAsync = typeof Asyncify === "object" ? Asyncify.handleAsync.bind(Asyncify) : null;
      Module3["handleAsync"] = handleAsync;
      const targets = /* @__PURE__ */ new Map();
      Module3["setCallback"] = (key, target3) => targets.set(key, target3);
      Module3["getCallback"] = (key) => targets.get(key);
      Module3["deleteCallback"] = (key) => targets.delete(key);
      adapters_support = /* @__PURE__ */ __name(function(isAsync, key, ...args2) {
        const receiver = targets.get(key);
        let methodName = null;
        const f = typeof receiver === "function" ? receiver : receiver[methodName = UTF8ToString(args2.shift())];
        if (isAsync) {
          if (handleAsync) {
            return handleAsync(() => f.apply(receiver, args2));
          }
          throw new Error("Synchronous WebAssembly cannot call async function");
        }
        const result = f.apply(receiver, args2);
        if (typeof result?.then == "function") {
          console.error("unexpected Promise", f);
          throw new Error(`${methodName} unexpectedly returned a Promise`);
        }
        return result;
      }, "adapters_support");
    }, "adapters_support");
    function _ipp(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ipp, "_ipp");
    function _ipp_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ipp_async, "_ipp_async");
    function _ippipppp(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ippipppp, "_ippipppp");
    function _ippipppp_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ippipppp_async, "_ippipppp_async");
    function _ippp(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ippp, "_ippp");
    function _ippp_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ippp_async, "_ippp_async");
    function _ipppi(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ipppi, "_ipppi");
    function _ipppi_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ipppi_async, "_ipppi_async");
    function _ipppiii(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ipppiii, "_ipppiii");
    function _ipppiii_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ipppiii_async, "_ipppiii_async");
    function _ipppiiip(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ipppiiip, "_ipppiiip");
    function _ipppiiip_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ipppiiip_async, "_ipppiiip_async");
    function _ipppip(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ipppip, "_ipppip");
    function _ipppip_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ipppip_async, "_ipppip_async");
    function _ipppj(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ipppj, "_ipppj");
    function _ipppj_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ipppj_async, "_ipppj_async");
    function _ipppp(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ipppp, "_ipppp");
    function _ipppp_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ipppp_async, "_ipppp_async");
    function _ippppi(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ippppi, "_ippppi");
    function _ippppi_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ippppi_async, "_ippppi_async");
    function _ippppij(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ippppij, "_ippppij");
    function _ippppij_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ippppij_async, "_ippppij_async");
    function _ippppip(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ippppip, "_ippppip");
    function _ippppip_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ippppip_async, "_ippppip_async");
    function _ipppppip(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_ipppppip, "_ipppppip");
    function _ipppppip_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_ipppppip_async, "_ipppppip_async");
    function _vppippii(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_vppippii, "_vppippii");
    function _vppippii_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_vppippii_async, "_vppippii_async");
    function _vppp(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_vppp, "_vppp");
    function _vppp_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_vppp_async, "_vppp_async");
    function _vpppip(...args2) {
      return adapters_support(false, ...args2);
    }
    __name(_vpppip, "_vpppip");
    function _vpppip_async(...args2) {
      return adapters_support(true, ...args2);
    }
    __name(_vpppip_async, "_vpppip_async");
    var runtimeKeepaliveCounter = 0;
    var keepRuntimeAlive = /* @__PURE__ */ __name(() => noExitRuntime || runtimeKeepaliveCounter > 0, "keepRuntimeAlive");
    var _proc_exit = /* @__PURE__ */ __name((code) => {
      EXITSTATUS = code;
      if (!keepRuntimeAlive()) {
        Module3["onExit"]?.(code);
        ABORT = true;
      }
      quit_(code, new ExitStatus(code));
    }, "_proc_exit");
    var exitJS = /* @__PURE__ */ __name((status3, implicit) => {
      EXITSTATUS = status3;
      _proc_exit(status3);
    }, "exitJS");
    var handleException = /* @__PURE__ */ __name((e) => {
      if (e instanceof ExitStatus || e == "unwind") {
        return EXITSTATUS;
      }
      quit_(1, e);
    }, "handleException");
    var uleb128Encode = /* @__PURE__ */ __name((n, target3) => {
      if (n < 128) {
        target3.push(n);
      } else {
        target3.push(n % 128 | 128, n >> 7);
      }
    }, "uleb128Encode");
    var sigToWasmTypes = /* @__PURE__ */ __name((sig) => {
      var typeNames = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" };
      var type3 = { parameters: [], results: sig[0] == "v" ? [] : [typeNames[sig[0]]] };
      for (var i = 1; i < sig.length; ++i) {
        type3.parameters.push(typeNames[sig[i]]);
      }
      return type3;
    }, "sigToWasmTypes");
    var generateFuncType = /* @__PURE__ */ __name((sig, target3) => {
      var sigRet = sig.slice(0, 1);
      var sigParam = sig.slice(1);
      var typeCodes = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
      target3.push(96);
      uleb128Encode(sigParam.length, target3);
      for (var i = 0; i < sigParam.length; ++i) {
        target3.push(typeCodes[sigParam[i]]);
      }
      if (sigRet == "v") {
        target3.push(0);
      } else {
        target3.push(1, typeCodes[sigRet]);
      }
    }, "generateFuncType");
    var convertJsFunctionToWasm = /* @__PURE__ */ __name((func2, sig) => {
      if (typeof WebAssembly.Function == "function") {
        return new WebAssembly.Function(sigToWasmTypes(sig), func2);
      }
      var typeSectionBody = [1];
      generateFuncType(sig, typeSectionBody);
      var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1];
      uleb128Encode(typeSectionBody.length, bytes);
      bytes.push(...typeSectionBody);
      bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
      var module = new WebAssembly.Module(new Uint8Array(bytes));
      var instance = new WebAssembly.Instance(module, { e: { f: func2 } });
      var wrappedFunc = instance.exports["f"];
      return wrappedFunc;
    }, "convertJsFunctionToWasm");
    var wasmTable;
    var getWasmTableEntry = /* @__PURE__ */ __name((funcPtr) => wasmTable.get(funcPtr), "getWasmTableEntry");
    var updateTableMap = /* @__PURE__ */ __name((offset, count7) => {
      if (functionsInTableMap) {
        for (var i = offset; i < offset + count7; i++) {
          var item = getWasmTableEntry(i);
          if (item) {
            functionsInTableMap.set(item, i);
          }
        }
      }
    }, "updateTableMap");
    var functionsInTableMap;
    var getFunctionAddress = /* @__PURE__ */ __name((func2) => {
      if (!functionsInTableMap) {
        functionsInTableMap = /* @__PURE__ */ new WeakMap();
        updateTableMap(0, wasmTable.length);
      }
      return functionsInTableMap.get(func2) || 0;
    }, "getFunctionAddress");
    var freeTableIndexes = [];
    var getEmptyTableSlot = /* @__PURE__ */ __name(() => {
      if (freeTableIndexes.length) {
        return freeTableIndexes.pop();
      }
      try {
        wasmTable.grow(1);
      } catch (err2) {
        if (!(err2 instanceof RangeError)) {
          throw err2;
        }
        throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
      }
      return wasmTable.length - 1;
    }, "getEmptyTableSlot");
    var setWasmTableEntry = /* @__PURE__ */ __name((idx, func2) => wasmTable.set(idx, func2), "setWasmTableEntry");
    var addFunction = /* @__PURE__ */ __name((func2, sig) => {
      var rtn = getFunctionAddress(func2);
      if (rtn) {
        return rtn;
      }
      var ret = getEmptyTableSlot();
      try {
        setWasmTableEntry(ret, func2);
      } catch (err2) {
        if (!(err2 instanceof TypeError)) {
          throw err2;
        }
        var wrapped = convertJsFunctionToWasm(func2, sig);
        setWasmTableEntry(ret, wrapped);
      }
      functionsInTableMap.set(func2, ret);
      return ret;
    }, "addFunction");
    var getCFunc = /* @__PURE__ */ __name((ident) => {
      var func2 = Module3["_" + ident];
      return func2;
    }, "getCFunc");
    var writeArrayToMemory = /* @__PURE__ */ __name((array7, buffer4) => {
      HEAP8.set(array7, buffer4);
    }, "writeArrayToMemory");
    var stackAlloc = /* @__PURE__ */ __name((sz) => __emscripten_stack_alloc(sz), "stackAlloc");
    var stringToUTF8OnStack = /* @__PURE__ */ __name((str) => {
      var size22 = lengthBytesUTF8(str) + 1;
      var ret = stackAlloc(size22);
      stringToUTF8(str, ret, size22);
      return ret;
    }, "stringToUTF8OnStack");
    var ccall = /* @__PURE__ */ __name((ident, returnType, argTypes, args2, opts) => {
      var toC = { string: /* @__PURE__ */ __name((str) => {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          ret2 = stringToUTF8OnStack(str);
        }
        return ret2;
      }, "string"), array: /* @__PURE__ */ __name((arr) => {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }, "array") };
      function convertReturnValue(ret2) {
        if (returnType === "string") {
          return UTF8ToString(ret2);
        }
        if (returnType === "boolean") return Boolean(ret2);
        return ret2;
      }
      __name(convertReturnValue, "convertReturnValue");
      var func2 = getCFunc(ident);
      var cArgs = [];
      var stack = 0;
      if (args2) {
        for (var i = 0; i < args2.length; i++) {
          var converter = toC[argTypes[i]];
          if (converter) {
            if (stack === 0) stack = stackSave();
            cArgs[i] = converter(args2[i]);
          } else {
            cArgs[i] = args2[i];
          }
        }
      }
      var ret = func2(...cArgs);
      function onDone3(ret2) {
        if (stack !== 0) stackRestore(stack);
        return convertReturnValue(ret2);
      }
      __name(onDone3, "onDone");
      ret = onDone3(ret);
      return ret;
    }, "ccall");
    var cwrap = /* @__PURE__ */ __name((ident, returnType, argTypes, opts) => {
      var numericArgs = !argTypes || argTypes.every((type3) => type3 === "number" || type3 === "boolean");
      var numericRet = returnType !== "string";
      if (numericRet && numericArgs && !opts) {
        return getCFunc(ident);
      }
      return (...args2) => ccall(ident, returnType, argTypes, args2, opts);
    }, "cwrap");
    var getTempRet0 = /* @__PURE__ */ __name((val) => __emscripten_tempret_get(), "getTempRet0");
    var stringToUTF16 = /* @__PURE__ */ __name((str, outPtr, maxBytesToWrite) => {
      maxBytesToWrite ??= 2147483647;
      if (maxBytesToWrite < 2) return 0;
      maxBytesToWrite -= 2;
      var startPtr = outPtr;
      var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
      for (var i = 0; i < numCharsToWrite; ++i) {
        var codeUnit = str.charCodeAt(i);
        HEAP16[outPtr >> 1] = codeUnit;
        outPtr += 2;
      }
      HEAP16[outPtr >> 1] = 0;
      return outPtr - startPtr;
    }, "stringToUTF16");
    var stringToUTF32 = /* @__PURE__ */ __name((str, outPtr, maxBytesToWrite) => {
      maxBytesToWrite ??= 2147483647;
      if (maxBytesToWrite < 4) return 0;
      var startPtr = outPtr;
      var endPtr = startPtr + maxBytesToWrite - 4;
      for (var i = 0; i < str.length; ++i) {
        var codeUnit = str.charCodeAt(i);
        if (codeUnit >= 55296 && codeUnit <= 57343) {
          var trailSurrogate = str.charCodeAt(++i);
          codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
        }
        HEAP32[outPtr >> 2] = codeUnit;
        outPtr += 4;
        if (outPtr + 4 > endPtr) break;
      }
      HEAP32[outPtr >> 2] = 0;
      return outPtr - startPtr;
    }, "stringToUTF32");
    var AsciiToString = /* @__PURE__ */ __name((ptr) => {
      var str = "";
      while (1) {
        var ch = HEAPU8[ptr++];
        if (!ch) return str;
        str += String.fromCharCode(ch);
      }
    }, "AsciiToString");
    var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
    var UTF16ToString = /* @__PURE__ */ __name((ptr, maxBytesToRead) => {
      var endPtr = ptr;
      var idx = endPtr >> 1;
      var maxIdx = idx + maxBytesToRead / 2;
      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
      endPtr = idx << 1;
      if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
      var str = "";
      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
        var codeUnit = HEAP16[ptr + i * 2 >> 1];
        if (codeUnit == 0) break;
        str += String.fromCharCode(codeUnit);
      }
      return str;
    }, "UTF16ToString");
    var UTF32ToString = /* @__PURE__ */ __name((ptr, maxBytesToRead) => {
      var i = 0;
      var str = "";
      while (!(i >= maxBytesToRead / 4)) {
        var utf32 = HEAP32[ptr + i * 4 >> 2];
        if (utf32 == 0) break;
        ++i;
        if (utf32 >= 65536) {
          var ch = utf32 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        } else {
          str += String.fromCharCode(utf32);
        }
      }
      return str;
    }, "UTF32ToString");
    function intArrayToString(array7) {
      var ret = [];
      for (var i = 0; i < array7.length; i++) {
        var chr = array7[i];
        if (chr > 255) {
          chr &= 255;
        }
        ret.push(String.fromCharCode(chr));
      }
      return ret.join("");
    }
    __name(intArrayToString, "intArrayToString");
    FS.createPreloadedFile = FS_createPreloadedFile;
    FS.staticInit();
    MEMFS.doesNotExistError = new FS.ErrnoError(44);
    MEMFS.doesNotExistError.stack = "<generic error, no stack>";
    adapters_support();
    var wasmImports = { a: ___assert_fail, Y: ___syscall_chmod, $: ___syscall_faccessat, Z: ___syscall_fchmod, X: ___syscall_fchown32, b: ___syscall_fcntl64, W: ___syscall_fstat64, y: ___syscall_ftruncate64, Q: ___syscall_getcwd, U: ___syscall_lstat64, N: ___syscall_mkdirat, S: ___syscall_newfstatat, L: ___syscall_openat, J: ___syscall_readlinkat, I: ___syscall_rmdir, V: ___syscall_stat64, G: ___syscall_unlinkat, F: ___syscall_utimensat, w: __localtime_js, u: __mmap_js, v: __munmap_js, M: __tzset_js, n: _emscripten_date_now, m: _emscripten_get_now, D: _emscripten_resize_heap, O: _environ_get, P: _environ_sizes_get, o: _fd_close, E: _fd_fdstat_get, K: _fd_read, x: _fd_seek, R: _fd_sync, H: _fd_write, s: _ipp, t: _ipp_async, ga: _ippipppp, ka: _ippipppp_async, i: _ippp, j: _ippp_async, c: _ipppi, d: _ipppi_async, ca: _ipppiii, da: _ipppiii_async, ea: _ipppiiip, fa: _ipppiiip_async, g: _ipppip, h: _ipppip_async, z: _ipppj, A: _ipppj_async, e: _ipppp, f: _ipppp_async, aa: _ippppi, ba: _ippppi_async, B: _ippppij, C: _ippppij_async, p: _ippppip, q: _ippppip_async, ha: _ipppppip, ia: _ipppppip_async, ja: _vppippii, r: _vppippii_async, k: _vppp, l: _vppp_async, T: _vpppip, _: _vpppip_async };
    var wasmExports = createWasm();
    var ___wasm_call_ctors = /* @__PURE__ */ __name(() => (___wasm_call_ctors = wasmExports["ma"])(), "___wasm_call_ctors");
    var _sqlite3_status64 = Module3["_sqlite3_status64"] = (a0, a1, a2, a3) => (_sqlite3_status64 = Module3["_sqlite3_status64"] = wasmExports["na"])(a0, a1, a2, a3);
    var _sqlite3_status = Module3["_sqlite3_status"] = (a0, a1, a2, a3) => (_sqlite3_status = Module3["_sqlite3_status"] = wasmExports["oa"])(a0, a1, a2, a3);
    var _sqlite3_db_status = Module3["_sqlite3_db_status"] = (a0, a1, a2, a3, a4) => (_sqlite3_db_status = Module3["_sqlite3_db_status"] = wasmExports["pa"])(a0, a1, a2, a3, a4);
    var _sqlite3_msize = Module3["_sqlite3_msize"] = (a0) => (_sqlite3_msize = Module3["_sqlite3_msize"] = wasmExports["qa"])(a0);
    var _sqlite3_vfs_find = Module3["_sqlite3_vfs_find"] = (a0) => (_sqlite3_vfs_find = Module3["_sqlite3_vfs_find"] = wasmExports["ra"])(a0);
    var _sqlite3_vfs_register = Module3["_sqlite3_vfs_register"] = (a0, a1) => (_sqlite3_vfs_register = Module3["_sqlite3_vfs_register"] = wasmExports["sa"])(a0, a1);
    var _sqlite3_vfs_unregister = Module3["_sqlite3_vfs_unregister"] = (a0) => (_sqlite3_vfs_unregister = Module3["_sqlite3_vfs_unregister"] = wasmExports["ta"])(a0);
    var _sqlite3_release_memory = Module3["_sqlite3_release_memory"] = (a0) => (_sqlite3_release_memory = Module3["_sqlite3_release_memory"] = wasmExports["ua"])(a0);
    var _sqlite3_soft_heap_limit64 = Module3["_sqlite3_soft_heap_limit64"] = (a0, a1) => (_sqlite3_soft_heap_limit64 = Module3["_sqlite3_soft_heap_limit64"] = wasmExports["va"])(a0, a1);
    var _sqlite3_memory_used = Module3["_sqlite3_memory_used"] = () => (_sqlite3_memory_used = Module3["_sqlite3_memory_used"] = wasmExports["wa"])();
    var _sqlite3_hard_heap_limit64 = Module3["_sqlite3_hard_heap_limit64"] = (a0, a1) => (_sqlite3_hard_heap_limit64 = Module3["_sqlite3_hard_heap_limit64"] = wasmExports["xa"])(a0, a1);
    var _sqlite3_memory_highwater = Module3["_sqlite3_memory_highwater"] = (a0) => (_sqlite3_memory_highwater = Module3["_sqlite3_memory_highwater"] = wasmExports["ya"])(a0);
    var _sqlite3_malloc = Module3["_sqlite3_malloc"] = (a0) => (_sqlite3_malloc = Module3["_sqlite3_malloc"] = wasmExports["za"])(a0);
    var _sqlite3_malloc64 = Module3["_sqlite3_malloc64"] = (a0, a1) => (_sqlite3_malloc64 = Module3["_sqlite3_malloc64"] = wasmExports["Aa"])(a0, a1);
    var _sqlite3_free = Module3["_sqlite3_free"] = (a0) => (_sqlite3_free = Module3["_sqlite3_free"] = wasmExports["Ba"])(a0);
    var _sqlite3_realloc = Module3["_sqlite3_realloc"] = (a0, a1) => (_sqlite3_realloc = Module3["_sqlite3_realloc"] = wasmExports["Ca"])(a0, a1);
    var _sqlite3_realloc64 = Module3["_sqlite3_realloc64"] = (a0, a1, a2) => (_sqlite3_realloc64 = Module3["_sqlite3_realloc64"] = wasmExports["Da"])(a0, a1, a2);
    var _sqlite3_str_vappendf = Module3["_sqlite3_str_vappendf"] = (a0, a1, a2) => (_sqlite3_str_vappendf = Module3["_sqlite3_str_vappendf"] = wasmExports["Ea"])(a0, a1, a2);
    var _sqlite3_str_append = Module3["_sqlite3_str_append"] = (a0, a1, a2) => (_sqlite3_str_append = Module3["_sqlite3_str_append"] = wasmExports["Fa"])(a0, a1, a2);
    var _sqlite3_str_appendchar = Module3["_sqlite3_str_appendchar"] = (a0, a1, a2) => (_sqlite3_str_appendchar = Module3["_sqlite3_str_appendchar"] = wasmExports["Ga"])(a0, a1, a2);
    var _sqlite3_str_appendall = Module3["_sqlite3_str_appendall"] = (a0, a1) => (_sqlite3_str_appendall = Module3["_sqlite3_str_appendall"] = wasmExports["Ha"])(a0, a1);
    var _sqlite3_str_appendf = Module3["_sqlite3_str_appendf"] = (a0, a1, a2) => (_sqlite3_str_appendf = Module3["_sqlite3_str_appendf"] = wasmExports["Ia"])(a0, a1, a2);
    var _sqlite3_str_finish = Module3["_sqlite3_str_finish"] = (a0) => (_sqlite3_str_finish = Module3["_sqlite3_str_finish"] = wasmExports["Ja"])(a0);
    var _sqlite3_str_errcode = Module3["_sqlite3_str_errcode"] = (a0) => (_sqlite3_str_errcode = Module3["_sqlite3_str_errcode"] = wasmExports["Ka"])(a0);
    var _sqlite3_str_length = Module3["_sqlite3_str_length"] = (a0) => (_sqlite3_str_length = Module3["_sqlite3_str_length"] = wasmExports["La"])(a0);
    var _sqlite3_str_value = Module3["_sqlite3_str_value"] = (a0) => (_sqlite3_str_value = Module3["_sqlite3_str_value"] = wasmExports["Ma"])(a0);
    var _sqlite3_str_reset = Module3["_sqlite3_str_reset"] = (a0) => (_sqlite3_str_reset = Module3["_sqlite3_str_reset"] = wasmExports["Na"])(a0);
    var _sqlite3_str_new = Module3["_sqlite3_str_new"] = (a0) => (_sqlite3_str_new = Module3["_sqlite3_str_new"] = wasmExports["Oa"])(a0);
    var _sqlite3_vmprintf = Module3["_sqlite3_vmprintf"] = (a0, a1) => (_sqlite3_vmprintf = Module3["_sqlite3_vmprintf"] = wasmExports["Pa"])(a0, a1);
    var _sqlite3_mprintf = Module3["_sqlite3_mprintf"] = (a0, a1) => (_sqlite3_mprintf = Module3["_sqlite3_mprintf"] = wasmExports["Qa"])(a0, a1);
    var _sqlite3_vsnprintf = Module3["_sqlite3_vsnprintf"] = (a0, a1, a2, a3) => (_sqlite3_vsnprintf = Module3["_sqlite3_vsnprintf"] = wasmExports["Ra"])(a0, a1, a2, a3);
    var _sqlite3_snprintf = Module3["_sqlite3_snprintf"] = (a0, a1, a2, a3) => (_sqlite3_snprintf = Module3["_sqlite3_snprintf"] = wasmExports["Sa"])(a0, a1, a2, a3);
    var _sqlite3_log = Module3["_sqlite3_log"] = (a0, a1, a2) => (_sqlite3_log = Module3["_sqlite3_log"] = wasmExports["Ta"])(a0, a1, a2);
    var _sqlite3_randomness = Module3["_sqlite3_randomness"] = (a0, a1) => (_sqlite3_randomness = Module3["_sqlite3_randomness"] = wasmExports["Ua"])(a0, a1);
    var _sqlite3_stricmp = Module3["_sqlite3_stricmp"] = (a0, a1) => (_sqlite3_stricmp = Module3["_sqlite3_stricmp"] = wasmExports["Va"])(a0, a1);
    var _sqlite3_strnicmp = Module3["_sqlite3_strnicmp"] = (a0, a1, a2) => (_sqlite3_strnicmp = Module3["_sqlite3_strnicmp"] = wasmExports["Wa"])(a0, a1, a2);
    var _sqlite3_os_init = Module3["_sqlite3_os_init"] = () => (_sqlite3_os_init = Module3["_sqlite3_os_init"] = wasmExports["Xa"])();
    var _sqlite3_os_end = Module3["_sqlite3_os_end"] = () => (_sqlite3_os_end = Module3["_sqlite3_os_end"] = wasmExports["Ya"])();
    var _sqlite3_serialize = Module3["_sqlite3_serialize"] = (a0, a1, a2, a3) => (_sqlite3_serialize = Module3["_sqlite3_serialize"] = wasmExports["Za"])(a0, a1, a2, a3);
    var _sqlite3_prepare_v2 = Module3["_sqlite3_prepare_v2"] = (a0, a1, a2, a3, a4) => (_sqlite3_prepare_v2 = Module3["_sqlite3_prepare_v2"] = wasmExports["_a"])(a0, a1, a2, a3, a4);
    var _sqlite3_step = Module3["_sqlite3_step"] = (a0) => (_sqlite3_step = Module3["_sqlite3_step"] = wasmExports["$a"])(a0);
    var _sqlite3_column_int64 = Module3["_sqlite3_column_int64"] = (a0, a1) => (_sqlite3_column_int64 = Module3["_sqlite3_column_int64"] = wasmExports["ab"])(a0, a1);
    var _sqlite3_reset = Module3["_sqlite3_reset"] = (a0) => (_sqlite3_reset = Module3["_sqlite3_reset"] = wasmExports["bb"])(a0);
    var _sqlite3_exec = Module3["_sqlite3_exec"] = (a0, a1, a2, a3, a4) => (_sqlite3_exec = Module3["_sqlite3_exec"] = wasmExports["cb"])(a0, a1, a2, a3, a4);
    var _sqlite3_column_int = Module3["_sqlite3_column_int"] = (a0, a1) => (_sqlite3_column_int = Module3["_sqlite3_column_int"] = wasmExports["db"])(a0, a1);
    var _sqlite3_finalize = Module3["_sqlite3_finalize"] = (a0) => (_sqlite3_finalize = Module3["_sqlite3_finalize"] = wasmExports["eb"])(a0);
    var _sqlite3_deserialize = Module3["_sqlite3_deserialize"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_sqlite3_deserialize = Module3["_sqlite3_deserialize"] = wasmExports["fb"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _sqlite3_database_file_object = Module3["_sqlite3_database_file_object"] = (a0) => (_sqlite3_database_file_object = Module3["_sqlite3_database_file_object"] = wasmExports["gb"])(a0);
    var _sqlite3_backup_init = Module3["_sqlite3_backup_init"] = (a0, a1, a2, a3) => (_sqlite3_backup_init = Module3["_sqlite3_backup_init"] = wasmExports["hb"])(a0, a1, a2, a3);
    var _sqlite3_backup_step = Module3["_sqlite3_backup_step"] = (a0, a1) => (_sqlite3_backup_step = Module3["_sqlite3_backup_step"] = wasmExports["ib"])(a0, a1);
    var _sqlite3_backup_finish = Module3["_sqlite3_backup_finish"] = (a0) => (_sqlite3_backup_finish = Module3["_sqlite3_backup_finish"] = wasmExports["jb"])(a0);
    var _sqlite3_backup_remaining = Module3["_sqlite3_backup_remaining"] = (a0) => (_sqlite3_backup_remaining = Module3["_sqlite3_backup_remaining"] = wasmExports["kb"])(a0);
    var _sqlite3_backup_pagecount = Module3["_sqlite3_backup_pagecount"] = (a0) => (_sqlite3_backup_pagecount = Module3["_sqlite3_backup_pagecount"] = wasmExports["lb"])(a0);
    var _sqlite3_clear_bindings = Module3["_sqlite3_clear_bindings"] = (a0) => (_sqlite3_clear_bindings = Module3["_sqlite3_clear_bindings"] = wasmExports["mb"])(a0);
    var _sqlite3_value_blob = Module3["_sqlite3_value_blob"] = (a0) => (_sqlite3_value_blob = Module3["_sqlite3_value_blob"] = wasmExports["nb"])(a0);
    var _sqlite3_value_text = Module3["_sqlite3_value_text"] = (a0) => (_sqlite3_value_text = Module3["_sqlite3_value_text"] = wasmExports["ob"])(a0);
    var _sqlite3_value_bytes = Module3["_sqlite3_value_bytes"] = (a0) => (_sqlite3_value_bytes = Module3["_sqlite3_value_bytes"] = wasmExports["pb"])(a0);
    var _sqlite3_value_bytes16 = Module3["_sqlite3_value_bytes16"] = (a0) => (_sqlite3_value_bytes16 = Module3["_sqlite3_value_bytes16"] = wasmExports["qb"])(a0);
    var _sqlite3_value_double = Module3["_sqlite3_value_double"] = (a0) => (_sqlite3_value_double = Module3["_sqlite3_value_double"] = wasmExports["rb"])(a0);
    var _sqlite3_value_int = Module3["_sqlite3_value_int"] = (a0) => (_sqlite3_value_int = Module3["_sqlite3_value_int"] = wasmExports["sb"])(a0);
    var _sqlite3_value_int64 = Module3["_sqlite3_value_int64"] = (a0) => (_sqlite3_value_int64 = Module3["_sqlite3_value_int64"] = wasmExports["tb"])(a0);
    var _sqlite3_value_subtype = Module3["_sqlite3_value_subtype"] = (a0) => (_sqlite3_value_subtype = Module3["_sqlite3_value_subtype"] = wasmExports["ub"])(a0);
    var _sqlite3_value_pointer = Module3["_sqlite3_value_pointer"] = (a0, a1) => (_sqlite3_value_pointer = Module3["_sqlite3_value_pointer"] = wasmExports["vb"])(a0, a1);
    var _sqlite3_value_text16 = Module3["_sqlite3_value_text16"] = (a0) => (_sqlite3_value_text16 = Module3["_sqlite3_value_text16"] = wasmExports["wb"])(a0);
    var _sqlite3_value_text16be = Module3["_sqlite3_value_text16be"] = (a0) => (_sqlite3_value_text16be = Module3["_sqlite3_value_text16be"] = wasmExports["xb"])(a0);
    var _sqlite3_value_text16le = Module3["_sqlite3_value_text16le"] = (a0) => (_sqlite3_value_text16le = Module3["_sqlite3_value_text16le"] = wasmExports["yb"])(a0);
    var _sqlite3_value_type = Module3["_sqlite3_value_type"] = (a0) => (_sqlite3_value_type = Module3["_sqlite3_value_type"] = wasmExports["zb"])(a0);
    var _sqlite3_value_encoding = Module3["_sqlite3_value_encoding"] = (a0) => (_sqlite3_value_encoding = Module3["_sqlite3_value_encoding"] = wasmExports["Ab"])(a0);
    var _sqlite3_value_nochange = Module3["_sqlite3_value_nochange"] = (a0) => (_sqlite3_value_nochange = Module3["_sqlite3_value_nochange"] = wasmExports["Bb"])(a0);
    var _sqlite3_value_frombind = Module3["_sqlite3_value_frombind"] = (a0) => (_sqlite3_value_frombind = Module3["_sqlite3_value_frombind"] = wasmExports["Cb"])(a0);
    var _sqlite3_value_dup = Module3["_sqlite3_value_dup"] = (a0) => (_sqlite3_value_dup = Module3["_sqlite3_value_dup"] = wasmExports["Db"])(a0);
    var _sqlite3_value_free = Module3["_sqlite3_value_free"] = (a0) => (_sqlite3_value_free = Module3["_sqlite3_value_free"] = wasmExports["Eb"])(a0);
    var _sqlite3_result_blob = Module3["_sqlite3_result_blob"] = (a0, a1, a2, a3) => (_sqlite3_result_blob = Module3["_sqlite3_result_blob"] = wasmExports["Fb"])(a0, a1, a2, a3);
    var _sqlite3_result_blob64 = Module3["_sqlite3_result_blob64"] = (a0, a1, a2, a3, a4) => (_sqlite3_result_blob64 = Module3["_sqlite3_result_blob64"] = wasmExports["Gb"])(a0, a1, a2, a3, a4);
    var _sqlite3_result_double = Module3["_sqlite3_result_double"] = (a0, a1) => (_sqlite3_result_double = Module3["_sqlite3_result_double"] = wasmExports["Hb"])(a0, a1);
    var _sqlite3_result_error = Module3["_sqlite3_result_error"] = (a0, a1, a2) => (_sqlite3_result_error = Module3["_sqlite3_result_error"] = wasmExports["Ib"])(a0, a1, a2);
    var _sqlite3_result_error16 = Module3["_sqlite3_result_error16"] = (a0, a1, a2) => (_sqlite3_result_error16 = Module3["_sqlite3_result_error16"] = wasmExports["Jb"])(a0, a1, a2);
    var _sqlite3_result_int = Module3["_sqlite3_result_int"] = (a0, a1) => (_sqlite3_result_int = Module3["_sqlite3_result_int"] = wasmExports["Kb"])(a0, a1);
    var _sqlite3_result_int64 = Module3["_sqlite3_result_int64"] = (a0, a1, a2) => (_sqlite3_result_int64 = Module3["_sqlite3_result_int64"] = wasmExports["Lb"])(a0, a1, a2);
    var _sqlite3_result_null = Module3["_sqlite3_result_null"] = (a0) => (_sqlite3_result_null = Module3["_sqlite3_result_null"] = wasmExports["Mb"])(a0);
    var _sqlite3_result_pointer = Module3["_sqlite3_result_pointer"] = (a0, a1, a2, a3) => (_sqlite3_result_pointer = Module3["_sqlite3_result_pointer"] = wasmExports["Nb"])(a0, a1, a2, a3);
    var _sqlite3_result_subtype = Module3["_sqlite3_result_subtype"] = (a0, a1) => (_sqlite3_result_subtype = Module3["_sqlite3_result_subtype"] = wasmExports["Ob"])(a0, a1);
    var _sqlite3_result_text = Module3["_sqlite3_result_text"] = (a0, a1, a2, a3) => (_sqlite3_result_text = Module3["_sqlite3_result_text"] = wasmExports["Pb"])(a0, a1, a2, a3);
    var _sqlite3_result_text64 = Module3["_sqlite3_result_text64"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3_result_text64 = Module3["_sqlite3_result_text64"] = wasmExports["Qb"])(a0, a1, a2, a3, a4, a5);
    var _sqlite3_result_text16 = Module3["_sqlite3_result_text16"] = (a0, a1, a2, a3) => (_sqlite3_result_text16 = Module3["_sqlite3_result_text16"] = wasmExports["Rb"])(a0, a1, a2, a3);
    var _sqlite3_result_text16be = Module3["_sqlite3_result_text16be"] = (a0, a1, a2, a3) => (_sqlite3_result_text16be = Module3["_sqlite3_result_text16be"] = wasmExports["Sb"])(a0, a1, a2, a3);
    var _sqlite3_result_text16le = Module3["_sqlite3_result_text16le"] = (a0, a1, a2, a3) => (_sqlite3_result_text16le = Module3["_sqlite3_result_text16le"] = wasmExports["Tb"])(a0, a1, a2, a3);
    var _sqlite3_result_value = Module3["_sqlite3_result_value"] = (a0, a1) => (_sqlite3_result_value = Module3["_sqlite3_result_value"] = wasmExports["Ub"])(a0, a1);
    var _sqlite3_result_error_toobig = Module3["_sqlite3_result_error_toobig"] = (a0) => (_sqlite3_result_error_toobig = Module3["_sqlite3_result_error_toobig"] = wasmExports["Vb"])(a0);
    var _sqlite3_result_zeroblob = Module3["_sqlite3_result_zeroblob"] = (a0, a1) => (_sqlite3_result_zeroblob = Module3["_sqlite3_result_zeroblob"] = wasmExports["Wb"])(a0, a1);
    var _sqlite3_result_zeroblob64 = Module3["_sqlite3_result_zeroblob64"] = (a0, a1, a2) => (_sqlite3_result_zeroblob64 = Module3["_sqlite3_result_zeroblob64"] = wasmExports["Xb"])(a0, a1, a2);
    var _sqlite3_result_error_code = Module3["_sqlite3_result_error_code"] = (a0, a1) => (_sqlite3_result_error_code = Module3["_sqlite3_result_error_code"] = wasmExports["Yb"])(a0, a1);
    var _sqlite3_result_error_nomem = Module3["_sqlite3_result_error_nomem"] = (a0) => (_sqlite3_result_error_nomem = Module3["_sqlite3_result_error_nomem"] = wasmExports["Zb"])(a0);
    var _sqlite3_user_data = Module3["_sqlite3_user_data"] = (a0) => (_sqlite3_user_data = Module3["_sqlite3_user_data"] = wasmExports["_b"])(a0);
    var _sqlite3_context_db_handle = Module3["_sqlite3_context_db_handle"] = (a0) => (_sqlite3_context_db_handle = Module3["_sqlite3_context_db_handle"] = wasmExports["$b"])(a0);
    var _sqlite3_vtab_nochange = Module3["_sqlite3_vtab_nochange"] = (a0) => (_sqlite3_vtab_nochange = Module3["_sqlite3_vtab_nochange"] = wasmExports["ac"])(a0);
    var _sqlite3_vtab_in_first = Module3["_sqlite3_vtab_in_first"] = (a0, a1) => (_sqlite3_vtab_in_first = Module3["_sqlite3_vtab_in_first"] = wasmExports["bc"])(a0, a1);
    var _sqlite3_vtab_in_next = Module3["_sqlite3_vtab_in_next"] = (a0, a1) => (_sqlite3_vtab_in_next = Module3["_sqlite3_vtab_in_next"] = wasmExports["cc"])(a0, a1);
    var _sqlite3_aggregate_context = Module3["_sqlite3_aggregate_context"] = (a0, a1) => (_sqlite3_aggregate_context = Module3["_sqlite3_aggregate_context"] = wasmExports["dc"])(a0, a1);
    var _sqlite3_get_auxdata = Module3["_sqlite3_get_auxdata"] = (a0, a1) => (_sqlite3_get_auxdata = Module3["_sqlite3_get_auxdata"] = wasmExports["ec"])(a0, a1);
    var _sqlite3_set_auxdata = Module3["_sqlite3_set_auxdata"] = (a0, a1, a2, a3) => (_sqlite3_set_auxdata = Module3["_sqlite3_set_auxdata"] = wasmExports["fc"])(a0, a1, a2, a3);
    var _sqlite3_column_count = Module3["_sqlite3_column_count"] = (a0) => (_sqlite3_column_count = Module3["_sqlite3_column_count"] = wasmExports["gc"])(a0);
    var _sqlite3_data_count = Module3["_sqlite3_data_count"] = (a0) => (_sqlite3_data_count = Module3["_sqlite3_data_count"] = wasmExports["hc"])(a0);
    var _sqlite3_column_blob = Module3["_sqlite3_column_blob"] = (a0, a1) => (_sqlite3_column_blob = Module3["_sqlite3_column_blob"] = wasmExports["ic"])(a0, a1);
    var _sqlite3_column_bytes = Module3["_sqlite3_column_bytes"] = (a0, a1) => (_sqlite3_column_bytes = Module3["_sqlite3_column_bytes"] = wasmExports["jc"])(a0, a1);
    var _sqlite3_column_bytes16 = Module3["_sqlite3_column_bytes16"] = (a0, a1) => (_sqlite3_column_bytes16 = Module3["_sqlite3_column_bytes16"] = wasmExports["kc"])(a0, a1);
    var _sqlite3_column_double = Module3["_sqlite3_column_double"] = (a0, a1) => (_sqlite3_column_double = Module3["_sqlite3_column_double"] = wasmExports["lc"])(a0, a1);
    var _sqlite3_column_text = Module3["_sqlite3_column_text"] = (a0, a1) => (_sqlite3_column_text = Module3["_sqlite3_column_text"] = wasmExports["mc"])(a0, a1);
    var _sqlite3_column_value = Module3["_sqlite3_column_value"] = (a0, a1) => (_sqlite3_column_value = Module3["_sqlite3_column_value"] = wasmExports["nc"])(a0, a1);
    var _sqlite3_column_text16 = Module3["_sqlite3_column_text16"] = (a0, a1) => (_sqlite3_column_text16 = Module3["_sqlite3_column_text16"] = wasmExports["oc"])(a0, a1);
    var _sqlite3_column_type = Module3["_sqlite3_column_type"] = (a0, a1) => (_sqlite3_column_type = Module3["_sqlite3_column_type"] = wasmExports["pc"])(a0, a1);
    var _sqlite3_column_name = Module3["_sqlite3_column_name"] = (a0, a1) => (_sqlite3_column_name = Module3["_sqlite3_column_name"] = wasmExports["qc"])(a0, a1);
    var _sqlite3_column_name16 = Module3["_sqlite3_column_name16"] = (a0, a1) => (_sqlite3_column_name16 = Module3["_sqlite3_column_name16"] = wasmExports["rc"])(a0, a1);
    var _sqlite3_bind_blob = Module3["_sqlite3_bind_blob"] = (a0, a1, a2, a3, a4) => (_sqlite3_bind_blob = Module3["_sqlite3_bind_blob"] = wasmExports["sc"])(a0, a1, a2, a3, a4);
    var _sqlite3_bind_blob64 = Module3["_sqlite3_bind_blob64"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3_bind_blob64 = Module3["_sqlite3_bind_blob64"] = wasmExports["tc"])(a0, a1, a2, a3, a4, a5);
    var _sqlite3_bind_double = Module3["_sqlite3_bind_double"] = (a0, a1, a2) => (_sqlite3_bind_double = Module3["_sqlite3_bind_double"] = wasmExports["uc"])(a0, a1, a2);
    var _sqlite3_bind_int = Module3["_sqlite3_bind_int"] = (a0, a1, a2) => (_sqlite3_bind_int = Module3["_sqlite3_bind_int"] = wasmExports["vc"])(a0, a1, a2);
    var _sqlite3_bind_int64 = Module3["_sqlite3_bind_int64"] = (a0, a1, a2, a3) => (_sqlite3_bind_int64 = Module3["_sqlite3_bind_int64"] = wasmExports["wc"])(a0, a1, a2, a3);
    var _sqlite3_bind_null = Module3["_sqlite3_bind_null"] = (a0, a1) => (_sqlite3_bind_null = Module3["_sqlite3_bind_null"] = wasmExports["xc"])(a0, a1);
    var _sqlite3_bind_pointer = Module3["_sqlite3_bind_pointer"] = (a0, a1, a2, a3, a4) => (_sqlite3_bind_pointer = Module3["_sqlite3_bind_pointer"] = wasmExports["yc"])(a0, a1, a2, a3, a4);
    var _sqlite3_bind_text = Module3["_sqlite3_bind_text"] = (a0, a1, a2, a3, a4) => (_sqlite3_bind_text = Module3["_sqlite3_bind_text"] = wasmExports["zc"])(a0, a1, a2, a3, a4);
    var _sqlite3_bind_text64 = Module3["_sqlite3_bind_text64"] = (a0, a1, a2, a3, a4, a5, a6) => (_sqlite3_bind_text64 = Module3["_sqlite3_bind_text64"] = wasmExports["Ac"])(a0, a1, a2, a3, a4, a5, a6);
    var _sqlite3_bind_text16 = Module3["_sqlite3_bind_text16"] = (a0, a1, a2, a3, a4) => (_sqlite3_bind_text16 = Module3["_sqlite3_bind_text16"] = wasmExports["Bc"])(a0, a1, a2, a3, a4);
    var _sqlite3_bind_value = Module3["_sqlite3_bind_value"] = (a0, a1, a2) => (_sqlite3_bind_value = Module3["_sqlite3_bind_value"] = wasmExports["Cc"])(a0, a1, a2);
    var _sqlite3_bind_zeroblob = Module3["_sqlite3_bind_zeroblob"] = (a0, a1, a2) => (_sqlite3_bind_zeroblob = Module3["_sqlite3_bind_zeroblob"] = wasmExports["Dc"])(a0, a1, a2);
    var _sqlite3_bind_zeroblob64 = Module3["_sqlite3_bind_zeroblob64"] = (a0, a1, a2, a3) => (_sqlite3_bind_zeroblob64 = Module3["_sqlite3_bind_zeroblob64"] = wasmExports["Ec"])(a0, a1, a2, a3);
    var _sqlite3_bind_parameter_count = Module3["_sqlite3_bind_parameter_count"] = (a0) => (_sqlite3_bind_parameter_count = Module3["_sqlite3_bind_parameter_count"] = wasmExports["Fc"])(a0);
    var _sqlite3_bind_parameter_name = Module3["_sqlite3_bind_parameter_name"] = (a0, a1) => (_sqlite3_bind_parameter_name = Module3["_sqlite3_bind_parameter_name"] = wasmExports["Gc"])(a0, a1);
    var _sqlite3_bind_parameter_index = Module3["_sqlite3_bind_parameter_index"] = (a0, a1) => (_sqlite3_bind_parameter_index = Module3["_sqlite3_bind_parameter_index"] = wasmExports["Hc"])(a0, a1);
    var _sqlite3_db_handle = Module3["_sqlite3_db_handle"] = (a0) => (_sqlite3_db_handle = Module3["_sqlite3_db_handle"] = wasmExports["Ic"])(a0);
    var _sqlite3_stmt_readonly = Module3["_sqlite3_stmt_readonly"] = (a0) => (_sqlite3_stmt_readonly = Module3["_sqlite3_stmt_readonly"] = wasmExports["Jc"])(a0);
    var _sqlite3_stmt_isexplain = Module3["_sqlite3_stmt_isexplain"] = (a0) => (_sqlite3_stmt_isexplain = Module3["_sqlite3_stmt_isexplain"] = wasmExports["Kc"])(a0);
    var _sqlite3_stmt_explain = Module3["_sqlite3_stmt_explain"] = (a0, a1) => (_sqlite3_stmt_explain = Module3["_sqlite3_stmt_explain"] = wasmExports["Lc"])(a0, a1);
    var _sqlite3_stmt_busy = Module3["_sqlite3_stmt_busy"] = (a0) => (_sqlite3_stmt_busy = Module3["_sqlite3_stmt_busy"] = wasmExports["Mc"])(a0);
    var _sqlite3_next_stmt = Module3["_sqlite3_next_stmt"] = (a0, a1) => (_sqlite3_next_stmt = Module3["_sqlite3_next_stmt"] = wasmExports["Nc"])(a0, a1);
    var _sqlite3_stmt_status = Module3["_sqlite3_stmt_status"] = (a0, a1, a2) => (_sqlite3_stmt_status = Module3["_sqlite3_stmt_status"] = wasmExports["Oc"])(a0, a1, a2);
    var _sqlite3_sql = Module3["_sqlite3_sql"] = (a0) => (_sqlite3_sql = Module3["_sqlite3_sql"] = wasmExports["Pc"])(a0);
    var _sqlite3_expanded_sql = Module3["_sqlite3_expanded_sql"] = (a0) => (_sqlite3_expanded_sql = Module3["_sqlite3_expanded_sql"] = wasmExports["Qc"])(a0);
    var _sqlite3_value_numeric_type = Module3["_sqlite3_value_numeric_type"] = (a0) => (_sqlite3_value_numeric_type = Module3["_sqlite3_value_numeric_type"] = wasmExports["Rc"])(a0);
    var _sqlite3_blob_open = Module3["_sqlite3_blob_open"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_sqlite3_blob_open = Module3["_sqlite3_blob_open"] = wasmExports["Sc"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _sqlite3_blob_close = Module3["_sqlite3_blob_close"] = (a0) => (_sqlite3_blob_close = Module3["_sqlite3_blob_close"] = wasmExports["Tc"])(a0);
    var _sqlite3_blob_read = Module3["_sqlite3_blob_read"] = (a0, a1, a2, a3) => (_sqlite3_blob_read = Module3["_sqlite3_blob_read"] = wasmExports["Uc"])(a0, a1, a2, a3);
    var _sqlite3_blob_write = Module3["_sqlite3_blob_write"] = (a0, a1, a2, a3) => (_sqlite3_blob_write = Module3["_sqlite3_blob_write"] = wasmExports["Vc"])(a0, a1, a2, a3);
    var _sqlite3_blob_bytes = Module3["_sqlite3_blob_bytes"] = (a0) => (_sqlite3_blob_bytes = Module3["_sqlite3_blob_bytes"] = wasmExports["Wc"])(a0);
    var _sqlite3_blob_reopen = Module3["_sqlite3_blob_reopen"] = (a0, a1, a2) => (_sqlite3_blob_reopen = Module3["_sqlite3_blob_reopen"] = wasmExports["Xc"])(a0, a1, a2);
    var _sqlite3_set_authorizer = Module3["_sqlite3_set_authorizer"] = (a0, a1, a2) => (_sqlite3_set_authorizer = Module3["_sqlite3_set_authorizer"] = wasmExports["Yc"])(a0, a1, a2);
    var _sqlite3_strglob = Module3["_sqlite3_strglob"] = (a0, a1) => (_sqlite3_strglob = Module3["_sqlite3_strglob"] = wasmExports["Zc"])(a0, a1);
    var _sqlite3_strlike = Module3["_sqlite3_strlike"] = (a0, a1, a2) => (_sqlite3_strlike = Module3["_sqlite3_strlike"] = wasmExports["_c"])(a0, a1, a2);
    var _sqlite3_errmsg = Module3["_sqlite3_errmsg"] = (a0) => (_sqlite3_errmsg = Module3["_sqlite3_errmsg"] = wasmExports["$c"])(a0);
    var _sqlite3_auto_extension = Module3["_sqlite3_auto_extension"] = (a0) => (_sqlite3_auto_extension = Module3["_sqlite3_auto_extension"] = wasmExports["ad"])(a0);
    var _sqlite3_cancel_auto_extension = Module3["_sqlite3_cancel_auto_extension"] = (a0) => (_sqlite3_cancel_auto_extension = Module3["_sqlite3_cancel_auto_extension"] = wasmExports["bd"])(a0);
    var _sqlite3_reset_auto_extension = Module3["_sqlite3_reset_auto_extension"] = () => (_sqlite3_reset_auto_extension = Module3["_sqlite3_reset_auto_extension"] = wasmExports["cd"])();
    var _sqlite3_prepare = Module3["_sqlite3_prepare"] = (a0, a1, a2, a3, a4) => (_sqlite3_prepare = Module3["_sqlite3_prepare"] = wasmExports["dd"])(a0, a1, a2, a3, a4);
    var _sqlite3_prepare_v3 = Module3["_sqlite3_prepare_v3"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3_prepare_v3 = Module3["_sqlite3_prepare_v3"] = wasmExports["ed"])(a0, a1, a2, a3, a4, a5);
    var _sqlite3_prepare16 = Module3["_sqlite3_prepare16"] = (a0, a1, a2, a3, a4) => (_sqlite3_prepare16 = Module3["_sqlite3_prepare16"] = wasmExports["fd"])(a0, a1, a2, a3, a4);
    var _sqlite3_prepare16_v2 = Module3["_sqlite3_prepare16_v2"] = (a0, a1, a2, a3, a4) => (_sqlite3_prepare16_v2 = Module3["_sqlite3_prepare16_v2"] = wasmExports["gd"])(a0, a1, a2, a3, a4);
    var _sqlite3_prepare16_v3 = Module3["_sqlite3_prepare16_v3"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3_prepare16_v3 = Module3["_sqlite3_prepare16_v3"] = wasmExports["hd"])(a0, a1, a2, a3, a4, a5);
    var _sqlite3_get_table = Module3["_sqlite3_get_table"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3_get_table = Module3["_sqlite3_get_table"] = wasmExports["id"])(a0, a1, a2, a3, a4, a5);
    var _sqlite3_free_table = Module3["_sqlite3_free_table"] = (a0) => (_sqlite3_free_table = Module3["_sqlite3_free_table"] = wasmExports["jd"])(a0);
    var _sqlite3_create_module = Module3["_sqlite3_create_module"] = (a0, a1, a2, a3) => (_sqlite3_create_module = Module3["_sqlite3_create_module"] = wasmExports["kd"])(a0, a1, a2, a3);
    var _sqlite3_create_module_v2 = Module3["_sqlite3_create_module_v2"] = (a0, a1, a2, a3, a4) => (_sqlite3_create_module_v2 = Module3["_sqlite3_create_module_v2"] = wasmExports["ld"])(a0, a1, a2, a3, a4);
    var _sqlite3_drop_modules = Module3["_sqlite3_drop_modules"] = (a0, a1) => (_sqlite3_drop_modules = Module3["_sqlite3_drop_modules"] = wasmExports["md"])(a0, a1);
    var _sqlite3_declare_vtab = Module3["_sqlite3_declare_vtab"] = (a0, a1) => (_sqlite3_declare_vtab = Module3["_sqlite3_declare_vtab"] = wasmExports["nd"])(a0, a1);
    var _sqlite3_vtab_on_conflict = Module3["_sqlite3_vtab_on_conflict"] = (a0) => (_sqlite3_vtab_on_conflict = Module3["_sqlite3_vtab_on_conflict"] = wasmExports["od"])(a0);
    var _sqlite3_vtab_config = Module3["_sqlite3_vtab_config"] = (a0, a1, a2) => (_sqlite3_vtab_config = Module3["_sqlite3_vtab_config"] = wasmExports["pd"])(a0, a1, a2);
    var _sqlite3_vtab_collation = Module3["_sqlite3_vtab_collation"] = (a0, a1) => (_sqlite3_vtab_collation = Module3["_sqlite3_vtab_collation"] = wasmExports["qd"])(a0, a1);
    var _sqlite3_vtab_in = Module3["_sqlite3_vtab_in"] = (a0, a1, a2) => (_sqlite3_vtab_in = Module3["_sqlite3_vtab_in"] = wasmExports["rd"])(a0, a1, a2);
    var _sqlite3_vtab_rhs_value = Module3["_sqlite3_vtab_rhs_value"] = (a0, a1, a2) => (_sqlite3_vtab_rhs_value = Module3["_sqlite3_vtab_rhs_value"] = wasmExports["sd"])(a0, a1, a2);
    var _sqlite3_vtab_distinct = Module3["_sqlite3_vtab_distinct"] = (a0) => (_sqlite3_vtab_distinct = Module3["_sqlite3_vtab_distinct"] = wasmExports["td"])(a0);
    var _sqlite3_keyword_name = Module3["_sqlite3_keyword_name"] = (a0, a1, a2) => (_sqlite3_keyword_name = Module3["_sqlite3_keyword_name"] = wasmExports["ud"])(a0, a1, a2);
    var _sqlite3_keyword_count = Module3["_sqlite3_keyword_count"] = () => (_sqlite3_keyword_count = Module3["_sqlite3_keyword_count"] = wasmExports["vd"])();
    var _sqlite3_keyword_check = Module3["_sqlite3_keyword_check"] = (a0, a1) => (_sqlite3_keyword_check = Module3["_sqlite3_keyword_check"] = wasmExports["wd"])(a0, a1);
    var _sqlite3_complete = Module3["_sqlite3_complete"] = (a0) => (_sqlite3_complete = Module3["_sqlite3_complete"] = wasmExports["xd"])(a0);
    var _sqlite3_complete16 = Module3["_sqlite3_complete16"] = (a0) => (_sqlite3_complete16 = Module3["_sqlite3_complete16"] = wasmExports["yd"])(a0);
    var _sqlite3_libversion = Module3["_sqlite3_libversion"] = () => (_sqlite3_libversion = Module3["_sqlite3_libversion"] = wasmExports["zd"])();
    var _sqlite3_libversion_number = Module3["_sqlite3_libversion_number"] = () => (_sqlite3_libversion_number = Module3["_sqlite3_libversion_number"] = wasmExports["Ad"])();
    var _sqlite3_threadsafe = Module3["_sqlite3_threadsafe"] = () => (_sqlite3_threadsafe = Module3["_sqlite3_threadsafe"] = wasmExports["Bd"])();
    var _sqlite3_initialize = Module3["_sqlite3_initialize"] = () => (_sqlite3_initialize = Module3["_sqlite3_initialize"] = wasmExports["Cd"])();
    var _sqlite3_shutdown = Module3["_sqlite3_shutdown"] = () => (_sqlite3_shutdown = Module3["_sqlite3_shutdown"] = wasmExports["Dd"])();
    var _sqlite3_config = Module3["_sqlite3_config"] = (a0, a1) => (_sqlite3_config = Module3["_sqlite3_config"] = wasmExports["Ed"])(a0, a1);
    var _sqlite3_db_mutex = Module3["_sqlite3_db_mutex"] = (a0) => (_sqlite3_db_mutex = Module3["_sqlite3_db_mutex"] = wasmExports["Fd"])(a0);
    var _sqlite3_db_release_memory = Module3["_sqlite3_db_release_memory"] = (a0) => (_sqlite3_db_release_memory = Module3["_sqlite3_db_release_memory"] = wasmExports["Gd"])(a0);
    var _sqlite3_db_cacheflush = Module3["_sqlite3_db_cacheflush"] = (a0) => (_sqlite3_db_cacheflush = Module3["_sqlite3_db_cacheflush"] = wasmExports["Hd"])(a0);
    var _sqlite3_db_config = Module3["_sqlite3_db_config"] = (a0, a1, a2) => (_sqlite3_db_config = Module3["_sqlite3_db_config"] = wasmExports["Id"])(a0, a1, a2);
    var _sqlite3_last_insert_rowid = Module3["_sqlite3_last_insert_rowid"] = (a0) => (_sqlite3_last_insert_rowid = Module3["_sqlite3_last_insert_rowid"] = wasmExports["Jd"])(a0);
    var _sqlite3_set_last_insert_rowid = Module3["_sqlite3_set_last_insert_rowid"] = (a0, a1, a2) => (_sqlite3_set_last_insert_rowid = Module3["_sqlite3_set_last_insert_rowid"] = wasmExports["Kd"])(a0, a1, a2);
    var _sqlite3_changes64 = Module3["_sqlite3_changes64"] = (a0) => (_sqlite3_changes64 = Module3["_sqlite3_changes64"] = wasmExports["Ld"])(a0);
    var _sqlite3_changes = Module3["_sqlite3_changes"] = (a0) => (_sqlite3_changes = Module3["_sqlite3_changes"] = wasmExports["Md"])(a0);
    var _sqlite3_total_changes64 = Module3["_sqlite3_total_changes64"] = (a0) => (_sqlite3_total_changes64 = Module3["_sqlite3_total_changes64"] = wasmExports["Nd"])(a0);
    var _sqlite3_total_changes = Module3["_sqlite3_total_changes"] = (a0) => (_sqlite3_total_changes = Module3["_sqlite3_total_changes"] = wasmExports["Od"])(a0);
    var _sqlite3_txn_state = Module3["_sqlite3_txn_state"] = (a0, a1) => (_sqlite3_txn_state = Module3["_sqlite3_txn_state"] = wasmExports["Pd"])(a0, a1);
    var _sqlite3_close = Module3["_sqlite3_close"] = (a0) => (_sqlite3_close = Module3["_sqlite3_close"] = wasmExports["Qd"])(a0);
    var _sqlite3_close_v2 = Module3["_sqlite3_close_v2"] = (a0) => (_sqlite3_close_v2 = Module3["_sqlite3_close_v2"] = wasmExports["Rd"])(a0);
    var _sqlite3_busy_handler = Module3["_sqlite3_busy_handler"] = (a0, a1, a2) => (_sqlite3_busy_handler = Module3["_sqlite3_busy_handler"] = wasmExports["Sd"])(a0, a1, a2);
    var _sqlite3_progress_handler = Module3["_sqlite3_progress_handler"] = (a0, a1, a2, a3) => (_sqlite3_progress_handler = Module3["_sqlite3_progress_handler"] = wasmExports["Td"])(a0, a1, a2, a3);
    var _sqlite3_busy_timeout = Module3["_sqlite3_busy_timeout"] = (a0, a1) => (_sqlite3_busy_timeout = Module3["_sqlite3_busy_timeout"] = wasmExports["Ud"])(a0, a1);
    var _sqlite3_interrupt = Module3["_sqlite3_interrupt"] = (a0) => (_sqlite3_interrupt = Module3["_sqlite3_interrupt"] = wasmExports["Vd"])(a0);
    var _sqlite3_is_interrupted = Module3["_sqlite3_is_interrupted"] = (a0) => (_sqlite3_is_interrupted = Module3["_sqlite3_is_interrupted"] = wasmExports["Wd"])(a0);
    var _sqlite3_create_function = Module3["_sqlite3_create_function"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_sqlite3_create_function = Module3["_sqlite3_create_function"] = wasmExports["Xd"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _sqlite3_create_function_v2 = Module3["_sqlite3_create_function_v2"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_sqlite3_create_function_v2 = Module3["_sqlite3_create_function_v2"] = wasmExports["Yd"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    var _sqlite3_create_window_function = Module3["_sqlite3_create_window_function"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (_sqlite3_create_window_function = Module3["_sqlite3_create_window_function"] = wasmExports["Zd"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
    var _sqlite3_create_function16 = Module3["_sqlite3_create_function16"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_sqlite3_create_function16 = Module3["_sqlite3_create_function16"] = wasmExports["_d"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _sqlite3_overload_function = Module3["_sqlite3_overload_function"] = (a0, a1, a2) => (_sqlite3_overload_function = Module3["_sqlite3_overload_function"] = wasmExports["$d"])(a0, a1, a2);
    var _sqlite3_trace_v2 = Module3["_sqlite3_trace_v2"] = (a0, a1, a2, a3) => (_sqlite3_trace_v2 = Module3["_sqlite3_trace_v2"] = wasmExports["ae"])(a0, a1, a2, a3);
    var _sqlite3_commit_hook = Module3["_sqlite3_commit_hook"] = (a0, a1, a2) => (_sqlite3_commit_hook = Module3["_sqlite3_commit_hook"] = wasmExports["be"])(a0, a1, a2);
    var _sqlite3_update_hook = Module3["_sqlite3_update_hook"] = (a0, a1, a2) => (_sqlite3_update_hook = Module3["_sqlite3_update_hook"] = wasmExports["ce"])(a0, a1, a2);
    var _sqlite3_rollback_hook = Module3["_sqlite3_rollback_hook"] = (a0, a1, a2) => (_sqlite3_rollback_hook = Module3["_sqlite3_rollback_hook"] = wasmExports["de"])(a0, a1, a2);
    var _sqlite3_autovacuum_pages = Module3["_sqlite3_autovacuum_pages"] = (a0, a1, a2, a3) => (_sqlite3_autovacuum_pages = Module3["_sqlite3_autovacuum_pages"] = wasmExports["ee"])(a0, a1, a2, a3);
    var _sqlite3_wal_autocheckpoint = Module3["_sqlite3_wal_autocheckpoint"] = (a0, a1) => (_sqlite3_wal_autocheckpoint = Module3["_sqlite3_wal_autocheckpoint"] = wasmExports["fe"])(a0, a1);
    var _sqlite3_wal_hook = Module3["_sqlite3_wal_hook"] = (a0, a1, a2) => (_sqlite3_wal_hook = Module3["_sqlite3_wal_hook"] = wasmExports["ge"])(a0, a1, a2);
    var _sqlite3_wal_checkpoint_v2 = Module3["_sqlite3_wal_checkpoint_v2"] = (a0, a1, a2, a3, a4) => (_sqlite3_wal_checkpoint_v2 = Module3["_sqlite3_wal_checkpoint_v2"] = wasmExports["he"])(a0, a1, a2, a3, a4);
    var _sqlite3_wal_checkpoint = Module3["_sqlite3_wal_checkpoint"] = (a0, a1) => (_sqlite3_wal_checkpoint = Module3["_sqlite3_wal_checkpoint"] = wasmExports["ie"])(a0, a1);
    var _sqlite3_error_offset = Module3["_sqlite3_error_offset"] = (a0) => (_sqlite3_error_offset = Module3["_sqlite3_error_offset"] = wasmExports["je"])(a0);
    var _sqlite3_errmsg16 = Module3["_sqlite3_errmsg16"] = (a0) => (_sqlite3_errmsg16 = Module3["_sqlite3_errmsg16"] = wasmExports["ke"])(a0);
    var _sqlite3_errcode = Module3["_sqlite3_errcode"] = (a0) => (_sqlite3_errcode = Module3["_sqlite3_errcode"] = wasmExports["le"])(a0);
    var _sqlite3_extended_errcode = Module3["_sqlite3_extended_errcode"] = (a0) => (_sqlite3_extended_errcode = Module3["_sqlite3_extended_errcode"] = wasmExports["me"])(a0);
    var _sqlite3_system_errno = Module3["_sqlite3_system_errno"] = (a0) => (_sqlite3_system_errno = Module3["_sqlite3_system_errno"] = wasmExports["ne"])(a0);
    var _sqlite3_errstr = Module3["_sqlite3_errstr"] = (a0) => (_sqlite3_errstr = Module3["_sqlite3_errstr"] = wasmExports["oe"])(a0);
    var _sqlite3_limit = Module3["_sqlite3_limit"] = (a0, a1, a2) => (_sqlite3_limit = Module3["_sqlite3_limit"] = wasmExports["pe"])(a0, a1, a2);
    var _sqlite3_open = Module3["_sqlite3_open"] = (a0, a1) => (_sqlite3_open = Module3["_sqlite3_open"] = wasmExports["qe"])(a0, a1);
    var _sqlite3_open_v2 = Module3["_sqlite3_open_v2"] = (a0, a1, a2, a3) => (_sqlite3_open_v2 = Module3["_sqlite3_open_v2"] = wasmExports["re"])(a0, a1, a2, a3);
    var _sqlite3_open16 = Module3["_sqlite3_open16"] = (a0, a1) => (_sqlite3_open16 = Module3["_sqlite3_open16"] = wasmExports["se"])(a0, a1);
    var _sqlite3_create_collation = Module3["_sqlite3_create_collation"] = (a0, a1, a2, a3, a4) => (_sqlite3_create_collation = Module3["_sqlite3_create_collation"] = wasmExports["te"])(a0, a1, a2, a3, a4);
    var _sqlite3_create_collation_v2 = Module3["_sqlite3_create_collation_v2"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3_create_collation_v2 = Module3["_sqlite3_create_collation_v2"] = wasmExports["ue"])(a0, a1, a2, a3, a4, a5);
    var _sqlite3_create_collation16 = Module3["_sqlite3_create_collation16"] = (a0, a1, a2, a3, a4) => (_sqlite3_create_collation16 = Module3["_sqlite3_create_collation16"] = wasmExports["ve"])(a0, a1, a2, a3, a4);
    var _sqlite3_collation_needed = Module3["_sqlite3_collation_needed"] = (a0, a1, a2) => (_sqlite3_collation_needed = Module3["_sqlite3_collation_needed"] = wasmExports["we"])(a0, a1, a2);
    var _sqlite3_collation_needed16 = Module3["_sqlite3_collation_needed16"] = (a0, a1, a2) => (_sqlite3_collation_needed16 = Module3["_sqlite3_collation_needed16"] = wasmExports["xe"])(a0, a1, a2);
    var _sqlite3_get_clientdata = Module3["_sqlite3_get_clientdata"] = (a0, a1) => (_sqlite3_get_clientdata = Module3["_sqlite3_get_clientdata"] = wasmExports["ye"])(a0, a1);
    var _sqlite3_set_clientdata = Module3["_sqlite3_set_clientdata"] = (a0, a1, a2, a3) => (_sqlite3_set_clientdata = Module3["_sqlite3_set_clientdata"] = wasmExports["ze"])(a0, a1, a2, a3);
    var _sqlite3_get_autocommit = Module3["_sqlite3_get_autocommit"] = (a0) => (_sqlite3_get_autocommit = Module3["_sqlite3_get_autocommit"] = wasmExports["Ae"])(a0);
    var _sqlite3_table_column_metadata = Module3["_sqlite3_table_column_metadata"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_sqlite3_table_column_metadata = Module3["_sqlite3_table_column_metadata"] = wasmExports["Be"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
    var _sqlite3_sleep = Module3["_sqlite3_sleep"] = (a0) => (_sqlite3_sleep = Module3["_sqlite3_sleep"] = wasmExports["Ce"])(a0);
    var _sqlite3_extended_result_codes = Module3["_sqlite3_extended_result_codes"] = (a0, a1) => (_sqlite3_extended_result_codes = Module3["_sqlite3_extended_result_codes"] = wasmExports["De"])(a0, a1);
    var _sqlite3_file_control = Module3["_sqlite3_file_control"] = (a0, a1, a2, a3) => (_sqlite3_file_control = Module3["_sqlite3_file_control"] = wasmExports["Ee"])(a0, a1, a2, a3);
    var _sqlite3_test_control = Module3["_sqlite3_test_control"] = (a0, a1) => (_sqlite3_test_control = Module3["_sqlite3_test_control"] = wasmExports["Fe"])(a0, a1);
    var _sqlite3_create_filename = Module3["_sqlite3_create_filename"] = (a0, a1, a2, a3, a4) => (_sqlite3_create_filename = Module3["_sqlite3_create_filename"] = wasmExports["Ge"])(a0, a1, a2, a3, a4);
    var _sqlite3_free_filename = Module3["_sqlite3_free_filename"] = (a0) => (_sqlite3_free_filename = Module3["_sqlite3_free_filename"] = wasmExports["He"])(a0);
    var _sqlite3_uri_parameter = Module3["_sqlite3_uri_parameter"] = (a0, a1) => (_sqlite3_uri_parameter = Module3["_sqlite3_uri_parameter"] = wasmExports["Ie"])(a0, a1);
    var _sqlite3_uri_key = Module3["_sqlite3_uri_key"] = (a0, a1) => (_sqlite3_uri_key = Module3["_sqlite3_uri_key"] = wasmExports["Je"])(a0, a1);
    var _sqlite3_uri_boolean = Module3["_sqlite3_uri_boolean"] = (a0, a1, a2) => (_sqlite3_uri_boolean = Module3["_sqlite3_uri_boolean"] = wasmExports["Ke"])(a0, a1, a2);
    var _sqlite3_uri_int64 = Module3["_sqlite3_uri_int64"] = (a0, a1, a2, a3) => (_sqlite3_uri_int64 = Module3["_sqlite3_uri_int64"] = wasmExports["Le"])(a0, a1, a2, a3);
    var _sqlite3_filename_database = Module3["_sqlite3_filename_database"] = (a0) => (_sqlite3_filename_database = Module3["_sqlite3_filename_database"] = wasmExports["Me"])(a0);
    var _sqlite3_filename_journal = Module3["_sqlite3_filename_journal"] = (a0) => (_sqlite3_filename_journal = Module3["_sqlite3_filename_journal"] = wasmExports["Ne"])(a0);
    var _sqlite3_filename_wal = Module3["_sqlite3_filename_wal"] = (a0) => (_sqlite3_filename_wal = Module3["_sqlite3_filename_wal"] = wasmExports["Oe"])(a0);
    var _sqlite3_db_name = Module3["_sqlite3_db_name"] = (a0, a1) => (_sqlite3_db_name = Module3["_sqlite3_db_name"] = wasmExports["Pe"])(a0, a1);
    var _sqlite3_db_filename = Module3["_sqlite3_db_filename"] = (a0, a1) => (_sqlite3_db_filename = Module3["_sqlite3_db_filename"] = wasmExports["Qe"])(a0, a1);
    var _sqlite3_db_readonly = Module3["_sqlite3_db_readonly"] = (a0, a1) => (_sqlite3_db_readonly = Module3["_sqlite3_db_readonly"] = wasmExports["Re"])(a0, a1);
    var _sqlite3_compileoption_used = Module3["_sqlite3_compileoption_used"] = (a0) => (_sqlite3_compileoption_used = Module3["_sqlite3_compileoption_used"] = wasmExports["Se"])(a0);
    var _sqlite3_compileoption_get = Module3["_sqlite3_compileoption_get"] = (a0) => (_sqlite3_compileoption_get = Module3["_sqlite3_compileoption_get"] = wasmExports["Te"])(a0);
    var _sqlite3session_create = Module3["_sqlite3session_create"] = (a0, a1, a2) => (_sqlite3session_create = Module3["_sqlite3session_create"] = wasmExports["Ue"])(a0, a1, a2);
    var _sqlite3session_delete = Module3["_sqlite3session_delete"] = (a0) => (_sqlite3session_delete = Module3["_sqlite3session_delete"] = wasmExports["Ve"])(a0);
    var _sqlite3session_attach = Module3["_sqlite3session_attach"] = (a0, a1) => (_sqlite3session_attach = Module3["_sqlite3session_attach"] = wasmExports["We"])(a0, a1);
    var _sqlite3session_changeset = Module3["_sqlite3session_changeset"] = (a0, a1, a2) => (_sqlite3session_changeset = Module3["_sqlite3session_changeset"] = wasmExports["Xe"])(a0, a1, a2);
    var _sqlite3session_enable = Module3["_sqlite3session_enable"] = (a0, a1) => (_sqlite3session_enable = Module3["_sqlite3session_enable"] = wasmExports["Ye"])(a0, a1);
    var _sqlite3changeset_start = Module3["_sqlite3changeset_start"] = (a0, a1, a2) => (_sqlite3changeset_start = Module3["_sqlite3changeset_start"] = wasmExports["Ze"])(a0, a1, a2);
    var _sqlite3changeset_finalize = Module3["_sqlite3changeset_finalize"] = (a0) => (_sqlite3changeset_finalize = Module3["_sqlite3changeset_finalize"] = wasmExports["_e"])(a0);
    var _sqlite3changeset_invert = Module3["_sqlite3changeset_invert"] = (a0, a1, a2, a3) => (_sqlite3changeset_invert = Module3["_sqlite3changeset_invert"] = wasmExports["$e"])(a0, a1, a2, a3);
    var _sqlite3changeset_apply = Module3["_sqlite3changeset_apply"] = (a0, a1, a2, a3, a4, a5) => (_sqlite3changeset_apply = Module3["_sqlite3changeset_apply"] = wasmExports["af"])(a0, a1, a2, a3, a4, a5);
    var _sqlite3_sourceid = Module3["_sqlite3_sourceid"] = () => (_sqlite3_sourceid = Module3["_sqlite3_sourceid"] = wasmExports["bf"])();
    var _malloc = Module3["_malloc"] = (a0) => (_malloc = Module3["_malloc"] = wasmExports["cf"])(a0);
    var _free = Module3["_free"] = (a0) => (_free = Module3["_free"] = wasmExports["df"])(a0);
    var _RegisterExtensionFunctions = Module3["_RegisterExtensionFunctions"] = (a0) => (_RegisterExtensionFunctions = Module3["_RegisterExtensionFunctions"] = wasmExports["ef"])(a0);
    var _getSqliteFree = Module3["_getSqliteFree"] = () => (_getSqliteFree = Module3["_getSqliteFree"] = wasmExports["ff"])();
    var _main = Module3["_main"] = (a0, a1) => (_main = Module3["_main"] = wasmExports["gf"])(a0, a1);
    var _libauthorizer_set_authorizer = Module3["_libauthorizer_set_authorizer"] = (a0, a1, a2) => (_libauthorizer_set_authorizer = Module3["_libauthorizer_set_authorizer"] = wasmExports["hf"])(a0, a1, a2);
    var _libfunction_create_function = Module3["_libfunction_create_function"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (_libfunction_create_function = Module3["_libfunction_create_function"] = wasmExports["jf"])(a0, a1, a2, a3, a4, a5, a6, a7);
    var _libhook_commit_hook = Module3["_libhook_commit_hook"] = (a0, a1, a2) => (_libhook_commit_hook = Module3["_libhook_commit_hook"] = wasmExports["kf"])(a0, a1, a2);
    var _libhook_update_hook = Module3["_libhook_update_hook"] = (a0, a1, a2) => (_libhook_update_hook = Module3["_libhook_update_hook"] = wasmExports["lf"])(a0, a1, a2);
    var _libprogress_progress_handler = Module3["_libprogress_progress_handler"] = (a0, a1, a2, a3) => (_libprogress_progress_handler = Module3["_libprogress_progress_handler"] = wasmExports["mf"])(a0, a1, a2, a3);
    var _libvfs_vfs_register = Module3["_libvfs_vfs_register"] = (a0, a1, a2, a3, a4, a5) => (_libvfs_vfs_register = Module3["_libvfs_vfs_register"] = wasmExports["nf"])(a0, a1, a2, a3, a4, a5);
    var _emscripten_builtin_memalign = /* @__PURE__ */ __name((a0, a1) => (_emscripten_builtin_memalign = wasmExports["pf"])(a0, a1), "_emscripten_builtin_memalign");
    var __emscripten_tempret_get = /* @__PURE__ */ __name(() => (__emscripten_tempret_get = wasmExports["qf"])(), "__emscripten_tempret_get");
    var __emscripten_stack_restore = /* @__PURE__ */ __name((a0) => (__emscripten_stack_restore = wasmExports["rf"])(a0), "__emscripten_stack_restore");
    var __emscripten_stack_alloc = /* @__PURE__ */ __name((a0) => (__emscripten_stack_alloc = wasmExports["sf"])(a0), "__emscripten_stack_alloc");
    var _emscripten_stack_get_current = /* @__PURE__ */ __name(() => (_emscripten_stack_get_current = wasmExports["tf"])(), "_emscripten_stack_get_current");
    var _sqlite3_version = Module3["_sqlite3_version"] = 5472;
    Module3["getTempRet0"] = getTempRet0;
    Module3["ccall"] = ccall;
    Module3["cwrap"] = cwrap;
    Module3["addFunction"] = addFunction;
    Module3["setValue"] = setValue;
    Module3["getValue"] = getValue;
    Module3["UTF8ToString"] = UTF8ToString;
    Module3["stringToUTF8"] = stringToUTF8;
    Module3["lengthBytesUTF8"] = lengthBytesUTF8;
    Module3["intArrayFromString"] = intArrayFromString;
    Module3["intArrayToString"] = intArrayToString;
    Module3["AsciiToString"] = AsciiToString;
    Module3["UTF16ToString"] = UTF16ToString;
    Module3["stringToUTF16"] = stringToUTF16;
    Module3["UTF32ToString"] = UTF32ToString;
    Module3["stringToUTF32"] = stringToUTF32;
    Module3["writeArrayToMemory"] = writeArrayToMemory;
    var calledRun;
    dependenciesFulfilled = /* @__PURE__ */ __name(function runCaller() {
      if (!calledRun) run10();
      if (!calledRun) dependenciesFulfilled = runCaller;
    }, "runCaller");
    function callMain() {
      var entryFunction = _main;
      var argc = 0;
      var argv2 = 0;
      try {
        var ret = entryFunction(argc, argv2);
        exitJS(ret, true);
        return ret;
      } catch (e) {
        return handleException(e);
      }
    }
    __name(callMain, "callMain");
    function run10() {
      if (runDependencies > 0) {
        return;
      }
      preRun();
      if (runDependencies > 0) {
        return;
      }
      function doRun() {
        if (calledRun) return;
        calledRun = true;
        Module3["calledRun"] = true;
        if (ABORT) return;
        initRuntime();
        preMain();
        readyPromiseResolve(Module3);
        Module3["onRuntimeInitialized"]?.();
        if (shouldRunNow) callMain();
        postRun();
      }
      __name(doRun, "doRun");
      if (Module3["setStatus"]) {
        Module3["setStatus"]("Running...");
        setTimeout(() => {
          setTimeout(() => Module3["setStatus"](""), 1);
          doRun();
        }, 1);
      } else {
        doRun();
      }
    }
    __name(run10, "run");
    if (Module3["preInit"]) {
      if (typeof Module3["preInit"] == "function") Module3["preInit"] = [Module3["preInit"]];
      while (Module3["preInit"].length > 0) {
        Module3["preInit"].pop()();
      }
    }
    var shouldRunNow = true;
    if (Module3["noInitialRun"]) shouldRunNow = false;
    run10();
    (function() {
      const AsyncFunction3 = Object.getPrototypeOf(async function() {
      }).constructor;
      let pAsyncFlags = 0;
      Module3["set_authorizer"] = function(db, xAuthorizer, pApp) {
        if (pAsyncFlags) {
          Module3["deleteCallback"](pAsyncFlags);
          Module3["_sqlite3_free"](pAsyncFlags);
          pAsyncFlags = 0;
        }
        pAsyncFlags = Module3["_sqlite3_malloc"](4);
        setValue(pAsyncFlags, xAuthorizer instanceof AsyncFunction3 ? 1 : 0, "i32");
        const result = ccall("libauthorizer_set_authorizer", "number", ["number", "number", "number"], [db, xAuthorizer ? 1 : 0, pAsyncFlags]);
        if (!result && xAuthorizer) {
          Module3["setCallback"](pAsyncFlags, (_, iAction, p3, p4, p5, p6) => xAuthorizer(pApp, iAction, p3, p4, p5, p6));
        }
        return result;
      };
    })();
    (function() {
      const AsyncFunction3 = Object.getPrototypeOf(async function() {
      }).constructor;
      const FUNC_METHODS = ["xFunc", "xStep", "xFinal"];
      const mapFunctionNameToKey = /* @__PURE__ */ new Map();
      Module3["create_function"] = function(db, zFunctionName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
        const pAsyncFlags = Module3["_sqlite3_malloc"](4);
        const target3 = { xFunc, xStep, xFinal };
        setValue(pAsyncFlags, FUNC_METHODS.reduce((mask, method, i) => {
          if (target3[method] instanceof AsyncFunction3) {
            return mask | 1 << i;
          }
          return mask;
        }, 0), "i32");
        const result = ccall("libfunction_create_function", "number", ["number", "string", "number", "number", "number", "number", "number", "number"], [db, zFunctionName, nArg, eTextRep, pAsyncFlags, xFunc ? 1 : 0, xStep ? 1 : 0, xFinal ? 1 : 0]);
        if (!result) {
          if (mapFunctionNameToKey.has(zFunctionName)) {
            const oldKey = mapFunctionNameToKey.get(zFunctionName);
            Module3["deleteCallback"](oldKey);
          }
          mapFunctionNameToKey.set(zFunctionName, pAsyncFlags);
          Module3["setCallback"](pAsyncFlags, { xFunc, xStep, xFinal });
        }
        return result;
      };
    })();
    (function() {
      const AsyncFunction3 = Object.getPrototypeOf(async function() {
      }).constructor;
      let pAsyncFlags = 0;
      Module3["update_hook"] = function(db, xUpdateHook) {
        if (pAsyncFlags) {
          Module3["deleteCallback"](pAsyncFlags);
          Module3["_sqlite3_free"](pAsyncFlags);
          pAsyncFlags = 0;
        }
        pAsyncFlags = Module3["_sqlite3_malloc"](4);
        setValue(pAsyncFlags, xUpdateHook instanceof AsyncFunction3 ? 1 : 0, "i32");
        ccall("libhook_update_hook", "void", ["number", "number", "number"], [db, xUpdateHook ? 1 : 0, pAsyncFlags]);
        if (xUpdateHook) {
          Module3["setCallback"](pAsyncFlags, (_, iUpdateType, dbName, tblName, lo32, hi32) => xUpdateHook(iUpdateType, dbName, tblName, lo32, hi32));
        }
      };
    })();
    (function() {
      const AsyncFunction3 = Object.getPrototypeOf(async function() {
      }).constructor;
      let pAsyncFlags = 0;
      Module3["commit_hook"] = function(db, xCommitHook) {
        if (pAsyncFlags) {
          Module3["deleteCallback"](pAsyncFlags);
          Module3["_sqlite3_free"](pAsyncFlags);
          pAsyncFlags = 0;
        }
        pAsyncFlags = Module3["_sqlite3_malloc"](4);
        setValue(pAsyncFlags, xCommitHook instanceof AsyncFunction3 ? 1 : 0, "i32");
        ccall("libhook_commit_hook", "void", ["number", "number", "number"], [db, xCommitHook ? 1 : 0, pAsyncFlags]);
        if (xCommitHook) {
          Module3["setCallback"](pAsyncFlags, (_) => xCommitHook());
        }
      };
    })();
    (function() {
      const AsyncFunction3 = Object.getPrototypeOf(async function() {
      }).constructor;
      let pAsyncFlags = 0;
      Module3["progress_handler"] = function(db, nOps, xProgress, pApp) {
        if (pAsyncFlags) {
          Module3["deleteCallback"](pAsyncFlags);
          Module3["_sqlite3_free"](pAsyncFlags);
          pAsyncFlags = 0;
        }
        pAsyncFlags = Module3["_sqlite3_malloc"](4);
        setValue(pAsyncFlags, xProgress instanceof AsyncFunction3 ? 1 : 0, "i32");
        ccall("libprogress_progress_handler", "number", ["number", "number", "number", "number"], [db, nOps, xProgress ? 1 : 0, pAsyncFlags]);
        if (xProgress) {
          Module3["setCallback"](pAsyncFlags, (_) => xProgress(pApp));
        }
      };
    })();
    (function() {
      const VFS_METHODS = ["xOpen", "xDelete", "xAccess", "xFullPathname", "xRandomness", "xSleep", "xCurrentTime", "xGetLastError", "xCurrentTimeInt64", "xClose", "xRead", "xWrite", "xTruncate", "xSync", "xFileSize", "xLock", "xUnlock", "xCheckReservedLock", "xFileControl", "xSectorSize", "xDeviceCharacteristics", "xShmMap", "xShmLock", "xShmBarrier", "xShmUnmap"];
      const mapVFSNameToKey = /* @__PURE__ */ new Map();
      Module3["vfs_register"] = function(vfs, makeDefault) {
        let methodMask = 0;
        let asyncMask = 0;
        VFS_METHODS.forEach((method, i) => {
          if (vfs[method]) {
            methodMask |= 1 << i;
            if (vfs["hasAsyncMethod"](method)) {
              asyncMask |= 1 << i;
            }
          }
        });
        const vfsReturn = Module3["_sqlite3_malloc"](4);
        try {
          const result = ccall("libvfs_vfs_register", "number", ["string", "number", "number", "number", "number", "number"], [vfs.name, vfs.mxPathname, methodMask, asyncMask, makeDefault ? 1 : 0, vfsReturn]);
          if (!result) {
            if (mapVFSNameToKey.has(vfs.name)) {
              const oldKey = mapVFSNameToKey.get(vfs.name);
              Module3["deleteCallback"](oldKey);
            }
            const key = getValue(vfsReturn, "*");
            mapVFSNameToKey.set(vfs.name, key);
            Module3["setCallback"](key, vfs);
          }
          return result;
        } finally {
          Module3["_sqlite3_free"](vfsReturn);
        }
      };
    })();
    moduleRtn = readyPromise;
    return moduleRtn;
  });
})();
var wa_sqlite_default = Module2;

// node_modules/.pnpm/@livestore+sqlite-wasm@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sqlite-wasm/dist/load-wasm/mod.workerd.js
import wasm from "./43fb1f57a6d9aa311b5ae89157780f1805a1447d-wa-sqlite.wasm";
var loadSqlite3Wasm = /* @__PURE__ */ __name(async () => {
  const module = await wa_sqlite_default({
    instantiateWasm: /* @__PURE__ */ __name((info4, receiveInstance) => {
      try {
        const instance = new WebAssembly.Instance(wasm, info4);
        receiveInstance(instance, wasm);
        return instance.exports;
      } catch (error5) {
        console.error("Failed to instantiate WASM:", error5);
        throw error5;
      }
    }, "instantiateWasm")
  });
  const sqlite3 = Factory(module);
  sqlite3.module = module;
  return sqlite3;
}, "loadSqlite3Wasm");

// node_modules/.pnpm/@livestore+adapter-cloudflare@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/adapter-cloudflare/dist/make-adapter.js
var makeAdapter = /* @__PURE__ */ __name(({ storage, clientId: clientId2, syncOptions, sessionId: sessionId2 }) => (adapterArgs) => Effect_exports2.gen(function* () {
  const {
    storeId: storeId2,
    /* devtoolsEnabled, shutdown, bootStatusQueue,  */
    syncPayload,
    schema: schema4
  } = adapterArgs;
  const devtoolsOptions = { enabled: false };
  const sqlite3 = yield* Effect_exports2.promise(() => loadSqlite3Wasm());
  const makeSqliteDb2 = sqliteDbFactory({ sqlite3 });
  const syncInMemoryDb = yield* makeSqliteDb2({ _tag: "in-memory", storage, configureDb: /* @__PURE__ */ __name(() => {
  }, "configureDb") }).pipe(UnexpectedError.mapToUnexpectedError);
  const schemaHashSuffix = schema4.state.sqlite.migrations.strategy === "manual" ? "fixed" : schema4.state.sqlite.hash.toString();
  const dbState = yield* makeSqliteDb2({
    _tag: "storage",
    storage,
    fileName: getStateDbFileName(schemaHashSuffix),
    configureDb: /* @__PURE__ */ __name(() => {
    }, "configureDb")
  }).pipe(UnexpectedError.mapToUnexpectedError);
  const dbEventlog = yield* makeSqliteDb2({
    _tag: "storage",
    storage,
    fileName: `eventlog@${liveStoreStorageFormatVersion}.db`,
    configureDb: /* @__PURE__ */ __name(() => {
    }, "configureDb")
  }).pipe(UnexpectedError.mapToUnexpectedError);
  const shutdownChannel = yield* mod_exports.noopChannel();
  const layer14 = yield* Layer_exports.build(makeLeaderThreadLayer({
    schema: schema4,
    storeId: storeId2,
    clientId: clientId2,
    makeSqliteDb: makeSqliteDb2,
    syncOptions,
    dbState,
    dbEventlog,
    devtoolsOptions,
    shutdownChannel,
    syncPayload
  }));
  const { leaderThread, initialSnapshot } = yield* Effect_exports2.gen(function* () {
    const { dbState: dbState2, dbEventlog: dbEventlog2, syncProcessor, extraIncomingMessagesQueue, initialState } = yield* LeaderThreadCtx;
    const initialLeaderHead = eventlog_exports.getClientHeadFromDb(dbEventlog2);
    const leaderThread2 = ClientSessionLeaderThreadProxy_exports.of({
      events: {
        pull: /* @__PURE__ */ __name(({ cursor }) => syncProcessor.pull({ cursor }), "pull"),
        push: /* @__PURE__ */ __name((batch) => syncProcessor.push(batch.map((item) => new LiveStoreEvent_exports.EncodedWithMeta(item)), { waitForProcessing: true }), "push")
      },
      initialState: { leaderHead: initialLeaderHead, migrationsReport: initialState.migrationsReport },
      export: Effect_exports2.sync(() => dbState2.export()),
      getEventlogData: Effect_exports2.sync(() => dbEventlog2.export()),
      getSyncState: syncProcessor.syncState,
      sendDevtoolsMessage: /* @__PURE__ */ __name((message) => extraIncomingMessagesQueue.offer(message), "sendDevtoolsMessage")
    }, {
      // overrides: testing?.overrides?.clientSession?.leaderThreadProxy
    });
    const initialSnapshot2 = dbState2.export();
    return { leaderThread: leaderThread2, initialSnapshot: initialSnapshot2 };
  }).pipe(Effect_exports2.provide(layer14));
  syncInMemoryDb.import(initialSnapshot);
  const lockStatus = yield* SubscriptionRef_exports2.make("has-lock");
  const clientSession = yield* makeClientSession({
    ...adapterArgs,
    sqliteDb: syncInMemoryDb,
    webmeshMode: "proxy",
    connectWebmeshNode: Effect_exports2.fnUntraced(function* ({ webmeshNode }) {
      console.log("connectWebmeshNode", { webmeshNode });
    }),
    leaderThread,
    lockStatus,
    clientId: clientId2,
    sessionId: sessionId2,
    isLeader: true,
    // Not really applicable for node as there is no "reload the app" concept
    registerBeforeUnload: /* @__PURE__ */ __name((_onBeforeUnload) => () => {
    }, "registerBeforeUnload")
  });
  return clientSession;
}).pipe(Effect_exports2.withSpan("@livestore/adapter-cloudflare:makeAdapter", { attributes: { clientId: clientId2, sessionId: sessionId2 } }), Effect_exports2.provide(FetchHttpClient_exports.layer)), "makeAdapter");
var getStateDbFileName = /* @__PURE__ */ __name((suffix) => `state${suffix}@${liveStoreStorageFormatVersion}.db`, "getStateDbFileName");

// node_modules/.pnpm/@livestore+adapter-cloudflare@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/adapter-cloudflare/dist/make-client-durable-object.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/client/transport/do-rpc-client.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/common-cf/dist/do-rpc/mod.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+common-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/common-cf/dist/do-rpc/client.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var processReadableStream = /* @__PURE__ */ __name((stream6, parser, writeResponse) => Effect_exports2.gen(function* () {
  const reader = stream6.getReader();
  yield* Effect_exports2.gen(function* () {
    while (true) {
      const { done: done12, value: value6 } = yield* Effect_exports2.tryPromise({
        try: /* @__PURE__ */ __name(() => reader.read(), "try"),
        catch: /* @__PURE__ */ __name((cause3) => cause3, "catch")
      }).pipe(Effect_exports2.orDie);
      if (done12) {
        break;
      }
      const decoded = parser.decode(value6);
      let messages;
      if (Array.isArray(decoded) && decoded.length === 1 && Array.isArray(decoded[0])) {
        messages = decoded[0];
      } else if (Array.isArray(decoded)) {
        messages = decoded;
      } else {
        messages = [decoded];
      }
      for (const message of messages) {
        yield* writeResponse(message);
      }
    }
  }).pipe(Effect_exports2.ensuring(Effect_exports2.promise(() => reader.cancel()).pipe(Effect_exports2.andThen(() => Effect_exports2.sync(() => reader.releaseLock())))));
}), "processReadableStream");
var layerProtocolDurableObject = /* @__PURE__ */ __name((args2) => Layer_exports.scoped(RpcClient_exports2.Protocol, makeProtocolDurableObject(args2)), "layerProtocolDurableObject");
var makeProtocolDurableObject = /* @__PURE__ */ __name(({ callRpc }) => RpcClient_exports2.Protocol.make(Effect_exports2.fnUntraced(function* (writeResponse) {
  const parser = RpcSerialization_exports.msgPack.unsafeMake();
  const fiberMap = /* @__PURE__ */ new Map();
  const send2 = /* @__PURE__ */ __name((message) => {
    if (message._tag !== "Request") {
      if (message._tag === "Interrupt") {
        return Effect_exports2.gen(function* () {
          const fiber = fiberMap.get(message.requestId);
          yield* Fiber_exports.interrupt(fiber);
        });
      }
      return Effect_exports2.void;
    }
    const serializedPayload = parser.encode([message]);
    return Effect_exports2.gen(function* () {
      const serializedResponse = yield* Effect_exports2.tryPromise({
        try: /* @__PURE__ */ __name(() => callRpc(serializedPayload), "try"),
        catch: /* @__PURE__ */ __name((cause3) => cause3, "catch")
      }).pipe(Effect_exports2.orDie);
      if (serializedResponse instanceof ReadableStream) {
        const fiber = yield* processReadableStream(serializedResponse, parser, writeResponse).pipe(Effect_exports2.fork);
        fiberMap.set(message.id, fiber);
        yield* fiber;
        return;
      }
      const decoded = parser.decode(serializedResponse);
      let responseArray;
      if (Array.isArray(decoded) && decoded.length === 1 && Array.isArray(decoded[0])) {
        responseArray = decoded[0];
      } else if (Array.isArray(decoded)) {
        responseArray = decoded;
      } else {
        responseArray = [decoded];
      }
      for (const response of responseArray) {
        yield* writeResponse(response);
      }
    }).pipe(Effect_exports2.orDie);
  }, "send");
  return {
    send: send2,
    supportsAck: false,
    // DO RPC doesn't support ack mechanism like WebSockets
    supportsTransferables: false
    // DO RPC doesn't support transferables yet
  };
})), "makeProtocolDurableObject");

// node_modules/.pnpm/@livestore+common-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/common-cf/dist/do-rpc/server.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var toDurableObjectHandler = /* @__PURE__ */ __name((group5, options4) => (serializedPayload) => Effect_exports2.gen(function* () {
  const parser = RpcSerialization_exports.msgPack.unsafeMake();
  const decoded = parser.decode(serializedPayload);
  let requests;
  if (Array.isArray(decoded) && decoded.length === 1 && Array.isArray(decoded[0])) {
    requests = decoded[0];
  } else if (Array.isArray(decoded)) {
    requests = decoded;
  } else {
    requests = [];
  }
  const context17 = yield* Effect_exports2.context();
  const responses = [];
  for (const request2 of requests) {
    if (request2._tag !== "Request") {
      continue;
    }
    const rpc = group5.requests.get(request2.tag);
    const entry = context17.unsafeMap.get(rpc.key);
    if (!rpc || !entry) {
      responses.push({
        _tag: "Exit",
        requestId: request2.id,
        exit: Exit_exports.die(`Unknown request tag: ${request2.tag}`)
      });
      continue;
    }
    const isStream3 = RpcSchema_exports.isStreamSchema(rpc.successSchema);
    if (isStream3 && requests.length === 1) {
      return yield* createStreamingResponse(rpc, entry, request2, parser, options4.layer);
    }
    const result = yield* Effect_exports2.gen(function* () {
      const handlerResult = entry.handler(request2.payload, Headers_exports.fromInput({
        "x-rpc-request-id": request2.id.toString()
      }));
      let value6;
      if (Effect_exports2.isEffect(handlerResult)) {
        value6 = yield* handlerResult;
      } else {
        value6 = handlerResult;
      }
      const exitSchema3 = Rpc_exports.exitSchema(rpc);
      let encodedExit;
      if (exitSchema3) {
        const rawExit = Exit_exports.succeed(value6);
        encodedExit = yield* Schema_exports2.encodeUnknown(exitSchema3)(rawExit);
      } else {
        encodedExit = Exit_exports.succeed(value6);
      }
      return {
        _tag: "Exit",
        requestId: request2.id,
        exit: encodedExit
      };
    }).pipe(Effect_exports2.catchAllCause((cause3) => {
      const exitSchema3 = Rpc_exports.exitSchema(rpc);
      return Effect_exports2.gen(function* () {
        let encodedExit;
        if (exitSchema3) {
          const rawExit = Exit_exports.failCause(cause3);
          encodedExit = yield* Schema_exports2.encodeUnknown(exitSchema3)(rawExit);
        } else {
          encodedExit = Exit_exports.failCause(cause3);
        }
        return {
          _tag: "Exit",
          requestId: request2.id,
          exit: encodedExit
        };
      });
    }));
    responses.push(result);
  }
  const encoded = parser.encode(responses);
  return encoded;
}).pipe(Effect_exports2.provide(options4.layer), Effect_exports2.scoped, Effect_exports2.orDie), "toDurableObjectHandler");
var emitStreamResponse = /* @__PURE__ */ __name(({ callerContext, env: env3, requestId: requestId2, values: values6 }) => Effect_exports2.gen(function* () {
  const clientDoNamespace = env3[callerContext.bindingName];
  if (clientDoNamespace === void 0) {
    throw new Error(`Client DO namespace not found: ${callerContext.bindingName}`);
  }
  const clientDo = clientDoNamespace.get(clientDoNamespace.idFromString(callerContext.durableObjectId));
  const res = { _tag: "Chunk", requestId: requestId2, values: values6 };
  yield* Effect_exports2.tryPromise(() => clientDo.syncUpdateRpc(res));
}).pipe(Effect_exports2.withSpan("do-rpc/emitStreamResponse")), "emitStreamResponse");
var createStreamingResponse = /* @__PURE__ */ __name((rpc, entry, request2, parser, layer14) => Effect_exports2.gen(function* () {
  const handlerResult = entry.handler(request2.payload, Headers_exports.fromInput({
    "x-rpc-request-id": request2.id.toString()
  }));
  let stream6;
  if (Effect_exports2.isEffect(handlerResult)) {
    stream6 = yield* handlerResult;
  } else {
    stream6 = handlerResult;
  }
  const streamSchemas = RpcSchema_exports.getStreamSchemas(rpc.successSchema.ast);
  const chunkEncoder = Option_exports.isSome(streamSchemas) ? Schema_exports2.encodeUnknown(Schema_exports2.Array(streamSchemas.value.success)) : Schema_exports2.encodeUnknown(Schema_exports2.Array(Schema_exports2.Any));
  const readableStream = new ReadableStream({
    start(controller) {
      const runStream = Effect_exports2.gen(function* () {
        yield* Stream_exports2.runForEachChunk(stream6, (chunk4) => Effect_exports2.gen(function* () {
          const chunkArray = Chunk_exports.toReadonlyArray(chunk4);
          if (chunkArray.length === 0)
            return;
          const encodedValues = yield* chunkEncoder(chunkArray);
          const chunkMessage = {
            _tag: "Chunk",
            requestId: request2.id,
            values: encodedValues
          };
          const serialized = parser.encode([chunkMessage]);
          controller.enqueue(serialized);
        }));
        const rawExit = Exit_exports.void;
        const exitSchema3 = Rpc_exports.exitSchema(rpc);
        const encodedExit = yield* Schema_exports2.encodeUnknown(exitSchema3)(rawExit);
        const exitMessage = {
          _tag: "Exit",
          requestId: request2.id,
          exit: encodedExit
        };
        const exitSerialized = parser.encode([exitMessage]);
        controller.enqueue(exitSerialized);
        controller.close();
      }).pipe(Effect_exports2.catchAllCause((cause3) => Effect_exports2.gen(function* () {
        const rawExit = Exit_exports.failCause(cause3);
        const exitSchema3 = Rpc_exports.exitSchema(rpc);
        const encodedExit = yield* Schema_exports2.encodeUnknown(exitSchema3)(rawExit);
        const exitMessage = {
          _tag: "Exit",
          requestId: request2.id,
          exit: encodedExit
        };
        const exitSerialized = parser.encode([exitMessage]);
        controller.enqueue(exitSerialized);
        controller.close();
      })));
      runStream.pipe(Effect_exports2.provide(layer14), Effect_exports2.scoped, Effect_exports2.tapCauseLogPretty, Effect_exports2.runPromise);
    }
  });
  return readableStream;
}), "createStreamingResponse");

// node_modules/.pnpm/@livestore+common-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/common-cf/dist/ws-rpc/ws-rpc-server.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var setupDurableObjectWebSocketRpc = /* @__PURE__ */ __name(({ doSelf, rpcLayer, webSocketMode, onMessage, mainLayer }) => {
  if (webSocketMode === "accept") {
    return notYetImplemented(`WebSocket mode 'accept' is not yet implemented`);
  }
  const serverCtxMap = /* @__PURE__ */ new Map();
  const launchServer = /* @__PURE__ */ __name((ws) => Effect_exports2.gen(function* () {
    if (serverCtxMap.has(ws)) {
      return serverCtxMap.get(ws);
    }
    yield* Effect_exports2.logDebug(`Launching WebSocket Effect RPC server`);
    const scope5 = yield* Scope_exports.make();
    const incomingQueue = yield* Mailbox_exports.make();
    yield* Scope_exports.addFinalizer(scope5, incomingQueue.shutdown);
    const ProtocolLive = layerRpcServerWebsocket({
      ws,
      incomingQueue,
      onMessage
    }).pipe(Layer_exports.provide(RpcSerialization_exports.layerJson));
    const ServerLive = rpcLayer.pipe(Layer_exports.provide(ProtocolLive));
    yield* Layer_exports.launch(ServerLive).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.forkIn(scope5));
    const runtime8 = yield* Effect_exports2.runtime();
    const ctx = {
      scope: scope5,
      onMessage: /* @__PURE__ */ __name((message) => incomingQueue.offer(message).pipe(Effect_exports2.asVoid, Effect_exports2.withSpan("ws-rpc-server/onMessage", { root: true }), Effect_exports2.provide(runtime8), Effect_exports2.runPromise), "onMessage")
    };
    serverCtxMap.set(ws, ctx);
    return ctx;
  }).pipe(
    Effect_exports2.tapCauseLogPretty,
    Logger_exports2.withMinimumLogLevel(LogLevel_exports.Debug),
    // Useful for debugging
    Effect_exports2.provide(Layer_exports.mergeAll(Logger_exports2.consoleWithThread("ws-rpc-server"), mainLayer ?? Layer_exports.empty)),
    Effect_exports2.withSpan("effect-ws-rpc-server"),
    Effect_exports2.runPromise
  ), "launchServer");
  const webSocketMessage = /* @__PURE__ */ __name(async (ws, message) => {
    const { onMessage: onMessage2 } = await launchServer(ws);
    await onMessage2(message);
  }, "webSocketMessage");
  const webSocketClose = /* @__PURE__ */ __name(async (ws, _code, _reason, _wasClean) => {
    const ctx = serverCtxMap.get(ws);
    if (ctx) {
      await Scope_exports.close(ctx.scope, Exit_exports.void).pipe(Effect_exports2.runPromise);
      serverCtxMap.delete(ws);
    }
  }, "webSocketClose");
  doSelf.webSocketMessage = webSocketMessage.bind(doSelf);
  doSelf.webSocketClose = webSocketClose.bind(doSelf);
  return {
    webSocketMessage,
    webSocketClose
  };
}, "setupDurableObjectWebSocketRpc");
var layerRpcServerWebsocket = /* @__PURE__ */ __name((args2) => Layer_exports.scoped(RpcServer_exports.Protocol, makeSocketProtocol2(args2)), "layerRpcServerWebsocket");
var makeSocketProtocol2 = /* @__PURE__ */ __name(({ incomingQueue, ws, onMessage }) => Effect_exports2.gen(function* () {
  const serialization = yield* RpcSerialization_exports.RpcSerialization;
  const disconnects = yield* Mailbox_exports.make();
  const writeRaw = /* @__PURE__ */ __name((msg) => Effect_exports2.succeed(ws.send(msg)), "writeRaw");
  let writeRequest;
  const parser = serialization.unsafeMake();
  const id4 = 0;
  const write3 = /* @__PURE__ */ __name((response) => {
    try {
      const encoded = parser.encode(response);
      if (encoded === void 0) {
        return Effect_exports2.void;
      }
      return Effect_exports2.orDie(writeRaw(encoded));
    } catch (cause3) {
      return Effect_exports2.orDie(writeRaw(parser.encode(RpcMessage_exports.ResponseDefectEncoded(cause3))));
    }
  }, "write");
  const protocol = yield* RpcServer_exports.Protocol.make((writeRequest_) => {
    writeRequest = writeRequest_;
    const startProcessing = Mailbox_exports.toStream(incomingQueue).pipe(Stream_exports2.tap((data) => {
      try {
        const decoded = parser.decode(data);
        if (decoded.length === 0)
          return Effect_exports2.void;
        let i = 0;
        return Effect_exports2.whileLoop({
          while: /* @__PURE__ */ __name(() => i < decoded.length, "while"),
          body: /* @__PURE__ */ __name(() => {
            const request2 = decoded[i++];
            if (onMessage) {
              onMessage(request2, ws);
            }
            return writeRequest(id4, request2);
          }, "body"),
          step: constVoid
        });
      } catch (cause3) {
        return Effect_exports2.orDie(writeRaw(parser.encode(RpcMessage_exports.ResponseDefectEncoded(cause3))));
      }
    }), Stream_exports2.runDrain, Effect_exports2.tapCauseLogPretty, Effect_exports2.fork);
    return Effect_exports2.map(startProcessing, () => ({
      disconnects,
      send: /* @__PURE__ */ __name((_clientId, response) => Effect_exports2.orDie(write3(response)), "send"),
      end(_clientId) {
        return Effect_exports2.void;
      },
      // Always just one client
      clientIds: Effect_exports2.sync(() => [id4]),
      initialMessage: Effect_exports2.succeedNone,
      supportsAck: true,
      supportsTransferables: false,
      supportsSpanPropagation: true
    }));
  });
  return protocol;
}), "makeSocketProtocol");

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/common/do-rpc-schema.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/common/sync-message-types.js
var sync_message_types_exports = {};
__export(sync_message_types_exports, {
  AdminInfoRequest: () => AdminInfoRequest,
  AdminInfoResponse: () => AdminInfoResponse,
  AdminResetRoomRequest: () => AdminResetRoomRequest,
  AdminResetRoomResponse: () => AdminResetRoomResponse,
  BackendToClientMessage: () => BackendToClientMessage,
  ClientToBackendMessage: () => ClientToBackendMessage,
  InvalidParentEventNumber: () => InvalidParentEventNumber,
  Message: () => Message3,
  Ping: () => Ping3,
  Pong: () => Pong3,
  PullRequest: () => PullRequest,
  PullResponse: () => PullResponse,
  PushAck: () => PushAck,
  PushRequest: () => PushRequest,
  SyncError: () => SyncError2,
  SyncMetadata: () => SyncMetadata
});
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SyncMetadata = Schema_exports2.TaggedStruct("SyncMessage.SyncMetadata", {
  /** ISO date format */
  createdAt: Schema_exports2.String
}).annotations({ title: "@livestore/sync-cf:SyncMetadata" });
var PullRequest = Schema_exports2.Struct({
  /** Omitting the cursor will start from the beginning */
  cursor: Schema_exports2.optional(EventSequenceNumber_exports.GlobalEventSequenceNumber)
}).annotations({ title: "@livestore/sync-cf:PullRequest" });
var PullResponse = Schema_exports2.Struct({
  batch: Schema_exports2.Array(Schema_exports2.Struct({
    eventEncoded: LiveStoreEvent_exports.AnyEncodedGlobal,
    metadata: Schema_exports2.Option(SyncMetadata)
  })),
  pageInfo: sync_backend_exports.PullResPageInfo
}).annotations({ title: "@livestore/sync-cf:PullResponse" });
var PushRequest = Schema_exports2.Struct({
  batch: Schema_exports2.Array(LiveStoreEvent_exports.AnyEncodedGlobal)
}).annotations({ title: "@livestore/sync-cf:PushRequest" });
var PushAck = Schema_exports2.Struct({}).annotations({
  title: "@livestore/sync-cf:PushAck"
});
var InvalidParentEventNumber = Schema_exports2.TaggedStruct("SyncMessage.SyncError.InvalidParentEventNumber", {
  expected: EventSequenceNumber_exports.GlobalEventSequenceNumber,
  received: EventSequenceNumber_exports.GlobalEventSequenceNumber
}).annotations({ title: "@livestore/sync-cf:InvalidParentEventNumber" });
var SyncError2 = class extends Schema_exports2.TaggedError()("SyncMessage.SyncError", {
  cause: Schema_exports2.Union(UnexpectedError, InvalidParentEventNumber),
  storeId: Schema_exports2.optional(Schema_exports2.String)
}, { title: "@livestore/sync-cf:SyncError" }) {
  static {
    __name(this, "SyncError");
  }
};
var Ping3 = Schema_exports2.TaggedStruct("SyncMessage.Ping", {}).annotations({ title: "@livestore/sync-cf:Ping" });
var Pong3 = Schema_exports2.TaggedStruct("SyncMessage.Pong", {}).annotations({ title: "@livestore/sync-cf:Pong" });
var AdminResetRoomRequest = Schema_exports2.TaggedStruct("SyncMessage.AdminResetRoomRequest", {
  adminSecret: Schema_exports2.String
}).annotations({ title: "@livestore/sync-cf:AdminResetRoomRequest" });
var AdminResetRoomResponse = Schema_exports2.TaggedStruct("SyncMessage.AdminResetRoomResponse", {}).annotations({
  title: "@livestore/sync-cf:AdminResetRoomResponse"
});
var AdminInfoRequest = Schema_exports2.TaggedStruct("SyncMessage.AdminInfoRequest", {
  adminSecret: Schema_exports2.String
}).annotations({ title: "@livestore/sync-cf:AdminInfoRequest" });
var AdminInfoResponse = Schema_exports2.TaggedStruct("SyncMessage.AdminInfoResponse", {
  info: Schema_exports2.Struct({
    durableObjectId: Schema_exports2.String
  })
}).annotations({ title: "@livestore/sync-cf:AdminInfoResponse" });
var BackendToClientMessage = Schema_exports2.Union(PullResponse, PushAck, SyncError2, Pong3, AdminResetRoomResponse, AdminInfoResponse);
var ClientToBackendMessage = Schema_exports2.Union(PullRequest, PushRequest, Ping3, AdminResetRoomRequest, AdminInfoRequest);
var Message3 = Schema_exports2.Union(BackendToClientMessage, ClientToBackendMessage);

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/common/do-rpc-schema.js
var commonPayloadFields = {
  /**
   * While the storeId is already implied by the durable object, we still need the explicit storeId
   * since a DO doesn't know its own id.name value. 
   * https://community.cloudflare.com/t/how-can-i-get-the-name-of-a-durable-object-from-itself/505961/8
   */
  storeId: Schema_exports2.String,
  /** Needed for various reasons (e.g. auth) */
  payload: Schema_exports2.optional(Schema_exports2.JsonValue)
};
var SyncDoRpc = class extends RpcGroup_exports.make(Rpc_exports.make("SyncDoRpc.Pull", {
  payload: {
    /** Omitting the cursor will start from the beginning */
    cursor: Schema_exports2.optional(EventSequenceNumber_exports.GlobalEventSequenceNumber),
    /** Whether to keep the pull stream alive and wait for more events */
    rpcContext: Schema_exports2.optional(Schema_exports2.Struct({
      callerContext: Schema_exports2.Struct({
        bindingName: Schema_exports2.String,
        durableObjectId: Schema_exports2.String
      })
    })),
    ...commonPayloadFields
  },
  success: Schema_exports2.Struct({
    rpcRequestId: Schema_exports2.String,
    ...PullResponse.fields
  }),
  error: SyncError2,
  stream: true
}), Rpc_exports.make("SyncDoRpc.Push", {
  payload: {
    batch: Schema_exports2.Array(LiveStoreEvent_exports.AnyEncodedGlobal),
    ...commonPayloadFields
  },
  success: PushAck,
  error: SyncError2
}), Rpc_exports.make("SyncDoRpc.Ping", {
  payload: {
    ...commonPayloadFields
  },
  success: Schema_exports2.Void
})) {
  static {
    __name(this, "SyncDoRpc");
  }
};

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/common/mod.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/common/http-rpc-schema.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SyncHttpRpc = class extends RpcGroup_exports.make(Rpc_exports.make("SyncHttpRpc.Pull", {
  payload: Schema_exports2.Struct({
    storeId: Schema_exports2.String,
    payload: Schema_exports2.optional(Schema_exports2.JsonValue),
    ...PullRequest.fields
  }),
  success: PullResponse,
  error: SyncError2,
  stream: true
}), Rpc_exports.make("SyncHttpRpc.Push", {
  payload: Schema_exports2.Struct({
    storeId: Schema_exports2.String,
    payload: Schema_exports2.optional(Schema_exports2.JsonValue),
    ...PushRequest.fields
  }),
  success: PushAck,
  error: SyncError2
}), Rpc_exports.make("SyncHttpRpc.Ping", {
  payload: Schema_exports2.Struct({
    storeId: Schema_exports2.String,
    payload: Schema_exports2.optional(Schema_exports2.JsonValue)
  }),
  success: Pong3,
  error: SyncError2
})) {
  static {
    __name(this, "SyncHttpRpc");
  }
};

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/common/mod.js
var SearchParamsSchema = Schema_exports2.Struct({
  storeId: Schema_exports2.String,
  payload: Schema_exports2.compose(Schema_exports2.StringFromUriComponent, Schema_exports2.parseJson(Schema_exports2.JsonValue)).pipe(Schema_exports2.UndefinedOr),
  // NOTE `do-rpc` is handled differently
  transport: Schema_exports2.Union(Schema_exports2.Literal("http"), Schema_exports2.Literal("ws"))
});

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/client/transport/do-rpc-client.js
var requestIdMailboxMap = /* @__PURE__ */ new Map();
var makeDoRpcSync = /* @__PURE__ */ __name(({ syncBackendStub, durableObjectContext }) => ({ storeId: storeId2, payload }) => Effect_exports2.gen(function* () {
  const isConnected = yield* SubscriptionRef_exports2.make(true);
  const ProtocolLive = layerProtocolDurableObject({
    callRpc: /* @__PURE__ */ __name((payload2) => syncBackendStub.rpc(payload2), "callRpc"),
    callerContext: durableObjectContext
  }).pipe(Layer_exports.provide(RpcSerialization_exports.layerJson));
  const rpcClient = yield* RpcClient_exports2.make(SyncDoRpc).pipe(Effect_exports2.provide(ProtocolLive));
  const connect = Effect_exports2.void;
  const pull = /* @__PURE__ */ __name((args2, options4) => Effect_exports2.gen(function* () {
    const live = options4?.live ?? false;
    return rpcClient.SyncDoRpc.Pull({
      cursor: Option_exports.getOrUndefined(args2)?.cursor,
      storeId: storeId2,
      rpcContext: live ? { callerContext: durableObjectContext } : void 0
    }).pipe(live ? Stream_exports2.concatWithLastElement((res) => Effect_exports2.gen(function* () {
      if (res._tag === "None")
        return shouldNeverHappen("There should at least be a no-more page info response");
      const mailbox = yield* Mailbox_exports.make().pipe(Effect_exports2.acquireRelease((mailbox2) => mailbox2.shutdown));
      requestIdMailboxMap.set(res.value.rpcRequestId, mailbox);
      return Mailbox_exports.toStream(mailbox);
    }).pipe(Stream_exports2.unwrapScoped)) : identity);
  }).pipe(Stream_exports2.unwrapScoped, Stream_exports2.mapError((cause3) => new InvalidPullError({ cause: cause3 })), Stream_exports2.withSpan("rpc-sync-client:pull")), "pull");
  const push = /* @__PURE__ */ __name((batch) => Effect_exports2.gen(function* () {
    if (batch.length === 0) {
      return;
    }
    yield* rpcClient.SyncDoRpc.Push({ batch, storeId: storeId2 });
  }).pipe(Effect_exports2.mapError((cause3) => new InvalidPushError({ reason: { _tag: "Unexpected", cause: cause3 } })), Effect_exports2.withSpan("rpc-sync-client:push")), "push");
  const ping = rpcClient.SyncDoRpc.Ping({
    storeId: storeId2,
    payload
  }).pipe(UnexpectedError.mapToUnexpectedError, Effect_exports2.withSpan("rpc-sync-client:ping"));
  return sync_backend_exports.of({
    connect,
    isConnected,
    pull,
    push,
    ping,
    metadata: {
      name: "rpc-sync-client",
      description: "Cloudflare Durable Object RPC Sync Client",
      protocol: "rpc",
      storeId: storeId2
    },
    supports: {
      pullPageInfoKnown: true,
      pullLive: true
    }
  });
}), "makeDoRpcSync");
var ResponseChunkEncoded = Schema_exports2.Struct({
  requestId: Schema_exports2.String,
  values: Schema_exports2.Array(Schema_exports2.Any)
});

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/common/ws-rpc-schema.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var SyncWsRpc = class extends RpcGroup_exports.make(Rpc_exports.make("SyncWsRpc.Pull", {
  payload: Schema_exports2.Struct({
    storeId: Schema_exports2.String,
    payload: Schema_exports2.optional(Schema_exports2.JsonValue),
    /** Whether to keep the pull stream alive and wait for more events */
    live: Schema_exports2.Boolean,
    ...PullRequest.fields
  }),
  success: PullResponse,
  error: SyncError2,
  stream: true
}), Rpc_exports.make("SyncWsRpc.Push", {
  payload: Schema_exports2.Struct({
    storeId: Schema_exports2.String,
    payload: Schema_exports2.optional(Schema_exports2.JsonValue),
    ...PushRequest.fields
  }),
  success: PushAck,
  error: SyncError2
})) {
  static {
    __name(this, "SyncWsRpc");
  }
};

// node_modules/.pnpm/@livestore+adapter-cloudflare@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/adapter-cloudflare/dist/make-client-durable-object.js
var createStoreDo = /* @__PURE__ */ __name(({ schema: schema4, storeId: storeId2, clientId: clientId2, sessionId: sessionId2, storage, syncBackendDurableObject, durableObjectId, bindingName, livePull = false }) => Effect_exports2.gen(function* () {
  const scope5 = yield* Scope_exports.make();
  const adapter5 = makeAdapter({
    clientId: clientId2,
    sessionId: sessionId2,
    storage,
    syncOptions: {
      backend: makeDoRpcSync({
        syncBackendStub: syncBackendDurableObject,
        durableObjectContext: { bindingName, durableObjectId }
      }),
      livePull,
      // Uses DO RPC callbacks for reactive pull
      // backend: makeHttpSync({ url: `http://localhost:8787`, livePull: { pollInterval: 500 } }),
      initialSyncOptions: { _tag: "Blocking", timeout: 500 }
      // backend: makeWsSyncProviderClient({ durableObject: syncBackendDurableObject }),
    }
  });
  return yield* createStore({ schema: schema4, adapter: adapter5, storeId: storeId2 }).pipe(Scope_exports.extend(scope5), provideOtel({}));
}), "createStoreDo");
var createStoreDoPromise = /* @__PURE__ */ __name((options4) => createStoreDo(options4).pipe(Logger_exports2.withMinimumLogLevel(LogLevel_exports.Debug), Effect_exports2.provide(Logger_exports2.consoleWithThread("DoClient")), Effect_exports2.tapCauseLogPretty, Effect_exports2.runPromise), "createStoreDoPromise");

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/do/durable-object.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
import { DurableObject } from "cloudflare:workers";

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/shared.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var PERSISTENCE_FORMAT_VERSION = 7;
var encodeOutgoingMessage = Schema_exports2.encodeSync(Schema_exports2.parseJson(sync_message_types_exports.BackendToClientMessage));
var encodeIncomingMessage = Schema_exports2.encodeSync(Schema_exports2.parseJson(sync_message_types_exports.ClientToBackendMessage));
var getSyncRequestSearchParams = /* @__PURE__ */ __name((request2) => {
  const url2 = new URL(request2.url);
  const urlParams3 = UrlParams_exports.fromInput(url2.searchParams);
  const paramsResult = UrlParams_exports.schemaStruct(SearchParamsSchema)(urlParams3).pipe(Effect_exports2.option, Effect_exports2.runSync);
  return paramsResult;
}, "getSyncRequestSearchParams");
var PULL_CHUNK_SIZE = 100;
var WebSocketAttachmentSchema = Schema_exports2.parseJson(Schema_exports2.Struct({
  // Same across all websocket connections
  storeId: Schema_exports2.String,
  // Different for each websocket connection
  payload: Schema_exports2.optional(Schema_exports2.JsonValue),
  pullRequestIds: Schema_exports2.Array(Schema_exports2.String)
}));

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/do/sqlite.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var eventlogTable = mod_exports4.SQLite.table({
  // NOTE actual table name is determined at runtime
  name: "eventlog_$PERSISTENCE_FORMAT_VERSION_$storeId",
  columns: {
    seqNum: mod_exports4.SQLite.integer({ primaryKey: true, schema: EventSequenceNumber_exports.GlobalEventSequenceNumber }),
    parentSeqNum: mod_exports4.SQLite.integer({ schema: EventSequenceNumber_exports.GlobalEventSequenceNumber }),
    name: mod_exports4.SQLite.text({}),
    args: mod_exports4.SQLite.text({ schema: Schema_exports2.parseJson(Schema_exports2.Any), nullable: true }),
    /** ISO date format. Currently only used for debugging purposes. */
    createdAt: mod_exports4.SQLite.text({}),
    clientId: mod_exports4.SQLite.text({}),
    sessionId: mod_exports4.SQLite.text({})
  }
});
var contextTable = mod_exports4.SQLite.table({
  name: "context",
  columns: {
    storeId: mod_exports4.SQLite.text({ primaryKey: true }),
    currentHead: mod_exports4.SQLite.integer({ schema: EventSequenceNumber_exports.GlobalEventSequenceNumber })
  }
});

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/do/sync-storage.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeStorage = /* @__PURE__ */ __name((ctx, env3, storeId2) => {
  const dbName = `eventlog_${PERSISTENCE_FORMAT_VERSION}_${toValidTableName(storeId2)}`;
  const execDb = /* @__PURE__ */ __name((cb) => Effect_exports2.tryPromise({
    try: /* @__PURE__ */ __name(() => cb(env3.DB), "try"),
    catch: /* @__PURE__ */ __name((error5) => new UnexpectedError({ cause: error5, payload: { dbName } }), "catch")
  }).pipe(Effect_exports2.map((_) => _.results), Effect_exports2.withSpan("@livestore/sync-cf:durable-object:execDb")), "execDb");
  const getEvents = /* @__PURE__ */ __name((cursor) => Effect_exports2.gen(function* () {
    const whereClause = cursor === void 0 ? "" : `WHERE seqNum > ${cursor}`;
    const sql2 = `SELECT * FROM ${dbName} ${whereClause} ORDER BY seqNum ASC`;
    const rawEvents = yield* execDb((db) => db.prepare(sql2).all());
    const events2 = Schema_exports2.decodeUnknownSync(Schema_exports2.Array(eventlogTable.rowSchema))(rawEvents).map(({ createdAt, ...eventEncoded }) => ({
      eventEncoded,
      metadata: Option_exports.some(SyncMetadata.make({ createdAt }))
    }));
    return events2;
  }).pipe(UnexpectedError.mapToUnexpectedError), "getEvents");
  const appendEvents = /* @__PURE__ */ __name((batch, createdAt) => Effect_exports2.gen(function* () {
    if (batch.length === 0)
      return;
    const CHUNK_SIZE2 = 14;
    for (let i = 0; i < batch.length; i += CHUNK_SIZE2) {
      const chunk4 = batch.slice(i, i + CHUNK_SIZE2);
      const valuesPlaceholders = chunk4.map(() => "(?, ?, ?, ?, ?, ?, ?)").join(", ");
      const sql2 = `INSERT INTO ${dbName} (seqNum, parentSeqNum, args, name, createdAt, clientId, sessionId) VALUES ${valuesPlaceholders}`;
      const params2 = chunk4.flatMap((event) => [
        event.seqNum,
        event.parentSeqNum,
        event.args === void 0 ? null : JSON.stringify(event.args),
        event.name,
        createdAt,
        event.clientId,
        event.sessionId
      ]);
      yield* execDb((db) => db.prepare(sql2).bind(...params2).run());
    }
  }).pipe(UnexpectedError.mapToUnexpectedError), "appendEvents");
  const resetStore = Effect_exports2.promise(() => ctx.storage.deleteAll()).pipe(UnexpectedError.mapToUnexpectedError);
  return {
    dbName,
    // getHead,
    getEvents,
    appendEvents,
    resetStore
  };
}, "makeStorage");
var toValidTableName = /* @__PURE__ */ __name((str) => str.replaceAll(/[^a-zA-Z0-9]/g, "_"), "toValidTableName");

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/do/transport/do-rpc-server.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/do/pull.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeEndingPullStream = /* @__PURE__ */ __name(({ storage, doOptions, storeId: storeId2, payload }) => (req) => Effect_exports2.gen(function* () {
  if (doOptions?.onPull) {
    yield* Effect_exports2.tryAll(() => doOptions.onPull(req, { storeId: storeId2, payload })).pipe(UnexpectedError.mapToUnexpectedError);
  }
  const remainingEvents = yield* storage.getEvents(req.cursor);
  const batches = pipe(remainingEvents, Array_exports.chunksOf(PULL_CHUNK_SIZE), Array_exports.map((batch, i) => {
    const remaining = Math.max(0, remainingEvents.length - (i + 1) * PULL_CHUNK_SIZE);
    return sync_message_types_exports.PullResponse.make({
      batch,
      pageInfo: remaining > 0 ? sync_backend_exports.pageInfoMoreKnown(remaining) : sync_backend_exports.pageInfoNoMore
    });
  }));
  return Stream_exports2.fromIterable(batches);
}).pipe(Stream_exports2.unwrap, Stream_exports2.withSpan("cloudflare-provider:pull")), "makeEndingPullStream");

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/do/push.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makePush2 = /* @__PURE__ */ __name(({ storage, options: options4, rpcSubscriptions, currentHeadRef, storeId: storeId2, payload, ctx, env: env3 }) => (pushRequest) => Effect_exports2.gen(function* () {
  if (pushRequest.batch.length === 0) {
    return sync_message_types_exports.PushAck.make({});
  }
  if (options4?.onPush) {
    yield* Effect_exports2.tryAll(() => options4.onPush(pushRequest, { storeId: storeId2, payload })).pipe(UnexpectedError.mapToUnexpectedError);
  }
  const { createdAt } = yield* Effect_exports2.gen(function* () {
    if (currentHeadRef.current === "uninitialized") {
      const currentHeadFromStorage = yield* Effect_exports2.promise(() => ctx.storage.get("currentHead"));
      if (currentHeadFromStorage === void 0) {
        currentHeadRef.current = EventSequenceNumber_exports.ROOT.global;
      } else {
        currentHeadRef.current = currentHeadFromStorage;
      }
    } else {
    }
    const firstEvent = pushRequest.batch[0];
    if (firstEvent.parentSeqNum !== currentHeadRef.current) {
      const cause3 = sync_message_types_exports.InvalidParentEventNumber.make({
        expected: currentHeadRef.current,
        received: firstEvent.parentSeqNum
      });
      return yield* sync_message_types_exports.SyncError.make({ cause: cause3, storeId: storeId2 });
    }
    const createdAt2 = (/* @__PURE__ */ new Date()).toISOString();
    yield* storage.appendEvents(pushRequest.batch, createdAt2);
    currentHeadRef.current = pushRequest.batch.at(-1).seqNum;
    yield* Effect_exports2.promise(() => ctx.storage.put("currentHead", currentHeadRef.current));
    return { createdAt: createdAt2 };
  }).pipe(blockConcurrencyWhile(ctx));
  yield* Effect_exports2.gen(function* () {
    const connectedClients = ctx.getWebSockets();
    const pullRes = sync_message_types_exports.PullResponse.make({
      batch: pushRequest.batch.map((eventEncoded) => ({
        eventEncoded,
        metadata: Option_exports.some(sync_message_types_exports.SyncMetadata.make({ createdAt }))
      })),
      pageInfo: sync_backend_exports.pageInfoNoMore
    });
    const pullResEnc = Schema_exports2.encodeSync(sync_message_types_exports.PullResponse)(pullRes);
    if (connectedClients.length > 0) {
      if (options4?.onPullRes) {
        yield* Effect_exports2.tryAll(() => options4.onPullRes(pullRes)).pipe(UnexpectedError.mapToUnexpectedError);
      }
      for (const conn of connectedClients) {
        const attachment = Schema_exports2.decodeSync(WebSocketAttachmentSchema)(conn.deserializeAttachment());
        for (const requestId2 of attachment.pullRequestIds) {
          const res = {
            _tag: "Chunk",
            requestId: requestId2,
            values: [pullResEnc]
          };
          conn.send(JSON.stringify(res));
        }
      }
      yield* Effect_exports2.logDebug(`Broadcasted to ${connectedClients.length} WebSocket clients`);
    }
    if (rpcSubscriptions.size > 0) {
      yield* Effect_exports2.forEach(rpcSubscriptions.values(), (subscription) => emitStreamResponse({
        callerContext: subscription.callerContext,
        env: env3,
        requestId: subscription.requestId,
        values: [pullResEnc]
      }).pipe(Effect_exports2.tapCauseLogPretty, Effect_exports2.exit), { concurrency: "unbounded" });
      yield* Effect_exports2.logDebug(`Broadcasted to ${rpcSubscriptions.size} RPC clients`);
    }
  }).pipe(
    Effect_exports2.tapCauseLogPretty,
    Effect_exports2.withSpan("push-rpc-broadcast"),
    Effect_exports2.uninterruptible,
    // We need to make sure Effect RPC doesn't interrupt this fiber
    Effect_exports2.fork
  );
  yield* Effect_exports2.yieldNow();
  return sync_message_types_exports.PushAck.make({});
}).pipe(Effect_exports2.tap(Effect_exports2.fn(function* (message) {
  if (options4?.onPushRes) {
    yield* Effect_exports2.tryAll(() => options4.onPushRes(message)).pipe(UnexpectedError.mapToUnexpectedError);
  }
})), Effect_exports2.mapError((cause3) => cause3._tag === "LiveStore.UnexpectedError" ? sync_message_types_exports.SyncError.make({ cause: cause3, storeId: storeId2 }) : cause3)), "makePush");
var blockConcurrencyWhile = /* @__PURE__ */ __name((ctx) => (eff) => Effect_exports2.gen(function* () {
  const runtime8 = yield* Effect_exports2.runtime();
  const exit5 = yield* Effect_exports2.promise(() => ctx.blockConcurrencyWhile(() => eff.pipe(Effect_exports2.provide(runtime8), Effect_exports2.runPromiseExit)));
  return yield* exit5;
}), "blockConcurrencyWhile");

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/do/transport/do-rpc-server.js
var createDoRpcHandler = /* @__PURE__ */ __name((options4) => Effect_exports2.gen(void 0, function* () {
  const { ctx, env: env3, rpcSubscriptions, currentHeadRef, payload, ensureStorageCache } = options4;
  const RpcLive = SyncDoRpc.toLayer({
    "SyncDoRpc.Ping": /* @__PURE__ */ __name((_req) => {
      return Effect_exports2.succeed(sync_message_types_exports.Pong.make({}));
    }, "SyncDoRpc.Ping"),
    "SyncDoRpc.Pull": /* @__PURE__ */ __name((req, headers) => Effect_exports2.gen(this, function* () {
      yield* ensureStorageCache(req.storeId);
      const pull = makeEndingPullStream({
        storage: makeStorage(ctx, env3, req.storeId),
        doOptions: options4.doOptions,
        storeId: req.storeId,
        payload: req.payload
      });
      if (req.rpcContext) {
        rpcSubscriptions.set(req.storeId, {
          // clientId: req.clientId,
          storeId: req.storeId,
          payload: req.payload,
          subscribedAt: Date.now(),
          requestId: Headers_exports.get(headers, "x-rpc-request-id").pipe(Option_exports.getOrThrow),
          callerContext: req.rpcContext.callerContext
        });
      }
      return pull(req);
    }).pipe(Stream_exports2.unwrap, Stream_exports2.emitIfEmpty(sync_backend_exports.pullResItemEmpty()), Stream_exports2.map((res) => ({
      ...res,
      rpcRequestId: Headers_exports.get(headers, "x-rpc-request-id").pipe(Option_exports.getOrThrow)
    })), Stream_exports2.mapError((cause3) => sync_message_types_exports.SyncError.make({ cause: cause3, storeId: req.storeId }))), "SyncDoRpc.Pull"),
    "SyncDoRpc.Push": /* @__PURE__ */ __name((req) => Effect_exports2.gen(this, function* () {
      yield* ensureStorageCache(req.storeId);
      const push = makePush2({
        storage: makeStorage(ctx, env3, req.storeId),
        ctx,
        env: env3,
        currentHeadRef,
        storeId: req.storeId,
        payload: void 0,
        rpcSubscriptions,
        options: options4.doOptions
      });
      return yield* push(req);
    }), "SyncDoRpc.Push")
  });
  const handler = toDurableObjectHandler(SyncDoRpc, {
    layer: Layer_exports.mergeAll(RpcLive, RpcSerialization_exports.layerJson, HttpServer_exports.layerContext).pipe(Layer_exports.provide(Logger_exports2.consoleWithThread("SyncDo")), Layer_exports.provide(Logger_exports2.minimumLogLevel(LogLevel_exports.Debug)))
  });
  return yield* handler(payload);
}).pipe(Effect_exports2.withSpan("createDoRpcHandler")), "createDoRpcHandler");

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/do/transport/http-rpc-server.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var createHttpRpcHandler = /* @__PURE__ */ __name((options4) => Effect_exports2.gen(function* () {
  const handlerLayer = createHttpRpcLayer(options4);
  const httpApp = RpcServer_exports.toHttpApp(SyncHttpRpc).pipe(Effect_exports2.provide(handlerLayer));
  const webHandler = yield* httpApp.pipe(Effect_exports2.map(HttpApp_exports.toWebHandler));
  return yield* Effect_exports2.promise(() => webHandler(options4.request)).pipe(Effect_exports2.timeout(1e4));
}).pipe(Effect_exports2.withSpan("createHttpRpcHandler")), "createHttpRpcHandler");
var createHttpRpcLayer = /* @__PURE__ */ __name((options4) => (
  // TODO implement admin requests
  SyncHttpRpc.toLayer({
    "SyncHttpRpc.Pull": /* @__PURE__ */ __name((req) => Effect_exports2.gen(function* () {
      const storage = yield* options4.makeStorage(req.storeId);
      const pull = makeEndingPullStream({
        storage,
        doOptions: options4.doOptions,
        storeId: req.storeId,
        payload: req.payload
      });
      return pull(req);
    }).pipe(Stream_exports2.unwrap, Stream_exports2.mapError((cause3) => SyncError2.make({ cause: cause3, storeId: req.storeId }))), "SyncHttpRpc.Pull"),
    "SyncHttpRpc.Push": /* @__PURE__ */ __name((req) => Effect_exports2.gen(function* () {
      const storage = yield* options4.makeStorage(req.storeId);
      const push = makePush2({
        storage,
        ctx: options4.ctx,
        env: options4.env,
        currentHeadRef: options4.currentHeadRef,
        storeId: req.storeId,
        payload: void 0,
        rpcSubscriptions: options4.rpcSubscriptions,
        options: options4.doOptions
      });
      return yield* push(req);
    }), "SyncHttpRpc.Push"),
    "SyncHttpRpc.Ping": /* @__PURE__ */ __name(() => Effect_exports2.succeed(Pong3.make({})), "SyncHttpRpc.Ping")
  }).pipe(Layer_exports.provideMerge(RpcServer_exports.layerProtocolHttp({ path: "/http-rpc" })), Layer_exports.provideMerge(RpcSerialization_exports.layerJson))
), "createHttpRpcLayer");

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/do/transport/ws-rpc-server.js
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var makeRpcServer = /* @__PURE__ */ __name(({ options: options4, ctx, env: env3, rpcSubscriptions, currentHeadRef }) => {
  const handlersLayer = SyncWsRpc.toLayer({
    "SyncWsRpc.Pull": /* @__PURE__ */ __name((req) => Effect_exports2.gen(function* () {
      const { storeId: storeId2, payload } = req;
      const storage = makeStorage(ctx, env3, storeId2);
      const pull = makeEndingPullStream({ storage, doOptions: options4, storeId: storeId2, payload });
      return pull(req).pipe(Stream_exports2.tap(Effect_exports2.fn(function* (res) {
        if (options4?.onPullRes) {
          yield* Effect_exports2.tryAll(() => options4.onPullRes(res)).pipe(UnexpectedError.mapToUnexpectedError);
        }
      })));
    }).pipe(
      Stream_exports2.unwrap,
      Stream_exports2.emitIfEmpty(sync_backend_exports.pullResItemEmpty()),
      // Needed to keep the stream alive on the client side for phase 2 (i.e. not send the `Exit` stream RPC message)
      req.live ? Stream_exports2.concat(Stream_exports2.never) : identity,
      Stream_exports2.mapError((cause3) => sync_message_types_exports.SyncError.make({ cause: cause3, storeId: req.storeId }))
    ), "SyncWsRpc.Pull"),
    "SyncWsRpc.Push": /* @__PURE__ */ __name((req) => Effect_exports2.gen(function* () {
      const { storeId: storeId2, payload } = req;
      const storage = makeStorage(ctx, env3, storeId2);
      const push = makePush2({
        storage,
        options: options4,
        rpcSubscriptions,
        currentHeadRef,
        storeId: storeId2,
        payload,
        ctx,
        env: env3
      });
      return yield* push(req);
    }), "SyncWsRpc.Push")
  });
  return RpcServer_exports.layer(SyncWsRpc).pipe(Layer_exports.provide(handlersLayer));
}, "makeRpcServer");

// node_modules/.pnpm/@livestore+sync-cf@0.0.0-snapshot-8452e32b7fbfc129741b253b9c853f866b52129f_947719b188f48aad6a4d88fa2b3ff904/node_modules/@livestore/sync-cf/dist/cf-worker/do/durable-object.js
var DurableObjectBase = DurableObject;
var makeDurableObject = /* @__PURE__ */ __name((options4) => {
  const enabledTransports = options4?.enabledTransports ?? /* @__PURE__ */ new Set(["http", "ws", "do-rpc"]);
  const Logging = Logger_exports2.consoleWithThread("SyncDo");
  const Observability = options4?.otel?.baseUrl ? Otlp_exports.layer({
    baseUrl: options4.otel.baseUrl,
    tracerExportInterval: 50,
    resource: {
      serviceName: options4.otel.serviceName ?? "sync-cf-do"
    }
  }).pipe(Layer_exports.provide(FetchHttpClient_exports.layer)) : Layer_exports.empty;
  return class SyncBackendDOBase extends DurableObjectBase {
    static {
      __name(this, "SyncBackendDOBase");
    }
    __DURABLE_OBJECT_BRAND = "SyncBackendDOBase";
    ctx;
    env;
    // Cached value
    storageCache;
    // TODO move to `storageCache`
    currentHeadRef = {
      current: "uninitialized"
    };
    // TODO refactor
    /** RPC subscription storage */
    rpcSubscriptions = /* @__PURE__ */ new Map();
    constructor(ctx, env3) {
      super(ctx, env3);
      this.ctx = ctx;
      this.env = env3;
      const WebSocketRpcServerLive = makeRpcServer({
        options: options4,
        ctx: this.ctx,
        env: this.env,
        currentHeadRef: this.currentHeadRef,
        rpcSubscriptions: this.rpcSubscriptions
      });
      if (enabledTransports.has("ws")) {
        setupDurableObjectWebSocketRpc({
          doSelf: this,
          rpcLayer: WebSocketRpcServerLive,
          webSocketMode: "hibernate",
          // See `pull.ts` for more details how `pull` Effect RPC requests streams are handled
          // in combination with DO hibernation
          onMessage: /* @__PURE__ */ __name((request2, ws) => {
            if (request2._tag === "Request" && request2.tag === "SyncWsRpc.Pull") {
              const attachment = ws.deserializeAttachment();
              const { pullRequestIds, ...rest } = Schema_exports2.decodeSync(WebSocketAttachmentSchema)(attachment);
              ws.serializeAttachment(Schema_exports2.encodeSync(WebSocketAttachmentSchema)({
                ...rest,
                pullRequestIds: [...pullRequestIds, request2.id]
              }));
            } else if (request2._tag === "Interrupt") {
              const attachment = ws.deserializeAttachment();
              const { pullRequestIds, ...rest } = Schema_exports2.decodeSync(WebSocketAttachmentSchema)(attachment);
              ws.serializeAttachment(Schema_exports2.encodeSync(WebSocketAttachmentSchema)({
                ...rest,
                pullRequestIds: pullRequestIds.filter((id4) => id4 !== request2.requestId)
              }));
            }
          }, "onMessage"),
          mainLayer: Observability
        });
      }
    }
    fetch = /* @__PURE__ */ __name(async (request2) => Effect_exports2.gen(this, function* () {
      const requestParamsResult = getSyncRequestSearchParams(request2);
      if (requestParamsResult._tag === "None") {
        throw new Error("No search params found in request URL");
      }
      const { storeId: storeId2, payload, transport } = requestParamsResult.value;
      if (enabledTransports.has(transport) === false) {
        throw new Error(`Transport ${transport} is not enabled (based on \`options.enabledTransports\`)`);
      }
      if (transport === "http") {
        return yield* this.handleHttp(request2);
      }
      if (transport === "ws") {
        yield* this.getStorageCache(request2);
        const { 0: client, 1: server } = new WebSocketPair();
        server.serializeAttachment(Schema_exports2.encodeSync(WebSocketAttachmentSchema)({ storeId: storeId2, payload, pullRequestIds: [] }));
        this.ctx.acceptWebSocket(server);
        this.ctx.setWebSocketAutoResponse(new WebSocketRequestResponsePair(JSON.stringify(RpcMessage_exports.constPing), JSON.stringify(RpcMessage_exports.constPong)));
        return new Response(null, {
          status: 101,
          webSocket: client
        });
      }
      console.error("Invalid path", request2.url);
      return new Response("Invalid path", {
        status: 400,
        statusText: "Bad Request"
      });
    }).pipe(
      Effect_exports2.tapCauseLogPretty,
      // Also log errors to console before catching them
      Effect_exports2.catchAllCause((cause3) => Effect_exports2.succeed(new Response("Error", { status: 500, statusText: cause3.toString() }))),
      Effect_exports2.withSpan("@livestore/sync-cf:durable-object:fetch"),
      this.runEffectAsPromise
    ), "fetch");
    /**
     * Handles DO <-> DO RPC calls
     */
    async rpc(payload) {
      if (enabledTransports.has("do-rpc") === false) {
        throw new Error("Do RPC transport is not enabled (based on `options.enabledTransports`)");
      }
      return createDoRpcHandler({
        ctx: this.ctx,
        env: this.env,
        doOptions: options4,
        rpcSubscriptions: this.rpcSubscriptions,
        currentHeadRef: this.currentHeadRef,
        payload,
        ensureStorageCache: /* @__PURE__ */ __name((storeId2) => this.getStorageCache({ storeId: storeId2 }), "ensureStorageCache")
      }).pipe(Effect_exports2.withSpan("@livestore/sync-cf:durable-object:rpc"), this.runEffectAsPromise);
    }
    /**
     * Handles HTTP RPC calls
     *
     * Requires the `enable_request_signal` compatibility flag to properly support `pull` streaming responses
     */
    handleHttp = /* @__PURE__ */ __name((request2) => createHttpRpcHandler({
      ctx: this.ctx,
      env: this.env,
      makeStorage: /* @__PURE__ */ __name((storeId2) => Effect_exports2.gen(this, function* () {
        yield* this.getStorageCache({ storeId: storeId2 });
        return makeStorage(this.ctx, this.env, storeId2);
      }), "makeStorage"),
      doOptions: options4,
      rpcSubscriptions: this.rpcSubscriptions,
      currentHeadRef: this.currentHeadRef,
      request: request2
    }).pipe(Effect_exports2.withSpan("@livestore/sync-cf:durable-object:handleHttp")), "handleHttp");
    // TODO refactor with Effect layer
    getStorageCache = /* @__PURE__ */ __name((request2) => Effect_exports2.gen(this, function* () {
      if (this.storageCache !== void 0) {
        return this.storageCache;
      }
      const getStoreId = /* @__PURE__ */ __name((request3) => {
        if (Predicate_exports.hasProperty(request3, "url")) {
          const url2 = new URL(request3.url);
          return url2.searchParams.get("storeId") ?? shouldNeverHappen(`No storeId provided in request URL search params`);
        }
        return request3.storeId;
      }, "getStoreId");
      const storeId2 = getStoreId(request2);
      const storage = makeStorage(this.ctx, this.env, storeId2);
      {
        const colSpec = mod_exports4.SQLite.makeColumnSpec(eventlogTable.sqliteDef.ast);
        yield* Effect_exports2.promise(() => this.env.DB.exec(`CREATE TABLE IF NOT EXISTS "${storage.dbName}" (${colSpec}) strict`));
      }
      {
        const colSpec = mod_exports4.SQLite.makeColumnSpec(contextTable.sqliteDef.ast);
        this.ctx.storage.sql.exec(`CREATE TABLE IF NOT EXISTS "${contextTable.sqliteDef.name}" (${colSpec}) strict`);
      }
      const storageCache = { storeId: storeId2, currentHead: EventSequenceNumber_exports.ROOT.global };
      this.storageCache = storageCache;
      this.ctx.storage.sql.exec(`INSERT OR REPLACE INTO "${contextTable.sqliteDef.name}" (storeId, currentHead) VALUES (?, ?)`, storageCache.storeId, storageCache.currentHead);
      return storageCache;
    }).pipe(Effect_exports2.withSpan("@livestore/sync-cf:durable-object:getStorageCache")), "getStorageCache");
    runEffectAsPromise = /* @__PURE__ */ __name((effect4) => effect4.pipe(Effect_exports2.tapCauseLogPretty, Logger_exports2.withMinimumLogLevel(LogLevel_exports.Debug), Effect_exports2.provide(Layer_exports.mergeAll(Observability, Logging)), Effect_exports2.scoped, Effect_exports2.runPromise), "runEffectAsPromise");
  };
}, "makeDurableObject");
var StorageCacheSchema = Schema_exports2.parseJson(Schema_exports2.Struct({
  storeId: Schema_exports2.String,
  // TODO
  currentHead: Schema_exports2.optional(EventSequenceNumber_exports.GlobalEventSequenceNumber)
}));

// src/livestore/schema.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var tables = {
  todos: mod_exports4.SQLite.table({
    name: "todos",
    columns: {
      id: mod_exports4.SQLite.text({ primaryKey: true }),
      text: mod_exports4.SQLite.text({ default: "" }),
      completed: mod_exports4.SQLite.boolean({ default: false }),
      deletedAt: mod_exports4.SQLite.integer({ nullable: true, schema: Schema_exports2.DateFromNumber })
    }
  }),
  // Client documents can be used for local-only state (e.g. form inputs)
  uiState: mod_exports4.SQLite.clientDocument({
    name: "uiState",
    schema: Schema_exports2.Struct({ newTodoText: Schema_exports2.String, filter: Schema_exports2.Literal("all", "active", "completed") }),
    default: { id: SessionIdSymbol, value: { newTodoText: "", filter: "all" } }
  })
};
var events = {
  todoCreated: events_exports.synced({
    name: "v1.TodoCreated",
    schema: Schema_exports2.Struct({ id: Schema_exports2.String, text: Schema_exports2.String })
  }),
  todoCompleted: events_exports.synced({
    name: "v1.TodoCompleted",
    schema: Schema_exports2.Struct({ id: Schema_exports2.String })
  }),
  todoUncompleted: events_exports.synced({
    name: "v1.TodoUncompleted",
    schema: Schema_exports2.Struct({ id: Schema_exports2.String })
  }),
  todoDeleted: events_exports.synced({
    name: "v1.TodoDeleted",
    schema: Schema_exports2.Struct({ id: Schema_exports2.String, deletedAt: Schema_exports2.Date })
  }),
  todoClearedCompleted: events_exports.synced({
    name: "v1.TodoClearedCompleted",
    schema: Schema_exports2.Struct({ deletedAt: Schema_exports2.Date })
  }),
  uiStateSet: tables.uiState.set
};
var materializers2 = mod_exports4.SQLite.materializers(events, {
  "v1.TodoCreated": /* @__PURE__ */ __name(({ id: id4, text: text7 }) => tables.todos.insert({ id: id4, text: text7, completed: false }), "v1.TodoCreated"),
  "v1.TodoCompleted": /* @__PURE__ */ __name(({ id: id4 }) => tables.todos.update({ completed: true }).where({ id: id4 }), "v1.TodoCompleted"),
  "v1.TodoUncompleted": /* @__PURE__ */ __name(({ id: id4 }) => tables.todos.update({ completed: false }).where({ id: id4 }), "v1.TodoUncompleted"),
  "v1.TodoDeleted": /* @__PURE__ */ __name(({ id: id4, deletedAt }) => tables.todos.update({ deletedAt }).where({ id: id4 }), "v1.TodoDeleted"),
  "v1.TodoClearedCompleted": /* @__PURE__ */ __name(({ deletedAt }) => tables.todos.update({ deletedAt }).where({ completed: true }), "v1.TodoClearedCompleted")
});
var state = mod_exports4.SQLite.makeState({ tables, materializers: materializers2 });
var schema3 = makeSchema({ events, state });

// src/cf-worker/index.ts
var storeId = "91ca65b1-ffff-4b79-8ca7-c24f1425ff15";
var WebSocketServer = class extends makeDurableObject({}) {
  static {
    __name(this, "WebSocketServer");
  }
};
var LiveStoreClientDO = class extends DurableObject2 {
  static {
    __name(this, "LiveStoreClientDO");
  }
  __DURABLE_OBJECT_BRAND = "LiveStoreClientDO";
  cachedStore;
  async fetch(request2) {
    console.log("LiveStoreClientDO.fetch called");
    console.log("ctx.storage exists:", !!this.ctx.storage);
    console.log("ctx.storage.sql exists:", !!this.ctx.storage?.sql);
    try {
      const store = await this.ensureStore();
      console.log("Store created successfully");
      const todos = store.query(tables.todos);
      console.log("Todos query result:", todos.length, "todos");
      return new Response(JSON.stringify(todos), {
        headers: { "Content-Type": "application/json" }
      });
    } catch (error5) {
      console.error("Error in fetch:", error5);
      return new Response(JSON.stringify({ error: String(error5) }), {
        status: 500,
        headers: { "Content-Type": "application/json" }
      });
    }
  }
  async ensureStore() {
    if (this.cachedStore !== void 0) {
      return this.cachedStore;
    }
    console.log("ensureStore: ctx.storage exists:", !!this.ctx.storage);
    console.log("ensureStore: ctx.storage.sql exists:", !!this.ctx.storage?.sql);
    const store = await createStoreDoPromise({
      schema: schema3,
      storeId,
      clientId: "client-do",
      sessionId: nanoid(),
      storage: this.ctx.storage,
      durableObjectId: this.ctx.id.toString(),
      bindingName: "CLIENT_DO",
      syncBackendDurableObject: this.env.SYNC_BACKEND_DO.get(this.env.SYNC_BACKEND_DO.idFromName(storeId)),
      livePull: true
    });
    this.cachedStore = store;
    return store;
  }
  async syncUpdateRpc(payload) {
  }
};
var cf_worker_default = {
  async fetch(request2, env3, ctx) {
    const url2 = new URL(request2.url);
    if (url2.pathname === "/") {
      const id4 = env3.CLIENT_DO.idFromName(storeId);
      return env3.CLIENT_DO.get(id4).fetch(request2);
    }
    return new Response("Not found", { status: 404 });
  }
};

// node_modules/.pnpm/wrangler@4.54.0_@cloudflare+workers-types@4.20241106.0/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var drainBody = /* @__PURE__ */ __name(async (request2, env3, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request2, env3);
  } finally {
    try {
      if (request2.body !== null && !request2.bodyUsed) {
        const reader = request2.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// node_modules/.pnpm/wrangler@4.54.0_@cloudflare+workers-types@4.20241106.0/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request2, env3, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request2, env3);
  } catch (e) {
    const error5 = reduceError(e);
    return Response.json(error5, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-jYI8r8/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = cf_worker_default;

// node_modules/.pnpm/wrangler@4.54.0_@cloudflare+workers-types@4.20241106.0/node_modules/wrangler/templates/middleware/common.ts
init_modules_watch_stub();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __facade_middleware__ = [];
function __facade_register__(...args2) {
  __facade_middleware__.push(...args2.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request2, env3, ctx, dispatch, middlewareChain) {
  const [head13, ...tail3] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail3);
    }
  };
  return head13(request2, env3, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request2, env3, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request2, env3, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-jYI8r8/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron3, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron3;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware2 of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware2);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request2, env3, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request2, env3, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request2, env3, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type3, init2) {
        if (type3 === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init2.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env3, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request2, env3, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware2 of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware2);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request2, env3, ctx) => {
      this.env = env3;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request2);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type3, init2) => {
      if (type3 === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init2.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request2) {
      return __facade_invoke__(
        request2,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  LiveStoreClientDO,
  WebSocketServer,
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
//# sourceMappingURL=index.js.map

import { Chunk, Effect, Exit, Headers, Layer, Rpc, RpcClient, RpcSerialization, Schema, Stream, } from '@livestore/utils/effect';
/**
 * Creates a Protocol layer that uses Cloudflare Durable Object RPC calls.
 * This enables direct RPC communication with Durable Objects using Cloudflare's native RPC.
 */
export const layerProtocolDurableObject = (callRpc) => Layer.scoped(RpcClient.Protocol, makeProtocolDurableObject(callRpc));
/**
 * Construct a Durable Object RPC handler from an `RpcGroup`.
 * This is the DO equivalent of `RpcServer.toWebHandler`.
 *
 * This follows the same pattern as RpcServer.toWebHandler but adapts it for
 * direct Durable Object RPC calls instead of HTTP.
 */
export const toDurableObjectHandler = (group, options) => {
    return (serializedPayload) => {
        return Effect.gen(function* () {
            const serialization = yield* RpcSerialization.RpcSerialization;
            const parser = serialization.unsafeMake();
            // Decode incoming requests - client sends array of requests
            const decoded = parser.decode(serializedPayload);
            // Handle potential nested array from client serialization
            let requests;
            if (Array.isArray(decoded) && decoded.length === 1 && Array.isArray(decoded[0])) {
                // Double-wrapped array [[{...}]] -> [{...}]
                requests = decoded[0];
            }
            else if (Array.isArray(decoded)) {
                // Single array [{...}]
                requests = decoded;
            }
            else {
                requests = [];
            }
            const responses = [];
            // Get the context with handlers - similar to how RpcServer.make accesses handlers
            const context = yield* Effect.context();
            // Process each request - similar to the main server loop in RpcServer.make
            for (const request of requests) {
                if (request._tag !== 'Request') {
                    continue;
                }
                // Find the RPC handler - similar to handleRequest in RpcServer line 225
                const rpc = group.requests.get(request.tag);
                const entry = rpc ? context.unsafeMap.get(rpc.key) : undefined;
                if (!rpc || !entry) {
                    responses.push({
                        _tag: 'Exit',
                        requestId: request.id,
                        exit: Exit.die(`Unknown request tag: ${request.tag}`),
                    });
                    continue;
                }
                // For streaming RPCs, we need to process chunks as they come
                // Check if this is a streaming RPC by looking at the success schema
                const rpcAny = rpc;
                const isStreamingRpc = rpcAny.successSchema?.ast?.annotations?.[Symbol.for('@effect/rpc/RpcSchema/Stream')] !== undefined;
                if (isStreamingRpc) {
                    // Handle streaming RPC
                    const handlerResult = entry.handler(request.payload, Headers.empty);
                    if (Effect.isEffect(handlerResult)) {
                        // If handler returns Effect, execute it first
                        const streamResult = yield* handlerResult;
                        // Process the stream result
                        yield* Stream.runForEachChunk(streamResult, (chunk) => {
                            if (Chunk.isNonEmpty(chunk)) {
                                responses.push({
                                    _tag: 'Chunk',
                                    requestId: request.id,
                                    values: Chunk.toReadonlyArray(chunk),
                                });
                            }
                            return Effect.void;
                        });
                    }
                    else {
                        // Process stream directly
                        yield* Stream.runForEachChunk(handlerResult, (chunk) => {
                            if (Chunk.isNonEmpty(chunk)) {
                                responses.push({
                                    _tag: 'Chunk',
                                    requestId: request.id,
                                    values: Chunk.toReadonlyArray(chunk),
                                });
                            }
                            return Effect.void;
                        });
                    }
                    // For streaming RPCs, send final exit with void success
                    const exitSchema = Rpc.exitSchema(rpc);
                    const exit = Exit.succeed(undefined);
                    const encodedExit = Schema.encodeSync(exitSchema)(exit);
                    responses.push({
                        _tag: 'Exit',
                        requestId: request.id,
                        exit: encodedExit,
                    });
                    continue;
                }
                // Execute the handler for non-streaming RPCs
                const result = yield* Effect.gen(function* () {
                    const handlerResult = entry.handler(request.payload, Headers.empty);
                    let value;
                    if (Effect.isEffect(handlerResult)) {
                        value = yield* handlerResult;
                    }
                    else {
                        value = handlerResult;
                    }
                    // Use the RPC's exit schema for proper encoding
                    const exitSchema = Rpc.exitSchema(rpc);
                    const exit = Exit.succeed(value);
                    const encodedExit = Schema.encodeSync(exitSchema)(exit);
                    return {
                        _tag: 'Exit',
                        requestId: request.id,
                        exit: encodedExit,
                    };
                }).pipe(Effect.catchAllCause((cause) => {
                    // Use the RPC's exit schema for proper encoding
                    const exitSchema = Rpc.exitSchema(rpc);
                    const exit = Exit.failCause(cause);
                    const encodedExit = Schema.encodeSync(exitSchema)(exit);
                    return Effect.succeed({
                        _tag: 'Exit',
                        requestId: request.id,
                        exit: encodedExit,
                    });
                }));
                responses.push(result);
            }
            return parser.encode(responses);
        }).pipe(Effect.provide(options.layer), Effect.scoped, Effect.runPromise);
    };
};
/**
 * Implementation of the RPC Protocol interface using Cloudflare Durable Object RPC calls.
 * Provides the core protocol methods required by @effect/rpc.
 */
const makeProtocolDurableObject = (callRpc) => RpcClient.Protocol.make(Effect.fnUntraced(function* (writeResponse) {
    const serialization = yield* RpcSerialization.RpcSerialization;
    const parser = serialization.unsafeMake();
    const send = (payload) => {
        if (payload._tag !== 'Request') {
            return Effect.void;
        }
        // Wrap single Request in array to match server expected format
        const serializedPayload = parser.encode([payload]);
        return Effect.gen(function* () {
            const serializedResponse = yield* Effect.tryPromise({
                try: () => callRpc(serializedPayload),
                catch: (cause) => ({
                    _tag: 'ProtocolError',
                    message: 'Failed to send Durable Object RPC payload',
                    cause,
                }),
            });
            // Cloudflare DO RPC returns serialized responses, need to decode them
            const decodedResponse = parser.decode(serializedResponse);
            // Handle potential nested array from serialization (same as server-side)
            let responseArray;
            if (Array.isArray(decodedResponse) && decodedResponse.length === 1 && Array.isArray(decodedResponse[0])) {
                // Double-wrapped array [[Exit]] -> [Exit]
                responseArray = decodedResponse[0];
            }
            else if (Array.isArray(decodedResponse)) {
                // Single array [Exit]
                responseArray = decodedResponse;
            }
            else {
                responseArray = [decodedResponse];
            }
            for (const response of responseArray) {
                yield* writeResponse(response);
            }
        });
    };
    return {
        send,
        supportsAck: false, // DO RPC doesn't support ack mechanism like WebSockets
        supportsTransferables: false, // DO RPC doesn't support transferables yet
    };
}));
//# sourceMappingURL=protocol-durable-object.js.map
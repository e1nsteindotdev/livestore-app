import { InvalidPullError, InvalidPushError, SyncBackend, UnexpectedError } from '@livestore/common';
import { layerProtocolDurableObject } from '@livestore/common-cf';
import { shouldNeverHappen } from '@livestore/utils';
import { Effect, identity, Layer, Mailbox, Option, RpcClient, RpcSerialization, Schema, Stream, SubscriptionRef, } from '@livestore/utils/effect';
import { SyncDoRpc } from "../../common/do-rpc-schema.js";
import { SyncMessage } from "../../common/mod.js";
const requestIdMailboxMap = new Map();
/**
 * Creates a sync backend that uses Durable Object RPC to communicate with the sync backend.
 *
 * Used internally by `@livestore/adapter-cf` to connect to the sync backend.
 */
export const makeDoRpcSync = ({ syncBackendStub, durableObjectContext }) => ({ storeId, payload }) => Effect.gen(function* () {
    const isConnected = yield* SubscriptionRef.make(true);
    const ProtocolLive = layerProtocolDurableObject({
        callRpc: (payload) => syncBackendStub.rpc(payload),
        callerContext: durableObjectContext,
    }).pipe(Layer.provide(RpcSerialization.layerJson));
    const rpcClient = yield* RpcClient.make(SyncDoRpc).pipe(Effect.provide(ProtocolLive));
    // Nothing to do here
    const connect = Effect.void;
    const pull = (args, options) => Effect.gen(function* () {
        const live = options?.live ?? false;
        return rpcClient.SyncDoRpc.Pull({
            cursor: Option.getOrUndefined(args)?.cursor,
            storeId,
            rpcContext: live ? { callerContext: durableObjectContext } : undefined,
        }).pipe(live
            ? Stream.concatWithLastElement((res) => Effect.gen(function* () {
                if (res._tag === 'None')
                    return shouldNeverHappen('There should at least be a no-more page info response');
                const mailbox = yield* Mailbox.make().pipe(Effect.acquireRelease((mailbox) => mailbox.shutdown));
                requestIdMailboxMap.set(res.value.rpcRequestId, mailbox);
                return Mailbox.toStream(mailbox);
            }).pipe(Stream.unwrapScoped))
            : identity);
    }).pipe(Stream.unwrapScoped, Stream.mapError((cause) => new InvalidPullError({ cause })), Stream.withSpan('rpc-sync-client:pull'));
    const push = (batch) => Effect.gen(function* () {
        if (batch.length === 0) {
            return;
        }
        yield* rpcClient.SyncDoRpc.Push({ batch, storeId });
    }).pipe(Effect.mapError((cause) => new InvalidPushError({ reason: { _tag: 'Unexpected', cause } })), Effect.withSpan('rpc-sync-client:push'));
    const ping = rpcClient.SyncDoRpc.Ping({
        storeId,
        payload,
    }).pipe(UnexpectedError.mapToUnexpectedError, Effect.withSpan('rpc-sync-client:ping'));
    return SyncBackend.of({
        connect,
        isConnected,
        pull,
        push,
        ping,
        metadata: {
            name: 'rpc-sync-client',
            description: 'Cloudflare Durable Object RPC Sync Client',
            protocol: 'rpc',
            storeId,
        },
        supports: {
            pullPageInfoKnown: true,
            pullLive: true,
        },
    });
});
/**
 *
 * ```ts
 * import { DurableObject } from 'cloudflare:workers'
 * import { ClientDoWithRpcCallback } from '@livestore/common-cf'
 *
 * export class MyDurableObject extends DurableObject implements ClientDoWithRpcCallback {
 *   // ...
 *
 *   async syncUpdateRpc(payload: RpcMessage.ResponseChunkEncoded) {
 *     return handleSyncUpdateRpc(payload)
 *   }
 * }
 * ```
 */
export const handleSyncUpdateRpc = (payload) => Effect.gen(function* () {
    const decodedPayload = yield* Schema.decodeUnknown(ResponseChunkEncoded)(payload);
    const decoded = yield* Schema.decodeUnknown(SyncMessage.PullResponse)(decodedPayload.values[0]);
    const pullStreamMailbox = requestIdMailboxMap.get(decodedPayload.requestId);
    if (pullStreamMailbox === undefined) {
        // Case: DO was hibernated, so we need to manually update the store
        yield* Effect.log(`No mailbox found for ${decodedPayload.requestId}`);
    }
    else {
        // Case: DO was still alive, so the existing `pull` will pick up the new events
        yield* pullStreamMailbox.offer(decoded);
    }
}).pipe(Effect.withSpan('rpc-sync-client:rpcCallback'), Effect.tapCauseLogPretty, Effect.runPromise);
const ResponseChunkEncoded = Schema.Struct({
    requestId: Schema.String,
    values: Schema.Array(Schema.Any),
});
//# sourceMappingURL=do-rpc-client.js.map
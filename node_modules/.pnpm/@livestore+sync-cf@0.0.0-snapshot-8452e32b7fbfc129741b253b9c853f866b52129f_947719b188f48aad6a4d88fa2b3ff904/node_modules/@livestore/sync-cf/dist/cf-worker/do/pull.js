import { SyncBackend, UnexpectedError } from '@livestore/common';
import { Effect, pipe, ReadonlyArray, Stream } from '@livestore/utils/effect';
import { SyncMessage } from "../../common/mod.js";
import { PULL_CHUNK_SIZE } from "../shared.js";
// Notes on stream handling:
// We're intentionally closing the stream once we've read all existing events
//
// WebSocket:
// - Further chunks will be emitted manually in `push.ts`
// - If the client sends a `Interrupt` RPC message, it will be handled in the `durable-object.ts` constructor
// DO RPC:
// - Further chunks will be emitted manually in `push.ts`
// - If the client sends a `Interrupt` RPC message, TODO
export const makeEndingPullStream = ({ storage, doOptions, storeId, payload, }) => (req) => Effect.gen(function* () {
    if (doOptions?.onPull) {
        yield* Effect.tryAll(() => doOptions.onPull(req, { storeId, payload })).pipe(UnexpectedError.mapToUnexpectedError);
    }
    // TODO use streaming for db results
    const remainingEvents = yield* storage.getEvents(req.cursor);
    const batches = pipe(remainingEvents, ReadonlyArray.chunksOf(PULL_CHUNK_SIZE), ReadonlyArray.map((batch, i) => {
        const remaining = Math.max(0, remainingEvents.length - (i + 1) * PULL_CHUNK_SIZE);
        return SyncMessage.PullResponse.make({
            batch,
            pageInfo: remaining > 0 ? SyncBackend.pageInfoMoreKnown(remaining) : SyncBackend.pageInfoNoMore,
        });
    }));
    return Stream.fromIterable(batches);
}).pipe(Stream.unwrap, Stream.withSpan('cloudflare-provider:pull'));
//# sourceMappingURL=pull.js.map
import type { CfTypes } from '@livestore/common-cf';
import { Effect, type Option, Schema } from '@livestore/utils/effect';
import { SearchParamsSchema, SyncMessage } from '../common/mod.ts';
export interface Env {
    /** Eventlog database */
    DB: CfTypes.D1Database;
    ADMIN_SECRET: string;
}
export type MakeDurableObjectClassOptions = {
    onPush?: (message: SyncMessage.PushRequest, context: {
        storeId: StoreId;
        payload?: Schema.JsonValue;
    }) => Effect.SyncOrPromiseOrEffect<void>;
    onPushRes?: (message: SyncMessage.PushAck | SyncMessage.SyncError) => Effect.SyncOrPromiseOrEffect<void>;
    onPull?: (message: SyncMessage.PullRequest, context: {
        storeId: StoreId;
        payload?: Schema.JsonValue;
    }) => Effect.SyncOrPromiseOrEffect<void>;
    onPullRes?: (message: SyncMessage.PullResponse | SyncMessage.SyncError) => Effect.SyncOrPromiseOrEffect<void>;
    /**
     * Enabled transports for sync backend
     * - `http`: HTTP JSON-RPC
     * - `ws`: WebSocket
     * - `do-rpc`: Durable Object RPC calls (only works in combination with `@livestore/adapter-cf`)
     *
     * @default Set(['http', 'ws', 'do-rpc'])
     */
    enabledTransports?: Set<'http' | 'ws' | 'do-rpc'>;
    otel?: {
        baseUrl?: string;
        serviceName?: string;
    };
};
export type StoreId = string;
export type DurableObjectId = string;
/**
 * Needs to be bumped when the storage format changes (e.g. eventlogTable schema changes)
 *
 * Changing this version number will lead to a "soft reset".
 */
export declare const PERSISTENCE_FORMAT_VERSION = 7;
export declare const DEFAULT_SYNC_DURABLE_OBJECT_NAME = "SYNC_BACKEND_DO";
export declare const encodeOutgoingMessage: (a: {
    readonly batch: readonly {
        readonly metadata: Option.Option<{
            readonly createdAt: string;
            readonly _tag: "SyncMessage.SyncMetadata";
        }>;
        readonly eventEncoded: {
            readonly name: string;
            readonly args: any;
            readonly seqNum: any;
            readonly parentSeqNum: any;
            readonly clientId: string;
            readonly sessionId: string;
        };
    }[];
    readonly pageInfo: {
        readonly _tag: "MoreUnknown";
    } | {
        readonly _tag: "MoreKnown";
        readonly remaining: number;
    } | {
        readonly _tag: "NoMore";
    };
} | {} | SyncMessage.SyncError | {
    readonly _tag: "SyncMessage.Pong";
} | {
    readonly _tag: "SyncMessage.AdminResetRoomResponse";
} | {
    readonly info: {
        readonly durableObjectId: string;
    };
    readonly _tag: "SyncMessage.AdminInfoResponse";
}, overrideOptions?: import("effect/SchemaAST").ParseOptions) => string;
export declare const encodeIncomingMessage: (a: {
    readonly cursor?: (number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">) | undefined;
} | {
    readonly batch: readonly {
        readonly name: string;
        readonly args: any;
        readonly seqNum: any;
        readonly parentSeqNum: any;
        readonly clientId: string;
        readonly sessionId: string;
    }[];
} | {
    readonly _tag: "SyncMessage.Ping";
} | {
    readonly _tag: "SyncMessage.AdminResetRoomRequest";
    readonly adminSecret: string;
} | {
    readonly _tag: "SyncMessage.AdminInfoRequest";
    readonly adminSecret: string;
}, overrideOptions?: import("effect/SchemaAST").ParseOptions) => string;
export declare const getSyncRequestSearchParams: (request: CfTypes.Request) => Option.Option<typeof SearchParamsSchema.Type>;
export declare const PULL_CHUNK_SIZE = 100;
export type RpcSubscription = {
    clientId?: string;
    storeId: StoreId;
    payload?: Schema.JsonValue;
    subscribedAt: number;
    /** Effect RPC request ID */
    requestId: string;
    callerContext: {
        bindingName: string;
        durableObjectId: string;
    };
};
/**
 * Durable Object interface supporting the DO RPC protocol for DO <> DO syncing.
 */
export interface SyncBackendRpcInterface {
    __DURABLE_OBJECT_BRAND: never;
    rpc(payload: Uint8Array): Promise<Uint8Array | CfTypes.ReadableStream>;
}
export declare const WebSocketAttachmentSchema: Schema.transform<Schema.SchemaClass<unknown, string, never>, Schema.Struct<{
    storeId: typeof Schema.String;
    payload: Schema.optional<Schema.Schema<Schema.JsonValue, Schema.JsonValue, never>>;
    pullRequestIds: Schema.Array$<typeof Schema.String>;
}>>;
//# sourceMappingURL=shared.d.ts.map
import type { Schema } from '@livestore/utils/effect';
import type { CfTypes, SearchParams } from '../common/mod.ts';
import { type Env } from './shared.ts';
export declare namespace HelperTypes {
    type AnyDON = CfTypes.DurableObjectNamespace<undefined>;
    type DOKeys<T> = {
        [K in keyof T]-?: T[K] extends AnyDON ? K : never;
    }[keyof T];
    type NonBuiltins<T> = Omit<T, keyof Env>;
    /**
     * Helper type to extract DurableObject keys from Env to give consumer type safety.
     *
     * @example
     * ```ts
     *  type PlatformEnv = {
     *    DB: D1Database
     *    ADMIN_TOKEN: string
     *    SYNC_BACKEND_DO: DurableObjectNamespace<SyncBackendDO>
     * }
     *  export default makeWorker<PlatformEnv>({
     *    durableObject: { name: "SYNC_BACKEND_DO" },
     *    // ^ (property) name?: "SYNC_BACKEND_DO" | undefined
     *  });
     */
    export type ExtractDurableObjectKeys<TEnv = Env> = DOKeys<NonBuiltins<TEnv>> extends never ? string : DOKeys<NonBuiltins<TEnv>>;
    export {};
}
export type CFWorker<TEnv extends Env = Env, _T extends CfTypes.Rpc.DurableObjectBranded | undefined = undefined> = {
    fetch: <CFHostMetada = unknown>(request: CfTypes.Request<CFHostMetada>, env: TEnv, ctx: CfTypes.ExecutionContext) => Promise<CfTypes.Response>;
};
export type MakeWorkerOptions<TEnv extends Env = Env> = {
    /**
     * Validates the payload during WebSocket connection establishment.
     * Note: This runs only at connection time, not for individual push events.
     * For push event validation, use the `onPush` callback in the durable object.
     */
    validatePayload?: (payload: Schema.JsonValue | undefined, context: {
        storeId: string;
    }) => void | Promise<void>;
    /** @default false */
    enableCORS?: boolean;
    durableObject?: {
        /**
         * Needs to match the binding name from the wrangler config
         *
         * @default 'SYNC_BACKEND_DO'
         */
        name?: HelperTypes.ExtractDurableObjectKeys<TEnv>;
    };
};
export declare const makeWorker: <TEnv extends Env = Env, TDurableObjectRpc extends CfTypes.Rpc.DurableObjectBranded | undefined = undefined>(options?: MakeWorkerOptions<TEnv>) => CFWorker<TEnv, TDurableObjectRpc>;
/**
 * Handles `/sync` endpoint.
 *
 * @example
 * ```ts
 * const validatePayload = (payload: Schema.JsonValue | undefined, context: { storeId: string }) => {
 *   console.log(`Validating connection for store: ${context.storeId}`)
 *   if (payload?.authToken !== 'insecure-token-change-me') {
 *     throw new Error('Invalid auth token')
 *   }
 * }
 *
 * export default {
 *   fetch: async (request, env, ctx) => {
 *     const requestParamsResult = getSyncRequestSearchParams(request)
 *
 *     // Is LiveStore sync request
 *     if (requestParamsResult._tag === 'Some') {
 *       return handleSyncRequest({
 *         request,
 *         searchParams: requestParamsResult.value,
 *         env,
 *         ctx,
 *         options: { headers: {}, validatePayload }
 *       })
 *     }
 *
 *     return new Response('Invalid path', { status: 400 })
 *   }
 * }
 * ```
 *
 * @throws {UnexpectedError} If the payload is invalid
 */
export declare const handleSyncRequest: <TEnv extends Env = Env, TDurableObjectRpc extends CfTypes.Rpc.DurableObjectBranded | undefined = undefined, CFHostMetada = unknown>({ request, searchParams, env, options, }: {
    request: CfTypes.Request<CFHostMetada>;
    searchParams: SearchParams;
    env: TEnv;
    /** Only there for type-level reasons */
    ctx: CfTypes.ExecutionContext;
    options?: {
        headers?: CfTypes.HeadersInit;
        durableObject?: MakeWorkerOptions<TEnv>["durableObject"];
        validatePayload?: (payload: Schema.JsonValue | undefined, context: {
            storeId: string;
        }) => void | Promise<void>;
    };
}) => Promise<CfTypes.Response>;
//# sourceMappingURL=worker.d.ts.map
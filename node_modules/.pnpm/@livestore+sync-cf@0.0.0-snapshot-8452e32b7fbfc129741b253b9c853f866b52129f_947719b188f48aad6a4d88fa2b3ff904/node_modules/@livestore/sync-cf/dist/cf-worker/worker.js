import { UnexpectedError } from '@livestore/common';
import { Effect } from '@livestore/utils/effect';
import { DEFAULT_SYNC_DURABLE_OBJECT_NAME, getSyncRequestSearchParams } from "./shared.js";
export const makeWorker = (options = {}) => {
    return {
        fetch: async (request, env, _ctx) => {
            const url = new URL(request.url);
            await new Promise((resolve) => setTimeout(resolve, 500));
            if (request.method === 'GET' && url.pathname === '/') {
                return new Response('Info: WebSocket sync backend endpoint for @livestore/sync-cf.', {
                    status: 200,
                    headers: { 'Content-Type': 'text/plain' },
                });
            }
            const corsHeaders = options.enableCORS
                ? {
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
                    'Access-Control-Allow-Headers': request.headers.get('Access-Control-Request-Headers') ?? '*',
                }
                : {};
            if (request.method === 'OPTIONS' && options.enableCORS) {
                return new Response(null, {
                    status: 204,
                    headers: corsHeaders,
                });
            }
            const requestParamsResult = getSyncRequestSearchParams(request);
            if (requestParamsResult._tag === 'Some') {
                return handleSyncRequest({
                    request,
                    searchParams: requestParamsResult.value,
                    env,
                    ctx: _ctx,
                    options: {
                        headers: corsHeaders,
                        validatePayload: options.validatePayload,
                        durableObject: options.durableObject,
                    },
                });
            }
            console.error('Invalid path', url.pathname);
            return new Response('Invalid path', {
                status: 400,
                statusText: 'Bad Request',
                headers: {
                    ...corsHeaders,
                    'Content-Type': 'text/plain',
                },
            });
        },
    };
};
/**
 * Handles `/sync` endpoint.
 *
 * @example
 * ```ts
 * const validatePayload = (payload: Schema.JsonValue | undefined, context: { storeId: string }) => {
 *   console.log(`Validating connection for store: ${context.storeId}`)
 *   if (payload?.authToken !== 'insecure-token-change-me') {
 *     throw new Error('Invalid auth token')
 *   }
 * }
 *
 * export default {
 *   fetch: async (request, env, ctx) => {
 *     const requestParamsResult = getSyncRequestSearchParams(request)
 *
 *     // Is LiveStore sync request
 *     if (requestParamsResult._tag === 'Some') {
 *       return handleSyncRequest({
 *         request,
 *         searchParams: requestParamsResult.value,
 *         env,
 *         ctx,
 *         options: { headers: {}, validatePayload }
 *       })
 *     }
 *
 *     return new Response('Invalid path', { status: 400 })
 *   }
 * }
 * ```
 *
 * @throws {UnexpectedError} If the payload is invalid
 */
export const handleSyncRequest = ({ request, searchParams, env, options = {}, }) => Effect.gen(function* () {
    const { storeId, payload, transport } = searchParams;
    if (options.validatePayload !== undefined) {
        const result = yield* Effect.promise(async () => options.validatePayload(payload, { storeId })).pipe(UnexpectedError.mapToUnexpectedError, Effect.either);
        if (result._tag === 'Left') {
            console.error('Invalid payload', result.left);
            return new Response(result.left.toString(), { status: 400, headers: options.headers });
        }
    }
    const durableObjectName = options.durableObject?.name ?? DEFAULT_SYNC_DURABLE_OBJECT_NAME;
    if (!(durableObjectName in env)) {
        return new Response(`Failed dependency: Required Durable Object binding '${durableObjectName}' not available`, {
            status: 424,
            headers: options.headers,
        });
    }
    const durableObjectNamespace = env[durableObjectName];
    const id = durableObjectNamespace.idFromName(storeId);
    const durableObject = durableObjectNamespace.get(id);
    // Handle WebSocket upgrade request
    const upgradeHeader = request.headers.get('Upgrade');
    if (transport === 'ws' && (upgradeHeader === null || upgradeHeader !== 'websocket')) {
        return new Response('Durable Object expected Upgrade: websocket', {
            status: 426,
            headers: options?.headers,
        });
    }
    return yield* Effect.promise(() => durableObject.fetch(request));
}).pipe(Effect.tapCauseLogPretty, Effect.runPromise);
//# sourceMappingURL=worker.js.map
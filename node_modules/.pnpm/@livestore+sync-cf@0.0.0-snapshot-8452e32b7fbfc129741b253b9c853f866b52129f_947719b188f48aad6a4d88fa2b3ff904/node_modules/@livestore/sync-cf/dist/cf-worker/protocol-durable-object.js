import { Effect, Headers, Layer, RpcClient, RpcSerialization, } from '@livestore/utils/effect';
/**
 * Creates a Protocol layer that uses Cloudflare Durable Object RPC calls.
 * This enables direct RPC communication with Durable Objects using Cloudflare's native RPC.
 */
export const layerProtocolDurableObject = (callRpc) => Layer.scoped(RpcClient.Protocol, makeProtocolDurableObject(callRpc));
/**
 * Construct a Durable Object RPC handler from an `RpcGroup`.
 * This is the DO equivalent of `RpcServer.toWebHandler`.
 *
 * This follows the same pattern as RpcServer.toWebHandler but adapts it for
 * direct Durable Object RPC calls instead of HTTP.
 */
export const toDurableObjectHandler = (group, options) => {
    return (serializedPayload) => {
        return Effect.gen(function* () {
            const serialization = yield* RpcSerialization.RpcSerialization;
            const parser = serialization.unsafeMake();
            // Decode incoming requests - client sends array of requests
            const decoded = parser.decode(serializedPayload);
            // Handle potential nested array from client serialization
            let requests;
            if (Array.isArray(decoded) && decoded.length === 1 && Array.isArray(decoded[0])) {
                // Double-wrapped array [[{...}]] -> [{...}]
                requests = decoded[0];
            }
            else if (Array.isArray(decoded)) {
                // Single array [{...}]
                requests = decoded;
            }
            else {
                requests = [];
            }
            const responses = [];
            // Get the context with handlers - similar to how RpcServer.make accesses handlers
            const context = yield* Effect.context();
            // Process each request - similar to the main server loop in RpcServer.make
            for (const request of requests) {
                if (request._tag !== 'Request') {
                    continue;
                }
                // Find the RPC handler - similar to handleRequest in RpcServer line 225
                const rpc = group.requests.get(request.tag);
                const entry = context.unsafeMap.get(rpc?.key);
                if (!rpc || !entry) {
                    responses.push({
                        _tag: 'Exit',
                        requestId: request.id,
                        exit: {
                            _tag: 'Failure',
                            cause: { _tag: 'Die', defect: `Unknown request tag: ${request.tag}` },
                        },
                    });
                    continue;
                }
                // Execute the handler - similar to line 241 in RpcServer
                const result = yield* Effect.gen(function* () {
                    const handlerResult = entry.handler(request.payload, Headers.empty);
                    // Handle both Effect and Stream results
                    const value = Effect.isEffect(handlerResult) ? yield* handlerResult : handlerResult;
                    return {
                        _tag: 'Exit',
                        requestId: request.id,
                        exit: { _tag: 'Success', value },
                    };
                }).pipe(Effect.catchAllCause((cause) => Effect.succeed({
                    _tag: 'Exit',
                    requestId: request.id,
                    exit: { _tag: 'Failure', cause },
                })));
                responses.push(result);
            }
            return parser.encode(responses);
        }).pipe(Effect.provide(options.layer), Effect.scoped, Effect.runPromise);
    };
};
/**
 * Implementation of the RPC Protocol interface using Cloudflare Durable Object RPC calls.
 * Provides the core protocol methods required by @effect/rpc.
 */
const makeProtocolDurableObject = (callRpc) => RpcClient.Protocol.make(Effect.fnUntraced(function* (writeResponse) {
    const serialization = yield* RpcSerialization.RpcSerialization;
    const parser = serialization.unsafeMake();
    const send = (payload) => {
        if (payload._tag !== 'Request') {
            return Effect.void;
        }
        // Wrap single Request in array to match server expected format
        const serializedPayload = parser.encode([payload]);
        return Effect.gen(function* () {
            const serializedResponse = yield* Effect.tryPromise({
                try: () => callRpc(serializedPayload),
                catch: (cause) => ({
                    _tag: 'ProtocolError',
                    message: 'Failed to send Durable Object RPC payload',
                    cause,
                }),
            });
            // Cloudflare DO RPC returns serialized responses, need to decode them
            const decodedResponse = parser.decode(serializedResponse);
            // Handle potential nested array from serialization (same as server-side)
            let responseArray;
            if (Array.isArray(decodedResponse) && decodedResponse.length === 1 && Array.isArray(decodedResponse[0])) {
                // Double-wrapped array [[Exit]] -> [Exit]
                responseArray = decodedResponse[0];
            }
            else if (Array.isArray(decodedResponse)) {
                // Single array [Exit]
                responseArray = decodedResponse;
            }
            else {
                responseArray = [decodedResponse];
            }
            for (const exitResponse of responseArray) {
                yield* writeResponse(exitResponse);
            }
        });
    };
    return {
        send,
        supportsAck: false, // DO RPC doesn't support ack mechanism like WebSockets
        supportsTransferables: false, // DO RPC doesn't support transferables yet
    };
}));
//# sourceMappingURL=protocol-durable-object.js.map
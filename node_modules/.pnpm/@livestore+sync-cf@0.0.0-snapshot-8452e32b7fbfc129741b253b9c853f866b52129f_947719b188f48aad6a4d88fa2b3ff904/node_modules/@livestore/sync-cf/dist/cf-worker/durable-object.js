/// <reference types="@cloudflare/workers-types" />
import { DurableObject } from 'cloudflare:workers';
import { EventSequenceNumber, State } from '@livestore/common/schema';
import { CfDeclare } from '@livestore/common-cf/declare';
import { shouldNeverHappen } from '@livestore/utils';
import { Effect, Logger, LogLevel, Predicate, Schema } from '@livestore/utils/effect';
import { SyncMessage } from "../common/mod.js";
import { encodeIncomingMessage, encodeOutgoingMessage, getRequestSearchParams, WebSocketAttachmentSchema, } from "./shared.js";
import { contextTable, eventlogTable } from "./sqlite.js";
import { makeStorage } from "./sync-storage.js";
import { createDoRpcHandler } from "./transport/do-rpc.js";
import { createHttpRpcHandler } from "./transport/http-rpc.js";
import { handleWebSocketMessage } from "./transport/ws.js";
const DurableObjectBase = DurableObject;
const PropsSchema = Schema.parseJson(Schema.Struct({
    storeId: Schema.String,
    // TODO
    currentHead: Schema.optional(EventSequenceNumber.GlobalEventSequenceNumber),
}));
// export type MakeDurableObjectClass = (options?: MakeDurableObjectClassOptions) => {
//   new (ctx: CfTypes.DurableObjectState, env: Env): CfTypes.DurableObject
// }
/**
 * Creates a Durable Object class for handling WebSocket-based sync.
 * A sync durable object is uniquely scoped to a specific `storeId`.
 *
 * The sync DO supports 3 transport modes:
 * - HTTP JSON-RPC
 * - WebSocket
 * - Durable Object RPC calls (only works in combination with `@livestore/adapter-cf`)
 *
 * Example:
 *
 * ```ts
 * // In your Cloudflare Worker file
 * import { makeDurableObject } from '@livestore/sync-cf/cf-worker'
 *
 * export class SyncBackendDO extends makeDurableObject({
 *   onPush: async (message) => {
 *     console.log('onPush', message.batch)
 *   },
 *   onPull: async (message) => {
 *     console.log('onPull', message)
 *   },
 * }) {}
 * ```
 *
 * `wrangler.toml`
 * ```toml
 * [[durable_objects.bindings]]
 * name = "SYNC_BACKEND_DO"
 * class_name = "SyncBackendDO"

 * [[migrations]]
 * tag = "v1"
 * new_sqlite_classes = ["SyncBackendDO"]
 * ```
 */
export const makeDurableObject = (options) => {
    return class SyncBackendDOBase extends DurableObjectBase {
        __DURABLE_OBJECT_BRAND = 'SyncBackendDOBase';
        ctx;
        env;
        // Cached value
        props;
        constructor(ctx, env) {
            super(ctx, env);
            this.ctx = ctx;
            this.env = env;
        }
        /** Needed to prevent concurrent pushes */
        pushSemaphore = Effect.makeSemaphore(1).pipe(Effect.runSync);
        // TODO move to `props`
        currentHeadRef = {
            current: 'uninitialized',
        };
        /** RPC subscription storage */
        rpcSubscriptions = new Map();
        fetch = async (request) => Effect.gen(this, function* () {
            // TODO implement HTTP RPC calls
            const url = new URL(request.url);
            if (url.pathname.endsWith('/http-rpc')) {
                return yield* this.handleHttp(request);
            }
            if (url.pathname.endsWith('/websocket')) {
                const { storeId, payload } = getRequestSearchParams(request);
                const storage = makeStorage(this.ctx, this.env, storeId);
                this.getProps(request);
                const { 0: client, 1: server } = new WebSocketPair();
                // Since we're using websocket hibernation, we need to remember the storeId for subsequent `webSocketMessage` calls
                server.serializeAttachment(Schema.encodeSync(WebSocketAttachmentSchema)({ storeId, payload }));
                // See https://developers.cloudflare.com/durable-objects/examples/websocket-hibernation-server
                this.ctx.acceptWebSocket(server);
                this.ctx.setWebSocketAutoResponse(new WebSocketRequestResponsePair(encodeIncomingMessage(SyncMessage.Ping.make({ requestId: 'ping' })), encodeOutgoingMessage(SyncMessage.Pong.make({ requestId: 'ping' }))));
                this.initializeStorage(storage);
                return new Response(null, {
                    status: 101,
                    webSocket: client,
                });
            }
            console.error('Invalid path', request.url);
            return new Response('Invalid path', {
                status: 400,
                statusText: 'Bad Request',
            });
        }).pipe(Effect.tapCauseLogPretty, Effect.catchAllCause((cause) => Effect.succeed(new Response('Error', { status: 500, statusText: cause.toString() }))), Effect.withSpan('@livestore/sync-cf:durable-object:fetch'), this.runEffectAsPromise);
        /**
         * Handles HTTP RPC calls
         *
         * Requires the `enable_request_signal` compatibility flag to properly support `pull` streaming responses
         */
        handleHttp = (request) => createHttpRpcHandler({
            ctx: this.ctx,
            makeStorage: (storeId) => {
                // ensure storage is initialized
                this.getProps({ storeId });
                return makeStorage(this.ctx, this.env, storeId);
            },
            doOptions: options,
            pushSemaphore: this.pushSemaphore,
            rpcSubscriptions: this.rpcSubscriptions,
            currentHeadRef: this.currentHeadRef,
            request,
        }).pipe(Effect.withSpan('@livestore/sync-cf:durable-object:handleHttp'));
        /**
         * Handles DO <-> DO RPC calls
         */
        async rpc(payload) {
            return createDoRpcHandler({
                ctx: this.ctx,
                env: this.env,
                doOptions: options,
                pushSemaphore: this.pushSemaphore,
                rpcSubscriptions: this.rpcSubscriptions,
                currentHeadRef: this.currentHeadRef,
                payload,
                ensureProps: (storeId) => this.getProps({ storeId }),
            }).pipe(Effect.withSpan('@livestore/sync-cf:durable-object:rpc'), this.runEffectAsPromise);
        }
        // #region WebSocket transport
        webSocketMessage = (ws, message) => {
            const decodedMessageRes = Schema.decodeUnknownEither(Schema.parseJson(SyncMessage.ClientToBackendMessage))(message);
            if (decodedMessageRes._tag === 'Left') {
                Effect.logError('Invalid message received', { message }).pipe(Effect.provide(Logger.prettyWithThread('durable-object')), Effect.runSync);
                return;
            }
            return handleWebSocketMessage({
                message: decodedMessageRes.right,
                currentHeadRef: this.currentHeadRef,
                rpcSubscriptions: this.rpcSubscriptions,
                pushSemaphore: this.pushSemaphore,
                options,
                ctx: this.ctx,
                ws,
                env: this.env,
            }).pipe(this.runEffectAsPromise);
        };
        webSocketClose = async (ws, code, _reason, _wasClean) => {
            // If the client closes the connection, the runtime will invoke the webSocketClose() handler.
            // Code 1006 is reserved and cannot be used by applications, so use 1000 (Normal Closure) instead
            const closeCode = code === 1006 ? 1000 : code;
            ws.close(closeCode, 'Durable Object is closing WebSocket');
        };
        // #endregion
        initializeStorage = (storage) => {
            {
                const colSpec = State.SQLite.makeColumnSpec(eventlogTable.sqliteDef.ast);
                this.env.DB.exec(`CREATE TABLE IF NOT EXISTS ${storage.dbName} (${colSpec}) strict`);
            }
            {
                const colSpec = State.SQLite.makeColumnSpec(contextTable.sqliteDef.ast);
                this.ctx.storage.sql.exec(`CREATE TABLE IF NOT EXISTS ${contextTable.sqliteDef.name} (${colSpec}) strict`);
            }
        };
        getProps = (request) => {
            if (this.props !== undefined) {
                return this.props;
            }
            const getStoreId = (request) => {
                if (Predicate.hasProperty(request, 'url')) {
                    const url = new URL(request.url);
                    return (url.searchParams.get('storeId') ?? shouldNeverHappen(`No storeId provided in request URL search params`));
                }
                return request.storeId;
            };
            const storeId = getStoreId(request);
            const storage = makeStorage(this.ctx, this.env, storeId);
            this.initializeStorage(storage);
            const props = { storeId, currentHead: EventSequenceNumber.ROOT.global };
            this.props = props;
            this.ctx.storage.sql.exec(`INSERT OR REPLACE INTO ${contextTable.sqliteDef.name} (storeId, currentHead) VALUES (?, ?)`, props.storeId, props.currentHead);
            return props;
        };
        runEffectAsPromise = (effect) => effect.pipe(Effect.tapCauseLogPretty, Logger.withMinimumLogLevel(LogLevel.Debug), Effect.provide(Logger.prettyWithThread('SyncDo')), Effect.scoped, Effect.runPromise);
    };
};
//# sourceMappingURL=durable-object.js.map
import { Rpc, RpcGroup, Schema } from '@livestore/utils/effect';
import * as SyncMessage from './sync-message-types.ts';
declare const SyncDoRpc_base: RpcGroup.RpcGroup<Rpc.Rpc<"SyncDoRpc.Pull", Schema.Struct<{
    /**
     * While the storeId is already implied by the durable object, we still need the explicit storeId
     * since a DO doesn't know its own id.name value. ðŸ« 
     * https://community.cloudflare.com/t/how-can-i-get-the-name-of-a-durable-object-from-itself/505961/8
     */
    storeId: typeof Schema.String;
    /** Needed for various reasons (e.g. auth) */
    payload: Schema.optional<Schema.Schema<Schema.JsonValue, Schema.JsonValue, never>>;
    /** Omitting the cursor will start from the beginning */
    cursor: Schema.optional<Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>>;
    /** Whether to keep the pull stream alive and wait for more events */
    rpcContext: Schema.optional<Schema.Struct<{
        callerContext: Schema.Struct<{
            bindingName: typeof Schema.String;
            durableObjectId: typeof Schema.String;
        }>;
    }>>;
}>, import("@effect/rpc/RpcSchema").Stream<Schema.Struct<{
    batch: Schema.Array$<Schema.Struct<{
        eventEncoded: Schema.Struct<{
            name: typeof Schema.String;
            args: typeof Schema.Any;
            seqNum: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
            parentSeqNum: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
            clientId: typeof Schema.String;
            sessionId: typeof Schema.String;
        }>;
        metadata: Schema.Option<Schema.Struct<{
            _tag: Schema.tag<"SyncMessage.SyncMetadata">;
        } & {
            createdAt: typeof Schema.String;
        }>>;
    }>>;
    pageInfo: Schema.Union<[Schema.TaggedStruct<"MoreUnknown", {}>, Schema.TaggedStruct<"MoreKnown", {
        remaining: typeof Schema.Number;
    }>, Schema.TaggedStruct<"NoMore", {}>]>;
    rpcRequestId: typeof Schema.String;
}>, typeof SyncMessage.SyncError>, typeof Schema.Never, never> | Rpc.Rpc<"SyncDoRpc.Push", Schema.Struct<{
    /**
     * While the storeId is already implied by the durable object, we still need the explicit storeId
     * since a DO doesn't know its own id.name value. ðŸ« 
     * https://community.cloudflare.com/t/how-can-i-get-the-name-of-a-durable-object-from-itself/505961/8
     */
    storeId: typeof Schema.String;
    /** Needed for various reasons (e.g. auth) */
    payload: Schema.optional<Schema.Schema<Schema.JsonValue, Schema.JsonValue, never>>;
    batch: Schema.Array$<Schema.Struct<{
        name: typeof Schema.String;
        args: typeof Schema.Any;
        seqNum: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        parentSeqNum: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        clientId: typeof Schema.String;
        sessionId: typeof Schema.String;
    }>>;
}>, Schema.Struct<{}>, typeof SyncMessage.SyncError, never> | Rpc.Rpc<"SyncDoRpc.Ping", Schema.Struct<{
    /**
     * While the storeId is already implied by the durable object, we still need the explicit storeId
     * since a DO doesn't know its own id.name value. ðŸ« 
     * https://community.cloudflare.com/t/how-can-i-get-the-name-of-a-durable-object-from-itself/505961/8
     */
    storeId: typeof Schema.String;
    /** Needed for various reasons (e.g. auth) */
    payload: Schema.optional<Schema.Schema<Schema.JsonValue, Schema.JsonValue, never>>;
}>, typeof Schema.Void, typeof Schema.Never, never>>;
export declare class SyncDoRpc extends SyncDoRpc_base {
}
export {};
//# sourceMappingURL=do-rpc-schema.d.ts.map
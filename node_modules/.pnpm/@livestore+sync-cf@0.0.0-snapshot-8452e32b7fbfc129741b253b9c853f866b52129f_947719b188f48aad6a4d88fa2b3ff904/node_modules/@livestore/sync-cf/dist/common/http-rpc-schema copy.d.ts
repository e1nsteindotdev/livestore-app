import { Rpc, RpcGroup, Schema } from '@livestore/utils/effect';
import * as SyncMessage from './sync-message-types.ts';
declare const SyncHttpRpc_base: RpcGroup.RpcGroup<Rpc.Rpc<"SyncHttpRpc.Pull", Schema.Struct<{
    _tag: Schema.tag<"SyncMessage.PullRequest">;
    requestId: typeof Schema.String;
    cursor: Schema.optional<Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>>;
    storeId: typeof Schema.String;
    payload: Schema.optional<Schema.Schema<Schema.JsonValue, Schema.JsonValue, never>>;
}>, import("@effect/rpc/RpcSchema").Stream<Schema.Struct<{
    _tag: Schema.tag<"SyncMessage.PullResponse">;
} & {
    batch: Schema.Array$<Schema.Struct<{
        eventEncoded: Schema.Struct<{
            name: typeof Schema.String;
            args: typeof Schema.Any;
            seqNum: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
            parentSeqNum: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
            clientId: typeof Schema.String;
            sessionId: typeof Schema.String;
        }>;
        metadata: Schema.Option<Schema.Struct<{
            _tag: Schema.tag<"SyncMessage.SyncMetadata">;
        } & {
            createdAt: typeof Schema.String;
        }>>;
    }>>;
    requestId: Schema.Struct<{
        context: Schema.Literal<["pull", "push"]>;
        requestId: typeof Schema.String;
    }>;
    remaining: typeof Schema.Number;
}>, typeof SyncMessage.SyncError>, typeof Schema.Never, never> | Rpc.Rpc<"SyncHttpRpc.Push", Schema.Struct<{
    _tag: Schema.tag<"SyncMessage.PushRequest">;
    requestId: typeof Schema.String;
    batch: Schema.Array$<Schema.Struct<{
        name: typeof Schema.String;
        args: typeof Schema.Any;
        seqNum: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        parentSeqNum: Schema.BrandSchema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        clientId: typeof Schema.String;
        sessionId: typeof Schema.String;
    }>>;
    storeId: typeof Schema.String;
    payload: Schema.optional<Schema.Schema<Schema.JsonValue, Schema.JsonValue, never>>;
}>, Schema.Struct<{
    _tag: Schema.tag<"SyncMessage.PushAck">;
} & {
    requestId: typeof Schema.String;
}>, typeof SyncMessage.SyncError, never> | Rpc.Rpc<"SyncHttpRpc.Ping", Schema.Struct<{
    storeId: typeof Schema.String;
    payload: Schema.optional<Schema.Schema<Schema.JsonValue, Schema.JsonValue, never>>;
    requestId: typeof Schema.String;
}>, Schema.Struct<{
    _tag: Schema.tag<"SyncMessage.Pong">;
} & {
    requestId: typeof Schema.String;
}>, typeof SyncMessage.SyncError, never>>;
/**
 * HTTP RPC Schema for LiveStore CF Sync Provider
 *
 * This defines the RPC endpoints available over HTTP transport.
 * Unlike WebSocket transport which maintains persistent connections,
 * HTTP transport uses request/response patterns for each operation.
 */
export declare class SyncHttpRpc extends SyncHttpRpc_base {
}
export {};
//# sourceMappingURL=http-rpc-schema%20copy.d.ts.map
// import path from 'node:path'
import { UnexpectedError } from '@livestore/common';
import { Effect } from '@livestore/utils/effect';
import { makeInMemoryDb } from "../in-memory-vfs.js";
import { makeSqliteDb } from "../make-sqlite-db.js";
import { CloudflareSqlVFS } from "./CloudflareSqlVFS.js";
export { BlockManager } from "./BlockManager.js";
export { CloudflareSqlVFS } from "./CloudflareSqlVFS.js";
export { CloudflareWorkerVFS } from "./CloudflareWorkerVFS.js";
export const sqliteDbFactory = ({ sqlite3 }) => (input) => Effect.gen(function* () {
    if (input._tag === 'in-memory') {
        const { dbPointer, vfs } = makeInMemoryDb(sqlite3);
        return makeSqliteDb({
            sqlite3,
            metadata: {
                _tag: 'in-memory',
                vfs,
                dbPointer,
                persistenceInfo: { fileName: ':memory:' },
                deleteDb: () => { },
                configureDb: input.configureDb ?? (() => { }),
            },
        });
    }
    const { dbPointer, vfs } = yield* makeCloudflareFsDb({
        sqlite3,
        fileName: input.fileName,
        // directory: input.directory,
        storage: input.storage,
    });
    // const filePath = path.join(input.directory, input.fileName)
    // const filePath = `${input.directory}/${input.fileName}`
    return makeSqliteDb({
        sqlite3,
        metadata: {
            _tag: 'storage',
            vfs,
            dbPointer,
            persistenceInfo: { fileName: input.fileName },
            // deleteDb: () => vfs.deleteDb(filePath),
            // TODO: implement deleteDb
            deleteDb: () => { },
            configureDb: input.configureDb ?? (() => { }),
        },
    });
});
const makeCloudflareFsDb = ({ sqlite3, fileName, 
// directory,
storage, }) => Effect.gen(function* () {
    // NOTE to keep the filePath short, we use the directory name in the vfs name
    // If this is becoming a problem, we can use a hashed version of the directory name
    const vfsName = `cf-do-sqlite-${fileName}`;
    if (sqlite3.vfs_registered.has(vfsName) === false) {
        // TODO refactor with Effect FileSystem instead of using `node:fs` directly inside of CloudflareWorkerVFS
        // const nodeFsVfs = new CloudflareWorkerVFS(vfsName, storage, (sqlite3 as any).module)
        const nodeFsVfs = new CloudflareSqlVFS(vfsName, storage.sql, sqlite3.module);
        // Initialize the VFS schema before registering it
        const isReady = yield* Effect.promise(() => nodeFsVfs.isReady());
        if (!isReady) {
            throw new Error(`Failed to initialize CloudflareSqlVFS for ${vfsName}`);
        }
        // @ts-expect-error TODO fix types
        sqlite3.vfs_register(nodeFsVfs, false);
    }
    // yield* fs.makeDirectory(directory, { recursive: true })
    const FILE_NAME_MAX_LENGTH = 56;
    if (fileName.length > FILE_NAME_MAX_LENGTH) {
        throw new Error(`File name ${fileName} is too long. Maximum length is ${FILE_NAME_MAX_LENGTH} characters.`);
    }
    // NOTE SQLite will return a "disk I/O error" if the file path is too long.
    const dbPointer = sqlite3.open_v2Sync(fileName, undefined, vfsName);
    return { dbPointer, vfs: {} };
}).pipe(UnexpectedError.mapToUnexpectedError);
//# sourceMappingURL=mod.js.map
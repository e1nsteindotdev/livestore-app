import { constVoid, Effect, Layer, Mailbox, RpcMessage, RpcSerialization, RpcServer, Stream, } from '@livestore/utils/effect';
export const layerRpcServerWebsocket = (args) => Layer.scoped(RpcServer.Protocol, makeSocketProtocol(args));
const makeSocketProtocol = ({ incomingQueue, send: writeRaw }) => Effect.gen(function* () {
    const serialization = yield* RpcSerialization.RpcSerialization;
    const disconnects = yield* Mailbox.make();
    let writeRequest;
    const parser = serialization.unsafeMake();
    const id = 0;
    const write = (response) => {
        try {
            const encoded = parser.encode(response);
            if (encoded === undefined) {
                return Effect.void;
            }
            return Effect.orDie(writeRaw(encoded));
        }
        catch (cause) {
            return Effect.orDie(writeRaw(parser.encode(RpcMessage.ResponseDefectEncoded(cause))));
        }
    };
    yield* Mailbox.toStream(incomingQueue).pipe(Stream.tap((data) => {
        try {
            const decoded = parser.decode(data);
            if (decoded.length === 0)
                return Effect.void;
            let i = 0;
            return Effect.whileLoop({
                while: () => i < decoded.length,
                body: () => writeRequest(id, decoded[i++]),
                step: constVoid,
            });
        }
        catch (cause) {
            return Effect.orDie(writeRaw(parser.encode(RpcMessage.ResponseDefectEncoded(cause))));
        }
    }), Stream.runDrain, Effect.tapCauseLogPretty, Effect.forkScoped);
    const protocol = yield* RpcServer.Protocol.make((writeRequest_) => {
        writeRequest = writeRequest_;
        return Effect.succeed({
            disconnects,
            send: (_clientId, response) => Effect.orDie(write(response)),
            end(_clientId) {
                return Effect.void;
            },
            clientIds: Effect.sync(() => [id]),
            initialMessage: Effect.succeedNone,
            supportsAck: true,
            supportsTransferables: false,
            supportsSpanPropagation: true,
        });
    });
    return protocol;
});
//# sourceMappingURL=ws-rpc-server.js.map
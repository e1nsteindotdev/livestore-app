import { Effect, type Layer, type NonEmptyArray, Rpc, type RpcGroup, type RpcMessage } from '@livestore/utils/effect';
import type * as CfTypes from '../cf-types.ts';
export interface ClientDoWithRpcCallback {
    __DURABLE_OBJECT_BRAND: never;
    syncUpdateRpc: (payload: RpcMessage.ResponseChunkEncoded) => Promise<void>;
}
/**
 * Construct a Durable Object RPC handler from an `RpcGroup`.
 * This is the DO equivalent of `RpcServer.toWebHandler`.
 */
export declare const toDurableObjectHandler: <Rpcs extends Rpc.Any, LE>(group: RpcGroup.RpcGroup<Rpcs>, options: {
    readonly layer: Layer.Layer<Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>, LE>;
    readonly disableTracing?: boolean | undefined;
    readonly spanPrefix?: string | undefined;
    readonly spanAttributes?: Record<string, unknown> | undefined;
}) => ((serializedPayload: Uint8Array<ArrayBuffer>) => Effect.Effect<Uint8Array<ArrayBuffer> | CfTypes.ReadableStream>);
/** Out-of-band RPC stream response emission back to the caller DO */
export declare const emitStreamResponse: ({ callerContext, env, requestId, values, }: {
    env: Record<string, any>;
    callerContext: {
        bindingName: string;
        durableObjectId: string;
    };
    requestId: string;
    values: NonEmptyArray<any>;
}) => Effect.Effect<void, import("effect/Cause").UnknownException, never>;
//# sourceMappingURL=server.d.ts.map
// import { InvalidPullError, InvalidPushError, SyncBackend } from '@livestore/common'
// import { layerProtocolDurableObject } from '@livestore/common-cf'
// import * as CfSyncBackend from '@livestore/sync-cf/cf-worker'
// import {
//   Effect,
//   Layer,
//   Option,
//   Queue,
//   RpcClient,
//   RpcSerialization,
//   Stream,
//   SubscriptionRef,
// } from '@livestore/utils/effect'
// import { nanoid } from '@livestore/utils/nanoid'
// import type * as CfWorker from './cf-types.ts'
export {};
// // Extended RPC interface for sync backend stub
// interface SyncBackendRpcStub extends CfWorker.DurableObjectStub, CfSyncBackend.SyncBackendRpcInterface {}
// export type MakeRpcSyncBackendOptions = {
//   /** Sync backend Durable Object stub for RPC calls */
//   syncBackendStub: SyncBackendRpcStub
//   /** This client's ID for subscription callbacks */
//   clientId: string
//   /** This client's Durable Object ID for subscription callbacks */
//   durableObjectId: string
// }
// /**
//  * RPC-based sync client that uses direct Durable Object RPC calls
//  * instead of WebSocket connections
//  */
// export const makeRpcSyncProviderClient =
//   ({
//     syncBackendStub,
//     clientId,
//     durableObjectId,
//   }: MakeRpcSyncBackendOptions): SyncBackend.SyncBackendConstructor<{ createdAt: string }> =>
//   ({ storeId, payload }) =>
//     Effect.gen(function* () {
//       const isConnected = yield* SubscriptionRef.make(true)
//       // PubSub for incoming messages from RPC callbacks
//       const ProtocolLive = layerProtocolDurableObject((payload) => syncBackendStub.rpc(payload)).pipe(
//         Layer.provide(RpcSerialization.layerJson),
//       )
//       const rpcClient = yield* RpcClient.make(CfSyncBackend.SyncDoRpc).pipe(Effect.provide(ProtocolLive))
//       // Nothing to do here
//       const connect = Effect.void
//       const pull: SyncBackend.SyncBackend<{ createdAt: string }>['pull'] = (args) =>
//         Effect.gen(function* () {
//           const initialCursor = Option.getOrUndefined(args)?.cursor.global
//           const cursorRef = { current: initialCursor }
//           // const incomingMessages = yield* PubSub.unbounded<SyncBackend.PullResItem>()
//           const messagesQueue =
//             yield* Queue.unbounded<SyncBackend.PullResItem<{ createdAt: string }>>().pipe(
//               // Effect.acquireRelease(Queue.shutdown),
//             )
//           const requestId = nanoid()
//           const runPull = Effect.gen(function* () {
//             yield* rpcClient.SyncDoRpc.Pull({
//               requestId,
//               cursor: cursorRef.current,
//               storeId,
//             }).pipe(
//               Stream.mapError((cause) => new InvalidPullError({ cause })),
//               Stream.map((_) => ({ batch: _.batch, remaining: _.remaining })),
//               Stream.tap((msg) => Effect.log(`RPC pulled ${msg.batch.length} events from sync provider`)),
//               Stream.tap((msg) =>
//                 Effect.sync(() => {
//                   if (msg.batch.length > 0) {
//                     cursorRef.current = msg.batch.at(-1)!.eventEncoded.seqNum
//                   }
//                 }),
//               ),
//               Stream.withSpan('rpc-sync-client:pull'),
//               Stream.tapErrorCause((cause) => Effect.logError(cause)),
//               Stream.tapChunk((msg) => Queue.offerAll(messagesQueue, msg)),
//               Stream.runDrain,
//             )
//           })
//           yield* rpcClient.SyncDoRpc.Subscribe({ clientId, storeId, requestId, durableObjectId, payload }).pipe(
//             // yield* Stream.succeed('ok').pipe(
//             //   Stream.repeat(Schedule.spaced(1000)),
//             Stream.tapLogWithLabel('rpc-sync-client:subscribe'),
//             Stream.tap(() => runPull),
//             Stream.onDone(() => Effect.log('rpc-sync-client:subscribe done')),
//             Stream.onEnd(Effect.log('rpc-sync-client:subscribe end')),
//             Stream.runDrain,
//             Effect.tapCauseLogPretty,
//             Effect.tap(() => Effect.log('rpc-sync-client:subscribe tap')),
//             // Effect.forkScoped,
//             Effect.fork,
//             Effect.tapCauseLogPretty,
//           )
//           // setInterval(() => {
//           //   console.log('runPull')
//           // }, 1000)
//           yield* runPull
//           yield* Effect.addFinalizerLog('rpc-sync-client:finalizer')
//           // console.log('client do pull', args)
//           // return Stream.empty
//           return Stream.fromQueue(messagesQueue)
//         }).pipe(Stream.unwrapScoped)
//       const push: SyncBackend.SyncBackend<{ createdAt: string }>['push'] = (batch) =>
//         Effect.gen(function* () {
//           yield* Effect.log(`RPC Sync Client: Pushing ${batch.length} events`)
//           if (batch.length === 0) {
//             return
//           }
//           yield* rpcClient.SyncDoRpc.Push({ requestId: nanoid(), batch, storeId }).pipe(
//             Effect.tapCauseLogPretty,
//             Effect.mapError((cause) => new InvalidPushError({ reason: { _tag: 'Unexpected', cause } })),
//             // Effect.orDie,
//           )
//           yield* Effect.log(`RPC Sync Client: Successfully pushed ${batch.length} events`)
//           // console.log(`RPC Sync Client: Pushing ${batch.length} events`)
//           // const pushReq = WSMessage.PushReq.make({
//           //   requestId: `rpc-push-${Date.now()}`,
//           //   batch,
//           // })
//           // // Direct RPC call to sync backend
//           // // yield* Effect.tryPromise({
//           // //   try: () => syncBackendStub.push(pushReq),
//           // //   catch: (error) => new InvalidPushError({ reason: { _tag: 'Unexpected', message: String(error) } }),
//           // // })
//           // console.log(`RPC Sync Client: Successfully pushed ${batch.length} events`)
//         }).pipe(Effect.withSpan('rpc-sync-client:push'))
//       return SyncBackend.of({
//         connect,
//         isConnected,
//         pull,
//         push,
//         metadata: {
//           name: 'rpc-sync-client',
//           description: 'Cloudflare Durable Object RPC Sync Client',
//           protocol: 'rpc',
//           storeId,
//         },
//       })
//     }).pipe(Effect.withSpan('makeRpcSyncProviderClient'))
//# sourceMappingURL=sync-provider-rpc-client.js.map
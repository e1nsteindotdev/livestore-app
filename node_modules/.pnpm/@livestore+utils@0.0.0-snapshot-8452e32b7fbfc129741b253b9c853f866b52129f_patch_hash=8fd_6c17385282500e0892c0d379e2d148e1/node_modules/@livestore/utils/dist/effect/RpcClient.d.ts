export * from '@effect/rpc/RpcClient';
import { Socket } from '@effect/platform';
import { RpcClient, RpcSerialization } from '@effect/rpc';
import { Protocol } from '@effect/rpc/RpcClient';
import { Effect, Layer, Schedule, type Scope } from 'effect';
import * as SubscriptionRef from './SubscriptionRef.ts';
export declare const layerProtocolSocketWithIsConnected: (options: {
    readonly url: string;
    readonly retryTransientErrors?: Schedule.Schedule<unknown> | undefined;
    readonly isConnected: SubscriptionRef.SubscriptionRef<boolean>;
    readonly pingSchedule?: Schedule.Schedule<unknown> | undefined;
}) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | Socket.Socket>;
export declare const makeProtocolSocketWithIsConnected: (options: {
    readonly url: string;
    readonly retryTransientErrors?: Schedule.Schedule<unknown> | undefined;
    readonly isConnected: SubscriptionRef.SubscriptionRef<boolean>;
    readonly pingSchedule?: Schedule.Schedule<unknown> | undefined;
}) => Effect.Effect<Protocol["Type"], never, Scope.Scope | RpcSerialization.RpcSerialization | Socket.Socket>;
export declare const SocketPinger: Effect.Effect<{
    readonly timeout: Effect.Effect<void, never, never>;
    readonly reset: () => void;
    readonly onPong: () => void;
    readonly ping: Effect.Effect<void, never, never>;
}, never, RpcClient.Protocol>;
export type SocketPinger = Effect.Effect.Success<ReturnType<typeof makePinger>>;
declare const makePinger: <A, E, R>(writePing: Effect.Effect<A, E, R>, pingSchedule?: Schedule.Schedule<unknown, unknown, never> | undefined) => Effect.Effect<{
    readonly timeout: Effect.Effect<void, never, never>;
    readonly reset: () => void;
    readonly onPong: () => void;
    readonly ping: Effect.Effect<void, never, never>;
}, never, Scope.Scope | R>;
//# sourceMappingURL=RpcClient.d.ts.map
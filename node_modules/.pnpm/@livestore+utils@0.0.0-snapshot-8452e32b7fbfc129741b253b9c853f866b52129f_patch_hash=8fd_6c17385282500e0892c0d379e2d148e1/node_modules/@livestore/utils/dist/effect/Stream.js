/** biome-ignore-all lint/suspicious/useIterableCallbackReturn: Biome bug */
export * from 'effect/Stream';
import { Chunk, Effect, Option, pipe, Ref, Stream } from 'effect';
import { dual } from 'effect/Function';
export const tapLog = (stream) => tapChunk(Effect.forEach((_) => Effect.succeed(console.log(_))))(stream);
export const tapSync = (tapFn) => (stream) => Stream.tap(stream, (a) => Effect.sync(() => tapFn(a)));
export const tapLogWithLabel = (label) => (stream) => tapChunk(Effect.forEach((_) => Effect.succeed(console.log(label, _))))(stream);
export const tapChunk = (f) => (self) => Stream.mapChunksEffect(self, (chunks) => pipe(f(chunks), Effect.map(() => chunks)));
const isIdentity = (a1, a2) => a1 === a2;
export const skipRepeated = (isEqual = isIdentity) => (stream) => skipRepeated_(stream, isEqual);
export const skipRepeated_ = (stream, isEqual = isIdentity) => pipe(Ref.make(Option.none()), Stream.fromEffect, Stream.flatMap((ref) => pipe(stream, Stream.filterEffect((el) => pipe(Ref.get(ref), Effect.flatMap((prevEl) => {
    if (prevEl._tag === 'None' || isEqual(prevEl.value, el) === false) {
        return pipe(Ref.set(ref, Option.some(el)), Effect.map(() => true));
    }
    else {
        return Effect.succeed(false);
    }
}))))));
/**
 * Returns the first element of the stream or `None` if the stream is empty.
 * It's different than `Stream.runHead` which runs the stream to completion.
 * */
export const runFirst = (stream) => stream.pipe(Stream.take(1), Stream.runCollect, Effect.map(Chunk.head));
/**
 * Returns the first element of the stream or throws a `NoSuchElementException` if the stream is empty.
 * It's different than `Stream.runHead` which runs the stream to completion.
 * */
export const runFirstUnsafe = (stream) => runFirst(stream).pipe(Effect.flatten);
export const runCollectReadonlyArray = (stream) => stream.pipe(Stream.runCollect, Effect.map(Chunk.toReadonlyArray));
/**
 * Concatenates two streams where the second stream has access to the last element
 * of the first stream as an `Option`. If the first stream is empty, the callback
 * receives `Option.none()`.
 *
 * @param stream - The first stream to consume
 * @param getStream2 - Function that receives the last element from the first stream
 *   and returns the second stream to concatenate
 * @returns A new stream containing all elements from both streams
 *
 * @example
 * ```ts
 * // Direct usage
 * const result = concatWithLastElement(
 *   Stream.make(1, 2, 3),
 *   lastElement => lastElement.pipe(
 *     Option.match({
 *       onNone: () => Stream.make('empty'),
 *       onSome: last => Stream.make(`last-was-${last}`)
 *     })
 *   )
 * )
 *
 * // Piped usage
 * const result = Stream.make(1, 2, 3).pipe(
 *   concatWithLastElement(lastElement =>
 *     Stream.make(lastElement.pipe(Option.getOrElse(() => 0)) * 10)
 *   )
 * )
 * ```
 */
export const concatWithLastElement = dual(2, (stream1, getStream2) => pipe(Ref.make(Option.none()), Stream.fromEffect, Stream.flatMap((lastRef) => pipe(stream1, Stream.tap((value) => Ref.set(lastRef, Option.some(value))), Stream.concat(pipe(Ref.get(lastRef), Effect.map(getStream2), Stream.unwrap))))));
/**
 * Emits a default value if the stream is empty, otherwise passes through all elements.
 * Uses `concatWithLastElement` internally to detect if the stream was empty.
 *
 * @param fallbackValue - The value to emit if the stream is empty
 * @returns A dual function that can be used in pipe or direct call
 *
 * @example
 * ```ts
 * // Direct usage
 * const result = emitIfEmpty(Stream.empty, 'default')
 * // Emits: 'default'
 *
 * // Piped usage
 * const result = Stream.make(1, 2, 3).pipe(emitIfEmpty('fallback'))
 * // Emits: 1, 2, 3
 *
 * const empty = Stream.empty.pipe(emitIfEmpty('fallback'))
 * // Emits: 'fallback'
 * ```
 */
export const emitIfEmpty = dual(2, (stream, fallbackValue) => concatWithLastElement(stream, (lastElement) => lastElement._tag === 'None' ? Stream.make(fallbackValue) : Stream.empty));
//# sourceMappingURL=Stream.js.map
/** biome-ignore-all lint/suspicious/useIterableCallbackReturn: Biome bug */
export * from 'effect/Stream';
import { type Cause, Chunk, Effect, Option, Stream } from 'effect';
export declare const tapLog: <R, E, A>(stream: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>;
export declare const tapSync: <A>(tapFn: (a: A) => unknown) => <R, E>(stream: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>;
export declare const tapLogWithLabel: (label: string) => <R, E, A>(stream: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>;
export declare const tapChunk: <R1, E1, A, Z>(f: (a: Chunk.Chunk<A>) => Effect.Effect<Z, E1, R1>) => <R, E>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E1 | E, R1 | R>;
export declare const skipRepeated: <A>(isEqual?: (prevEl: A, newEl: A) => boolean) => <R, E>(stream: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>;
export declare const skipRepeated_: <R, E, A>(stream: Stream.Stream<A, E, R>, isEqual?: (prevEl: A, newEl: A) => boolean) => Stream.Stream<A, E, R>;
/**
 * Returns the first element of the stream or `None` if the stream is empty.
 * It's different than `Stream.runHead` which runs the stream to completion.
 * */
export declare const runFirst: <A, E, R>(stream: Stream.Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>;
/**
 * Returns the first element of the stream or throws a `NoSuchElementException` if the stream is empty.
 * It's different than `Stream.runHead` which runs the stream to completion.
 * */
export declare const runFirstUnsafe: <A, E, R>(stream: Stream.Stream<A, E, R>) => Effect.Effect<A, Cause.NoSuchElementException | E, R>;
export declare const runCollectReadonlyArray: <A, E, R>(stream: Stream.Stream<A, E, R>) => Effect.Effect<readonly A[], E, R>;
/**
 * Concatenates two streams where the second stream has access to the last element
 * of the first stream as an `Option`. If the first stream is empty, the callback
 * receives `Option.none()`.
 *
 * @param stream - The first stream to consume
 * @param getStream2 - Function that receives the last element from the first stream
 *   and returns the second stream to concatenate
 * @returns A new stream containing all elements from both streams
 *
 * @example
 * ```ts
 * // Direct usage
 * const result = concatWithLastElement(
 *   Stream.make(1, 2, 3),
 *   lastElement => lastElement.pipe(
 *     Option.match({
 *       onNone: () => Stream.make('empty'),
 *       onSome: last => Stream.make(`last-was-${last}`)
 *     })
 *   )
 * )
 *
 * // Piped usage
 * const result = Stream.make(1, 2, 3).pipe(
 *   concatWithLastElement(lastElement =>
 *     Stream.make(lastElement.pipe(Option.getOrElse(() => 0)) * 10)
 *   )
 * )
 * ```
 */
export declare const concatWithLastElement: {
    <A1, A2, E2, R2>(getStream2: (lastElement: Option.Option<A1>) => Stream.Stream<A2, E2, R2>): <E1, R1>(stream: Stream.Stream<A1, E1, R1>) => Stream.Stream<A1 | A2, E1 | E2, R1 | R2>;
    <A1, E1, R1, A2, E2, R2>(stream: Stream.Stream<A1, E1, R1>, getStream2: (lastElement: Option.Option<A1>) => Stream.Stream<A2, E2, R2>): Stream.Stream<A1 | A2, E1 | E2, R1 | R2>;
};
/**
 * Emits a default value if the stream is empty, otherwise passes through all elements.
 * Uses `concatWithLastElement` internally to detect if the stream was empty.
 *
 * @param fallbackValue - The value to emit if the stream is empty
 * @returns A dual function that can be used in pipe or direct call
 *
 * @example
 * ```ts
 * // Direct usage
 * const result = emitIfEmpty(Stream.empty, 'default')
 * // Emits: 'default'
 *
 * // Piped usage
 * const result = Stream.make(1, 2, 3).pipe(emitIfEmpty('fallback'))
 * // Emits: 1, 2, 3
 *
 * const empty = Stream.empty.pipe(emitIfEmpty('fallback'))
 * // Emits: 'fallback'
 * ```
 */
export declare const emitIfEmpty: {
    <A>(fallbackValue: A): <E, R>(stream: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>;
    <A, E, R>(stream: Stream.Stream<A, E, R>, fallbackValue: A): Stream.Stream<A, E, R>;
};
//# sourceMappingURL=Stream.d.ts.map
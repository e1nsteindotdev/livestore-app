"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unsafeServiceName = exports.unknownToAttributeValue = exports.make = exports.fromConfig = exports.entriesToAttributes = void 0;
var Arr = _interopRequireWildcard(require("effect/Array"));
var Config = _interopRequireWildcard(require("effect/Config"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Inspectable = _interopRequireWildcard(require("effect/Inspectable"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

const ATTR_SERVICE_NAME = "service.name";
const ATTR_SERVICE_VERSION = "service.version";
/**
 * @since 1.0.0
 * @category Constructors
 */
const make = options => {
  const resourceAttributes = options.attributes ? entriesToAttributes(Object.entries(options.attributes)) : [];
  resourceAttributes.push({
    key: ATTR_SERVICE_NAME,
    value: {
      stringValue: options.serviceName
    }
  });
  if (options.serviceVersion) {
    resourceAttributes.push({
      key: ATTR_SERVICE_VERSION,
      value: {
        stringValue: options.serviceVersion
      }
    });
  }
  return {
    attributes: resourceAttributes,
    droppedAttributesCount: 0
  };
};
/**
 * @since 1.0.0
 * @category Constructors
 */
exports.make = make;
const fromConfig = exports.fromConfig = /*#__PURE__*/Effect.fnUntraced(function* (options) {
  const attributes = yield* Config.string("OTEL_RESOURCE_ATTRIBUTES").pipe(Config.map(s => {
    const attrs = s.split(",");
    return Arr.reduce(attrs, {}, (acc, attr) => {
      const parts = attr.split("=");
      if (parts.length !== 2) {
        return acc;
      }
      acc[parts[0].trim()] = parts[1].trim();
      return acc;
    });
  }), Config.withDefault({}), Effect.map(envAttrs => ({
    ...envAttrs,
    ...options?.attributes
  })));
  const serviceName = options?.serviceName ?? attributes[ATTR_SERVICE_NAME] ?? (yield* Config.string("OTEL_SERVICE_NAME"));
  const serviceVersion = options?.serviceVersion ?? attributes[ATTR_SERVICE_VERSION] ?? (yield* Config.string("OTEL_SERVICE_VERSION").pipe(Config.withDefault(undefined)));
  return make({
    serviceName,
    serviceVersion,
    attributes
  });
}, Effect.orDie);
/**
 * @since 1.0.0
 * @category Attributes
 */
const unsafeServiceName = resource => {
  const serviceNameAttribute = resource.attributes.find(attr => attr.key === ATTR_SERVICE_NAME);
  if (!serviceNameAttribute || !serviceNameAttribute.value.stringValue) {
    throw new Error("Resource does not contain a service name");
  }
  return serviceNameAttribute.value.stringValue;
};
/**
 * @since 1.0.0
 * @category Attributes
 */
exports.unsafeServiceName = unsafeServiceName;
const entriesToAttributes = entries => {
  const attributes = [];
  for (const [key, value] of entries) {
    attributes.push({
      key,
      value: unknownToAttributeValue(value)
    });
  }
  return attributes;
};
/**
 * @since 1.0.0
 * @category Attributes
 */
exports.entriesToAttributes = entriesToAttributes;
const unknownToAttributeValue = value => {
  if (Array.isArray(value)) {
    return {
      arrayValue: {
        values: value.map(unknownToAttributeValue)
      }
    };
  }
  switch (typeof value) {
    case "string":
      return {
        stringValue: value
      };
    case "bigint":
      return {
        intValue: Number(value)
      };
    case "number":
      return Number.isInteger(value) ? {
        intValue: value
      } : {
        doubleValue: value
      };
    case "boolean":
      return {
        boolValue: value
      };
    default:
      return {
        stringValue: Inspectable.toStringUnknown(value)
      };
  }
};
exports.unknownToAttributeValue = unknownToAttributeValue;
//# sourceMappingURL=OtlpResource.js.map
import { Effect, Schema, Stream } from '@livestore/utils/effect';
declare const UnexpectedError_base: Schema.TaggedErrorClass<UnexpectedError, "LiveStore.UnexpectedError", {
    readonly _tag: Schema.tag<"LiveStore.UnexpectedError">;
} & {
    cause: typeof Schema.Defect;
    note: Schema.optional<typeof Schema.String>;
    payload: Schema.optional<typeof Schema.Any>;
}>;
export declare class UnexpectedError extends UnexpectedError_base {
    static mapToUnexpectedError: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, UnexpectedError, R>;
    static mapToUnexpectedErrorStream: <A, E, R>(stream: Stream.Stream<A, E, R>) => Stream.Stream<A, UnexpectedError, R>;
}
declare const SyncError_base: Schema.TaggedErrorClass<SyncError, "LiveStore.SyncError", {
    readonly _tag: Schema.tag<"LiveStore.SyncError">;
} & {
    cause: typeof Schema.Defect;
}>;
export declare class SyncError extends SyncError_base {
}
declare const MaterializerHashMismatchError_base: Schema.TaggedErrorClass<MaterializerHashMismatchError, "LiveStore.MaterializerHashMismatchError", {
    readonly _tag: Schema.tag<"LiveStore.MaterializerHashMismatchError">;
} & {
    eventName: typeof Schema.String;
    note: Schema.optionalWith<typeof Schema.String, {
        default: () => string;
    }>;
}>;
export declare class MaterializerHashMismatchError extends MaterializerHashMismatchError_base {
}
declare const IntentionalShutdownCause_base: Schema.TaggedErrorClass<IntentionalShutdownCause, "LiveStore.IntentionalShutdownCause", {
    readonly _tag: Schema.tag<"LiveStore.IntentionalShutdownCause">;
} & {
    reason: Schema.Literal<["devtools-reset", "devtools-import", "adapter-reset", "manual"]>;
}>;
export declare class IntentionalShutdownCause extends IntentionalShutdownCause_base {
}
declare const StoreInterrupted_base: Schema.TaggedErrorClass<StoreInterrupted, "LiveStore.StoreInterrupted", {
    readonly _tag: Schema.tag<"LiveStore.StoreInterrupted">;
} & {
    reason: typeof Schema.String;
}>;
export declare class StoreInterrupted extends StoreInterrupted_base {
}
declare const SqliteError_base: Schema.TaggedErrorClass<SqliteError, "LiveStore.SqliteError", {
    readonly _tag: Schema.tag<"LiveStore.SqliteError">;
} & {
    query: Schema.optional<Schema.Struct<{
        sql: typeof Schema.String;
        bindValues: Schema.Union<[Schema.Record$<typeof Schema.String, typeof Schema.Any>, Schema.Array$<typeof Schema.Any>]>;
    }>>;
    /** The SQLite result code */
    code: Schema.optional<Schema.Union<[typeof Schema.Number, typeof Schema.String]>>;
    /** The original SQLite3 error */
    cause: typeof Schema.Defect;
    note: Schema.optional<typeof Schema.String>;
}>;
export declare class SqliteError extends SqliteError_base {
}
export {};
//# sourceMappingURL=errors.d.ts.map
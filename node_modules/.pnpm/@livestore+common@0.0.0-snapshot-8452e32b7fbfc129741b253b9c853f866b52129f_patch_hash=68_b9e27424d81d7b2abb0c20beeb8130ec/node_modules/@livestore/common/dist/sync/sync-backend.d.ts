import { type Cause, type Effect, type HttpClient, Option, Schema, type Scope, type Stream, type SubscriptionRef } from '@livestore/utils/effect';
import type { UnexpectedError } from '../adapter-types.ts';
import type * as LiveStoreEvent from '../schema/LiveStoreEvent.ts';
import type { EventSequenceNumber } from '../schema/mod.ts';
import type { InvalidPullError, InvalidPushError, IsOfflineError } from './errors.ts';
/**
 * Those arguments can be used to implement multi-tenancy etc and are passed in from the store.
 */
export type MakeBackendArgs = {
    storeId: string;
    clientId: string;
    payload: Schema.JsonValue | undefined;
};
export type SyncBackendConstructor<TSyncMetadata = Schema.JsonValue> = (args: MakeBackendArgs) => Effect.Effect<SyncBackend<TSyncMetadata>, UnexpectedError, Scope.Scope | HttpClient.HttpClient>;
export type SyncBackend<TSyncMetadata = Schema.JsonValue> = {
    /**
     * Can be implemented to prepare a connection to the sync backend to speed up the first pull/push.
     */
    connect: Effect.Effect<void, IsOfflineError | UnexpectedError, Scope.Scope>;
    pull: (args: Option.Option<{
        cursor: EventSequenceNumber.GlobalEventSequenceNumber;
        /** Metadata is needed by some sync backends */
        metadata: Option.Option<TSyncMetadata>;
    }>, options?: {
        /**
         * If true, the sync backend will return a stream of events that have been pushed after the cursor.
         *
         * @default false
         */
        live?: boolean;
    }) => Stream.Stream<PullResItem<TSyncMetadata>, IsOfflineError | InvalidPullError>;
    push: (
    /**
     * Constraints for batch:
     * - Number of events: 1-100
     * - sequence numbers must be in ascending order
     * */
    batch: ReadonlyArray<LiveStoreEvent.AnyEncodedGlobal>) => Effect.Effect<void, IsOfflineError | InvalidPushError>;
    ping: Effect.Effect<void, IsOfflineError | UnexpectedError | Cause.TimeoutException>;
    isConnected: SubscriptionRef.SubscriptionRef<boolean>;
    /**
     * Metadata describing the sync backend. (Currently only used by devtools.)
     */
    metadata: {
        name: string;
        description: string;
    } & Record<string, Schema.JsonValue>;
    /** Information about the sync backend capabilities. */
    supports: {
        /**
         * Whether the sync backend supports the `hasMore` field in the pull response.
         */
        pullPageInfoKnown: boolean;
        /**
         * Whether the sync backend supports the `live` option for the pull method and thus
         * long-lived, reactive pull streams.
         */
        pullLive: boolean;
    };
};
export declare const PullResPageInfo: Schema.Union<[Schema.TaggedStruct<"MoreUnknown", {}>, Schema.TaggedStruct<"MoreKnown", {
    remaining: typeof Schema.Number;
}>, Schema.TaggedStruct<"NoMore", {}>]>;
export type PullResPageInfo = typeof PullResPageInfo.Type;
export declare const pageInfoNoMore: PullResPageInfo;
export declare const pageInfoMoreUnknown: PullResPageInfo;
export declare const pageInfoMoreKnown: (remaining: number) => PullResPageInfo;
export declare const pullResItemEmpty: <TSyncMetadata = Schema.JsonValue>() => PullResItem<TSyncMetadata>;
export interface PullResItem<TSyncMetadata = Schema.JsonValue> {
    batch: ReadonlyArray<{
        eventEncoded: LiveStoreEvent.AnyEncodedGlobal;
        metadata: Option.Option<TSyncMetadata>;
    }>;
    pageInfo: PullResPageInfo;
}
export declare const of: <TSyncMetadata = Schema.JsonValue>(obj: SyncBackend<TSyncMetadata>) => SyncBackend<TSyncMetadata>;
/**
 * Useful to continue pulling from the last event in the batch.
 */
export declare const cursorFromPullResItem: <TSyncMetadata = Schema.JsonValue>(item: PullResItem<TSyncMetadata>) => Option.Option<{
    cursor: EventSequenceNumber.GlobalEventSequenceNumber;
    metadata: Option.Option<TSyncMetadata>;
}>;
//# sourceMappingURL=sync-backend.d.ts.map
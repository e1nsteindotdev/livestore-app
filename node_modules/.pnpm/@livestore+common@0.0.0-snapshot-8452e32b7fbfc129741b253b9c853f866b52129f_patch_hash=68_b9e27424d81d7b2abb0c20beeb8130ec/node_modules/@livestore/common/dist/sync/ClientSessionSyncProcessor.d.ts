import { Effect, Option, type Runtime, Schema, type Scope, Subscribable } from '@livestore/utils/effect';
import type * as otel from '@opentelemetry/api';
import { type ClientSession, type MaterializerHashMismatchError, type UnexpectedError } from '../adapter-types.ts';
import * as LiveStoreEvent from '../schema/LiveStoreEvent.ts';
import { type LiveStoreSchema } from '../schema/mod.ts';
import * as SyncState from './syncstate.ts';
/**
 * Rebase behaviour:
 * - We continously pull events from the leader and apply them to the local store.
 * - If there was a race condition (i.e. the leader and client session have both advacned),
 *   we'll need to rebase the local pending events on top of the leader's head.
 * - The goal is to never block the UI, so we'll interrupt rebasing if a new events is pushed by the client session.
 * - We also want to avoid "backwards-jumping" in the UI, so we'll transactionally apply state changes during a rebase.
 * - We might need to make the rebase behaviour configurable e.g. to let users manually trigger a rebase
 *
 * Longer term we should evalutate whether we can unify the ClientSessionSyncProcessor with the LeaderSyncProcessor.
 *
 * The session and leader sync processor are different in the following ways:
 * - The leader sync processor pulls regular LiveStore events, while the session sync processor pulls SyncState.PayloadUpstream items
 * - The session sync processor has no downstream nodes.
 */
export declare const makeClientSessionSyncProcessor: ({ schema, clientSession, runtime, materializeEvent, rollback, refreshTables, span, params, confirmUnsavedChanges, }: {
    schema: LiveStoreSchema;
    clientSession: ClientSession;
    runtime: Runtime.Runtime<Scope.Scope>;
    materializeEvent: (eventDecoded: LiveStoreEvent.AnyDecoded, options: {
        withChangeset: boolean;
        materializerHashLeader: Option.Option<number>;
    }) => Effect.Effect<{
        writeTables: Set<string>;
        sessionChangeset: {
            _tag: "sessionChangeset";
            data: Uint8Array<ArrayBuffer>;
            debug: any;
        } | {
            _tag: "no-op";
        } | {
            _tag: "unset";
        };
        materializerHash: Option.Option<number>;
    }, MaterializerHashMismatchError>;
    rollback: (changeset: Uint8Array<ArrayBuffer>) => void;
    refreshTables: (tables: Set<string>) => void;
    span: otel.Span;
    params: {
        leaderPushBatchSize: number;
        simulation?: ClientSessionSyncProcessorSimulationParams;
    };
    /**
     * Currently only used in the web adapter:
     * If true, registers a beforeunload event listener to confirm unsaved changes.
     */
    confirmUnsavedChanges: boolean;
}) => ClientSessionSyncProcessor;
export interface ClientSessionSyncProcessor {
    push: (batch: ReadonlyArray<LiveStoreEvent.PartialAnyDecoded>) => Effect.Effect<{
        writeTables: Set<string>;
    }, MaterializerHashMismatchError>;
    boot: Effect.Effect<void, UnexpectedError, Scope.Scope>;
    /**
     * Only used for debugging / observability.
     */
    syncState: Subscribable.Subscribable<SyncState.SyncState>;
    debug: {
        print: () => void;
        debugInfo: () => {
            rebaseCount: number;
            advanceCount: number;
        };
    };
}
export declare const ClientSessionSyncProcessorSimulationParams: Schema.Struct<{
    pull: Schema.Struct<{
        '1_before_leader_push_fiber_interrupt': Schema.filter<typeof Schema.Int>;
        '2_before_leader_push_queue_clear': Schema.filter<typeof Schema.Int>;
        '3_before_rebase_rollback': Schema.filter<typeof Schema.Int>;
        '4_before_leader_push_queue_offer': Schema.filter<typeof Schema.Int>;
        '5_before_leader_push_fiber_run': Schema.filter<typeof Schema.Int>;
    }>;
}>;
type ClientSessionSyncProcessorSimulationParams = typeof ClientSessionSyncProcessorSimulationParams.Type;
export {};
//# sourceMappingURL=ClientSessionSyncProcessor.d.ts.map
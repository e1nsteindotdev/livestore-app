import { Effect, Mailbox, Option, Queue, Stream, SubscriptionRef } from '@livestore/utils/effect';
import { EventSequenceNumber } from "../schema/mod.js";
import * as SyncBackend from "./sync-backend.js";
import { validatePushPayload } from "./validate-push-payload.js";
export const makeMockSyncBackend = Effect.gen(function* () {
    const syncEventSequenceNumberRef = { current: EventSequenceNumber.ROOT.global };
    const syncPullQueue = yield* Queue.unbounded();
    const pushedEventsQueue = yield* Mailbox.make();
    const syncIsConnectedRef = yield* SubscriptionRef.make(true);
    const span = yield* Effect.currentSpan.pipe(Effect.orDie);
    const semaphore = yield* Effect.makeSemaphore(1);
    const makeSyncBackend = Effect.gen(function* () {
        return SyncBackend.of({
            isConnected: syncIsConnectedRef,
            connect: Effect.void,
            ping: Effect.void,
            pull: () => Stream.fromQueue(syncPullQueue).pipe(Stream.chunks, Stream.map((chunk) => ({
                batch: [...chunk].map((eventEncoded) => ({ eventEncoded, metadata: Option.none() })),
                pageInfo: SyncBackend.pageInfoNoMore,
            })), Stream.withSpan('MockSyncBackend:pull', { parent: span })),
            push: (batch) => Effect.gen(function* () {
                yield* validatePushPayload(batch, syncEventSequenceNumberRef.current);
                yield* Effect.sleep(10).pipe(Effect.withSpan('MockSyncBackend:push:sleep')); // Simulate network latency
                yield* pushedEventsQueue.offerAll(batch);
                yield* syncPullQueue.offerAll(batch);
                syncEventSequenceNumberRef.current = batch.at(-1).seqNum;
            }).pipe(Effect.withSpan('MockSyncBackend:push', {
                parent: span,
                attributes: {
                    nums: batch.map((_) => _.seqNum),
                },
            }), semaphore.withPermits(1)),
            metadata: {
                name: '@livestore/mock-sync',
                description: 'Just a mock sync backend',
            },
            supports: {
                pullPageInfoKnown: true,
                pullLive: true,
            },
        });
    });
    const advance = (...batch) => Effect.gen(function* () {
        syncEventSequenceNumberRef.current = batch.at(-1).seqNum;
        yield* syncPullQueue.offerAll(batch);
    }).pipe(Effect.withSpan('MockSyncBackend:advance', {
        parent: span,
        attributes: { nums: batch.map((_) => _.seqNum) },
    }), semaphore.withPermits(1));
    const connect = SubscriptionRef.set(syncIsConnectedRef, true);
    const disconnect = SubscriptionRef.set(syncIsConnectedRef, false);
    return {
        syncEventSequenceNumberRef,
        syncPullQueue,
        pushedEvents: Mailbox.toStream(pushedEventsQueue),
        connect,
        disconnect,
        makeSyncBackend,
        advance,
    };
}).pipe(Effect.withSpanScoped('MockSyncBackend'));
//# sourceMappingURL=mock-sync-backend.js.map
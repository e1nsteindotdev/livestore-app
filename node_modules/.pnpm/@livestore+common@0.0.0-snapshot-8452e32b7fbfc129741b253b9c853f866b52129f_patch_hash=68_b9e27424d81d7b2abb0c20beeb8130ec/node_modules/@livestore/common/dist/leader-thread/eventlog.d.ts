import { Effect, Option, Schema } from '@livestore/utils/effect';
import type { SqliteDb } from '../adapter-types.ts';
import * as EventSequenceNumber from '../schema/EventSequenceNumber.ts';
import * as LiveStoreEvent from '../schema/LiveStoreEvent.ts';
import { LeaderThreadCtx } from './types.ts';
export declare const initEventlogDb: (dbEventlog: SqliteDb) => Effect.Effect<void, import("../errors.ts").SqliteError, never>;
/**
 * Exclusive of the "since event"
 * Also queries the state db in order to get the SQLite session changeset data.
 */
export declare const getEventsSince: ({ dbEventlog, dbState, since, }: {
    dbEventlog: SqliteDb;
    dbState: SqliteDb;
    since: EventSequenceNumber.EventSequenceNumber;
}) => ReadonlyArray<LiveStoreEvent.EncodedWithMeta>;
export declare const getClientHeadFromDb: (dbEventlog: SqliteDb) => EventSequenceNumber.EventSequenceNumber;
export declare const getBackendHeadFromDb: (dbEventlog: SqliteDb) => EventSequenceNumber.GlobalEventSequenceNumber;
export declare const updateBackendHead: (dbEventlog: SqliteDb, head: EventSequenceNumber.EventSequenceNumber) => void;
export declare const insertIntoEventlog: (eventEncoded: LiveStoreEvent.EncodedWithMeta, dbEventlog: SqliteDb, eventDefSchemaHash: number, clientId: string, sessionId: string) => Effect.Effect<void, import("../errors.ts").SqliteError, never>;
export declare const updateSyncMetadata: (items: ReadonlyArray<LiveStoreEvent.EncodedWithMeta>) => Effect.Effect<void, import("../errors.ts").SqliteError, LeaderThreadCtx>;
export declare const getSyncBackendCursorInfo: ({ remoteHead, }: {
    remoteHead: EventSequenceNumber.GlobalEventSequenceNumber;
}) => Effect.Effect<Option.None<{
    cursor: EventSequenceNumber.GlobalEventSequenceNumber;
    metadata: Option.Option<Schema.JsonValue>;
}> | Option.Some<{
    cursor: EventSequenceNumber.GlobalEventSequenceNumber;
    metadata: Option.Option<Schema.JsonValue>;
}>, never, LeaderThreadCtx>;
//# sourceMappingURL=eventlog.d.ts.map
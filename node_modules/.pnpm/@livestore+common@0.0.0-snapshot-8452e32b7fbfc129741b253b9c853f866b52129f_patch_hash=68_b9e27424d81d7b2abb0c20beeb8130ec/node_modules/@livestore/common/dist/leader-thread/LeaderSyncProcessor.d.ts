import type { Scope } from '@livestore/utils/effect';
import { Effect } from '@livestore/utils/effect';
import { type SqliteDb, UnexpectedError } from '../adapter-types.ts';
import type { LiveStoreSchema } from '../schema/mod.ts';
import * as SyncState from '../sync/syncstate.ts';
import type { InitialBlockingSyncContext, LeaderSyncProcessor } from './types.ts';
/**
 * The LeaderSyncProcessor manages synchronization of events between
 * the local state and the sync backend, ensuring efficient and orderly processing.
 *
 * In the LeaderSyncProcessor, pulling always has precedence over pushing.
 *
 * Responsibilities:
 * - Queueing incoming local events in a localPushesQueue.
 * - Broadcasting events to client sessions via pull queues.
 * - Pushing events to the sync backend.
 *
 * Notes:
 *
 * local push processing:
 * - localPushesQueue:
 *   - Maintains events in ascending order.
 *   - Uses `Deferred` objects to resolve/reject events based on application success.
 * - Processes events from the queue, applying events in batches.
 * - Controlled by a `Latch` to manage execution flow.
 * - The latch closes on pull receipt and re-opens post-pull completion.
 * - Processes up to `maxBatchSize` events per cycle.
 *
 * Currently we're advancing the state db and eventlog in lockstep, but we could also decouple this in the future
 *
 * Tricky concurrency scenarios:
 * - Queued local push batches becoming invalid due to a prior local push item being rejected.
 *   Solution: Introduce a generation number for local push batches which is used to filter out old batches items in case of rejection.
 *
 * See ClientSessionSyncProcessor for how the leader and session sync processors are similar/different.
 */
export declare const makeLeaderSyncProcessor: ({ schema, dbState, initialBlockingSyncContext, initialSyncState, onError, livePull, params, testing, }: {
    schema: LiveStoreSchema;
    dbState: SqliteDb;
    initialBlockingSyncContext: InitialBlockingSyncContext;
    /** Initial sync state rehydrated from the persisted eventlog or initial sync state */
    initialSyncState: SyncState.SyncState;
    onError: "shutdown" | "ignore";
    params: {
        /**
         * @default 10
         */
        localPushBatchSize?: number;
        /**
         * @default 50
         */
        backendPushBatchSize?: number;
    };
    /** * Whether the sync backend should reactively pull new events from the sync backend */
    livePull: boolean;
    testing: {
        delays?: {
            localPushProcessing?: Effect.Effect<void>;
        };
    };
}) => Effect.Effect<LeaderSyncProcessor, UnexpectedError, Scope.Scope>;
//# sourceMappingURL=LeaderSyncProcessor.d.ts.map
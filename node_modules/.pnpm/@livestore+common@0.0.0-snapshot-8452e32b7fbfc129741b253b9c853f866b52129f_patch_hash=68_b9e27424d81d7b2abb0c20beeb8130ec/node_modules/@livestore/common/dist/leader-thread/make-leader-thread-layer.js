import { shouldNeverHappen } from '@livestore/utils';
import { Deferred, Effect, Layer, Queue, SubscriptionRef } from '@livestore/utils/effect';
import { UnexpectedError, } from "../adapter-types.js";
import { EventSequenceNumber, LiveStoreEvent, SystemTables } from "../schema/mod.js";
import { SyncState } from "../sync/syncstate.js";
import { sql } from "../util.js";
import * as Eventlog from "./eventlog.js";
import { makeLeaderSyncProcessor } from "./LeaderSyncProcessor.js";
import { bootDevtools } from "./leader-worker-devtools.js";
import { makeMaterializeEvent } from "./materialize-event.js";
import { recreateDb } from "./recreate-db.js";
import { LeaderThreadCtx } from "./types.js";
export const makeLeaderThreadLayer = ({ schema, storeId, clientId, syncPayload, makeSqliteDb, syncOptions, dbState, dbEventlog, devtoolsOptions, shutdownChannel, params, testing, }) => Effect.gen(function* () {
    const bootStatusQueue = yield* Queue.unbounded().pipe(Effect.acquireRelease(Queue.shutdown));
    const dbEventlogMissing = !hasEventlogTables(dbEventlog);
    // Either happens on initial boot or if schema changes
    const dbStateMissing = !hasStateTables(dbState);
    const syncBackend = syncOptions?.backend === undefined
        ? undefined
        : yield* syncOptions.backend({ storeId, clientId, payload: syncPayload });
    if (syncBackend !== undefined) {
        // We're already connecting to the sync backend concurrently
        yield* syncBackend.connect.pipe(Effect.tapCauseLogPretty, Effect.forkScoped);
    }
    const initialBlockingSyncContext = yield* makeInitialBlockingSyncContext({
        initialSyncOptions: syncOptions?.initialSyncOptions ?? { _tag: 'Skip' },
        bootStatusQueue,
    });
    yield* Eventlog.initEventlogDb(dbEventlog);
    const materializeEvent = yield* makeMaterializeEvent({ schema, dbState, dbEventlog });
    // Recreate state database if needed BEFORE creating sync processor
    // This ensures all system tables exist before any queries are made
    const { migrationsReport } = dbStateMissing
        ? yield* recreateDb({ dbState, dbEventlog, schema, bootStatusQueue, materializeEvent })
        : { migrationsReport: { migrations: [] } };
    const syncProcessor = yield* makeLeaderSyncProcessor({
        schema,
        dbState,
        initialSyncState: getInitialSyncState({ dbEventlog, dbState, dbEventlogMissing }),
        initialBlockingSyncContext,
        onError: syncOptions?.onSyncError ?? 'ignore',
        livePull: syncOptions?.livePull ?? true,
        params: {
            localPushBatchSize: params?.localPushBatchSize,
            backendPushBatchSize: params?.backendPushBatchSize,
        },
        testing: {
            delays: testing?.syncProcessor?.delays,
        },
    });
    const extraIncomingMessagesQueue = yield* Queue.unbounded().pipe(Effect.acquireRelease(Queue.shutdown));
    const devtoolsContext = devtoolsOptions.enabled
        ? {
            enabled: true,
            syncBackendLatch: yield* Effect.makeLatch(true),
            syncBackendLatchState: yield* SubscriptionRef.make({ latchClosed: false }),
        }
        : { enabled: false };
    const ctx = {
        schema,
        bootStatusQueue,
        storeId,
        clientId,
        dbState,
        dbEventlog,
        makeSqliteDb,
        eventSchema: LiveStoreEvent.makeEventDefSchema(schema),
        shutdownStateSubRef: yield* SubscriptionRef.make('running'),
        shutdownChannel,
        syncBackend,
        syncProcessor,
        materializeEvent,
        extraIncomingMessagesQueue,
        devtools: devtoolsContext,
        // State will be set during `bootLeaderThread`
        initialState: {},
    };
    // @ts-expect-error For debugging purposes
    globalThis.__leaderThreadCtx = ctx;
    const layer = Layer.succeed(LeaderThreadCtx, ctx);
    ctx.initialState = yield* bootLeaderThread({
        migrationsReport,
        initialBlockingSyncContext,
        devtoolsOptions,
    }).pipe(Effect.provide(layer));
    return layer;
}).pipe(Effect.withSpan('@livestore/common:leader-thread:boot'), Effect.withSpanScoped('@livestore/common:leader-thread'), UnexpectedError.mapToUnexpectedError, Effect.tapCauseLogPretty, Layer.unwrapScoped);
const hasEventlogTables = (db) => {
    const tableNames = new Set(db.select(sql `select name from sqlite_master`).map((_) => _.name));
    const eventlogTables = new Set(SystemTables.eventlogSystemTables.map((_) => _.sqliteDef.name));
    return isSubsetOf(eventlogTables, tableNames);
};
const hasStateTables = (db) => {
    const tableNames = new Set(db.select(sql `select name from sqlite_master`).map((_) => _.name));
    const stateTables = new Set(SystemTables.stateSystemTables.map((_) => _.sqliteDef.name));
    return isSubsetOf(stateTables, tableNames);
};
const isSubsetOf = (a, b) => {
    for (const item of a) {
        if (!b.has(item)) {
            return false;
        }
    }
    return true;
};
const getInitialSyncState = ({ dbEventlog, dbState, dbEventlogMissing, }) => {
    const initialBackendHead = dbEventlogMissing
        ? EventSequenceNumber.ROOT.global
        : Eventlog.getBackendHeadFromDb(dbEventlog);
    const initialLocalHead = dbEventlogMissing ? EventSequenceNumber.ROOT : Eventlog.getClientHeadFromDb(dbEventlog);
    if (initialBackendHead > initialLocalHead.global) {
        return shouldNeverHappen(`During boot the backend head (${initialBackendHead}) should never be greater than the local head (${initialLocalHead.global})`);
    }
    return SyncState.make({
        localHead: initialLocalHead,
        upstreamHead: {
            global: initialBackendHead,
            client: EventSequenceNumber.clientDefault,
            rebaseGeneration: EventSequenceNumber.rebaseGenerationDefault,
        },
        pending: dbEventlogMissing
            ? []
            : Eventlog.getEventsSince({
                dbEventlog,
                dbState,
                since: {
                    global: initialBackendHead,
                    client: EventSequenceNumber.clientDefault,
                    rebaseGeneration: initialLocalHead.rebaseGeneration,
                },
            }),
    });
};
const makeInitialBlockingSyncContext = ({ initialSyncOptions, bootStatusQueue, }) => Effect.gen(function* () {
    const ctx = {
        isDone: false,
        processedEvents: 0,
        total: -1,
    };
    const blockingDeferred = initialSyncOptions._tag === 'Blocking' ? yield* Deferred.make() : undefined;
    if (blockingDeferred !== undefined && initialSyncOptions._tag === 'Blocking') {
        yield* Deferred.succeed(blockingDeferred, void 0).pipe(Effect.delay(initialSyncOptions.timeout), Effect.forkScoped);
    }
    return {
        blockingDeferred,
        update: ({ processed, pageInfo }) => Effect.gen(function* () {
            if (ctx.isDone === true)
                return;
            if (ctx.total === -1 && pageInfo._tag === 'MoreKnown') {
                ctx.total = pageInfo.remaining + processed;
            }
            ctx.processedEvents += processed;
            yield* Queue.offer(bootStatusQueue, {
                stage: 'syncing',
                progress: { done: ctx.processedEvents, total: ctx.total },
            });
            if (pageInfo._tag === 'NoMore' && blockingDeferred !== undefined) {
                yield* Deferred.succeed(blockingDeferred, void 0);
                ctx.isDone = true;
            }
        }),
    };
});
/**
 * Blocks until the leader thread has finished its initial setup.
 * It also starts various background processes (e.g. syncing)
 */
const bootLeaderThread = ({ migrationsReport, initialBlockingSyncContext, devtoolsOptions, }) => Effect.gen(function* () {
    const { bootStatusQueue, syncProcessor } = yield* LeaderThreadCtx;
    // NOTE the sync processor depends on the dbs being initialized properly
    const { initialLeaderHead } = yield* syncProcessor.boot;
    if (initialBlockingSyncContext.blockingDeferred !== undefined) {
        // Provides a syncing status right away before the first pull response comes in
        yield* Queue.offer(bootStatusQueue, {
            stage: 'syncing',
            progress: { done: 0, total: -1 },
        });
        yield* initialBlockingSyncContext.blockingDeferred.pipe(Effect.withSpan('@livestore/common:leader-thread:initial-sync-blocking'));
    }
    yield* Queue.offer(bootStatusQueue, { stage: 'done' });
    yield* bootDevtools(devtoolsOptions).pipe(Effect.tapCauseLogPretty, Effect.forkScoped);
    return { migrationsReport, leaderHead: initialLeaderHead };
});
//# sourceMappingURL=make-leader-thread-layer.js.map
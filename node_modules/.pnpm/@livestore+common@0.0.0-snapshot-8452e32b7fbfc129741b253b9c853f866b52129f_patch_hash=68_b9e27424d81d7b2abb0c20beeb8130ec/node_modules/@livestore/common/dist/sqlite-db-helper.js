import { Schema } from '@livestore/utils/effect';
import { SqliteError } from "./adapter-types.js";
import { getResultSchema, isQueryBuilder } from "./schema/state/sqlite/query-builder/mod.js";
export const makeExecute = (execute) => {
    return (...args) => {
        const [queryStrOrQueryBuilder, bindValuesOrOptions, maybeOptions] = args;
        if (isQueryBuilder(queryStrOrQueryBuilder)) {
            const { query, bindValues } = queryStrOrQueryBuilder.asSql();
            return execute(query, bindValues, bindValuesOrOptions);
        }
        else {
            return execute(queryStrOrQueryBuilder, bindValuesOrOptions, maybeOptions);
        }
    };
};
export const makeSelect = (select) => {
    return (...args) => {
        const [queryStrOrQueryBuilder, maybeBindValues] = args;
        if (isQueryBuilder(queryStrOrQueryBuilder)) {
            const { query, bindValues } = queryStrOrQueryBuilder.asSql();
            const resultSchema = getResultSchema(queryStrOrQueryBuilder);
            const results = select(query, bindValues);
            return Schema.decodeSync(resultSchema)(results);
        }
        else {
            return select(queryStrOrQueryBuilder, maybeBindValues);
        }
    };
};
export const validateSnapshot = (snapshot) => {
    const headerBytes = new TextDecoder().decode(snapshot.slice(0, 16));
    const hasValidHeader = headerBytes.startsWith('SQLite format 3');
    if (!hasValidHeader) {
        throw new SqliteError({
            cause: 'Invalid SQLite header',
            note: `Expected header to start with 'SQLite format 3', but got: ${headerBytes}`,
        });
    }
};
export const makeExport = (exportFn) => () => {
    const snapshot = exportFn();
    validateSnapshot(snapshot);
    return snapshot;
};
//# sourceMappingURL=sqlite-db-helper.js.map
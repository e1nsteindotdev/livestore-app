import { Brand, Schema } from '@livestore/utils/effect';
export type ClientEventSequenceNumber = Brand.Branded<number, 'ClientEventSequenceNumber'>;
export declare const localEventSequenceNumber: Brand.Brand.Constructor<ClientEventSequenceNumber>;
export declare const ClientEventSequenceNumber: Schema.BrandSchema<number & Brand.Brand<"ClientEventSequenceNumber">, number, never>;
export type GlobalEventSequenceNumber = Brand.Branded<number, 'GlobalEventSequenceNumber'>;
export declare const globalEventSequenceNumber: Brand.Brand.Constructor<GlobalEventSequenceNumber>;
export declare const GlobalEventSequenceNumber: Schema.BrandSchema<number & Brand.Brand<"GlobalEventSequenceNumber">, number, never>;
export declare const clientDefault: ClientEventSequenceNumber;
export declare const rebaseGenerationDefault = 0;
/**
 * LiveStore event sequence number value consisting of a globally unique event sequence number
 * and a client sequence number.
 *
 * The client sequence number is only used for clientOnly events and starts from 0 for each global sequence number.
 */
export type EventSequenceNumber = {
    global: GlobalEventSequenceNumber;
    client: ClientEventSequenceNumber;
    /**
     * Generation integer that is incremented whenever the client rebased.
     * Starts from and resets to 0 for each global sequence number.
     */
    rebaseGeneration: number;
};
export type EventSequenceNumberInput = EventSequenceNumber | (Omit<typeof EventSequenceNumber.Encoded, 'rebaseGeneration'> & {
    rebaseGeneration?: number;
});
/**
 * NOTE: Client mutation events with a non-0 client id, won't be synced to the sync backend.
 */
export declare const EventSequenceNumber: Schema.Struct<{
    global: Schema.BrandSchema<number & Brand.Brand<"GlobalEventSequenceNumber">, number, never>;
    /** Only increments for clientOnly events */
    client: Schema.BrandSchema<number & Brand.Brand<"ClientEventSequenceNumber">, number, never>;
    rebaseGeneration: typeof Schema.Int;
}>;
/**
 * Compare two event sequence numbers i.e. checks if the first event sequence number is less than the second.
 * Comparison hierarchy: global > client > rebaseGeneration
 */
export declare const compare: (a: EventSequenceNumber, b: EventSequenceNumber) => number;
/**
 * Convert an event sequence number to a string representation.
 */
export declare const toString: (seqNum: EventSequenceNumber) => string;
/**
 * Convert a string representation of an event sequence number to an event sequence number.
 * Parses strings in the format: e{global}[+{client}][r{rebaseGeneration}]
 * Examples: "e0", "e0r1", "e0+1", "e0+1r1"
 */
export declare const fromString: (str: string) => EventSequenceNumber;
export declare const fromGlobal: (seqNum: GlobalEventSequenceNumber) => {
    global: GlobalEventSequenceNumber;
    client: ClientEventSequenceNumber;
    rebaseGeneration: number;
};
export declare const isEqual: (a: EventSequenceNumber, b: EventSequenceNumber) => boolean;
export type EventSequenceNumberPair = {
    seqNum: EventSequenceNumber;
    parentSeqNum: EventSequenceNumber;
};
export declare const ROOT: {
    global: GlobalEventSequenceNumber;
    client: ClientEventSequenceNumber;
    rebaseGeneration: number;
};
export declare const isGreaterThan: (a: EventSequenceNumber, b: EventSequenceNumber) => boolean;
export declare const isGreaterThanOrEqual: (a: EventSequenceNumber, b: EventSequenceNumber) => boolean;
export declare const max: (a: EventSequenceNumber, b: EventSequenceNumber) => EventSequenceNumber;
export declare const diff: (a: EventSequenceNumber, b: EventSequenceNumber) => {
    global: number;
    client: number;
};
export declare const make: (seqNum: EventSequenceNumberInput) => EventSequenceNumber;
export declare const nextPair: ({ seqNum, isClient, rebaseGeneration, }: {
    seqNum: EventSequenceNumber;
    isClient: boolean;
    rebaseGeneration?: number;
}) => EventSequenceNumberPair;
//# sourceMappingURL=EventSequenceNumber.d.ts.map
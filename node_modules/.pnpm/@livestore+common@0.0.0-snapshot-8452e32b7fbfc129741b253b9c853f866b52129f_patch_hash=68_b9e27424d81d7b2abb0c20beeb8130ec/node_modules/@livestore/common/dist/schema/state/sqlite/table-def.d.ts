import { type Nullable } from '@livestore/utils';
import { type Schema, type Types } from '@livestore/utils/effect';
import { getColumnDefForSchema } from './column-def.ts';
import { SqliteDsl } from './db-schema/mod.ts';
import type { QueryBuilder } from './query-builder/mod.ts';
export declare const blob: SqliteDsl.ColDefFn<"blob">, boolean: SqliteDsl.SpecializedColDefFn<"integer", false, boolean>, column: <TColumnType extends SqliteDsl.FieldColumnType>(columnType: TColumnType) => SqliteDsl.ColDefFn<TColumnType>, datetime: SqliteDsl.SpecializedColDefFn<"text", false, Date>, integer: SqliteDsl.ColDefFn<"integer">, isColumnDefinition: (value: unknown) => value is SqliteDsl.ColumnDefinition.Any, json: SqliteDsl.SpecializedColDefFn<"text", true, unknown>, real: SqliteDsl.ColDefFn<"real">, text: SqliteDsl.ColDefFn<"text">;
export { getColumnDefForSchema };
export type StateType = 'singleton' | 'dynamic';
export type DefaultSqliteTableDef = SqliteDsl.TableDefinition<string, SqliteDsl.Columns>;
export type DefaultSqliteTableDefConstrained = SqliteDsl.TableDefinition<string, SqliteDsl.ConstraintColumns>;
export declare const TableDefInternalsSymbol: unique symbol;
export type TableDefInternalsSymbol = typeof TableDefInternalsSymbol;
export type TableDefBase<TSqliteDef extends DefaultSqliteTableDef = DefaultSqliteTableDefConstrained, TOptions extends TableOptions = TableOptions> = {
    sqliteDef: TSqliteDef;
    options: TOptions;
    rowSchema: SqliteDsl.StructSchemaForColumns<TSqliteDef['columns']>;
    insertSchema: SqliteDsl.InsertStructSchemaForColumns<TSqliteDef['columns']>;
};
export type TableDef<TSqliteDef extends DefaultSqliteTableDef = DefaultSqliteTableDefConstrained, TOptions extends TableOptions = TableOptions, TSchema = Schema.Schema<SqliteDsl.AnyIfConstained<TSqliteDef['columns'], {
    readonly [K in keyof TSqliteDef['columns']]: TSqliteDef['columns'][K]['schema']['Type'];
}>, SqliteDsl.AnyIfConstained<TSqliteDef['columns'], {
    readonly [K in keyof TSqliteDef['columns']]: TSqliteDef['columns'][K]['schema']['Encoded'];
}>>> = {
    sqliteDef: TSqliteDef;
    options: TOptions;
    rowSchema: TSchema;
    insertSchema: SqliteDsl.InsertStructSchemaForColumns<TSqliteDef['columns']>;
    readonly Type: Schema.Schema.Type<TSchema>;
    readonly Encoded: Schema.Schema.Encoded<TSchema>;
} & QueryBuilder<ReadonlyArray<Schema.Schema.Type<TSchema>>, TableDefBase<TSqliteDef & {}, TOptions>>;
export type TableOptionsInput = Partial<{
    indexes: SqliteDsl.Index[];
}>;
export declare namespace TableDef {
    type Any = TableDef<any, any>;
}
export type TableOptions = {
    /** Derived based on whether the table definition has one or more columns (besides the `id` column) */
    readonly isClientDocumentTable: boolean;
};
/**
 * Creates a SQLite table definition from columns or an Effect Schema.
 *
 * This function supports two main ways to define a table:
 * 1. Using explicit column definitions
 * 2. Using an Effect Schema (either the `name` property needs to be provided or the schema needs to have a title/identifier)
 *
 * ```ts
 * // Using explicit columns
 * const usersTable = State.SQLite.table({
 *   name: 'users',
 *   columns: {
 *     id: State.SQLite.text({ primaryKey: true }),
 *     name: State.SQLite.text({ nullable: false }),
 *     email: State.SQLite.text({ nullable: false }),
 *     age: State.SQLite.integer({ nullable: true }),
 *   },
 * })
 * ```
 *
 * ```ts
 * // Using Effect Schema with annotations
 * import { Schema } from '@livestore/utils/effect'
 *
 * const UserSchema = Schema.Struct({
 *   id: Schema.Int.pipe(State.SQLite.withPrimaryKey).pipe(State.SQLite.withAutoIncrement),
 *   email: Schema.String.pipe(State.SQLite.withUnique),
 *   name: Schema.String,
 *   active: Schema.Boolean.pipe(State.SQLite.withDefault(true)),
 *   createdAt: Schema.optional(Schema.Date),
 * })
 *
 * // Option 1: With explicit name
 * const usersTable = State.SQLite.table({
 *   name: 'users',
 *   schema: UserSchema,
 * })
 *
 * // Option 2: With name from schema annotation (title or identifier)
 * const AnnotatedUserSchema = UserSchema.annotations({ title: 'users' })
 * const usersTable2 = State.SQLite.table({
 *   schema: AnnotatedUserSchema,
 * })
 * ```
 *
 * ```ts
 * // Adding indexes
 * const PostSchema = Schema.Struct({
 *   id: Schema.String.pipe(State.SQLite.withPrimaryKey),
 *   title: Schema.String,
 *   authorId: Schema.String,
 *   createdAt: Schema.Date,
 * }).annotations({ identifier: 'posts' })
 *
 * const postsTable = State.SQLite.table({
 *   schema: PostSchema,
 *   indexes: [
 *     { name: 'idx_posts_author', columns: ['authorId'] },
 *     { name: 'idx_posts_created', columns: ['createdAt'], isUnique: false },
 *   ],
 * })
 * ```
 *
 * @remarks
 * - Primary key columns are automatically non-nullable
 * - Columns with `State.SQLite.withUnique` annotation automatically get unique indexes
 * - The `State.SQLite.withAutoIncrement` annotation only works with integer primary keys
 * - Default values can be literal values or SQL expressions
 * - When using Effect Schema without explicit name, the schema must have a title or identifier annotation
 */
export declare function table<TName extends string, TColumns extends SqliteDsl.Columns | SqliteDsl.ColumnDefinition.Any, const TOptionsInput extends TableOptionsInput = TableOptionsInput>(args: {
    name: TName;
    columns: TColumns;
} & Partial<TOptionsInput>): TableDef<SqliteTableDefForInput<TName, TColumns>, WithDefaults<TColumns>>;
export declare function table<TName extends string, TSchema extends Schema.Schema.AnyNoContext, const TOptionsInput extends TableOptionsInput = TableOptionsInput>(args: {
    name: TName;
    schema: TSchema;
} & Partial<TOptionsInput>): TableDef<SqliteTableDefForSchemaInput<TName, Schema.Schema.Type<TSchema>, Schema.Schema.Encoded<TSchema>, TSchema>, TableOptions>;
export declare function table<TSchema extends Schema.Schema.AnyNoContext, const TOptionsInput extends TableOptionsInput = TableOptionsInput>(args: {
    schema: TSchema;
} & Partial<TOptionsInput>): TableDef<SqliteTableDefForSchemaInput<string, Schema.Schema.Type<TSchema>, Schema.Schema.Encoded<TSchema>, TSchema>, TableOptions>;
export declare namespace FromTable {
    type RowDecoded<TTableDef extends TableDefBase> = Types.Simplify<Nullable<Pick<RowDecodedAll<TTableDef>, NullableColumnNames<TTableDef>>> & Omit<RowDecodedAll<TTableDef>, NullableColumnNames<TTableDef>>>;
    type NullableColumnNames<TTableDef extends TableDefBase> = FromColumns.NullableColumnNames<TTableDef['sqliteDef']['columns']>;
    type Columns<TTableDef extends TableDefBase> = {
        [K in keyof TTableDef['sqliteDef']['columns']]: TTableDef['sqliteDef']['columns'][K]['columnType'];
    };
    type RowEncodeNonNullable<TTableDef extends TableDefBase> = {
        [K in keyof TTableDef['sqliteDef']['columns']]: Schema.Schema.Encoded<TTableDef['sqliteDef']['columns'][K]['schema']>;
    };
    type RowEncoded<TTableDef extends TableDefBase> = Types.Simplify<Nullable<Pick<RowEncodeNonNullable<TTableDef>, NullableColumnNames<TTableDef>>> & Omit<RowEncodeNonNullable<TTableDef>, NullableColumnNames<TTableDef>>>;
    type RowDecodedAll<TTableDef extends TableDefBase> = {
        [K in keyof TTableDef['sqliteDef']['columns']]: Schema.Schema.Type<TTableDef['sqliteDef']['columns'][K]['schema']>;
    };
}
export declare namespace FromColumns {
    type RowDecoded<TColumns extends SqliteDsl.Columns> = Types.Simplify<Nullable<Pick<RowDecodedAll<TColumns>, NullableColumnNames<TColumns>>> & Omit<RowDecodedAll<TColumns>, NullableColumnNames<TColumns>>>;
    type RowDecodedAll<TColumns extends SqliteDsl.Columns> = {
        [K in keyof TColumns]: Schema.Schema.Type<TColumns[K]['schema']>;
    };
    type RowEncoded<TColumns extends SqliteDsl.Columns> = Types.Simplify<Nullable<Pick<RowEncodeNonNullable<TColumns>, NullableColumnNames<TColumns>>> & Omit<RowEncodeNonNullable<TColumns>, NullableColumnNames<TColumns>>>;
    type RowEncodeNonNullable<TColumns extends SqliteDsl.Columns> = {
        [K in keyof TColumns]: Schema.Schema.Encoded<TColumns[K]['schema']>;
    };
    type NullableColumnNames<TColumns extends SqliteDsl.Columns> = keyof {
        [K in keyof TColumns as TColumns[K]['default'] extends true ? K : never]: {};
    };
    type RequiredInsertColumnNames<TColumns extends SqliteDsl.Columns> = SqliteDsl.FromColumns.RequiredInsertColumnNames<TColumns>;
    type InsertRowDecoded<TColumns extends SqliteDsl.Columns> = SqliteDsl.FromColumns.InsertRowDecoded<TColumns>;
}
export type SqliteTableDefForInput<TName extends string, TColumns extends SqliteDsl.Columns | SqliteDsl.ColumnDefinition.Any> = SqliteDsl.TableDefinition<TName, PrettifyFlat<ToColumns<TColumns>>>;
export type SqliteTableDefForSchemaInput<TName extends string, TType, TEncoded, _TSchema = any> = TableDefInput.ForSchema<TName, TType, TEncoded, _TSchema>;
export type WithDefaults<TColumns extends SqliteDsl.Columns | SqliteDsl.ColumnDefinition.Any> = {
    isClientDocumentTable: false;
    requiredInsertColumnNames: SqliteDsl.FromColumns.RequiredInsertColumnNames<ToColumns<TColumns>>;
};
export type PrettifyFlat<T> = T extends infer U ? {
    [K in keyof U]: U[K];
} : never;
export type ToColumns<TColumns extends SqliteDsl.Columns | SqliteDsl.ColumnDefinition.Any> = TColumns extends SqliteDsl.Columns ? TColumns : TColumns extends SqliteDsl.ColumnDefinition.Any ? {
    value: TColumns;
} : never;
export declare namespace SchemaToColumns {
    type ColumnDefForType<TEncoded, TType> = SqliteDsl.ColumnDefinition<TEncoded, TType>;
    type FromTypes<TType, TEncoded> = TType extends Record<string, any> ? TEncoded extends Record<string, any> ? {
        [K in keyof TType & keyof TEncoded]: ColumnDefForType<TEncoded[K], TType[K]>;
    } : SqliteDsl.Columns : SqliteDsl.Columns;
}
export declare namespace TableDefInput {
    type ForColumns<TName extends string, TColumns extends SqliteDsl.Columns | SqliteDsl.ColumnDefinition.Any> = SqliteDsl.TableDefinition<TName, PrettifyFlat<ToColumns<TColumns>>>;
    type ForSchema<TName extends string, TType, TEncoded, _TSchema = any> = SqliteDsl.TableDefinition<TName, SchemaToColumns.FromTypes<TType, TEncoded>>;
}
//# sourceMappingURL=table-def.d.ts.map
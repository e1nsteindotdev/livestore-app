import { Schema } from '@livestore/utils/effect';
export declare const SCHEMA_META_TABLE = "__livestore_schema";
export declare const schemaMetaTable: import("./table-def.ts").TableDef<import("./table-def.ts").SqliteTableDefForInput<"__livestore_schema", {
    readonly tableName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, import("./table-def.ts").WithDefaults<{
    readonly tableName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, Schema.Schema<{
    readonly tableName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, {
    readonly tableName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, never>>;
export type SchemaMetaRow = typeof schemaMetaTable.Type;
export declare const SCHEMA_EVENT_DEFS_META_TABLE = "__livestore_schema_event_defs";
export declare const schemaEventDefsMetaTable: import("./table-def.ts").TableDef<import("./table-def.ts").SqliteTableDefForInput<"__livestore_schema_event_defs", {
    readonly eventName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, import("./table-def.ts").WithDefaults<{
    readonly eventName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, Schema.Schema<{
    readonly eventName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, {
    readonly eventName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, never>>;
export type SchemaEventDefsMetaRow = typeof schemaEventDefsMetaTable.Type;
/**
 * Table which stores SQLite changeset blobs which is used for rolling back
 * read-model state during rebasing.
 */
export declare const SESSION_CHANGESET_META_TABLE = "__livestore_session_changeset";
export declare const sessionChangesetMetaTable: import("./table-def.ts").TableDef<import("./table-def.ts").SqliteTableDefForInput<"__livestore_session_changeset", {
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly seqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly changeset: {
        columnType: "blob";
        schema: Schema.Schema<Uint8Array<ArrayBuffer> | null, Uint8Array<ArrayBuffer> | null, never>;
        default: import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly debug: {
        columnType: "text";
        schema: Schema.Schema<unknown, string | null, never>;
        default: import("effect/Option").Some<any> | import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
        autoIncrement: false;
    };
}>, import("./table-def.ts").WithDefaults<{
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly seqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly changeset: {
        columnType: "blob";
        schema: Schema.Schema<Uint8Array<ArrayBuffer> | null, Uint8Array<ArrayBuffer> | null, never>;
        default: import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly debug: {
        columnType: "text";
        schema: Schema.Schema<unknown, string | null, never>;
        default: import("effect/Option").Some<any> | import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
        autoIncrement: false;
    };
}>, Schema.Schema<{
    readonly seqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly seqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly seqNumRebaseGeneration: number;
    readonly changeset: Uint8Array<ArrayBuffer> | null;
    readonly debug: unknown;
}, {
    readonly seqNumGlobal: number;
    readonly seqNumClient: number;
    readonly seqNumRebaseGeneration: number;
    readonly changeset: Uint8Array<ArrayBuffer> | null;
    readonly debug: string | null;
}, never>>;
export type SessionChangesetMetaRow = typeof sessionChangesetMetaTable.Type;
export declare const stateSystemTables: readonly [import("./table-def.ts").TableDef<import("./table-def.ts").SqliteTableDefForInput<"__livestore_schema", {
    readonly tableName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, import("./table-def.ts").WithDefaults<{
    readonly tableName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, Schema.Schema<{
    readonly tableName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, {
    readonly tableName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, never>>, import("./table-def.ts").TableDef<import("./table-def.ts").SqliteTableDefForInput<"__livestore_schema_event_defs", {
    readonly eventName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, import("./table-def.ts").WithDefaults<{
    readonly eventName: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** ISO date format */
    readonly updatedAt: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, Schema.Schema<{
    readonly eventName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, {
    readonly eventName: string;
    readonly schemaHash: number;
    readonly updatedAt: string;
}, never>>, import("./table-def.ts").TableDef<import("./table-def.ts").SqliteTableDefForInput<"__livestore_session_changeset", {
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly seqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly changeset: {
        columnType: "blob";
        schema: Schema.Schema<Uint8Array<ArrayBuffer> | null, Uint8Array<ArrayBuffer> | null, never>;
        default: import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly debug: {
        columnType: "text";
        schema: Schema.Schema<unknown, string | null, never>;
        default: import("effect/Option").Some<any> | import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
        autoIncrement: false;
    };
}>, import("./table-def.ts").WithDefaults<{
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly seqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly changeset: {
        columnType: "blob";
        schema: Schema.Schema<Uint8Array<ArrayBuffer> | null, Uint8Array<ArrayBuffer> | null, never>;
        default: import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly debug: {
        columnType: "text";
        schema: Schema.Schema<unknown, string | null, never>;
        default: import("effect/Option").Some<any> | import("effect/Option").None<never>;
        nullable: true;
        primaryKey: false;
        autoIncrement: false;
    };
}>, Schema.Schema<{
    readonly seqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly seqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly seqNumRebaseGeneration: number;
    readonly changeset: Uint8Array<ArrayBuffer> | null;
    readonly debug: unknown;
}, {
    readonly seqNumGlobal: number;
    readonly seqNumClient: number;
    readonly seqNumRebaseGeneration: number;
    readonly changeset: Uint8Array<ArrayBuffer> | null;
    readonly debug: string | null;
}, never>>];
export declare const isStateSystemTable: (tableName: string) => boolean;
export declare const EVENTLOG_META_TABLE = "eventlog";
export declare const eventlogMetaTable: import("./table-def.ts").TableDef<import("./table-def.ts").SqliteTableDefForInput<"eventlog", {
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly seqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly parentSeqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly parentSeqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly parentSeqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** Event definition name */
    readonly name: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly argsJson: {
        columnType: "text";
        schema: Schema.Schema<any, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly clientId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly sessionId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly syncMetadataJson: {
        columnType: "text";
        schema: Schema.Schema<import("effect/Option").None<Schema.JsonValue> | import("effect/Option").Some<Schema.JsonValue>, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, import("./table-def.ts").WithDefaults<{
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly seqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly parentSeqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly parentSeqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly parentSeqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** Event definition name */
    readonly name: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly argsJson: {
        columnType: "text";
        schema: Schema.Schema<any, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly clientId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly sessionId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly syncMetadataJson: {
        columnType: "text";
        schema: Schema.Schema<import("effect/Option").None<Schema.JsonValue> | import("effect/Option").Some<Schema.JsonValue>, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, Schema.Schema<{
    readonly seqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly seqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly seqNumRebaseGeneration: number;
    readonly parentSeqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly parentSeqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly parentSeqNumRebaseGeneration: number;
    readonly name: string;
    readonly argsJson: any;
    readonly clientId: string;
    readonly sessionId: string;
    readonly schemaHash: number;
    readonly syncMetadataJson: import("effect/Option").None<Schema.JsonValue> | import("effect/Option").Some<Schema.JsonValue>;
}, {
    readonly seqNumGlobal: number;
    readonly seqNumClient: number;
    readonly seqNumRebaseGeneration: number;
    readonly parentSeqNumGlobal: number;
    readonly parentSeqNumClient: number;
    readonly parentSeqNumRebaseGeneration: number;
    readonly name: string;
    readonly argsJson: string;
    readonly clientId: string;
    readonly sessionId: string;
    readonly schemaHash: number;
    readonly syncMetadataJson: string;
}, never>>;
export type EventlogMetaRow = typeof eventlogMetaTable.Type;
export declare const SYNC_STATUS_TABLE = "__livestore_sync_status";
export declare const syncStatusTable: import("./table-def.ts").TableDef<import("./table-def.ts").SqliteTableDefForInput<"__livestore_sync_status", {
    readonly head: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
}>, import("./table-def.ts").WithDefaults<{
    readonly head: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
}>, Schema.Schema<{
    readonly head: number;
}, {
    readonly head: number;
}, never>>;
export type SyncStatusRow = typeof syncStatusTable.Type;
export declare const eventlogSystemTables: readonly [import("./table-def.ts").TableDef<import("./table-def.ts").SqliteTableDefForInput<"eventlog", {
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly seqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly parentSeqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly parentSeqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly parentSeqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** Event definition name */
    readonly name: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly argsJson: {
        columnType: "text";
        schema: Schema.Schema<any, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly clientId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly sessionId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly syncMetadataJson: {
        columnType: "text";
        schema: Schema.Schema<import("effect/Option").None<Schema.JsonValue> | import("effect/Option").Some<Schema.JsonValue>, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, import("./table-def.ts").WithDefaults<{
    readonly seqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly seqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly seqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
    readonly parentSeqNumGlobal: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly parentSeqNumClient: {
        columnType: "integer";
        schema: Schema.Schema<number & import("effect/Brand").Brand<"ClientEventSequenceNumber">, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly parentSeqNumRebaseGeneration: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    /** Event definition name */
    readonly name: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly argsJson: {
        columnType: "text";
        schema: Schema.Schema<any, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly clientId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly sessionId: {
        columnType: "text";
        schema: Schema.Schema<string, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly schemaHash: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
    readonly syncMetadataJson: {
        columnType: "text";
        schema: Schema.Schema<import("effect/Option").None<Schema.JsonValue> | import("effect/Option").Some<Schema.JsonValue>, string, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: false;
        autoIncrement: false;
    };
}>, Schema.Schema<{
    readonly seqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly seqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly seqNumRebaseGeneration: number;
    readonly parentSeqNumGlobal: number & import("effect/Brand").Brand<"GlobalEventSequenceNumber">;
    readonly parentSeqNumClient: number & import("effect/Brand").Brand<"ClientEventSequenceNumber">;
    readonly parentSeqNumRebaseGeneration: number;
    readonly name: string;
    readonly argsJson: any;
    readonly clientId: string;
    readonly sessionId: string;
    readonly schemaHash: number;
    readonly syncMetadataJson: import("effect/Option").None<Schema.JsonValue> | import("effect/Option").Some<Schema.JsonValue>;
}, {
    readonly seqNumGlobal: number;
    readonly seqNumClient: number;
    readonly seqNumRebaseGeneration: number;
    readonly parentSeqNumGlobal: number;
    readonly parentSeqNumClient: number;
    readonly parentSeqNumRebaseGeneration: number;
    readonly name: string;
    readonly argsJson: string;
    readonly clientId: string;
    readonly sessionId: string;
    readonly schemaHash: number;
    readonly syncMetadataJson: string;
}, never>>, import("./table-def.ts").TableDef<import("./table-def.ts").SqliteTableDefForInput<"__livestore_sync_status", {
    readonly head: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
}>, import("./table-def.ts").WithDefaults<{
    readonly head: {
        columnType: "integer";
        schema: Schema.Schema<number, number, never>;
        default: import("effect/Option").None<never>;
        nullable: false;
        primaryKey: true;
        autoIncrement: false;
    };
}>, Schema.Schema<{
    readonly head: number;
}, {
    readonly head: number;
}, never>>];
//# sourceMappingURL=system-tables.d.ts.map
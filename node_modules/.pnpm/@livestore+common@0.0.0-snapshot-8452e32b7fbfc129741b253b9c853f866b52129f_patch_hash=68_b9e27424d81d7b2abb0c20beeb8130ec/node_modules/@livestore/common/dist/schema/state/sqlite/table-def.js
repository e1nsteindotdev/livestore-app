import { shouldNeverHappen } from '@livestore/utils';
import { Option, SchemaAST } from '@livestore/utils/effect';
import { getColumnDefForSchema, schemaFieldsToColumns } from "./column-def.js";
import { SqliteDsl } from "./db-schema/mod.js";
import { makeQueryBuilder, QueryBuilderAstSymbol, QueryBuilderTypeId } from "./query-builder/mod.js";
export const { blob, boolean, column, datetime, integer, isColumnDefinition, json, real, text } = SqliteDsl;
// Re-export the column definition function
export { getColumnDefForSchema };
// TODO use to hide table def internals
export const TableDefInternalsSymbol = Symbol('TableDefInternals');
// Implementation
export function table(args) {
    const { ...options } = args;
    let tableName;
    let columns;
    let additionalIndexes = [];
    if ('columns' in args) {
        tableName = args.name;
        const columnOrColumns = args.columns;
        columns = (SqliteDsl.isColumnDefinition(columnOrColumns) ? { value: columnOrColumns } : columnOrColumns);
        additionalIndexes = [];
    }
    else if ('schema' in args) {
        const result = schemaFieldsToColumns(SchemaAST.getPropertySignatures(args.schema.ast));
        columns = result.columns;
        // We'll set tableName first, then use it for index names
        let tempTableName;
        // If name is provided, use it; otherwise extract from schema annotations
        if ('name' in args) {
            tempTableName = args.name;
        }
        else {
            // Use title or identifier, with preference for title
            tempTableName = SchemaAST.getTitleAnnotation(args.schema.ast).pipe(Option.orElse(() => SchemaAST.getIdentifierAnnotation(args.schema.ast)), Option.getOrElse(() => shouldNeverHappen('When using schema without explicit name, the schema must have a title or identifier annotation')));
        }
        tableName = tempTableName;
        // Create unique indexes for columns with unique annotation
        additionalIndexes = (result.uniqueColumns || []).map((columnName) => ({
            name: `idx_${tableName}_${columnName}_unique`,
            columns: [columnName],
            isUnique: true,
        }));
    }
    else {
        return shouldNeverHappen('Either `columns` or `schema` must be provided when calling `table()`');
    }
    const options_ = {
        isClientDocumentTable: false,
    };
    // Combine user-provided indexes with unique column indexes
    const allIndexes = [...(options?.indexes ?? []), ...additionalIndexes];
    const sqliteDef = SqliteDsl.table(tableName, columns, allIndexes);
    const rowSchema = SqliteDsl.structSchemaForTable(sqliteDef);
    const insertSchema = SqliteDsl.insertStructSchemaForTable(sqliteDef);
    const tableDef = {
        sqliteDef,
        options: options_,
        rowSchema,
        insertSchema,
    };
    const query = makeQueryBuilder(tableDef);
    // tableDef.query = query
    // NOTE we're currently patching the existing tableDef object
    // as it's being used as part of the query builder API
    for (const key of Object.keys(query)) {
        // @ts-expect-error TODO properly implement this
        tableDef[key] = query[key];
    }
    // @ts-expect-error TODO properly type this
    tableDef[QueryBuilderAstSymbol] = query[QueryBuilderAstSymbol];
    // @ts-expect-error TODO properly type this
    tableDef[QueryBuilderTypeId] = query[QueryBuilderTypeId];
    return tableDef;
}
//# sourceMappingURL=table-def.js.map
import { shouldNeverHappen } from '@livestore/utils';
import { Option, Schema, SchemaAST } from '@livestore/utils/effect';
import { AutoIncrement, ColumnType, Default, PrimaryKeyId, Unique } from "./column-annotations.js";
import { SqliteDsl } from "./db-schema/mod.js";
/**
 * Maps a schema to a SQLite column definition, respecting column annotations.
 *
 * Note: When used with schema-based table definitions, optional fields (| undefined)
 * are transformed to nullable fields (| null) to match SQLite's NULL semantics.
 * Fields with both null and undefined will emit a warning as this is a lossy conversion.
 */
export const getColumnDefForSchema = (schema, propertySignature, forceNullable = false) => {
    const ast = schema.ast;
    // Extract annotations
    const getAnnotation = (annotationId) => propertySignature
        ? hasPropertyAnnotation(propertySignature, annotationId)
        : SchemaAST.getAnnotation(annotationId)(ast);
    const columnType = SchemaAST.getAnnotation(ColumnType)(ast);
    // Check if schema has null (e.g., Schema.NullOr) or undefined or if it's forced nullable (optional field)
    const isNullable = forceNullable || hasNull(ast) || hasUndefined(ast);
    // Get base column definition with nullable flag
    const baseColumn = Option.isSome(columnType)
        ? getColumnForType(columnType.value, isNullable)
        : getColumnForSchema(schema, isNullable);
    // Apply annotations
    const primaryKey = getAnnotation(PrimaryKeyId).pipe(Option.getOrElse(() => false));
    const autoIncrement = getAnnotation(AutoIncrement).pipe(Option.getOrElse(() => false));
    const defaultValue = getAnnotation(Default);
    return {
        ...baseColumn,
        ...(primaryKey && { primaryKey: true }),
        ...(autoIncrement && { autoIncrement: true }),
        ...(Option.isSome(defaultValue) && { default: Option.some(defaultValue.value) }),
    };
};
const hasPropertyAnnotation = (propertySignature, annotationId) => {
    if ('annotations' in propertySignature && propertySignature.annotations) {
        const annotation = SchemaAST.getAnnotation(annotationId)(propertySignature);
        if (Option.isSome(annotation))
            return annotation;
    }
    return SchemaAST.getAnnotation(annotationId)(propertySignature.type);
};
/**
 * Maps schema property signatures to SQLite column definitions.
 * Optional fields (| undefined) become nullable columns (| null).
 */
export const schemaFieldsToColumns = (propertySignatures) => {
    const columns = {};
    const uniqueColumns = [];
    for (const prop of propertySignatures) {
        if (typeof prop.name !== 'string')
            continue;
        const fieldSchema = Schema.make(prop.type);
        // Warn about lossy conversion for fields with both null and undefined
        if (prop.isOptional) {
            const { hasNull, hasUndefined } = checkNullUndefined(fieldSchema.ast);
            if (hasNull && hasUndefined) {
                console.warn(`Field '${prop.name}' has both null and undefined - treating | undefined as | null`);
            }
        }
        // Get column definition - pass nullable flag for optional fields
        const columnDef = getColumnDefForSchema(fieldSchema, prop, prop.isOptional);
        // Check for primary key and unique annotations
        const hasPrimaryKey = hasPropertyAnnotation(prop, PrimaryKeyId).pipe(Option.getOrElse(() => false));
        const hasUnique = hasPropertyAnnotation(prop, Unique).pipe(Option.getOrElse(() => false));
        // Build final column
        columns[prop.name] = {
            ...columnDef,
            ...(hasPrimaryKey && { primaryKey: true }),
        };
        // Validate primary key + nullable
        const column = columns[prop.name];
        if (column?.primaryKey && column.nullable) {
            throw new Error('Primary key columns cannot be nullable');
        }
        if (hasUnique)
            uniqueColumns.push(prop.name);
    }
    return { columns, uniqueColumns };
};
const checkNullUndefined = (ast) => {
    let hasNull = false;
    let hasUndefined = false;
    const visit = (type) => {
        if (SchemaAST.isUndefinedKeyword(type))
            hasUndefined = true;
        else if (SchemaAST.isLiteral(type) && type.literal === null)
            hasNull = true;
        else if (SchemaAST.isUnion(type))
            type.types.forEach(visit);
    };
    visit(ast);
    return { hasNull, hasUndefined };
};
const hasNull = (ast) => {
    if (SchemaAST.isLiteral(ast) && ast.literal === null)
        return true;
    if (SchemaAST.isUnion(ast)) {
        return ast.types.some((type) => hasNull(type));
    }
    return false;
};
const hasUndefined = (ast) => {
    if (SchemaAST.isUndefinedKeyword(ast))
        return true;
    if (SchemaAST.isUnion(ast)) {
        return ast.types.some((type) => hasUndefined(type));
    }
    return false;
};
const getColumnForType = (columnType, nullable = false) => {
    switch (columnType) {
        case 'text':
            return SqliteDsl.text({ nullable });
        case 'integer':
            return SqliteDsl.integer({ nullable });
        case 'real':
            return SqliteDsl.real({ nullable });
        case 'blob':
            return SqliteDsl.blob({ nullable });
        default:
            return shouldNeverHappen(`Unsupported column type: ${columnType}`);
    }
};
const getColumnForSchema = (schema, nullable = false) => {
    const ast = schema.ast;
    // Strip nullable wrapper to get core type
    const coreAst = stripNullable(ast);
    const coreSchema = stripNullable(ast) === ast ? schema : Schema.make(coreAst);
    // Special case: Boolean is transformed to integer in SQLite
    if (SchemaAST.isBooleanKeyword(coreAst)) {
        return SqliteDsl.boolean({ nullable });
    }
    // Get the encoded AST - what actually gets stored in SQLite
    const encodedAst = Schema.encodedSchema(coreSchema).ast;
    // Check if the encoded type matches SQLite native types
    if (SchemaAST.isStringKeyword(encodedAst)) {
        return SqliteDsl.text({ schema: coreSchema, nullable });
    }
    if (SchemaAST.isNumberKeyword(encodedAst)) {
        // Special cases for integer columns
        const id = SchemaAST.getIdentifierAnnotation(coreAst).pipe(Option.getOrElse(() => ''));
        if (id === 'Int' || id === 'DateFromNumber') {
            return SqliteDsl.integer({ schema: coreSchema, nullable });
        }
        return SqliteDsl.real({ schema: coreSchema, nullable });
    }
    // Literals based on their type
    if (SchemaAST.isLiteral(coreAst)) {
        const value = coreAst.literal;
        if (typeof value === 'boolean')
            return SqliteDsl.boolean({ nullable });
    }
    // Literals based on their encoded type
    if (SchemaAST.isLiteral(encodedAst)) {
        const value = encodedAst.literal;
        if (typeof value === 'string')
            return SqliteDsl.text({ schema: coreSchema, nullable });
        if (typeof value === 'number') {
            // Check if the original schema is Int
            const id = SchemaAST.getIdentifierAnnotation(coreAst).pipe(Option.getOrElse(() => ''));
            if (id === 'Int') {
                return SqliteDsl.integer({ schema: coreSchema, nullable });
            }
            return SqliteDsl.real({ schema: coreSchema, nullable });
        }
    }
    // Everything else needs JSON encoding
    return SqliteDsl.json({ schema: coreSchema, nullable });
};
const stripNullable = (ast) => {
    if (!SchemaAST.isUnion(ast))
        return ast;
    // Find non-null/undefined type
    const core = ast.types.find((type) => !(SchemaAST.isLiteral(type) && type.literal === null) && !SchemaAST.isUndefinedKeyword(type));
    return core || ast;
};
//# sourceMappingURL=column-def.js.map
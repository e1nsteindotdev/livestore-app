import { SqliteError } from "../adapter-types.js";
import { prepareBindValues } from "../util.js";
// TODO bring back statement caching
// will require proper scope-aware cleanup etc (for testing and apps with multiple LiveStore instances)
// const cachedStmts = new Map<string, PreparedStatement>()
export const dbExecute = (db, queryStr, bindValues) => {
    // let stmt = cachedStmts.get(queryStr)
    // if (!stmt) {
    const stmt = db.prepare(queryStr);
    // cachedStmts.set(queryStr, stmt)
    // }
    const preparedBindValues = bindValues ? prepareBindValues(bindValues, queryStr) : undefined;
    try {
        stmt.execute(preparedBindValues);
        stmt.finalize();
    }
    catch (cause) {
        throw new SqliteError({
            cause,
            query: { sql: queryStr, bindValues: preparedBindValues ?? {} },
        });
    }
};
export const dbSelect = (db, queryStr, bindValues) => {
    // let stmt = cachedStmts.get(queryStr)
    // if (!stmt) {
    const stmt = db.prepare(queryStr);
    // cachedStmts.set(queryStr, stmt)
    // }
    const res = stmt.select(bindValues ? prepareBindValues(bindValues, queryStr) : undefined);
    stmt.finalize();
    return res;
};
//# sourceMappingURL=common.js.map